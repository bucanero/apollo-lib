#include "upy.h"
/*
 * This file is part of the Micro Python project, http://micropython.org/
 *
 * The MIT License (MIT)
 *
 * Copyright (c) 2013, 2014 Damien P. George
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

//#include "py/mpconfig.h"
//#include "py/misc.h"
//#include "py/mpstate.h"

#if 0 // print debugging info
#define DEBUG_printf DEBUG_printf
#else // don't print debugging info
#define DEBUG_printf(...) (void)0
#endif

#if MICROPY_MEM_STATS
#define UPDATE_PEAK() { if ((mp_state)->mem.current_bytes_allocated > (mp_state)->mem.peak_bytes_allocated) (mp_state)->mem.peak_bytes_allocated = (mp_state)->mem.current_bytes_allocated; }
#endif

#if MICROPY_ENABLE_GC
//#include "py/gc.h"

// We redirect standard alloc functions to GC heap - just for the rest of
// this module. In the rest of micropython source, system malloc can be
// freely accessed - for interfacing with system and 3rd-party libs for
// example. On the other hand, some (e.g. bare-metal) ports may use GC
// heap as system heap, so, to avoid warnings, we do undef's first.
#undef malloc
#undef free
#undef realloc
#define malloc(b) micropy_gc_alloc(mp_state, (b), false)
#define malloc_with_finaliser(b) micropy_gc_alloc(mp_state, (b), true)
#define free(p) micropy_gc_free(mp_state, (p))
#define realloc(ptr, n) micropy_gc_realloc(mp_state, ptr, n, true)
#define micropy_realloc_ext(mp_state, ptr, n, mv) micropy_gc_realloc(mp_state, ptr, n, mv)
#else
STATIC void *micropy_realloc_ext(struct _mp_state_ctx_t *mp_state, void *ptr, size_t n_bytes, bool allow_move) {
    if (allow_move) {
        return realloc(ptr, n_bytes);
    } else {
        // We are asked to resize, but without moving the memory region pointed to
        // by ptr.  Unless the underlying memory manager has special provision for
        // this behaviour there is nothing we can do except fail to resize.
        return NULL;
    }
}
#endif // MICROPY_ENABLE_GC

void *micropy_m_malloc(struct _mp_state_ctx_t *mp_state, size_t num_bytes) {
    void *ptr = malloc(num_bytes);
    if (ptr == NULL && num_bytes != 0) {
        return micropy_m_malloc_fail(mp_state, num_bytes);
    }
#if MICROPY_MEM_STATS
    (mp_state)->mem.total_bytes_allocated += num_bytes;
    (mp_state)->mem.current_bytes_allocated += num_bytes;
    UPDATE_PEAK();
#endif
    DEBUG_printf("malloc %d : %p\n", num_bytes, ptr);
    return ptr;
}

void *micropy_m_malloc_maybe(struct _mp_state_ctx_t *mp_state, size_t num_bytes) {
    void *ptr = malloc(num_bytes);
#if MICROPY_MEM_STATS
    (mp_state)->mem.total_bytes_allocated += num_bytes;
    (mp_state)->mem.current_bytes_allocated += num_bytes;
    UPDATE_PEAK();
#endif
    DEBUG_printf("malloc %d : %p\n", num_bytes, ptr);
    return ptr;
}

#if MICROPY_ENABLE_FINALISER
void *micropy_m_malloc_with_finaliser(struct _mp_state_ctx_t *mp_state, size_t num_bytes) {
    void *ptr = malloc_with_finaliser(num_bytes);
    if (ptr == NULL && num_bytes != 0) {
        return micropy_m_malloc_fail(mp_state, num_bytes);
    }
#if MICROPY_MEM_STATS
    (mp_state)->mem.total_bytes_allocated += num_bytes;
    (mp_state)->mem.current_bytes_allocated += num_bytes;
    UPDATE_PEAK();
#endif
    DEBUG_printf("malloc %d : %p\n", num_bytes, ptr);
    return ptr;
}
#endif

void *micropy_m_malloc0(struct _mp_state_ctx_t *mp_state, size_t num_bytes) {
    void *ptr = micropy_m_malloc(mp_state, num_bytes);
    if (ptr == NULL && num_bytes != 0) {
        return micropy_m_malloc_fail(mp_state, num_bytes);
    }
    memset(ptr, 0, num_bytes);
    return ptr;
}

#if MICROPY_MALLOC_USES_ALLOCATED_SIZE
void *micropy_m_realloc(struct _mp_state_ctx_t *mp_state, void *ptr, size_t old_num_bytes, size_t new_num_bytes) {
#else
void *micropy_m_realloc(struct _mp_state_ctx_t *mp_state, void *ptr, size_t new_num_bytes) {
#endif
    void *new_ptr = realloc(ptr, new_num_bytes);
    if (new_ptr == NULL && new_num_bytes != 0) {
        return micropy_m_malloc_fail(mp_state, new_num_bytes);
    }
#if MICROPY_MEM_STATS
    // At first thought, "Total bytes allocated" should only grow,
    // after all, it's *total*. But consider for example 2K block
    // shrunk to 1K and then grown to 2K again. It's still 2K
    // allocated total. If we process only positive increments,
    // we'll count 3K.
    size_t diff = new_num_bytes - old_num_bytes;
    (mp_state)->mem.total_bytes_allocated += diff;
    (mp_state)->mem.current_bytes_allocated += diff;
    UPDATE_PEAK();
#endif
    DEBUG_printf("realloc %p, %d, %d : %p\n", ptr, old_num_bytes, new_num_bytes, new_ptr);
    return new_ptr;
}

#if MICROPY_MALLOC_USES_ALLOCATED_SIZE
void *micropy_m_realloc_maybe(struct _mp_state_ctx_t *mp_state, void *ptr, size_t old_num_bytes, size_t new_num_bytes, bool allow_move) {
#else
void *micropy_m_realloc_maybe(struct _mp_state_ctx_t *mp_state, void *ptr, size_t new_num_bytes, bool allow_move) {
#endif
    void *new_ptr = micropy_realloc_ext(mp_state, ptr, new_num_bytes, allow_move);
#if MICROPY_MEM_STATS
    // At first thought, "Total bytes allocated" should only grow,
    // after all, it's *total*. But consider for example 2K block
    // shrunk to 1K and then grown to 2K again. It's still 2K
    // allocated total. If we process only positive increments,
    // we'll count 3K.
    // Also, don't count failed reallocs.
    if (!(new_ptr == NULL && new_num_bytes != 0)) {
        size_t diff = new_num_bytes - old_num_bytes;
        (mp_state)->mem.total_bytes_allocated += diff;
        (mp_state)->mem.current_bytes_allocated += diff;
        UPDATE_PEAK();
    }
#endif
    DEBUG_printf("realloc %p, %d, %d : %p\n", ptr, old_num_bytes, new_num_bytes, new_ptr);
    return new_ptr;
}

#if MICROPY_MALLOC_USES_ALLOCATED_SIZE
void micropy_m_free(struct _mp_state_ctx_t *mp_state, void *ptr, size_t num_bytes) {
#else
void micropy_m_free(struct _mp_state_ctx_t *mp_state, void *ptr) {
#endif
    free(ptr);
#if MICROPY_MEM_STATS
    (mp_state)->mem.current_bytes_allocated -= num_bytes;
#endif
    DEBUG_printf("free %p, %d\n", ptr, num_bytes);
}

#if MICROPY_MEM_STATS
size_t micropy_m_get_total_bytes_allocated(struct _mp_state_ctx_t *mp_state) {
    return (mp_state)->mem.total_bytes_allocated;
}

size_t micropy_m_get_current_bytes_allocated(struct _mp_state_ctx_t *mp_state) {
    return (mp_state)->mem.current_bytes_allocated;
}

size_t micropy_m_get_peak_bytes_allocated(struct _mp_state_ctx_t *mp_state) {
    return (mp_state)->mem.peak_bytes_allocated;
}
#endif
/*
 * This file is part of the Micro Python project, http://micropython.org/
 *
 * The MIT License (MIT)
 *
 * Copyright (c) 2013, 2014 Damien P. George
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

#include <assert.h>
#include <string.h>
#include <stdio.h>

//#include "py/mpstate.h"
//#include "py/qstr.h"
//#include "py/gc.h"

// NOTE: we are using linear arrays to store and search for qstr's (unique strings, interned strings)
// ultimately we will replace this with a static hash table of some kind
// also probably need to include the length in the string data, to allow null bytes in the string

#if 0 // print debugging info
#define DEBUG_printf DEBUG_printf
#else // don't print debugging info
#define DEBUG_printf(...) (void)0
#endif

// A qstr is an index into the qstr pool.
// The data for a qstr contains (hash, length, data):
//  - hash (configurable number of bytes)
//  - length (configurable number of bytes)
//  - data ("length" number of bytes)
//  - \0 terminated (so they can be printed using printf)

#if MICROPY_QSTR_BYTES_IN_HASH == 1
    #define Q_HASH_MASK (0xff)
    #define Q_GET_HASH(q) ((mp_uint_t)(q)[0])
    #define Q_SET_HASH(q, hash) do { (q)[0] = (hash); } while (0)
#elif MICROPY_QSTR_BYTES_IN_HASH == 2
    #define Q_HASH_MASK (0xffff)
    #define Q_GET_HASH(q) ((mp_uint_t)(q)[0] | ((mp_uint_t)(q)[1] << 8))
    #define Q_SET_HASH(q, hash) do { (q)[0] = (hash); (q)[1] = (hash) >> 8; } while (0)
#else
    #error unimplemented qstr hash decoding
#endif
#define Q_GET_ALLOC(q)  (MICROPY_QSTR_BYTES_IN_HASH + MICROPY_QSTR_BYTES_IN_LEN + Q_GET_LENGTH(q) + 1)
#define Q_GET_DATA(q)   ((q) + MICROPY_QSTR_BYTES_IN_HASH + MICROPY_QSTR_BYTES_IN_LEN)
#if MICROPY_QSTR_BYTES_IN_LEN == 1
    #define Q_GET_LENGTH(q) ((q)[MICROPY_QSTR_BYTES_IN_HASH])
    #define Q_SET_LENGTH(q, len) do { (q)[MICROPY_QSTR_BYTES_IN_HASH] = (len); } while (0)
#elif MICROPY_QSTR_BYTES_IN_LEN == 2
    #define Q_GET_LENGTH(q) ((q)[MICROPY_QSTR_BYTES_IN_HASH] | ((q)[MICROPY_QSTR_BYTES_IN_HASH + 1] << 8))
    #define Q_SET_LENGTH(q, len) do { (q)[MICROPY_QSTR_BYTES_IN_HASH] = (len); (q)[MICROPY_QSTR_BYTES_IN_HASH + 1] = (len) >> 8; } while (0)
#else
    #error unimplemented qstr length decoding
#endif

// this must match the equivalent function in makeqstrdata.py
mp_uint_t micropy_qstr_compute_hash(struct _mp_state_ctx_t *mp_state, const byte *data, size_t len) {
    // djb2 algorithm; see http://www.cse.yorku.ca/~oz/hash.html
    mp_uint_t hash = 5381;
    for (const byte *top = data + len; data < top; data++) {
        hash = ((hash << 5) + hash) ^ (*data); // hash * 33 ^ data
    }
    hash &= Q_HASH_MASK;
    // Make sure that valid hash is never zero, zero means "hash not computed"
    if (hash == 0) {
        hash++;
    }
    return hash;
}

const qstr_pool_t mp_qstr_const_pool = {
    NULL,               // no previous pool
    0,                  // no previous pool
    10,                 // set so that the first dynamically allocated pool is twice this size; must be <= the len (just below)
    MP_QSTRnumber_of,   // corresponds to number of strings in array just below
    {
#ifndef __QSTR_EXTRACT
#define QDEF(id, str) str,
// This file was automatically generated by makeqstrdata.py

QDEF(MP_QSTR_NULL, (const byte*)"\x00\x00\x00" "")
QDEF(MP_QSTR_, (const byte*)"\x05\x15\x00" "")
QDEF(MP_QSTR__star_, (const byte*)"\x8f\xb5\x01" "*")
QDEF(MP_QSTR__, (const byte*)"\xfa\xb5\x01" "_")
QDEF(MP_QSTR__percent__hash_o, (const byte*)"\x6c\x1a\x03" "%#o")
QDEF(MP_QSTR__percent__hash_x, (const byte*)"\x7b\x1a\x03" "%#x")
QDEF(MP_QSTR__brace_open__colon__hash_b_brace_close_, (const byte*)"\x58\x37\x05" "{:#b}")
QDEF(MP_QSTR__0x0a_, (const byte*)"\xaf\xb5\x01" "\x0a")
QDEF(MP_QSTR_maximum_space_recursion_space_depth_space_exceeded, (const byte*)"\x73\x1e\x20" "maximum recursion depth exceeded")
QDEF(MP_QSTR__lt_module_gt_, (const byte*)"\xbd\x94\x08" "<module>")
QDEF(MP_QSTR__lt_lambda_gt_, (const byte*)"\x80\x8c\x08" "<lambda>")
QDEF(MP_QSTR__lt_listcomp_gt_, (const byte*)"\xd4\x15\x0a" "<listcomp>")
QDEF(MP_QSTR__lt_dictcomp_gt_, (const byte*)"\xcc\x8d\x0a" "<dictcomp>")
QDEF(MP_QSTR__lt_setcomp_gt_, (const byte*)"\x54\x51\x09" "<setcomp>")
QDEF(MP_QSTR__lt_genexpr_gt_, (const byte*)"\x34\x6a\x09" "<genexpr>")
QDEF(MP_QSTR__lt_string_gt_, (const byte*)"\x52\x53\x08" "<string>")
QDEF(MP_QSTR__lt_stdin_gt_, (const byte*)"\xe3\x63\x07" "<stdin>")
QDEF(MP_QSTR_utf_hyphen_8, (const byte*)"\xb7\x82\x05" "utf-8")
QDEF(MP_QSTR___locals__, (const byte*)"\x7b\x6a\x0a" "__locals__")
QDEF(MP_QSTR_BufferError, (const byte*)"\x1d\x59\x0b" "BufferError")
QDEF(MP_QSTR_FileExistsError, (const byte*)"\x5b\x14\x0f" "FileExistsError")
QDEF(MP_QSTR_FileNotFoundError, (const byte*)"\x78\x89\x11" "FileNotFoundError")
QDEF(MP_QSTR_FloatingPointError, (const byte*)"\x01\x34\x12" "FloatingPointError")
QDEF(MP_QSTR_UnboundLocalError, (const byte*)"\x99\x22\x11" "UnboundLocalError")
QDEF(MP_QSTR_xxxx, (const byte*)"\x05\xcd\x04" "xxxx")
QDEF(MP_QSTR_xxx, (const byte*)"\xdd\x91\x03" "xxx")
QDEF(MP_QSTR_function, (const byte*)"\x27\x02\x08" "function")
QDEF(MP_QSTR___del__, (const byte*)"\x68\x37\x07" "__del__")
QDEF(MP_QSTR_errno, (const byte*)"\xc1\x11\x05" "errno")
QDEF(MP_QSTR_uctypes, (const byte*)"\xf8\x71\x07" "uctypes")
QDEF(MP_QSTR_const, (const byte*)"\xc0\xff\x05" "const")
QDEF(MP_QSTR_micropython, (const byte*)"\x0b\x7c\x0b" "micropython")
QDEF(MP_QSTR_bytecode, (const byte*)"\x22\x7d\x08" "bytecode")
QDEF(MP_QSTR_native, (const byte*)"\x84\x0b\x06" "native")
QDEF(MP_QSTR_viper, (const byte*)"\x5d\x23\x05" "viper")
QDEF(MP_QSTR_asm_thumb, (const byte*)"\x43\x6d\x09" "asm_thumb")
QDEF(MP_QSTR_AssertionError, (const byte*)"\x97\x5a\x0e" "AssertionError")
QDEF(MP_QSTR_range, (const byte*)"\x1a\x5e\x05" "range")
QDEF(MP_QSTR___aiter__, (const byte*)"\x4e\x2b\x09" "__aiter__")
QDEF(MP_QSTR___anext__, (const byte*)"\x83\xb4\x09" "__anext__")
QDEF(MP_QSTR_StopAsyncIteration, (const byte*)"\xec\xf0\x12" "StopAsyncIteration")
QDEF(MP_QSTR___aenter__, (const byte*)"\x4c\x84\x0a" "__aenter__")
QDEF(MP_QSTR___aexit__, (const byte*)"\xc4\xcf\x09" "__aexit__")
QDEF(MP_QSTR___repl_print__, (const byte*)"\x00\xbb\x0e" "__repl_print__")
QDEF(MP_QSTR_super, (const byte*)"\xc4\xb2\x05" "super")
QDEF(MP_QSTR___class__, (const byte*)"\x2b\xc5\x09" "__class__")
QDEF(MP_QSTR___doc__, (const byte*)"\x2d\xac\x07" "__doc__")
QDEF(MP_QSTR___name__, (const byte*)"\xe2\x38\x08" "__name__")
QDEF(MP_QSTR___module__, (const byte*)"\xff\x30\x0a" "__module__")
QDEF(MP_QSTR___qualname__, (const byte*)"\x6b\x00\x0c" "__qualname__")
QDEF(MP_QSTR_object, (const byte*)"\x90\x8d\x06" "object")
QDEF(MP_QSTR_bool, (const byte*)"\xeb\x3c\x04" "bool")
QDEF(MP_QSTR_int, (const byte*)"\x16\x53\x03" "int")
QDEF(MP_QSTR_uint, (const byte*)"\xe3\x3d\x04" "uint")
QDEF(MP_QSTR_label, (const byte*)"\x43\xe7\x05" "label")
QDEF(MP_QSTR_align, (const byte*)"\xa8\xfb\x05" "align")
QDEF(MP_QSTR_data, (const byte*)"\x15\xdc\x04" "data")
QDEF(MP_QSTR___main__, (const byte*)"\x8e\x13\x08" "__main__")
QDEF(MP_QSTR___build_class__, (const byte*)"\x42\x88\x0f" "__build_class__")
QDEF(MP_QSTR_keys, (const byte*)"\x01\x13\x04" "keys")
QDEF(MP_QSTR___getitem__, (const byte*)"\x26\x39\x0b" "__getitem__")
QDEF(MP_QSTR_closure, (const byte*)"\x74\xca\x07" "closure")
QDEF(MP_QSTR_generator, (const byte*)"\x96\xc3\x09" "generator")
QDEF(MP_QSTR___next__, (const byte*)"\x02\x73\x08" "__next__")
QDEF(MP_QSTR_send, (const byte*)"\xb9\x76\x04" "send")
QDEF(MP_QSTR_close, (const byte*)"\x33\x67\x05" "close")
QDEF(MP_QSTR_throw, (const byte*)"\xb3\x44\x05" "throw")
QDEF(MP_QSTR___path__, (const byte*)"\xc8\x23\x08" "__path__")
QDEF(MP_QSTR___file__, (const byte*)"\x03\x54\x08" "__file__")
QDEF(MP_QSTR_code, (const byte*)"\x68\xda\x04" "code")
QDEF(MP_QSTR_single, (const byte*)"\x3f\x20\x06" "single")
QDEF(MP_QSTR_exec, (const byte*)"\x1e\xc0\x04" "exec")
QDEF(MP_QSTR_eval, (const byte*)"\x9b\xa6\x04" "eval")
QDEF(MP_QSTR_tuple, (const byte*)"\xfd\x41\x05" "tuple")
QDEF(MP_QSTR_append, (const byte*)"\x6b\x97\x06" "append")
QDEF(MP_QSTR_extend, (const byte*)"\x63\xe8\x06" "extend")
QDEF(MP_QSTR_array, (const byte*)"\x7c\x72\x05" "array")
QDEF(MP_QSTR_bytearray, (const byte*)"\x76\xa3\x09" "bytearray")
QDEF(MP_QSTR_memoryview, (const byte*)"\x69\x44\x0a" "memoryview")
QDEF(MP_QSTR_iterator, (const byte*)"\x47\xbe\x08" "iterator")
QDEF(MP_QSTR_bound_method, (const byte*)"\x97\xa2\x0c" "bound_method")
QDEF(MP_QSTR_real, (const byte*)"\xbf\xf9\x04" "real")
QDEF(MP_QSTR_imag, (const byte*)"\x47\xb7\x04" "imag")
QDEF(MP_QSTR_complex, (const byte*)"\xc5\x9d\x07" "complex")
QDEF(MP_QSTR_dict_view, (const byte*)"\x2d\xa9\x09" "dict_view")
QDEF(MP_QSTR_clear, (const byte*)"\x7c\xa0\x05" "clear")
QDEF(MP_QSTR_copy, (const byte*)"\xe0\xdb\x04" "copy")
QDEF(MP_QSTR_fromkeys, (const byte*)"\x37\xbd\x08" "fromkeys")
QDEF(MP_QSTR_get, (const byte*)"\x33\x3b\x03" "get")
QDEF(MP_QSTR_items, (const byte*)"\xe3\x53\x05" "items")
QDEF(MP_QSTR_pop, (const byte*)"\x2a\x73\x03" "pop")
QDEF(MP_QSTR_popitem, (const byte*)"\xbf\x2c\x07" "popitem")
QDEF(MP_QSTR_setdefault, (const byte*)"\x6c\xa3\x0a" "setdefault")
QDEF(MP_QSTR_update, (const byte*)"\xb4\x76\x06" "update")
QDEF(MP_QSTR_values, (const byte*)"\x7d\xbe\x06" "values")
QDEF(MP_QSTR___setitem__, (const byte*)"\x32\x3e\x0b" "__setitem__")
QDEF(MP_QSTR___delitem__, (const byte*)"\xfd\x35\x0b" "__delitem__")
QDEF(MP_QSTR_dict, (const byte*)"\x3f\xfc\x04" "dict")
QDEF(MP_QSTR_OrderedDict, (const byte*)"\xf0\x7e\x0b" "OrderedDict")
QDEF(MP_QSTR_iterable, (const byte*)"\x25\x92\x08" "iterable")
QDEF(MP_QSTR_start, (const byte*)"\x85\xef\x05" "start")
QDEF(MP_QSTR_enumerate, (const byte*)"\x71\xba\x09" "enumerate")
QDEF(MP_QSTR_args, (const byte*)"\xc2\xc6\x04" "args")
QDEF(MP_QSTR_value, (const byte*)"\x4e\x34\x05" "value")
QDEF(MP_QSTR___init__, (const byte*)"\x5f\xa5\x08" "__init__")
QDEF(MP_QSTR_BaseException, (const byte*)"\x07\x92\x0d" "BaseException")
QDEF(MP_QSTR_filter, (const byte*)"\x25\xbe\x06" "filter")
QDEF(MP_QSTR_float, (const byte*)"\x35\x44\x05" "float")
QDEF(MP_QSTR_from_bytes, (const byte*)"\x35\x74\x0a" "from_bytes")
QDEF(MP_QSTR_to_bytes, (const byte*)"\xd8\x3e\x08" "to_bytes")
QDEF(MP_QSTR_key, (const byte*)"\x32\x6d\x03" "key")
QDEF(MP_QSTR_reverse, (const byte*)"\x25\x2a\x07" "reverse")
QDEF(MP_QSTR_count, (const byte*)"\xa6\x4d\x05" "count")
QDEF(MP_QSTR_index, (const byte*)"\x7b\x28\x05" "index")
QDEF(MP_QSTR_insert, (const byte*)"\x12\x54\x06" "insert")
QDEF(MP_QSTR_remove, (const byte*)"\x63\x8a\x06" "remove")
QDEF(MP_QSTR_sort, (const byte*)"\xbf\x9d\x04" "sort")
QDEF(MP_QSTR_list, (const byte*)"\x27\x1d\x04" "list")
QDEF(MP_QSTR_map, (const byte*)"\xb9\x43\x03" "map")
QDEF(MP_QSTR_module, (const byte*)"\xbf\x99\x06" "module")
QDEF(MP_QSTR_builtins, (const byte*)"\xf7\x31\x08" "builtins")
QDEF(MP_QSTR_uio, (const byte*)"\xb6\x66\x03" "uio")
QDEF(MP_QSTR_ucollections, (const byte*)"\x15\x9a\x0c" "ucollections")
QDEF(MP_QSTR_ustruct, (const byte*)"\x47\x08\x07" "ustruct")
QDEF(MP_QSTR_math, (const byte*)"\x35\xbb\x04" "math")
QDEF(MP_QSTR_cmath, (const byte*)"\xb6\xf4\x05" "cmath")
QDEF(MP_QSTR_sys, (const byte*)"\xbc\x8e\x03" "sys")
QDEF(MP_QSTR_gc, (const byte*)"\x61\x6e\x02" "gc")
QDEF(MP_QSTR_uerrno, (const byte*)"\xb4\xe9\x06" "uerrno")
QDEF(MP_QSTR_uzlib, (const byte*)"\x6d\x9b\x05" "uzlib")
QDEF(MP_QSTR_ujson, (const byte*)"\xe8\x30\x05" "ujson")
QDEF(MP_QSTR_ure, (const byte*)"\x87\x63\x03" "ure")
QDEF(MP_QSTR_uheapq, (const byte*)"\x1d\x43\x06" "uheapq")
QDEF(MP_QSTR_uhashlib, (const byte*)"\x65\x9d\x08" "uhashlib")
QDEF(MP_QSTR_ubinascii, (const byte*)"\xc4\x88\x09" "ubinascii")
QDEF(MP_QSTR_ucrypto, (const byte*)"\x13\x22\x07" "ucrypto")
QDEF(MP_QSTR_urandom, (const byte*)"\xab\xae\x07" "urandom")
QDEF(MP_QSTR_ussl, (const byte*)"\x1c\xf2\x04" "ussl")
QDEF(MP_QSTR_lwip, (const byte*)"\x67\x89\x04" "lwip")
QDEF(MP_QSTR_websocket, (const byte*)"\x90\x8d\x09" "websocket")
QDEF(MP_QSTR__webrepl, (const byte*)"\x21\x95\x08" "_webrepl")
QDEF(MP_QSTR_framebuf, (const byte*)"\x69\x82\x08" "framebuf")
QDEF(MP_QSTR___new__, (const byte*)"\x79\x15\x07" "__new__")
QDEF(MP_QSTR_doc, (const byte*)"\x2d\x1f\x03" "doc")
QDEF(MP_QSTR_getter, (const byte*)"\x90\xb2\x06" "getter")
QDEF(MP_QSTR_setter, (const byte*)"\x04\x59\x06" "setter")
QDEF(MP_QSTR_deleter, (const byte*)"\x6e\xdb\x07" "deleter")
QDEF(MP_QSTR_property, (const byte*)"\xc2\x29\x08" "property")
QDEF(MP_QSTR_NoneType, (const byte*)"\x17\x68\x08" "NoneType")
QDEF(MP_QSTR_stop, (const byte*)"\x9d\x36\x04" "stop")
QDEF(MP_QSTR_step, (const byte*)"\x57\x36\x04" "step")
QDEF(MP_QSTR___reversed__, (const byte*)"\x61\xff\x0c" "__reversed__")
QDEF(MP_QSTR_reversed, (const byte*)"\xa1\x6e\x08" "reversed")
QDEF(MP_QSTR_add, (const byte*)"\x44\x32\x03" "add")
QDEF(MP_QSTR_discard, (const byte*)"\x0f\x71\x07" "discard")
QDEF(MP_QSTR_difference, (const byte*)"\x72\x24\x0a" "difference")
QDEF(MP_QSTR_difference_update, (const byte*)"\x9c\xfa\x11" "difference_update")
QDEF(MP_QSTR_intersection, (const byte*)"\x28\x2a\x0c" "intersection")
QDEF(MP_QSTR_intersection_update, (const byte*)"\x06\xdd\x13" "intersection_update")
QDEF(MP_QSTR_isdisjoint, (const byte*)"\xf7\x68\x0a" "isdisjoint")
QDEF(MP_QSTR_issubset, (const byte*)"\xb9\xc1\x08" "issubset")
QDEF(MP_QSTR_issuperset, (const byte*)"\xfc\xec\x0a" "issuperset")
QDEF(MP_QSTR_symmetric_difference, (const byte*)"\xce\x67\x14" "symmetric_difference")
QDEF(MP_QSTR_symmetric_difference_update, (const byte*)"\x60\xf8\x1b" "symmetric_difference_update")
QDEF(MP_QSTR_union, (const byte*)"\xf6\x7c\x05" "union")
QDEF(MP_QSTR___contains__, (const byte*)"\xc6\x5f\x0c" "__contains__")
QDEF(MP_QSTR_set, (const byte*)"\x27\x8f\x03" "set")
QDEF(MP_QSTR_frozenset, (const byte*)"\xed\x9c\x09" "frozenset")
QDEF(MP_QSTR_Ellipsis, (const byte*)"\xf0\xe0\x08" "Ellipsis")
QDEF(MP_QSTR_NotImplemented, (const byte*)"\x3e\xc6\x0e" "NotImplemented")
QDEF(MP_QSTR_slice, (const byte*)"\xb5\xf4\x05" "slice")
QDEF(MP_QSTR_keepends, (const byte*)"\x62\x8b\x08" "keepends")
QDEF(MP_QSTR_decode, (const byte*)"\xa9\x59\x06" "decode")
QDEF(MP_QSTR_encode, (const byte*)"\x43\xca\x06" "encode")
QDEF(MP_QSTR_find, (const byte*)"\x00\x34\x04" "find")
QDEF(MP_QSTR_rfind, (const byte*)"\xd2\x9c\x05" "rfind")
QDEF(MP_QSTR_rindex, (const byte*)"\xe9\x2b\x06" "rindex")
QDEF(MP_QSTR_join, (const byte*)"\xa7\x5c\x04" "join")
QDEF(MP_QSTR_split, (const byte*)"\xb7\x33\x05" "split")
QDEF(MP_QSTR_splitlines, (const byte*)"\x6a\xd3\x0a" "splitlines")
QDEF(MP_QSTR_rsplit, (const byte*)"\xa5\x00\x06" "rsplit")
QDEF(MP_QSTR_startswith, (const byte*)"\x74\xe8\x0a" "startswith")
QDEF(MP_QSTR_endswith, (const byte*)"\x1b\xa3\x08" "endswith")
QDEF(MP_QSTR_strip, (const byte*)"\x29\x1e\x05" "strip")
QDEF(MP_QSTR_lstrip, (const byte*)"\xe5\xb9\x06" "lstrip")
QDEF(MP_QSTR_rstrip, (const byte*)"\x3b\x95\x06" "rstrip")
QDEF(MP_QSTR_format, (const byte*)"\x26\x33\x06" "format")
QDEF(MP_QSTR_replace, (const byte*)"\x49\x25\x07" "replace")
QDEF(MP_QSTR_partition, (const byte*)"\x87\xe5\x09" "partition")
QDEF(MP_QSTR_rpartition, (const byte*)"\x15\xd0\x0a" "rpartition")
QDEF(MP_QSTR_center, (const byte*)"\x4e\xbf\x06" "center")
QDEF(MP_QSTR_lower, (const byte*)"\xc6\xcb\x05" "lower")
QDEF(MP_QSTR_upper, (const byte*)"\x27\x94\x05" "upper")
QDEF(MP_QSTR_isspace, (const byte*)"\x5b\xf8\x07" "isspace")
QDEF(MP_QSTR_isalpha, (const byte*)"\xeb\x37\x07" "isalpha")
QDEF(MP_QSTR_isdigit, (const byte*)"\xa8\x9a\x07" "isdigit")
QDEF(MP_QSTR_isupper, (const byte*)"\xdd\xa7\x07" "isupper")
QDEF(MP_QSTR_islower, (const byte*)"\xfc\x80\x07" "islower")
QDEF(MP_QSTR_str, (const byte*)"\x50\x8d\x03" "str")
QDEF(MP_QSTR_bytes, (const byte*)"\x5c\xb2\x05" "bytes")
QDEF(MP_QSTR_read, (const byte*)"\xb7\xf9\x04" "read")
QDEF(MP_QSTR_readall, (const byte*)"\x76\x4b\x07" "readall")
QDEF(MP_QSTR_readline, (const byte*)"\xf9\x19\x08" "readline")
QDEF(MP_QSTR_write, (const byte*)"\x98\xa8\x05" "write")
QDEF(MP_QSTR_getvalue, (const byte*)"\x78\xac\x08" "getvalue")
QDEF(MP_QSTR___enter__, (const byte*)"\x6d\xba\x09" "__enter__")
QDEF(MP_QSTR___exit__, (const byte*)"\x45\xf8\x08" "__exit__")
QDEF(MP_QSTR_StringIO, (const byte*)"\x76\x76\x08" "StringIO")
QDEF(MP_QSTR_BytesIO, (const byte*)"\x1a\xb7\x07" "BytesIO")
QDEF(MP_QSTR___str__, (const byte*)"\xd0\xcd\x07" "__str__")
QDEF(MP_QSTR___repr__, (const byte*)"\x10\x0b\x08" "__repr__")
QDEF(MP_QSTR___bool__, (const byte*)"\x2b\x65\x08" "__bool__")
QDEF(MP_QSTR___len__, (const byte*)"\xe2\xb0\x07" "__len__")
QDEF(MP_QSTR___hash__, (const byte*)"\xf7\xc8\x08" "__hash__")
QDEF(MP_QSTR___pos__, (const byte*)"\x29\xf0\x07" "__pos__")
QDEF(MP_QSTR___neg__, (const byte*)"\x69\xd5\x07" "__neg__")
QDEF(MP_QSTR___invert__, (const byte*)"\xf7\x77\x0a" "__invert__")
QDEF(MP_QSTR___eq__, (const byte*)"\x71\x3e\x06" "__eq__")
QDEF(MP_QSTR___add__, (const byte*)"\xc4\x82\x07" "__add__")
QDEF(MP_QSTR___sub__, (const byte*)"\x21\x09\x07" "__sub__")
QDEF(MP_QSTR___mul__, (const byte*)"\x31\x42\x07" "__mul__")
QDEF(MP_QSTR___floordiv__, (const byte*)"\x46\x5f\x0c" "__floordiv__")
QDEF(MP_QSTR___truediv__, (const byte*)"\x88\xef\x0b" "__truediv__")
QDEF(MP_QSTR___iadd__, (const byte*)"\x6d\x4a\x08" "__iadd__")
QDEF(MP_QSTR___isub__, (const byte*)"\x08\x78\x08" "__isub__")
QDEF(MP_QSTR___lt__, (const byte*)"\x5d\x68\x06" "__lt__")
QDEF(MP_QSTR___gt__, (const byte*)"\xb6\x82\x06" "__gt__")
QDEF(MP_QSTR___le__, (const byte*)"\xcc\x13\x06" "__le__")
QDEF(MP_QSTR___ge__, (const byte*)"\xa7\x46\x06" "__ge__")
QDEF(MP_QSTR___dict__, (const byte*)"\x7f\x54\x08" "__dict__")
QDEF(MP_QSTR___get__, (const byte*)"\xb3\x8f\x07" "__get__")
QDEF(MP_QSTR___getattr__, (const byte*)"\x40\xf8\x0b" "__getattr__")
QDEF(MP_QSTR___delete__, (const byte*)"\xdc\xed\x0a" "__delete__")
QDEF(MP_QSTR___set__, (const byte*)"\xa7\xb3\x07" "__set__")
QDEF(MP_QSTR___call__, (const byte*)"\xa7\xf9\x08" "__call__")
QDEF(MP_QSTR___iter__, (const byte*)"\xcf\x32\x08" "__iter__")
QDEF(MP_QSTR_type, (const byte*)"\x9d\x7f\x04" "type")
QDEF(MP_QSTR_staticmethod, (const byte*)"\x62\xaf\x0c" "staticmethod")
QDEF(MP_QSTR_classmethod, (const byte*)"\xb4\x8c\x0b" "classmethod")
QDEF(MP_QSTR_zip, (const byte*)"\xe6\xac\x03" "zip")
QDEF(MP_QSTR_default, (const byte*)"\xce\x7d\x07" "default")
QDEF(MP_QSTR_sep, (const byte*)"\x23\x8f\x03" "sep")
QDEF(MP_QSTR_end, (const byte*)"\x0a\x23\x03" "end")
QDEF(MP_QSTR_file, (const byte*)"\xc3\x34\x04" "file")
QDEF(MP_QSTR___import__, (const byte*)"\x38\x3e\x0a" "__import__")
QDEF(MP_QSTR_abs, (const byte*)"\x95\x32\x03" "abs")
QDEF(MP_QSTR_all, (const byte*)"\x44\x33\x03" "all")
QDEF(MP_QSTR_any, (const byte*)"\x13\x33\x03" "any")
QDEF(MP_QSTR_bin, (const byte*)"\xe0\x48\x03" "bin")
QDEF(MP_QSTR_callable, (const byte*)"\x0d\x70\x08" "callable")
QDEF(MP_QSTR_compile, (const byte*)"\xf4\xc9\x07" "compile")
QDEF(MP_QSTR_chr, (const byte*)"\xdc\x4c\x03" "chr")
QDEF(MP_QSTR_dir, (const byte*)"\xfa\x1e\x03" "dir")
QDEF(MP_QSTR_divmod, (const byte*)"\xb8\x04\x06" "divmod")
QDEF(MP_QSTR_execfile, (const byte*)"\x58\x28\x08" "execfile")
QDEF(MP_QSTR_getattr, (const byte*)"\xc0\x17\x07" "getattr")
QDEF(MP_QSTR_setattr, (const byte*)"\xd4\xa8\x07" "setattr")
QDEF(MP_QSTR_globals, (const byte*)"\x9d\x49\x07" "globals")
QDEF(MP_QSTR_hasattr, (const byte*)"\x8c\xb0\x07" "hasattr")
QDEF(MP_QSTR_hash, (const byte*)"\xb7\x70\x04" "hash")
QDEF(MP_QSTR_hex, (const byte*)"\x70\x50\x03" "hex")
QDEF(MP_QSTR_id, (const byte*)"\x28\x6f\x02" "id")
QDEF(MP_QSTR_isinstance, (const byte*)"\xb6\xbe\x0a" "isinstance")
QDEF(MP_QSTR_issubclass, (const byte*)"\xb5\x7f\x0a" "issubclass")
QDEF(MP_QSTR_iter, (const byte*)"\x8f\x21\x04" "iter")
QDEF(MP_QSTR_len, (const byte*)"\x62\x40\x03" "len")
QDEF(MP_QSTR_locals, (const byte*)"\x3b\xa1\x06" "locals")
QDEF(MP_QSTR_max, (const byte*)"\xb1\x43\x03" "max")
QDEF(MP_QSTR_min, (const byte*)"\xaf\x42\x03" "min")
QDEF(MP_QSTR_next, (const byte*)"\x42\x88\x04" "next")
QDEF(MP_QSTR_oct, (const byte*)"\xfd\x5c\x03" "oct")
QDEF(MP_QSTR_ord, (const byte*)"\x1c\x5e\x03" "ord")
QDEF(MP_QSTR_pow, (const byte*)"\x2d\x73\x03" "pow")
QDEF(MP_QSTR_print, (const byte*)"\x54\xc6\x05" "print")
QDEF(MP_QSTR_repr, (const byte*)"\xd0\xf7\x04" "repr")
QDEF(MP_QSTR_round, (const byte*)"\xe7\x25\x05" "round")
QDEF(MP_QSTR_sorted, (const byte*)"\x5e\x15\x06" "sorted")
QDEF(MP_QSTR_sum, (const byte*)"\x2e\x8d\x03" "sum")
QDEF(MP_QSTR_ArithmeticError, (const byte*)"\x2d\x8c\x0f" "ArithmeticError")
QDEF(MP_QSTR_AttributeError, (const byte*)"\x21\xde\x0e" "AttributeError")
QDEF(MP_QSTR_EOFError, (const byte*)"\x91\xbf\x08" "EOFError")
QDEF(MP_QSTR_Exception, (const byte*)"\xf2\x29\x09" "Exception")
QDEF(MP_QSTR_GeneratorExit, (const byte*)"\x16\x62\x0d" "GeneratorExit")
QDEF(MP_QSTR_ImportError, (const byte*)"\x20\x9c\x0b" "ImportError")
QDEF(MP_QSTR_IndentationError, (const byte*)"\x5c\x20\x10" "IndentationError")
QDEF(MP_QSTR_IndexError, (const byte*)"\x83\xad\x0a" "IndexError")
QDEF(MP_QSTR_KeyboardInterrupt, (const byte*)"\xaf\xe2\x11" "KeyboardInterrupt")
QDEF(MP_QSTR_KeyError, (const byte*)"\xea\x00\x08" "KeyError")
QDEF(MP_QSTR_LookupError, (const byte*)"\xff\x69\x0b" "LookupError")
QDEF(MP_QSTR_MemoryError, (const byte*)"\xdc\x83\x0b" "MemoryError")
QDEF(MP_QSTR_NameError, (const byte*)"\xba\x2d\x09" "NameError")
QDEF(MP_QSTR_NotImplementedError, (const byte*)"\xc6\x98\x13" "NotImplementedError")
QDEF(MP_QSTR_OSError, (const byte*)"\xa1\x65\x07" "OSError")
QDEF(MP_QSTR_OverflowError, (const byte*)"\x81\xe1\x0d" "OverflowError")
QDEF(MP_QSTR_RuntimeError, (const byte*)"\x61\xf1\x0c" "RuntimeError")
QDEF(MP_QSTR_StopIteration, (const byte*)"\xea\x1c\x0d" "StopIteration")
QDEF(MP_QSTR_SyntaxError, (const byte*)"\x94\x8f\x0b" "SyntaxError")
QDEF(MP_QSTR_SystemExit, (const byte*)"\x20\xff\x0a" "SystemExit")
QDEF(MP_QSTR_TypeError, (const byte*)"\x25\x96\x09" "TypeError")
QDEF(MP_QSTR_UnicodeError, (const byte*)"\x22\xd1\x0c" "UnicodeError")
QDEF(MP_QSTR_ValueError, (const byte*)"\x96\x87\x0a" "ValueError")
QDEF(MP_QSTR_ViperTypeError, (const byte*)"\xdd\x05\x0e" "ViperTypeError")
QDEF(MP_QSTR_ZeroDivisionError, (const byte*)"\xb6\x27\x11" "ZeroDivisionError")
QDEF(MP_QSTR_namedtuple, (const byte*)"\x1e\x16\x0a" "namedtuple")
QDEF(MP_QSTR_collect, (const byte*)"\x9b\x65\x07" "collect")
QDEF(MP_QSTR_disable, (const byte*)"\x91\x76\x07" "disable")
QDEF(MP_QSTR_enable, (const byte*)"\x04\xde\x06" "enable")
QDEF(MP_QSTR_isenabled, (const byte*)"\x9a\xe5\x09" "isenabled")
QDEF(MP_QSTR_mem_free, (const byte*)"\xcb\x62\x08" "mem_free")
QDEF(MP_QSTR_mem_alloc, (const byte*)"\x52\x2b\x09" "mem_alloc")
QDEF(MP_QSTR_flush, (const byte*)"\x61\xc1\x05" "flush")
QDEF(MP_QSTR_BufferedWriter, (const byte*)"\xeb\x2c\x0e" "BufferedWriter")
QDEF(MP_QSTR_open, (const byte*)"\xd1\x3a\x04" "open")
QDEF(MP_QSTR_FileIO, (const byte*)"\xc5\x15\x06" "FileIO")
QDEF(MP_QSTR_TextIOWrapper, (const byte*)"\xad\x8d\x0d" "TextIOWrapper")
QDEF(MP_QSTR_e, (const byte*)"\xc0\xb5\x01" "e")
QDEF(MP_QSTR_pi, (const byte*)"\x1c\x70\x02" "pi")
QDEF(MP_QSTR_sqrt, (const byte*)"\x21\x44\x04" "sqrt")
QDEF(MP_QSTR_exp, (const byte*)"\xc8\x24\x03" "exp")
QDEF(MP_QSTR_expm1, (const byte*)"\x74\x72\x05" "expm1")
QDEF(MP_QSTR_log, (const byte*)"\x21\x3f\x03" "log")
QDEF(MP_QSTR_log2, (const byte*)"\x73\x23\x04" "log2")
QDEF(MP_QSTR_log10, (const byte*)"\x40\x91\x05" "log10")
QDEF(MP_QSTR_cosh, (const byte*)"\xd2\xdb\x04" "cosh")
QDEF(MP_QSTR_sinh, (const byte*)"\xb9\xa6\x04" "sinh")
QDEF(MP_QSTR_tanh, (const byte*)"\xd6\xa1\x04" "tanh")
QDEF(MP_QSTR_acosh, (const byte*)"\x13\xa3\x05" "acosh")
QDEF(MP_QSTR_asinh, (const byte*)"\x38\x8f\x05" "asinh")
QDEF(MP_QSTR_atanh, (const byte*)"\x97\x81\x05" "atanh")
QDEF(MP_QSTR_cos, (const byte*)"\x7a\x4c\x03" "cos")
QDEF(MP_QSTR_sin, (const byte*)"\xb1\x90\x03" "sin")
QDEF(MP_QSTR_tan, (const byte*)"\xfe\x61\x03" "tan")
QDEF(MP_QSTR_acos, (const byte*)"\x1b\xa0\x04" "acos")
QDEF(MP_QSTR_asin, (const byte*)"\x50\xe5\x04" "asin")
QDEF(MP_QSTR_atan, (const byte*)"\x1f\xbe\x04" "atan")
QDEF(MP_QSTR_atan2, (const byte*)"\xcd\x81\x05" "atan2")
QDEF(MP_QSTR_ceil, (const byte*)"\x06\xb0\x04" "ceil")
QDEF(MP_QSTR_copysign, (const byte*)"\x33\x14\x08" "copysign")
QDEF(MP_QSTR_fabs, (const byte*)"\x93\x12\x04" "fabs")
QDEF(MP_QSTR_floor, (const byte*)"\x7d\x46\x05" "floor")
QDEF(MP_QSTR_fmod, (const byte*)"\xe5\x44\x04" "fmod")
QDEF(MP_QSTR_frexp, (const byte*)"\x1c\x98\x05" "frexp")
QDEF(MP_QSTR_ldexp, (const byte*)"\x40\x6f\x05" "ldexp")
QDEF(MP_QSTR_modf, (const byte*)"\x25\xc0\x04" "modf")
QDEF(MP_QSTR_isfinite, (const byte*)"\xa6\xab\x08" "isfinite")
QDEF(MP_QSTR_isinf, (const byte*)"\x3e\x11\x05" "isinf")
QDEF(MP_QSTR_isnan, (const byte*)"\x9e\x03\x05" "isnan")
QDEF(MP_QSTR_trunc, (const byte*)"\x5b\x99\x05" "trunc")
QDEF(MP_QSTR_radians, (const byte*)"\x87\x3f\x07" "radians")
QDEF(MP_QSTR_degrees, (const byte*)"\x02\x41\x07" "degrees")
QDEF(MP_QSTR_erf, (const byte*)"\x94\x23\x03" "erf")
QDEF(MP_QSTR_erfc, (const byte*)"\x77\x96\x04" "erfc")
QDEF(MP_QSTR_gamma, (const byte*)"\x02\x90\x05" "gamma")
QDEF(MP_QSTR_lgamma, (const byte*)"\xce\x6c\x06" "lgamma")
QDEF(MP_QSTR_phase, (const byte*)"\x6a\xd5\x05" "phase")
QDEF(MP_QSTR_polar, (const byte*)"\x05\x0c\x05" "polar")
QDEF(MP_QSTR_rect, (const byte*)"\xe5\xf9\x04" "rect")
QDEF(MP_QSTR_mem_total, (const byte*)"\xfd\x6a\x09" "mem_total")
QDEF(MP_QSTR_mem_current, (const byte*)"\x16\xba\x0b" "mem_current")
QDEF(MP_QSTR_mem_peak, (const byte*)"\x40\x25\x08" "mem_peak")
QDEF(MP_QSTR_mem_info, (const byte*)"\xd1\xf1\x08" "mem_info")
QDEF(MP_QSTR_qstr_info, (const byte*)"\xb0\x81\x09" "qstr_info")
QDEF(MP_QSTR_stack_use, (const byte*)"\x97\xf7\x09" "stack_use")
QDEF(MP_QSTR_alloc_emergency_exception_buf, (const byte*)"\x78\x2a\x1d" "alloc_emergency_exception_buf")
QDEF(MP_QSTR_heap_lock, (const byte*)"\xad\x8c\x09" "heap_lock")
QDEF(MP_QSTR_heap_unlock, (const byte*)"\x56\x2d\x0b" "heap_unlock")
QDEF(MP_QSTR_calcsize, (const byte*)"\x4d\x38\x08" "calcsize")
QDEF(MP_QSTR_pack, (const byte*)"\xbc\xd1\x04" "pack")
QDEF(MP_QSTR_pack_into, (const byte*)"\x1f\xa9\x09" "pack_into")
QDEF(MP_QSTR_unpack, (const byte*)"\x07\x3c\x06" "unpack")
QDEF(MP_QSTR_unpack_from, (const byte*)"\x0e\x6d\x0b" "unpack_from")
QDEF(MP_QSTR_name, (const byte*)"\xa2\x75\x04" "name")
QDEF(MP_QSTR_version, (const byte*)"\xbf\xd3\x07" "version")
QDEF(MP_QSTR_version_info, (const byte*)"\x6e\x0a\x0c" "version_info")
QDEF(MP_QSTR_implementation, (const byte*)"\x17\x2d\x0e" "implementation")
QDEF(MP_QSTR_platform, (const byte*)"\x3a\x19\x08" "platform")
QDEF(MP_QSTR_byteorder, (const byte*)"\x61\x99\x09" "byteorder")
QDEF(MP_QSTR_little, (const byte*)"\x89\x6a\x06" "little")
QDEF(MP_QSTR_big, (const byte*)"\xe9\x48\x03" "big")
QDEF(MP_QSTR_maxsize, (const byte*)"\xd4\x70\x07" "maxsize")
QDEF(MP_QSTR_exit, (const byte*)"\x85\xbe\x04" "exit")
QDEF(MP_QSTR_stdin, (const byte*)"\x21\x04\x05" "stdin")
QDEF(MP_QSTR_stdout, (const byte*)"\x08\x83\x06" "stdout")
QDEF(MP_QSTR_stderr, (const byte*)"\xa3\x58\x06" "stderr")
QDEF(MP_QSTR_exc_info, (const byte*)"\x0a\xff\x08" "exc_info")
QDEF(MP_QSTR_print_exception, (const byte*)"\x1c\x22\x0f" "print_exception")
QDEF(MP_QSTR_struct, (const byte*)"\x12\x90\x06" "struct")
QDEF(MP_QSTR_sizeof, (const byte*)"\x49\x73\x06" "sizeof")
QDEF(MP_QSTR_addressof, (const byte*)"\x5a\xf9\x09" "addressof")
QDEF(MP_QSTR_bytes_at, (const byte*)"\xb6\x5d\x08" "bytes_at")
QDEF(MP_QSTR_bytearray_at, (const byte*)"\x9c\x5c\x0c" "bytearray_at")
QDEF(MP_QSTR_NATIVE, (const byte*)"\x04\x8e\x06" "NATIVE")
QDEF(MP_QSTR_LITTLE_ENDIAN, (const byte*)"\xbf\x5b\x0d" "LITTLE_ENDIAN")
QDEF(MP_QSTR_BIG_ENDIAN, (const byte*)"\xff\x51\x0a" "BIG_ENDIAN")
QDEF(MP_QSTR_VOID, (const byte*)"\x31\xf2\x04" "VOID")
QDEF(MP_QSTR_UINT8, (const byte*)"\xbb\xe1\x05" "UINT8")
QDEF(MP_QSTR_INT8, (const byte*)"\xce\xbd\x04" "INT8")
QDEF(MP_QSTR_UINT16, (const byte*)"\xc4\x17\x06" "UINT16")
QDEF(MP_QSTR_INT16, (const byte*)"\x91\x76\x05" "INT16")
QDEF(MP_QSTR_UINT32, (const byte*)"\x82\x17\x06" "UINT32")
QDEF(MP_QSTR_INT32, (const byte*)"\x57\x76\x05" "INT32")
QDEF(MP_QSTR_UINT64, (const byte*)"\x61\x18\x06" "UINT64")
QDEF(MP_QSTR_INT64, (const byte*)"\xf4\x75\x05" "INT64")
QDEF(MP_QSTR_BFUINT8, (const byte*)"\xbf\xaf\x07" "BFUINT8")
QDEF(MP_QSTR_BFINT8, (const byte*)"\x4a\x9a\x06" "BFINT8")
QDEF(MP_QSTR_BFUINT16, (const byte*)"\x40\xa6\x08" "BFUINT16")
QDEF(MP_QSTR_BFINT16, (const byte*)"\x95\xe2\x07" "BFINT16")
QDEF(MP_QSTR_BFUINT32, (const byte*)"\x06\xa6\x08" "BFUINT32")
QDEF(MP_QSTR_BFINT32, (const byte*)"\x53\xe2\x07" "BFINT32")
QDEF(MP_QSTR_BF_POS, (const byte*)"\x52\x9d\x06" "BF_POS")
QDEF(MP_QSTR_BF_LEN, (const byte*)"\x19\xb0\x06" "BF_LEN")
QDEF(MP_QSTR_FLOAT32, (const byte*)"\xb4\x87\x07" "FLOAT32")
QDEF(MP_QSTR_FLOAT64, (const byte*)"\x17\x87\x07" "FLOAT64")
QDEF(MP_QSTR_PTR, (const byte*)"\xb3\x0c\x03" "PTR")
QDEF(MP_QSTR_ARRAY, (const byte*)"\x5c\x7a\x05" "ARRAY")
QDEF(MP_QSTR_dumps, (const byte*)"\x7a\x2d\x05" "dumps")
QDEF(MP_QSTR_loads, (const byte*)"\xb0\xb0\x05" "loads")
QDEF(MP_QSTR_group, (const byte*)"\xba\xb0\x05" "group")
QDEF(MP_QSTR_match, (const byte*)"\x96\x22\x05" "match")
QDEF(MP_QSTR_search, (const byte*)"\xab\xc1\x06" "search")
QDEF(MP_QSTR_DEBUG, (const byte*)"\x34\x6d\x05" "DEBUG")
QDEF(MP_QSTR_heappush, (const byte*)"\x87\x6b\x08" "heappush")
QDEF(MP_QSTR_heappop, (const byte*)"\xd6\x27\x07" "heappop")
QDEF(MP_QSTR_heapify, (const byte*)"\xaf\x2d\x07" "heapify")
QDEF(MP_QSTR_compress, (const byte*)"\xa3\x7a\x08" "compress")
QDEF(MP_QSTR_decompress, (const byte*)"\x62\xfb\x0a" "decompress")
QDEF(MP_QSTR_offzip, (const byte*)"\x89\x1e\x06" "offzip")
QDEF(MP_QSTR_CRC_16_BITS, (const byte*)"\xdc\x3b\x0b" "CRC_16_BITS")
QDEF(MP_QSTR_CRC_32_BITS, (const byte*)"\xda\xa4\x0b" "CRC_32_BITS")
QDEF(MP_QSTR_CRC_64_BITS, (const byte*)"\x19\x88\x0b" "CRC_64_BITS")
QDEF(MP_QSTR_crc, (const byte*)"\x17\x4d\x03" "crc")
QDEF(MP_QSTR_crc16, (const byte*)"\xb0\xe8\x05" "crc16")
QDEF(MP_QSTR_crc32, (const byte*)"\x76\xe8\x05" "crc32")
QDEF(MP_QSTR_crc32big, (const byte*)"\x3a\x19\x08" "crc32big")
QDEF(MP_QSTR_crc64_iso, (const byte*)"\x7f\xe9\x09" "crc64_iso")
QDEF(MP_QSTR_crc64_ecma, (const byte*)"\xe0\x66\x0a" "crc64_ecma")
QDEF(MP_QSTR_ripemd160, (const byte*)"\x55\x64\x09" "ripemd160")
QDEF(MP_QSTR_md5, (const byte*)"\x19\x44\x03" "md5")
QDEF(MP_QSTR_md5_xor, (const byte*)"\xe3\x4e\x07" "md5_xor")
QDEF(MP_QSTR_sha1, (const byte*)"\x8e\xac\x04" "sha1")
QDEF(MP_QSTR_sha256, (const byte*)"\x2e\x01\x06" "sha256")
QDEF(MP_QSTR_sha384, (const byte*)"\x80\x04\x06" "sha384")
QDEF(MP_QSTR_sha512, (const byte*)"\x69\xfd\x06" "sha512")
QDEF(MP_QSTR_hmac_sha1, (const byte*)"\x76\x8c\x09" "hmac_sha1")
QDEF(MP_QSTR_sha1_xor64, (const byte*)"\x76\x60\x0a" "sha1_xor64")
QDEF(MP_QSTR_adler16, (const byte*)"\x5c\x0d\x07" "adler16")
QDEF(MP_QSTR_adler32, (const byte*)"\x1a\x0d\x07" "adler32")
QDEF(MP_QSTR_checksum32, (const byte*)"\xe9\xfa\x0a" "checksum32")
QDEF(MP_QSTR_sdbm, (const byte*)"\x3d\x79\x04" "sdbm")
QDEF(MP_QSTR_fnv1, (const byte*)"\xca\x2a\x04" "fnv1")
QDEF(MP_QSTR_wadd, (const byte*)"\xf3\x55\x04" "wadd")
QDEF(MP_QSTR_dwadd, (const byte*)"\xb7\x15\x05" "dwadd")
QDEF(MP_QSTR_qwadd, (const byte*)"\x62\x3a\x05" "qwadd")
QDEF(MP_QSTR_wadd_le, (const byte*)"\x85\x51\x07" "wadd_le")
QDEF(MP_QSTR_dwadd_le, (const byte*)"\x41\x1a\x08" "dwadd_le")
QDEF(MP_QSTR_wsub, (const byte*)"\x16\x1b\x04" "wsub")
QDEF(MP_QSTR_force_crc32, (const byte*)"\x34\x81\x0b" "force_crc32")
QDEF(MP_QSTR_murmur3_32, (const byte*)"\xa8\xab\x0a" "murmur3_32")
QDEF(MP_QSTR_jhash, (const byte*)"\xfd\xc0\x05" "jhash")
QDEF(MP_QSTR_jenkins_oaat, (const byte*)"\x7f\xdc\x0c" "jenkins_oaat")
QDEF(MP_QSTR_lookup3_little2, (const byte*)"\xd5\x95\x0f" "lookup3_little2")
QDEF(MP_QSTR_djb2, (const byte*)"\x9b\xef\x04" "djb2")
QDEF(MP_QSTR_eachecksum, (const byte*)"\xec\xb9\x0a" "eachecksum")
QDEF(MP_QSTR_ffx_checksum, (const byte*)"\x2f\x3e\x0c" "ffx_checksum")
QDEF(MP_QSTR_ff13_checksum, (const byte*)"\xd5\xd0\x0d" "ff13_checksum")
QDEF(MP_QSTR_kh25_checksum, (const byte*)"\xd3\x45\x0d" "kh25_checksum")
QDEF(MP_QSTR_khcom_checksum, (const byte*)"\x15\xfe\x0e" "khcom_checksum")
QDEF(MP_QSTR_mgs2_checksum, (const byte*)"\x9c\xa5\x0d" "mgs2_checksum")
QDEF(MP_QSTR_mgspw_checksum, (const byte*)"\xc9\x29\x0e" "mgspw_checksum")
QDEF(MP_QSTR_sw4_checksum, (const byte*)"\x47\x0a\x0c" "sw4_checksum")
QDEF(MP_QSTR_toz_checksum, (const byte*)"\x36\x72\x0c" "toz_checksum")
QDEF(MP_QSTR_tiara2_checksum, (const byte*)"\xca\x9c\x0f" "tiara2_checksum")
QDEF(MP_QSTR_castlevania_checksum, (const byte*)"\x0a\x9f\x14" "castlevania_checksum")
QDEF(MP_QSTR_rockstar_checksum, (const byte*)"\x36\x95\x11" "rockstar_checksum")
QDEF(MP_QSTR_dbzxv2_checksum, (const byte*)"\x77\xc6\x0f" "dbzxv2_checksum")
QDEF(MP_QSTR_deadrising_checksum, (const byte*)"\xbb\x7c\x13" "deadrising_checksum")
QDEF(MP_QSTR_hexlify, (const byte*)"\x2a\x7f\x07" "hexlify")
QDEF(MP_QSTR_unhexlify, (const byte*)"\xb1\xb9\x09" "unhexlify")
QDEF(MP_QSTR_a2b_base64, (const byte*)"\x3c\x0b\x0a" "a2b_base64")
QDEF(MP_QSTR_b2a_base64, (const byte*)"\x3c\x8f\x0a" "b2a_base64")
QDEF(MP_QSTR_DECRYPT, (const byte*)"\x88\x0e\x07" "DECRYPT")
QDEF(MP_QSTR_ENCRYPT, (const byte*)"\x22\xbb\x07" "ENCRYPT")
QDEF(MP_QSTR_diablo3, (const byte*)"\xdb\x9b\x07" "diablo3")
QDEF(MP_QSTR_dw8xl, (const byte*)"\x7a\xf9\x05" "dw8xl")
QDEF(MP_QSTR_silent_hill3, (const byte*)"\x81\x05\x0c" "silent_hill3")
QDEF(MP_QSTR_nfs_undercover, (const byte*)"\xa4\xd0\x0e" "nfs_undercover")
QDEF(MP_QSTR_final_fantasy13, (const byte*)"\xe2\x78\x0f" "final_fantasy13")
QDEF(MP_QSTR_borderlands3, (const byte*)"\x8e\x3a\x0c" "borderlands3")
QDEF(MP_QSTR_mgs_pw, (const byte*)"\x24\x87\x06" "mgs_pw")
QDEF(MP_QSTR_mgs_base64, (const byte*)"\xd4\x71\x0a" "mgs_base64")
QDEF(MP_QSTR_mgs, (const byte*)"\xfc\x44\x03" "mgs")
QDEF(MP_QSTR_mgs5_tpp, (const byte*)"\x82\xf9\x08" "mgs5_tpp")
QDEF(MP_QSTR_monster_hunter, (const byte*)"\x76\x93\x0e" "monster_hunter")
QDEF(MP_QSTR_rgg_studio, (const byte*)"\xf8\x01\x0a" "rgg_studio")
QDEF(MP_QSTR_aes_ecb, (const byte*)"\x49\x8c\x07" "aes_ecb")
QDEF(MP_QSTR_aes_cbc, (const byte*)"\xef\x94\x07" "aes_cbc")
QDEF(MP_QSTR_aes_ctr, (const byte*)"\x28\x96\x07" "aes_ctr")
QDEF(MP_QSTR_des_ecb, (const byte*)"\x4c\xea\x07" "des_ecb")
QDEF(MP_QSTR_des3_cbc, (const byte*)"\x39\x03\x08" "des3_cbc")
QDEF(MP_QSTR_blowfish_ecb, (const byte*)"\xbc\xcd\x0c" "blowfish_ecb")
QDEF(MP_QSTR_blowfish_cbc, (const byte*)"\x1a\xd5\x0c" "blowfish_cbc")
QDEF(MP_QSTR_camellia_ecb, (const byte*)"\x1c\x73\x0c" "camellia_ecb")
#undef QDEF
#endif
    },
};

#ifdef MICROPY_QSTR_EXTRA_POOL
extern const qstr_pool_t MICROPY_QSTR_EXTRA_POOL;
#define CONST_POOL MICROPY_QSTR_EXTRA_POOL
#else
#define CONST_POOL mp_qstr_const_pool
#endif

void micropy_qstr_init(struct _mp_state_ctx_t *mp_state) {
    (mp_state)->vm.last_pool = (qstr_pool_t*)&CONST_POOL; // we won't modify the const_pool since it has no allocated room left
    (mp_state)->vm.qstr_last_chunk = NULL;
}

STATIC const byte *micropy_find_qstr(struct _mp_state_ctx_t *mp_state, qstr q) {
    // search pool for this qstr
    for (qstr_pool_t *pool = (mp_state)->vm.last_pool; pool != NULL; pool = pool->prev) {
        if (q >= pool->total_prev_len) {
            return pool->qstrs[q - pool->total_prev_len];
        }
    }

    // not found
    return 0;
}

STATIC qstr micropy_qstr_add(struct _mp_state_ctx_t *mp_state, const byte *q_ptr) {
    DEBUG_printf("QSTR: add hash=%d len=%d data=%.*s\n", Q_GET_HASH(q_ptr), Q_GET_LENGTH(q_ptr), Q_GET_LENGTH(q_ptr), Q_GET_DATA(q_ptr));

    // make sure we have room in the pool for a new qstr
    if ((mp_state)->vm.last_pool->len >= (mp_state)->vm.last_pool->alloc) {
        qstr_pool_t *pool = micropy_m_new_obj_var(mp_state, qstr_pool_t, const char*, (mp_state)->vm.last_pool->alloc * 2);
        pool->prev = (mp_state)->vm.last_pool;
        pool->total_prev_len = (mp_state)->vm.last_pool->total_prev_len + (mp_state)->vm.last_pool->len;
        pool->alloc = (mp_state)->vm.last_pool->alloc * 2;
        pool->len = 0;
        (mp_state)->vm.last_pool = pool;
        DEBUG_printf("QSTR: allocate new pool of size %d\n", (mp_state)->vm.last_pool->alloc);
    }

    // add the new qstr
    (mp_state)->vm.last_pool->qstrs[(mp_state)->vm.last_pool->len++] = q_ptr;

    // return id for the newly-added qstr
    return (mp_state)->vm.last_pool->total_prev_len + (mp_state)->vm.last_pool->len - 1;
}

qstr micropy_qstr_find_strn(struct _mp_state_ctx_t *mp_state, const char *str, size_t str_len) {
    // work out hash of str
    mp_uint_t str_hash = micropy_qstr_compute_hash(mp_state, (const byte*)str, str_len);

    // search pools for the data
    for (qstr_pool_t *pool = (mp_state)->vm.last_pool; pool != NULL; pool = pool->prev) {
        for (const byte **q = pool->qstrs, **q_top = pool->qstrs + pool->len; q < q_top; q++) {
            if (Q_GET_HASH(*q) == str_hash && Q_GET_LENGTH(*q) == str_len && memcmp(Q_GET_DATA(*q), str, str_len) == 0) {
                return pool->total_prev_len + (q - pool->qstrs);
            }
        }
    }

    // not found; return null qstr
    return 0;
}

qstr micropy_qstr_from_str(struct _mp_state_ctx_t *mp_state, const char *str) {
    return micropy_qstr_from_strn(mp_state, str, strlen(str));
}

qstr micropy_qstr_from_strn(struct _mp_state_ctx_t *mp_state, const char *str, size_t len) {
    assert(len < (1 << (8 * MICROPY_QSTR_BYTES_IN_LEN)));
    qstr q = micropy_qstr_find_strn(mp_state, str, len);
    if (q == 0) {
        // qstr does not exist in interned pool so need to add it

        // compute number of bytes needed to intern this string
        size_t n_bytes = MICROPY_QSTR_BYTES_IN_HASH + MICROPY_QSTR_BYTES_IN_LEN + len + 1;

        if ((mp_state)->vm.qstr_last_chunk != NULL && (mp_state)->vm.qstr_last_used + n_bytes > (mp_state)->vm.qstr_last_alloc) {
            // not enough room at end of previously interned string so try to grow
            byte *new_p = micropy_m_renew_maybe(mp_state, byte, (mp_state)->vm.qstr_last_chunk, (mp_state)->vm.qstr_last_alloc, (mp_state)->vm.qstr_last_alloc + n_bytes, false);
            if (new_p == NULL) {
                // could not grow existing memory; shrink it to fit previous
                (void)micropy_m_renew(mp_state, byte, (mp_state)->vm.qstr_last_chunk, (mp_state)->vm.qstr_last_alloc, (mp_state)->vm.qstr_last_used);
                (mp_state)->vm.qstr_last_chunk = NULL;
            } else {
                // could grow existing memory
                (mp_state)->vm.qstr_last_alloc += n_bytes;
            }
        }

        if ((mp_state)->vm.qstr_last_chunk == NULL) {
            // no existing memory for the interned string so allocate a new chunk
            size_t al = n_bytes;
            if (al < MICROPY_ALLOC_QSTR_CHUNK_INIT) {
                al = MICROPY_ALLOC_QSTR_CHUNK_INIT;
            }
            (mp_state)->vm.qstr_last_chunk = micropy_m_new_maybe(mp_state, byte, al);
            if ((mp_state)->vm.qstr_last_chunk == NULL) {
                // failed to allocate a large chunk so try with exact size
                (mp_state)->vm.qstr_last_chunk = micropy_m_new(mp_state, byte, n_bytes);
                al = n_bytes;
            }
            (mp_state)->vm.qstr_last_alloc = al;
            (mp_state)->vm.qstr_last_used = 0;
        }

        // allocate memory from the chunk for this new interned string's data
        byte *q_ptr = (mp_state)->vm.qstr_last_chunk + (mp_state)->vm.qstr_last_used;
        (mp_state)->vm.qstr_last_used += n_bytes;

        // store the interned strings' data
        mp_uint_t hash = micropy_qstr_compute_hash(mp_state, (const byte*)str, len);
        Q_SET_HASH(q_ptr, hash);
        Q_SET_LENGTH(q_ptr, len);
        memcpy(q_ptr + MICROPY_QSTR_BYTES_IN_HASH + MICROPY_QSTR_BYTES_IN_LEN, str, len);
        q_ptr[MICROPY_QSTR_BYTES_IN_HASH + MICROPY_QSTR_BYTES_IN_LEN + len] = '\0';
        q = micropy_qstr_add(mp_state, q_ptr);
    }
    return q;
}

byte *micropy_qstr_build_start(struct _mp_state_ctx_t *mp_state, size_t len, byte **q_ptr) {
    assert(len < (1 << (8 * MICROPY_QSTR_BYTES_IN_LEN)));
    *q_ptr = micropy_m_new(mp_state, byte, MICROPY_QSTR_BYTES_IN_HASH + MICROPY_QSTR_BYTES_IN_LEN + len + 1);
    Q_SET_LENGTH(*q_ptr, len);
    return Q_GET_DATA(*q_ptr);
}

qstr micropy_qstr_build_end(struct _mp_state_ctx_t *mp_state, byte *q_ptr) {
    qstr q = micropy_qstr_find_strn(mp_state, (const char*)Q_GET_DATA(q_ptr), Q_GET_LENGTH(q_ptr));
    if (q == 0) {
        size_t len = Q_GET_LENGTH(q_ptr);
        mp_uint_t hash = micropy_qstr_compute_hash(mp_state, Q_GET_DATA(q_ptr), len);
        Q_SET_HASH(q_ptr, hash);
        q_ptr[MICROPY_QSTR_BYTES_IN_HASH + MICROPY_QSTR_BYTES_IN_LEN + len] = '\0';
        q = micropy_qstr_add(mp_state, q_ptr);
    } else {
        micropy_m_del(mp_state, byte, q_ptr, Q_GET_ALLOC(q_ptr));
    }
    return q;
}

mp_uint_t micropy_qstr_hash(struct _mp_state_ctx_t *mp_state, qstr q) {
    return Q_GET_HASH(micropy_find_qstr(mp_state, q));
}

size_t micropy_qstr_len(struct _mp_state_ctx_t *mp_state, qstr q) {
    const byte *qd = micropy_find_qstr(mp_state, q);
    return Q_GET_LENGTH(qd);
}

// XXX to remove!
const char *micropy_qstr_str(struct _mp_state_ctx_t *mp_state, qstr q) {
    const byte *qd = micropy_find_qstr(mp_state, q);
    return (const char*)Q_GET_DATA(qd);
}

const byte *micropy_qstr_data(struct _mp_state_ctx_t *mp_state, qstr q, size_t *len) {
    const byte *qd = micropy_find_qstr(mp_state, q);
    *len = Q_GET_LENGTH(qd);
    return Q_GET_DATA(qd);
}

void micropy_qstr_pool_info(struct _mp_state_ctx_t *mp_state, size_t *n_pool, size_t *n_qstr, size_t *n_str_data_bytes, size_t *n_total_bytes) {
    *n_pool = 0;
    *n_qstr = 0;
    *n_str_data_bytes = 0;
    *n_total_bytes = 0;
    for (qstr_pool_t *pool = (mp_state)->vm.last_pool; pool != NULL && pool != &CONST_POOL; pool = pool->prev) {
        *n_pool += 1;
        *n_qstr += pool->len;
        for (const byte **q = pool->qstrs, **q_top = pool->qstrs + pool->len; q < q_top; q++) {
            *n_str_data_bytes += Q_GET_ALLOC(*q);
        }
        #if MICROPY_ENABLE_GC
        *n_total_bytes += micropy_gc_nbytes(mp_state, pool); // this counts actual bytes used in heap
        #else
        *n_total_bytes += sizeof(qstr_pool_t) + sizeof(qstr) * pool->alloc;
        #endif
    }
    *n_total_bytes += *n_str_data_bytes;
}

#if MICROPY_PY_MICROPYTHON_MEM_INFO
void micropy_qstr_dump_data(struct _mp_state_ctx_t *mp_state) {
    for (qstr_pool_t *pool = (mp_state)->vm.last_pool; pool != NULL && pool != &CONST_POOL; pool = pool->prev) {
        for (const byte **q = pool->qstrs, **q_top = pool->qstrs + pool->len; q < q_top; q++) {
            micropy_printf(mp_state, &mp_plat_print, "Q(%s)\n", Q_GET_DATA(*q));
        }
    }
}
#endif
/*
 * This file is part of the Micro Python project, http://micropython.org/
 *
 * The MIT License (MIT)
 *
 * Copyright (c) 2013-2015 Damien P. George
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

#include <assert.h>
#include <stdarg.h>
#include <stdint.h>
#include <stdio.h>
#include <string.h>

//#include "py/mphal.h"
//#include "py/mpprint.h"
//#include "py/obj.h"
//#include "py/objint.h"
//#include "py/runtime.h"

#if MICROPY_PY_BUILTINS_FLOAT
//#include "py/formatfloat.h"
#endif

static const char pad_spaces[] = "                ";
static const char pad_zeroes[] = "0000000000000000";

STATIC void micropy_plat_print_strn(struct _mp_state_ctx_t *mp_state, void *env, const char *str, size_t len) {
    (void)env;
    MP_PLAT_PRINT_STRN(str, len);
}

const mp_print_t mp_plat_print = {NULL, micropy_plat_print_strn};

int micropy_print_str(struct _mp_state_ctx_t *mp_state, const mp_print_t *print, const char *str) {
    size_t len = strlen(str);
    if (len) {
        print->print_strn(mp_state, print->data, str, len);
    }
    return len;
}

int micropy_print_strn(struct _mp_state_ctx_t *mp_state, const mp_print_t *print, const char *str, size_t len, int flags, char fill, int width) {
    int left_pad = 0;
    int right_pad = 0;
    int pad = width - len;
    int pad_size;
    int total_chars_printed = 0;
    const char *pad_chars;

    if (!fill || fill == ' ') {
        pad_chars = pad_spaces;
        pad_size = sizeof(pad_spaces) - 1;
    } else if (fill == '0') {
        pad_chars = pad_zeroes;
        pad_size = sizeof(pad_zeroes) - 1;
    } else {
        // Other pad characters are fairly unusual, so we'll take the hit
        // and output them 1 at a time.
        pad_chars = &fill;
        pad_size = 1;
    }

    if (flags & PF_FLAG_CENTER_ADJUST) {
        left_pad = pad / 2;
        right_pad = pad - left_pad;
    } else if (flags & PF_FLAG_LEFT_ADJUST) {
        right_pad = pad;
    } else {
        left_pad = pad;
    }

    if (left_pad > 0) {
        total_chars_printed += left_pad;
        while (left_pad > 0) {
            int p = left_pad;
            if (p > pad_size) {
                p = pad_size;
            }
            print->print_strn(mp_state, print->data, pad_chars, p);
            left_pad -= p;
        }
    }
    if (len) {
        print->print_strn(mp_state, print->data, str, len);
        total_chars_printed += len;
    }
    if (right_pad > 0) {
        total_chars_printed += right_pad;
        while (right_pad > 0) {
            int p = right_pad;
            if (p > pad_size) {
                p = pad_size;
            }
            print->print_strn(mp_state, print->data, pad_chars, p);
            right_pad -= p;
        }
    }
    return total_chars_printed;
}

// 32-bits is 10 digits, add 3 for commas, 1 for sign, 1 for terminating null
// We can use 16 characters for 32-bit and 32 characters for 64-bit
#define INT_BUF_SIZE (sizeof(mp_int_t) * 4)

// Our mp_vprintf function below does not support the '#' format modifier to
// print the prefix of a non-base-10 number, so we don't need code for this.
#define SUPPORT_INT_BASE_PREFIX (0)

// This function is used exclusively by mp_vprintf to format ints.
// It needs to be a separate function to mp_print_mp_int, since converting to a mp_int looses the MSB.
STATIC int micropy_print_int(struct _mp_state_ctx_t *mp_state, const mp_print_t *print, mp_uint_t x, int sgn, int base, int base_char, int flags, char fill, int width) {
    char sign = 0;
    if (sgn) {
        if ((mp_int_t)x < 0) {
            sign = '-';
            x = -x;
        } else if (flags & PF_FLAG_SHOW_SIGN) {
            sign = '+';
        } else if (flags & PF_FLAG_SPACE_SIGN) {
            sign = ' ';
        }
    }

    char buf[INT_BUF_SIZE];
    char *b = buf + INT_BUF_SIZE;

    if (x == 0) {
        *(--b) = '0';
    } else {
        do {
            int c = x % base;
            x /= base;
            if (c >= 10) {
                c += base_char - 10;
            } else {
                c += '0';
            }
            *(--b) = c;
        } while (b > buf && x != 0);
    }

    #if SUPPORT_INT_BASE_PREFIX
    char prefix_char = '\0';

    if (flags & PF_FLAG_SHOW_PREFIX) {
        if (base == 2) {
            prefix_char = base_char + 'b' - 'a';
        } else if (base == 8) {
            prefix_char = base_char + 'o' - 'a';
        } else if (base == 16) {
            prefix_char = base_char + 'x' - 'a';
        }
    }
    #endif

    int len = 0;
    if (flags & PF_FLAG_PAD_AFTER_SIGN) {
        if (sign) {
            len += micropy_print_strn(mp_state, print, &sign, 1, flags, fill, 1);
            width--;
        }
        #if SUPPORT_INT_BASE_PREFIX
        if (prefix_char) {
            len += micropy_print_strn(mp_state, print, "0", 1, flags, fill, 1);
            len += micropy_print_strn(mp_state, print, &prefix_char, 1, flags, fill, 1);
            width -= 2;
        }
        #endif
    } else {
        #if SUPPORT_INT_BASE_PREFIX
        if (prefix_char && b > &buf[1]) {
            *(--b) = prefix_char;
            *(--b) = '0';
        }
        #endif
        if (sign && b > buf) {
            *(--b) = sign;
        }
    }

    len += micropy_print_strn(mp_state, print, b, buf + INT_BUF_SIZE - b, flags, fill, width);
    return len;
}

int micropy_print_mp_int(struct _mp_state_ctx_t *mp_state, const mp_print_t *print, mp_obj_t x, int base, int base_char, int flags, char fill, int width, int prec) {
    if (!MP_OBJ_IS_INT(x)) {
        // This will convert booleans to int, or raise an error for
        // non-integer types.
        x = MP_OBJ_NEW_SMALL_INT(micropy_obj_get_int(mp_state, x));
    }

    if ((flags & (PF_FLAG_LEFT_ADJUST | PF_FLAG_CENTER_ADJUST)) == 0 && fill == '0') {
        if (prec > width) {
            width = prec;
        }
        prec = 0;
    }
    char prefix_buf[4];
    char *prefix = prefix_buf;

    if (micropy_obj_int_sign(mp_state, x) > 0) {
        if (flags & PF_FLAG_SHOW_SIGN) {
            *prefix++ = '+';
        } else if (flags & PF_FLAG_SPACE_SIGN) {
            *prefix++ = ' ';
        }
    }

    if (flags & PF_FLAG_SHOW_PREFIX) {
        if (base == 2) {
            *prefix++ = '0';
            *prefix++ = base_char + 'b' - 'a';
        } else if (base == 8) {
            *prefix++ = '0';
            if (flags & PF_FLAG_SHOW_OCTAL_LETTER) {
                *prefix++ = base_char + 'o' - 'a';
            }
        } else if (base == 16) {
            *prefix++ = '0';
            *prefix++ = base_char + 'x' - 'a';
        }
    }
    *prefix = '\0';
    int prefix_len = prefix - prefix_buf;
    prefix = prefix_buf;

    char comma = '\0';
    if (flags & PF_FLAG_SHOW_COMMA) {
        comma = ',';
    }

    // The size of this buffer is rather arbitrary. If it's not large
    // enough, a dynamic one will be allocated.
    char stack_buf[sizeof(mp_int_t) * 4];
    char *buf = stack_buf;
    mp_uint_t buf_size = sizeof(stack_buf);
    mp_uint_t fmt_size = 0;
    char *str;

    if (prec > 1) {
        flags |= PF_FLAG_PAD_AFTER_SIGN;
    }
    char sign = '\0';
    if (flags & PF_FLAG_PAD_AFTER_SIGN) {
        // We add the pad in this function, so since the pad goes after
        // the sign & prefix, we format without a prefix
        str = micropy_obj_int_formatted(mp_state, &buf, &buf_size, &fmt_size,
                                   x, base, NULL, base_char, comma);
        if (*str == '-') {
            sign = *str++;
            fmt_size--;
        }
    } else {
        str = micropy_obj_int_formatted(mp_state, &buf, &buf_size, &fmt_size,
                                   x, base, prefix, base_char, comma);
    }

    int spaces_before = 0;
    int spaces_after = 0;

    if (prec > 1) {
        // If prec was specified, then prec specifies the width to zero-pad the
        // the number to. This zero-padded number then gets left or right
        // aligned in width characters.

        int prec_width = fmt_size;  // The digits
        if (prec_width < prec) {
            prec_width = prec;
        }
        if (flags & PF_FLAG_PAD_AFTER_SIGN) {
            if (sign) {
                prec_width++;
            }
            prec_width += prefix_len;
        }
        if (prec_width < width) {
            if (flags & PF_FLAG_LEFT_ADJUST) {
                spaces_after = width - prec_width;
            } else {
                spaces_before = width - prec_width;
            }
        }
        fill = '0';
        flags &= ~PF_FLAG_LEFT_ADJUST;
    }

    int len = 0;
    if (spaces_before) {
        len += micropy_print_strn(mp_state, print, "", 0, 0, ' ', spaces_before);
    }
    if (flags & PF_FLAG_PAD_AFTER_SIGN) {
        // pad after sign implies pad after prefix as well.
        if (sign) {
            len += micropy_print_strn(mp_state, print, &sign, 1, 0, 0, 1);
            width--;
        }
        if (prefix_len) {
            len += micropy_print_strn(mp_state, print, prefix, prefix_len, 0, 0, 1);
            width -= prefix_len;
        }
    }
    if (prec > 1) {
        width = prec;
    }

    len += micropy_print_strn(mp_state, print, str, fmt_size, flags, fill, width);

    if (spaces_after) {
        len += micropy_print_strn(mp_state, print, "", 0, 0, ' ', spaces_after);
    }

    if (buf != stack_buf) {
        micropy_m_del(mp_state, char, buf, buf_size);
    }
    return len;
}

#if MICROPY_PY_BUILTINS_FLOAT
int micropy_print_float(struct _mp_state_ctx_t *mp_state, const mp_print_t *print, mp_float_t f, char fmt, int flags, char fill, int width, int prec) {
    char buf[32];
    char sign = '\0';
    int chrs = 0;

    if (flags & PF_FLAG_SHOW_SIGN) {
        sign = '+';
    }
    else
    if (flags & PF_FLAG_SPACE_SIGN) {
        sign = ' ';
    }

    int len = micropy_format_float(mp_state, f, buf, sizeof(buf), fmt, prec, sign);
    if (len < 0) {
        len = 0;
    }

    char *s = buf;

    if ((flags & PF_FLAG_ADD_PERCENT) && (size_t)(len + 1) < sizeof(buf)) {
        buf[len++] = '%';
        buf[len] = '\0';
    }

    // buf[0] < '0' returns true if the first character is space, + or -
    if ((flags & PF_FLAG_PAD_AFTER_SIGN) && buf[0] < '0') {
        // We have a sign character
        s++;
        chrs += micropy_print_strn(mp_state, print, &buf[0], 1, 0, 0, 1);
        width--;
        len--;
    }

    chrs += micropy_print_strn(mp_state, print, s, len, flags, fill, width);

    return chrs;
}
#endif

int micropy_printf(struct _mp_state_ctx_t *mp_state, const mp_print_t *print, const char *fmt, ...) {
    va_list ap;
    va_start(ap, fmt);
    int ret = micropy_vprintf(mp_state, print, fmt, ap);
    va_end(ap);
    return ret;
}

int micropy_vprintf(struct _mp_state_ctx_t *mp_state, const mp_print_t *print, const char *fmt, va_list args) {
    int chrs = 0;
    for (;;) {
        {
            const char *f = fmt;
            while (*f != '\0' && *f != '%') {
                ++f; // XXX UTF8 advance char
            }
            if (f > fmt) {
                print->print_strn(mp_state, print->data, fmt, f - fmt);
                chrs += f - fmt;
                fmt = f;
            }
        }

        if (*fmt == '\0') {
            break;
        }

        // move past % character
        ++fmt;

        // parse flags, if they exist
        int flags = 0;
        char fill = ' ';
        while (*fmt != '\0') {
            if (*fmt == '-') flags |= PF_FLAG_LEFT_ADJUST;
            else if (*fmt == '+') flags |= PF_FLAG_SHOW_SIGN;
            else if (*fmt == ' ') flags |= PF_FLAG_SPACE_SIGN;
            else if (*fmt == '!') flags |= PF_FLAG_NO_TRAILZ;
            else if (*fmt == '0') {
                flags |= PF_FLAG_PAD_AFTER_SIGN;
                fill = '0';
            } else break;
            ++fmt;
        }

        // parse width, if it exists
        int width = 0;
        for (; '0' <= *fmt && *fmt <= '9'; ++fmt) {
            width = width * 10 + *fmt - '0';
        }

        // parse precision, if it exists
        int prec = -1;
        if (*fmt == '.') {
            ++fmt;
            if (*fmt == '*') {
                ++fmt;
                prec = va_arg(args, int);
            } else {
                prec = 0;
                for (; '0' <= *fmt && *fmt <= '9'; ++fmt) {
                    prec = prec * 10 + *fmt - '0';
                }
            }
            if (prec < 0) {
                prec = 0;
            }
        }

        // parse long specifiers (current not used)
        //bool long_arg = false;
        if (*fmt == 'l') {
            ++fmt;
            //long_arg = true;
        }

        if (*fmt == '\0') {
            break;
        }

        switch (*fmt) {
            case 'b':
                if (va_arg(args, int)) {
                    chrs += micropy_print_strn(mp_state, print, "true", 4, flags, fill, width);
                } else {
                    chrs += micropy_print_strn(mp_state, print, "false", 5, flags, fill, width);
                }
                break;
            case 'c':
            {
                char str = va_arg(args, int);
                chrs += micropy_print_strn(mp_state, print, &str, 1, flags, fill, width);
                break;
            }
            case 'q':
            {
                qstr qst = va_arg(args, qstr);
                size_t len;
                const char *str = (const char*)micropy_qstr_data(mp_state, qst, &len);
                if (prec < 0) {
                    prec = len;
                }
                chrs += micropy_print_strn(mp_state, print, str, prec, flags, fill, width);
                break;
            }
            case 's':
            {
                const char *str = va_arg(args, const char*);
                if (str) {
                    if (prec < 0) {
                        prec = strlen(str);
                    }
                    chrs += micropy_print_strn(mp_state, print, str, prec, flags, fill, width);
                } else {
                    chrs += micropy_print_strn(mp_state, print, "(null)", 6, flags, fill, width);
                }
                break;
            }
            case 'u':
                chrs += micropy_print_int(mp_state, print, va_arg(args, unsigned int), 0, 10, 'a', flags, fill, width);
                break;
            case 'd':
                chrs += micropy_print_int(mp_state, print, va_arg(args, int), 1, 10, 'a', flags, fill, width);
                break;
            case 'x':
                chrs += micropy_print_int(mp_state, print, va_arg(args, unsigned int), 0, 16, 'a', flags, fill, width);
                break;
            case 'X':
                chrs += micropy_print_int(mp_state, print, va_arg(args, unsigned int), 0, 16, 'A', flags, fill, width);
                break;
            case 'p':
            case 'P': // don't bother to handle upcase for 'P'
                chrs += micropy_print_int(mp_state, print, va_arg(args, unsigned int), 0, 16, 'a', flags, fill, width);
                break;
#if MICROPY_PY_BUILTINS_FLOAT
            case 'e':
            case 'E':
            case 'f':
            case 'F':
            case 'g':
            case 'G':
            {
#if ((MICROPY_FLOAT_IMPL == MICROPY_FLOAT_IMPL_FLOAT) || (MICROPY_FLOAT_IMPL == MICROPY_FLOAT_IMPL_DOUBLE))
                mp_float_t f = va_arg(args, double);
                chrs += micropy_print_float(mp_state, print, f, *fmt, flags, fill, width, prec);
#else
#error Unknown MICROPY FLOAT IMPL
#endif
                break;
            }
#endif
            // Because 'l' is eaten above, another 'l' means %ll.  We need to support
            // this length specifier for OBJ_REPR_D (64-bit NaN boxing).
            // TODO Either enable this unconditionally, or provide a specific config var.
            #if (MICROPY_OBJ_REPR == MICROPY_OBJ_REPR_D) || defined(_WIN64)
            case 'l': {
                unsigned long long int arg_value = va_arg(args, unsigned long long int);
                ++fmt;
                if (*fmt == 'u' || *fmt == 'd') {
                    chrs += micropy_print_int(mp_state, print, arg_value, *fmt == 'd', 10, 'a', flags, fill, width);
                    break;
                }
                // fall through to default case to print unknown format char
            }
            #endif
            default:
                print->print_strn(mp_state, print->data, fmt, 1);
                chrs += 1;
                break;
        }
        ++fmt;
    }
    return chrs;
}
/*
 * This file is part of the Micro Python project, http://micropython.org/
 *
 * The MIT License (MIT)
 *
 * Copyright (c) 2013, 2014 Damien P. George
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

#include <stdio.h>
#include <stdarg.h>
#include <string.h>
#include <assert.h>

//#include "py/mpconfig.h"
//#include "py/misc.h"
//#include "py/mpprint.h"

// returned value is always at least 1 greater than argument
#define ROUND_ALLOC(a) (((a) & ((~0) - 7)) + 8)

// Init the vstr so it allocs exactly given number of bytes.  Set length to zero.
void micropy_vstr_init(struct _mp_state_ctx_t *mp_state, vstr_t *vstr, size_t alloc) {
    if (alloc < 1) {
        alloc = 1;
    }
    vstr->alloc = alloc;
    vstr->len = 0;
    vstr->buf = micropy_m_new(mp_state, char, vstr->alloc);
    if (vstr->buf == NULL) {
        vstr->had_error = true;
        return;
    }
    vstr->had_error = false;
    vstr->fixed_buf = false;
}

// Init the vstr so it allocs exactly enough ram to hold a null-terminated
// string of the given length, and set the length.
void micropy_vstr_init_len(struct _mp_state_ctx_t *mp_state, vstr_t *vstr, size_t len) {
    micropy_vstr_init(mp_state, vstr, len + 1);
    vstr->len = len;
}

void micropy_vstr_init_fixed_buf(struct _mp_state_ctx_t *mp_state, vstr_t *vstr, size_t alloc, char *buf) {
    vstr->alloc = alloc;
    vstr->len = 0;
    vstr->buf = buf;
    vstr->had_error = false;
    vstr->fixed_buf = true;
}

void micropy_vstr_init_print(struct _mp_state_ctx_t *mp_state, vstr_t *vstr, size_t alloc, mp_print_t *print) {
    micropy_vstr_init(mp_state, vstr, alloc);
    print->data = vstr;
    print->print_strn = (mp_print_strn_t)micropy_vstr_add_strn;
}

void micropy_vstr_clear(struct _mp_state_ctx_t *mp_state, vstr_t *vstr) {
    if (!vstr->fixed_buf) {
        micropy_m_del(mp_state, char, vstr->buf, vstr->alloc);
    }
    vstr->buf = NULL;
}

vstr_t *micropy_vstr_new(struct _mp_state_ctx_t *mp_state) {
    vstr_t *vstr = micropy_m_new_obj(mp_state, vstr_t);
    if (vstr == NULL) {
        return NULL;
    }
    micropy_vstr_init(mp_state, vstr, 16);
    return vstr;
}

vstr_t *micropy_vstr_new_size(struct _mp_state_ctx_t *mp_state, size_t alloc) {
    vstr_t *vstr = micropy_m_new_obj(mp_state, vstr_t);
    if (vstr == NULL) {
        return NULL;
    }
    micropy_vstr_init(mp_state, vstr, alloc);
    return vstr;
}

void micropy_vstr_free(struct _mp_state_ctx_t *mp_state, vstr_t *vstr) {
    if (vstr != NULL) {
        if (!vstr->fixed_buf) {
            micropy_m_del(mp_state, char, vstr->buf, vstr->alloc);
        }
        micropy_m_del_obj(mp_state, vstr_t, vstr);
    }
}

void micropy_vstr_reset(struct _mp_state_ctx_t *mp_state, vstr_t *vstr) {
    vstr->len = 0;
    vstr->had_error = false;
}

bool micropy_vstr_had_error(struct _mp_state_ctx_t *mp_state, vstr_t *vstr) {
    return vstr->had_error;
}

char *micropy_vstr_str(struct _mp_state_ctx_t *mp_state, vstr_t *vstr) {
    if (vstr->had_error) {
        return NULL;
    }
    return vstr->buf;
}

size_t micropy_vstr_len(struct _mp_state_ctx_t *mp_state, vstr_t *vstr) {
    if (vstr->had_error) {
        return 0;
    }
    return vstr->len;
}

// Extend vstr strictly by requested size, return pointer to newly added chunk.
char *micropy_vstr_extend(struct _mp_state_ctx_t *mp_state, vstr_t *vstr, size_t size) {
    if (vstr->fixed_buf) {
        return NULL;
    }
    char *new_buf = micropy_m_renew(mp_state, char, vstr->buf, vstr->alloc, vstr->alloc + size);
    if (new_buf == NULL) {
        vstr->had_error = true;
        return NULL;
    }
    char *p = new_buf + vstr->alloc;
    vstr->alloc += size;
    vstr->buf = new_buf;
    return p;
}

STATIC bool micropy_vstr_ensure_extra(struct _mp_state_ctx_t *mp_state, vstr_t *vstr, size_t size) {
    if (vstr->len + size > vstr->alloc) {
        if (vstr->fixed_buf) {
            return false;
        }
        size_t new_alloc = ROUND_ALLOC((vstr->len + size) + 16);
        char *new_buf = micropy_m_renew(mp_state, char, vstr->buf, vstr->alloc, new_alloc);
        if (new_buf == NULL) {
            vstr->had_error = true;
            return false;
        }
        vstr->alloc = new_alloc;
        vstr->buf = new_buf;
    }
    return true;
}

void micropy_vstr_hint_size(struct _mp_state_ctx_t *mp_state, vstr_t *vstr, size_t size) {
    // it's not an error if we fail to allocate for the size hint
    bool er = vstr->had_error;
    micropy_vstr_ensure_extra(mp_state, vstr, size);
    vstr->had_error = er;
}

char *micropy_vstr_add_len(struct _mp_state_ctx_t *mp_state, vstr_t *vstr, size_t len) {
    if (vstr->had_error || !micropy_vstr_ensure_extra(mp_state, vstr, len)) {
        return NULL;
    }
    char *buf = vstr->buf + vstr->len;
    vstr->len += len;
    return buf;
}

// Doesn't increase len, just makes sure there is a null byte at the end
char *micropy_vstr_null_terminated_str(struct _mp_state_ctx_t *mp_state, vstr_t *vstr) {
    if (vstr->had_error) {
        return NULL;
    }
    // If there's no more room, add single byte
    if (vstr->alloc == vstr->len) {
        if (micropy_vstr_extend(mp_state, vstr, 1) == NULL) {
            return NULL;
        }
    }
    vstr->buf[vstr->len] = '\0';
    return vstr->buf;
}

void micropy_vstr_add_byte(struct _mp_state_ctx_t *mp_state, vstr_t *vstr, byte b) {
    byte *buf = (byte*)micropy_vstr_add_len(mp_state, vstr, 1);
    if (buf == NULL) {
        return;
    }
    buf[0] = b;
}

void micropy_vstr_add_char(struct _mp_state_ctx_t *mp_state, vstr_t *vstr, unichar c) {
#if MICROPY_PY_BUILTINS_STR_UNICODE
    // TODO: Can this be simplified and deduplicated?
    // Is it worth just calling vstr_add_len(vstr, 4)?
    if (c < 0x80) {
        byte *buf = (byte*)micropy_vstr_add_len(mp_state, vstr, 1);
        if (buf == NULL) {
            return;
        }
        *buf = (byte)c;
    } else if (c < 0x800) {
        byte *buf = (byte*)micropy_vstr_add_len(mp_state, vstr, 2);
        if (buf == NULL) {
            return;
        }
        buf[0] = (c >> 6) | 0xC0;
        buf[1] = (c & 0x3F) | 0x80;
    } else if (c < 0x10000) {
        byte *buf = (byte*)micropy_vstr_add_len(mp_state, vstr, 3);
        if (buf == NULL) {
            return;
        }
        buf[0] = (c >> 12) | 0xE0;
        buf[1] = ((c >> 6) & 0x3F) | 0x80;
        buf[2] = (c & 0x3F) | 0x80;
    } else {
        assert(c < 0x110000);
        byte *buf = (byte*)micropy_vstr_add_len(mp_state, vstr, 4);
        if (buf == NULL) {
            return;
        }
        buf[0] = (c >> 18) | 0xF0;
        buf[1] = ((c >> 12) & 0x3F) | 0x80;
        buf[2] = ((c >> 6) & 0x3F) | 0x80;
        buf[3] = (c & 0x3F) | 0x80;
    }
#else
    micropy_vstr_add_byte(mp_state, vstr, c);
#endif
}

void micropy_vstr_add_str(struct _mp_state_ctx_t *mp_state, vstr_t *vstr, const char *str) {
    micropy_vstr_add_strn(mp_state, vstr, str, strlen(str));
}

void micropy_vstr_add_strn(struct _mp_state_ctx_t *mp_state, vstr_t *vstr, const char *str, size_t len) {
    if (vstr->had_error || !micropy_vstr_ensure_extra(mp_state, vstr, len)) {
        // if buf is fixed, we got here because there isn't enough room left
        // so just try to copy as much as we can, with room for a possible null byte
        if (vstr->fixed_buf && vstr->len < vstr->alloc) {
            len = vstr->alloc - vstr->len;
            goto copy;
        }
        return;
    }
copy:
    memmove(vstr->buf + vstr->len, str, len);
    vstr->len += len;
}

STATIC char *micropy_vstr_ins_blank_bytes(struct _mp_state_ctx_t *mp_state, vstr_t *vstr, size_t byte_pos, size_t byte_len) {
    if (vstr->had_error) {
        return NULL;
    }
    size_t l = vstr->len;
    if (byte_pos > l) {
        byte_pos = l;
    }
    if (byte_len > 0) {
        // ensure room for the new bytes
        if (!micropy_vstr_ensure_extra(mp_state, vstr, byte_len)) {
            return NULL;
        }
        // copy up the string to make room for the new bytes
        memmove(vstr->buf + byte_pos + byte_len, vstr->buf + byte_pos, l - byte_pos);
        // increase the length
        vstr->len += byte_len;
    }
    return vstr->buf + byte_pos;
}

void micropy_vstr_ins_byte(struct _mp_state_ctx_t *mp_state, vstr_t *vstr, size_t byte_pos, byte b) {
    char *s = micropy_vstr_ins_blank_bytes(mp_state, vstr, byte_pos, 1);
    if (s != NULL) {
        *s = b;
    }
}

void micropy_vstr_ins_char(struct _mp_state_ctx_t *mp_state, vstr_t *vstr, size_t char_pos, unichar chr) {
    // TODO UNICODE
    char *s = micropy_vstr_ins_blank_bytes(mp_state, vstr, char_pos, 1);
    if (s != NULL) {
        *s = chr;
    }
}

void micropy_vstr_cut_head_bytes(struct _mp_state_ctx_t *mp_state, vstr_t *vstr, size_t bytes_to_cut) {
    micropy_vstr_cut_out_bytes(mp_state, vstr, 0, bytes_to_cut);
}

void micropy_vstr_cut_tail_bytes(struct _mp_state_ctx_t *mp_state, vstr_t *vstr, size_t len) {
    if (vstr->had_error) {
        return;
    }
    if (len > vstr->len) {
        vstr->len = 0;
    } else {
        vstr->len -= len;
    }
}

void micropy_vstr_cut_out_bytes(struct _mp_state_ctx_t *mp_state, vstr_t *vstr, size_t byte_pos, size_t bytes_to_cut) {
    if (vstr->had_error || byte_pos >= vstr->len) {
        return;
    } else if (byte_pos + bytes_to_cut >= vstr->len) {
        vstr->len = byte_pos;
    } else {
        memmove(vstr->buf + byte_pos, vstr->buf + byte_pos + bytes_to_cut, vstr->len - byte_pos - bytes_to_cut);
        vstr->len -= bytes_to_cut;
    }
}

void micropy_vstr_printf(struct _mp_state_ctx_t *mp_state, vstr_t *vstr, const char *fmt, ...) {
    va_list ap;
    va_start(ap, fmt);
    micropy_vstr_vprintf(mp_state, vstr, fmt, ap);
    va_end(ap);
}

void micropy_vstr_vprintf(struct _mp_state_ctx_t *mp_state, vstr_t *vstr, const char *fmt, va_list ap) {
    mp_print_t print = {vstr, (mp_print_strn_t)micropy_vstr_add_strn};
    micropy_vprintf(mp_state, &print, fmt, ap);
}
/*
 * This file is part of the Micro Python project, http://micropython.org/
 *
 * The MIT License (MIT)
 *
 * Copyright (c) 2013, 2014 Damien P. George
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

#include <stdint.h>

//#include "py/unicode.h"

// attribute flags
#define FL_PRINT (0x01)
#define FL_SPACE (0x02)
#define FL_DIGIT (0x04)
#define FL_ALPHA (0x08)
#define FL_UPPER (0x10)
#define FL_LOWER (0x20)
#define FL_XDIGIT (0x40)

// shorthand character attributes
#define AT_PR (FL_PRINT)
#define AT_SP (FL_SPACE | FL_PRINT)
#define AT_DI (FL_DIGIT | FL_PRINT | FL_XDIGIT)
#define AT_AL (FL_ALPHA | FL_PRINT)
#define AT_UP (FL_UPPER | FL_ALPHA | FL_PRINT)
#define AT_LO (FL_LOWER | FL_ALPHA | FL_PRINT)
#define AT_UX (FL_UPPER | FL_ALPHA | FL_PRINT | FL_XDIGIT)
#define AT_LX (FL_LOWER | FL_ALPHA | FL_PRINT | FL_XDIGIT)

// table of attributes for ascii characters
STATIC const uint8_t attr[] = {
    0, 0, 0, 0, 0, 0, 0, 0,
    0, AT_SP, AT_SP, AT_SP, AT_SP, AT_SP, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    AT_SP, AT_PR, AT_PR, AT_PR, AT_PR, AT_PR, AT_PR, AT_PR,
    AT_PR, AT_PR, AT_PR, AT_PR, AT_PR, AT_PR, AT_PR, AT_PR,
    AT_DI, AT_DI, AT_DI, AT_DI, AT_DI, AT_DI, AT_DI, AT_DI,
    AT_DI, AT_DI, AT_PR, AT_PR, AT_PR, AT_PR, AT_PR, AT_PR,
    AT_PR, AT_UX, AT_UX, AT_UX, AT_UX, AT_UX, AT_UX, AT_UP,
    AT_UP, AT_UP, AT_UP, AT_UP, AT_UP, AT_UP, AT_UP, AT_UP,
    AT_UP, AT_UP, AT_UP, AT_UP, AT_UP, AT_UP, AT_UP, AT_UP,
    AT_UP, AT_UP, AT_UP, AT_PR, AT_PR, AT_PR, AT_PR, AT_PR,
    AT_PR, AT_LX, AT_LX, AT_LX, AT_LX, AT_LX, AT_LX, AT_LO,
    AT_LO, AT_LO, AT_LO, AT_LO, AT_LO, AT_LO, AT_LO, AT_LO,
    AT_LO, AT_LO, AT_LO, AT_LO, AT_LO, AT_LO, AT_LO, AT_LO,
    AT_LO, AT_LO, AT_LO, AT_PR, AT_PR, AT_PR, AT_PR, 0
};

// TODO: Rename to str_get_char
unichar utf8_get_char(const byte *s) {
#if MICROPY_PY_BUILTINS_STR_UNICODE
    unichar ord = *s++;
    if (!UTF8_IS_NONASCII(ord)) return ord;
    ord &= 0x7F;
    for (unichar mask = 0x40; ord & mask; mask >>= 1) {
        ord &= ~mask;
    }
    while (UTF8_IS_CONT(*s)) {
        ord = (ord << 6) | (*s++ & 0x3F);
    }
    return ord;
#else
    return *s;
#endif
}

// TODO: Rename to str_next_char
const byte *utf8_next_char(const byte *s) {
#if MICROPY_PY_BUILTINS_STR_UNICODE
    ++s;
    while (UTF8_IS_CONT(*s)) {
        ++s;
    }
    return s;
#else
    return s + 1;
#endif
}

mp_uint_t utf8_ptr_to_index(const byte *s, const byte *ptr) {
    mp_uint_t i = 0;
    while (ptr > s) {
        if (!UTF8_IS_CONT(*--ptr)) {
            i++;
        }
    }

    return i;
}

// TODO: Rename to str_charlen
mp_uint_t unichar_charlen(const char *str, mp_uint_t len) {
#if MICROPY_PY_BUILTINS_STR_UNICODE
    mp_uint_t charlen = 0;
    for (const char *top = str + len; str < top; ++str) {
        if (!UTF8_IS_CONT(*str)) {
            ++charlen;
        }
    }
    return charlen;
#else
    return len;
#endif
}

// Be aware: These unichar_is* functions are actually ASCII-only!
bool unichar_isspace(unichar c) {
    return c < 128 && (attr[c] & FL_SPACE) != 0;
}

bool unichar_isalpha(unichar c) {
    return c < 128 && (attr[c] & FL_ALPHA) != 0;
}

bool unichar_isprint(unichar c) {
    return c < 128 && (attr[c] & FL_PRINT) != 0;
}

bool unichar_isdigit(unichar c) {
    return c < 128 && (attr[c] & FL_DIGIT) != 0;
}

bool unichar_isxdigit(unichar c) {
    return c < 128 && (attr[c] & FL_XDIGIT) != 0;
}

bool unichar_isident(unichar c) {
    return c < 128 && ((attr[c] & (FL_ALPHA | FL_DIGIT)) != 0 || c == '_');
}

bool unichar_isupper(unichar c) {
    return c < 128 && (attr[c] & FL_UPPER) != 0;
}

bool unichar_islower(unichar c) {
    return c < 128 && (attr[c] & FL_LOWER) != 0;
}

unichar unichar_tolower(unichar c) {
    if (unichar_isupper(c)) {
        return c + 0x20;
    }
    return c;
}

unichar unichar_toupper(unichar c) {
    if (unichar_islower(c)) {
        return c - 0x20;
    }
    return c;
}

mp_uint_t unichar_xdigit_value(unichar c) {
    // c is assumed to be hex digit
    mp_uint_t n = c - '0';
    if (n > 9) {
        n &= ~('a' - 'A');
        n -= ('A' - ('9' + 1));
    }
    return n;
}
/*
 * This file is part of the Micro Python project, http://micropython.org/
 *
 * The MIT License (MIT)
 *
 * Copyright (c) 2013, 2014 Damien P. George
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

#include <string.h>
#include <assert.h>

//#include "py/mpz.h"

#if MICROPY_LONGINT_IMPL == MICROPY_LONGINT_IMPL_MPZ

#define DIG_SIZE (MPZ_DIG_SIZE)
#undef DIG_MASK
#define DIG_MASK ((MPZ_LONG_1 << DIG_SIZE) - 1)
#define DIG_MSB  (MPZ_LONG_1 << (DIG_SIZE - 1))
#define DIG_BASE (MPZ_LONG_1 << DIG_SIZE)

/*
 mpz is an arbitrary precision integer type with a public API.

 mpn functions act on non-negative integers represented by an array of generalised
 digits (eg a word per digit).  You also need to specify separately the length of the
 array.  There is no public API for mpn.  Rather, the functions are used by mpz to
 implement its features.

 Integer values are stored little endian (first digit is first in memory).

 Definition of normalise: ?
*/

/* compares i with j
   returns sign(i - j)
   assumes i, j are normalised
*/
STATIC int micropy_mpn_cmp(struct _mp_state_ctx_t *mp_state, const mpz_dig_t *idig, mp_uint_t ilen, const mpz_dig_t *jdig, mp_uint_t jlen) {
    if (ilen < jlen) { return -1; }
    if (ilen > jlen) { return 1; }

    for (idig += ilen, jdig += ilen; ilen > 0; --ilen) {
        mpz_dbl_dig_signed_t cmp = (mpz_dbl_dig_t)*(--idig) - (mpz_dbl_dig_t)*(--jdig);
        if (cmp < 0) { return -1; }
        if (cmp > 0) { return 1; }
    }

    return 0;
}

/* computes i = j << n
   returns number of digits in i
   assumes enough memory in i; assumes normalised j; assumes n > 0
   can have i, j pointing to same memory
*/
STATIC mp_uint_t micropy_mpn_shl(struct _mp_state_ctx_t *mp_state, mpz_dig_t *idig, mpz_dig_t *jdig, mp_uint_t jlen, mp_uint_t n) {
    mp_uint_t n_whole = (n + DIG_SIZE - 1) / DIG_SIZE;
    mp_uint_t n_part = n % DIG_SIZE;
    if (n_part == 0) {
        n_part = DIG_SIZE;
    }

    // start from the high end of the digit arrays
    idig += jlen + n_whole - 1;
    jdig += jlen - 1;

    // shift the digits
    mpz_dbl_dig_t d = 0;
    for (mp_uint_t i = jlen; i > 0; i--, idig--, jdig--) {
        d |= *jdig;
        *idig = (d >> (DIG_SIZE - n_part)) & DIG_MASK;
        d <<= DIG_SIZE;
    }

    // store remaining bits
    *idig = (d >> (DIG_SIZE - n_part)) & DIG_MASK;
    idig -= n_whole - 1;
    memset(idig, 0, (n_whole - 1) * sizeof(mpz_dig_t));

    // work out length of result
    jlen += n_whole;
    while (jlen != 0 && idig[jlen - 1] == 0) {
        jlen--;
    }

    // return length of result
    return jlen;
}

/* computes i = j >> n
   returns number of digits in i
   assumes enough memory in i; assumes normalised j; assumes n > 0
   can have i, j pointing to same memory
*/
STATIC mp_uint_t micropy_mpn_shr(struct _mp_state_ctx_t *mp_state, mpz_dig_t *idig, mpz_dig_t *jdig, mp_uint_t jlen, mp_uint_t n) {
    mp_uint_t n_whole = n / DIG_SIZE;
    mp_uint_t n_part = n % DIG_SIZE;

    if (n_whole >= jlen) {
        return 0;
    }

    jdig += n_whole;
    jlen -= n_whole;

    for (mp_uint_t i = jlen; i > 0; i--, idig++, jdig++) {
        mpz_dbl_dig_t d = *jdig;
        if (i > 1) {
            d |= (mpz_dbl_dig_t)jdig[1] << DIG_SIZE;
        }
        d >>= n_part;
        *idig = d & DIG_MASK;
    }

    if (idig[-1] == 0) {
        jlen--;
    }

    return jlen;
}

/* computes i = j + k
   returns number of digits in i
   assumes enough memory in i; assumes normalised j, k; assumes jlen >= klen
   can have i, j, k pointing to same memory
*/
STATIC mp_uint_t micropy_mpn_add(struct _mp_state_ctx_t *mp_state, mpz_dig_t *idig, const mpz_dig_t *jdig, mp_uint_t jlen, const mpz_dig_t *kdig, mp_uint_t klen) {
    mpz_dig_t *oidig = idig;
    mpz_dbl_dig_t carry = 0;

    jlen -= klen;

    for (; klen > 0; --klen, ++idig, ++jdig, ++kdig) {
        carry += (mpz_dbl_dig_t)*jdig + (mpz_dbl_dig_t)*kdig;
        *idig = carry & DIG_MASK;
        carry >>= DIG_SIZE;
    }

    for (; jlen > 0; --jlen, ++idig, ++jdig) {
        carry += *jdig;
        *idig = carry & DIG_MASK;
        carry >>= DIG_SIZE;
    }

    if (carry != 0) {
        *idig++ = carry;
    }

    return idig - oidig;
}

/* computes i = j - k
   returns number of digits in i
   assumes enough memory in i; assumes normalised j, k; assumes j >= k
   can have i, j, k pointing to same memory
*/
STATIC mp_uint_t micropy_mpn_sub(struct _mp_state_ctx_t *mp_state, mpz_dig_t *idig, const mpz_dig_t *jdig, mp_uint_t jlen, const mpz_dig_t *kdig, mp_uint_t klen) {
    mpz_dig_t *oidig = idig;
    mpz_dbl_dig_signed_t borrow = 0;

    jlen -= klen;

    for (; klen > 0; --klen, ++idig, ++jdig, ++kdig) {
        borrow += (mpz_dbl_dig_t)*jdig - (mpz_dbl_dig_t)*kdig;
        *idig = borrow & DIG_MASK;
        borrow >>= DIG_SIZE;
    }

    for (; jlen > 0; --jlen, ++idig, ++jdig) {
        borrow += *jdig;
        *idig = borrow & DIG_MASK;
        borrow >>= DIG_SIZE;
    }

    for (--idig; idig >= oidig && *idig == 0; --idig) {
    }

    return idig + 1 - oidig;
}

STATIC mp_uint_t micropy_mpn_remove_trailing_zeros(struct _mp_state_ctx_t *mp_state, mpz_dig_t *oidig, mpz_dig_t *idig) {
    for (--idig; idig >= oidig && *idig == 0; --idig) {
    }
    return idig + 1 - oidig;
}

#if MICROPY_OPT_MPZ_BITWISE

/* computes i = j & k
   returns number of digits in i
   assumes enough memory in i; assumes normalised j, k; assumes jlen >= klen (jlen argument not needed)
   can have i, j, k pointing to same memory
*/
STATIC mp_uint_t micropy_mpn_and(struct _mp_state_ctx_t *mp_state, mpz_dig_t *idig, const mpz_dig_t *jdig, const mpz_dig_t *kdig, mp_uint_t klen) {
    mpz_dig_t *oidig = idig;

    for (; klen > 0; --klen, ++idig, ++jdig, ++kdig) {
        *idig = *jdig & *kdig;
    }

    return micropy_mpn_remove_trailing_zeros(mp_state, oidig, idig);
}

#endif

/*  i = -((-j) & (-k))                = ~((~j + 1) & (~k + 1)) + 1
    i =  (j & (-k)) =  (j & (~k + 1)) =  (  j      & (~k + 1))
    i =  ((-j) & k) =  ((~j + 1) & k) =  ((~j + 1) &   k     )
   computes general form:
   i = (im ^ (((j ^ jm) + jc) & ((k ^ km) + kc))) + ic  where Xm = Xc == 0 ? 0 : DIG_MASK
   returns number of digits in i
   assumes enough memory in i; assumes normalised j, k; assumes length j >= length k
   can have i, j, k pointing to same memory
*/
STATIC mp_uint_t micropy_mpn_and_neg(struct _mp_state_ctx_t *mp_state, mpz_dig_t *idig, const mpz_dig_t *jdig, mp_uint_t jlen, const mpz_dig_t *kdig, mp_uint_t klen,
                            mpz_dbl_dig_t carryi, mpz_dbl_dig_t carryj, mpz_dbl_dig_t carryk) {
    mpz_dig_t *oidig = idig;
    mpz_dig_t imask = (0 == carryi) ? 0 : DIG_MASK;
    mpz_dig_t jmask = (0 == carryj) ? 0 : DIG_MASK;
    mpz_dig_t kmask = (0 == carryk) ? 0 : DIG_MASK;

    for (; jlen > 0; ++idig, ++jdig) {
        carryj += *jdig ^ jmask;
        carryk += (--klen <= --jlen) ? (*kdig++ ^ kmask) : kmask;
        carryi += ((carryj & carryk) ^ imask) & DIG_MASK;
        *idig = carryi & DIG_MASK;
        carryk >>= DIG_SIZE;
        carryj >>= DIG_SIZE;
        carryi >>= DIG_SIZE;
    }

    if (0 != carryi) {
        *idig++ = carryi;
    }

    return micropy_mpn_remove_trailing_zeros(mp_state, oidig, idig);
}

#if MICROPY_OPT_MPZ_BITWISE

/* computes i = j | k
   returns number of digits in i
   assumes enough memory in i; assumes normalised j, k; assumes jlen >= klen
   can have i, j, k pointing to same memory
*/
STATIC mp_uint_t micropy_mpn_or(struct _mp_state_ctx_t *mp_state, mpz_dig_t *idig, const mpz_dig_t *jdig, mp_uint_t jlen, const mpz_dig_t *kdig, mp_uint_t klen) {
    mpz_dig_t *oidig = idig;

    jlen -= klen;

    for (; klen > 0; --klen, ++idig, ++jdig, ++kdig) {
        *idig = *jdig | *kdig;
    }

    for (; jlen > 0; --jlen, ++idig, ++jdig) {
        *idig = *jdig;
    }

    return idig - oidig;
}

#endif

/*  i = -((-j) | (-k))                = ~((~j + 1) | (~k + 1)) + 1
    i = -(j | (-k)) = -(j | (~k + 1)) = ~(  j      | (~k + 1)) + 1
    i = -((-j) | k) = -((~j + 1) | k) = ~((~j + 1) |   k     ) + 1
   computes general form:
   i = ~(((j ^ jm) + jc) | ((k ^ km) + kc)) + 1  where Xm = Xc == 0 ? 0 : DIG_MASK
   returns number of digits in i
   assumes enough memory in i; assumes normalised j, k; assumes length j >= length k
   can have i, j, k pointing to same memory
*/

#if MICROPY_OPT_MPZ_BITWISE

STATIC mp_uint_t micropy_mpn_or_neg(struct _mp_state_ctx_t *mp_state, mpz_dig_t *idig, const mpz_dig_t *jdig, mp_uint_t jlen, const mpz_dig_t *kdig, mp_uint_t klen,
                            mpz_dbl_dig_t carryj, mpz_dbl_dig_t carryk) {
    mpz_dig_t *oidig = idig;
    mpz_dbl_dig_t carryi = 1;
    mpz_dig_t jmask = (0 == carryj) ? 0 : DIG_MASK;
    mpz_dig_t kmask = (0 == carryk) ? 0 : DIG_MASK;

    for (; jlen > 0; ++idig, ++jdig) {
        carryj += *jdig ^ jmask;
        carryk += (--klen <= --jlen) ? (*kdig++ ^ kmask) : kmask;
        carryi += ((carryj | carryk) ^ DIG_MASK) & DIG_MASK;
        *idig = carryi & DIG_MASK;
        carryk >>= DIG_SIZE;
        carryj >>= DIG_SIZE;
        carryi >>= DIG_SIZE;
    }

    if (0 != carryi) {
        *idig++ = carryi;
    }

    return micropy_mpn_remove_trailing_zeros(mp_state, oidig, idig);
}

#else

STATIC mp_uint_t micropy_mpn_or_neg(struct _mp_state_ctx_t *mp_state, mpz_dig_t *idig, const mpz_dig_t *jdig, mp_uint_t jlen, const mpz_dig_t *kdig, mp_uint_t klen,
                            mpz_dbl_dig_t carryi, mpz_dbl_dig_t carryj, mpz_dbl_dig_t carryk) {
    mpz_dig_t *oidig = idig;
    mpz_dig_t imask = (0 == carryi) ? 0 : DIG_MASK;
    mpz_dig_t jmask = (0 == carryj) ? 0 : DIG_MASK;
    mpz_dig_t kmask = (0 == carryk) ? 0 : DIG_MASK;

    for (; jlen > 0; ++idig, ++jdig) {
        carryj += *jdig ^ jmask;
        carryk += (--klen <= --jlen) ? (*kdig++ ^ kmask) : kmask;
        carryi += ((carryj | carryk) ^ imask) & DIG_MASK;
        *idig = carryi & DIG_MASK;
        carryk >>= DIG_SIZE;
        carryj >>= DIG_SIZE;
        carryi >>= DIG_SIZE;
    }

    if (0 != carryi) {
        *idig++ = carryi;
    }

    return micropy_mpn_remove_trailing_zeros(mp_state, oidig, idig);
}

#endif

#if MICROPY_OPT_MPZ_BITWISE

/* computes i = j ^ k
   returns number of digits in i
   assumes enough memory in i; assumes normalised j, k; assumes jlen >= klen
   can have i, j, k pointing to same memory
*/
STATIC mp_uint_t micropy_mpn_xor(struct _mp_state_ctx_t *mp_state, mpz_dig_t *idig, const mpz_dig_t *jdig, mp_uint_t jlen, const mpz_dig_t *kdig, mp_uint_t klen) {
    mpz_dig_t *oidig = idig;

    jlen -= klen;

    for (; klen > 0; --klen, ++idig, ++jdig, ++kdig) {
        *idig = *jdig ^ *kdig;
    }

    for (; jlen > 0; --jlen, ++idig, ++jdig) {
        *idig = *jdig;
    }

    return micropy_mpn_remove_trailing_zeros(mp_state, oidig, idig);
}

#endif

/*  i = (-j) ^ (-k) = ~(j - 1) ^ ~(k - 1)                   = (j - 1) ^ (k - 1)
    i = -(j ^ (-k)) = -(j ^ ~(k - 1)) = ~(j ^ ~(k - 1)) + 1 = (j ^ (k - 1)) + 1
    i = -((-j) ^ k) = -(~(j - 1) ^ k) = ~(~(j - 1) ^ k) + 1 = ((j - 1) ^ k) + 1
   computes general form:
   i = ((j - 1 + jc) ^ (k - 1 + kc)) + ic
   returns number of digits in i
   assumes enough memory in i; assumes normalised j, k; assumes length j >= length k
   can have i, j, k pointing to same memory
*/
STATIC mp_uint_t micropy_mpn_xor_neg(struct _mp_state_ctx_t *mp_state, mpz_dig_t *idig, const mpz_dig_t *jdig, mp_uint_t jlen, const mpz_dig_t *kdig, mp_uint_t klen,
                              mpz_dbl_dig_t carryi, mpz_dbl_dig_t carryj, mpz_dbl_dig_t carryk) {
    mpz_dig_t *oidig = idig;

    for (; jlen > 0; ++idig, ++jdig) {
        carryj += *jdig + DIG_MASK;
        carryk += (--klen <= --jlen) ? (*kdig++ + DIG_MASK) : DIG_MASK;
        carryi += (carryj ^ carryk) & DIG_MASK;
        *idig = carryi & DIG_MASK;
        carryk >>= DIG_SIZE;
        carryj >>= DIG_SIZE;
        carryi >>= DIG_SIZE;
    }

    if (0 != carryi) {
        *idig++ = carryi;
    }

    return micropy_mpn_remove_trailing_zeros(mp_state, oidig, idig);
}

/* computes i = i * d1 + d2
   returns number of digits in i
   assumes enough memory in i; assumes normalised i; assumes dmul != 0
*/
STATIC mp_uint_t micropy_mpn_mul_dig_add_dig(struct _mp_state_ctx_t *mp_state, mpz_dig_t *idig, mp_uint_t ilen, mpz_dig_t dmul, mpz_dig_t dadd) {
    mpz_dig_t *oidig = idig;
    mpz_dbl_dig_t carry = dadd;

    for (; ilen > 0; --ilen, ++idig) {
        carry += (mpz_dbl_dig_t)*idig * (mpz_dbl_dig_t)dmul; // will never overflow so long as DIG_SIZE <= 8*sizeof(mpz_dbl_dig_t)/2
        *idig = carry & DIG_MASK;
        carry >>= DIG_SIZE;
    }

    if (carry != 0) {
        *idig++ = carry;
    }

    return idig - oidig;
}

/* computes i = j * k
   returns number of digits in i
   assumes enough memory in i; assumes i is zeroed; assumes normalised j, k
   can have j, k point to same memory
*/
STATIC mp_uint_t micropy_mpn_mul(struct _mp_state_ctx_t *mp_state, mpz_dig_t *idig, mpz_dig_t *jdig, mp_uint_t jlen, mpz_dig_t *kdig, mp_uint_t klen) {
    mpz_dig_t *oidig = idig;
    mp_uint_t ilen = 0;

    for (; klen > 0; --klen, ++idig, ++kdig) {
        mpz_dig_t *id = idig;
        mpz_dbl_dig_t carry = 0;

        mp_uint_t jl = jlen;
        for (mpz_dig_t *jd = jdig; jl > 0; --jl, ++jd, ++id) {
            carry += (mpz_dbl_dig_t)*id + (mpz_dbl_dig_t)*jd * (mpz_dbl_dig_t)*kdig; // will never overflow so long as DIG_SIZE <= 8*sizeof(mpz_dbl_dig_t)/2
            *id = carry & DIG_MASK;
            carry >>= DIG_SIZE;
        }

        if (carry != 0) {
            *id++ = carry;
        }

        ilen = id - oidig;
    }

    return ilen;
}

/* natural_div - quo * den + new_num = old_num (ie num is replaced with rem)
   assumes den != 0
   assumes num_dig has enough memory to be extended by 1 digit
   assumes quo_dig has enough memory (as many digits as num)
   assumes quo_dig is filled with zeros
*/
STATIC void micropy_mpn_div(struct _mp_state_ctx_t *mp_state, mpz_dig_t *num_dig, mp_uint_t *num_len, const mpz_dig_t *den_dig, mp_uint_t den_len, mpz_dig_t *quo_dig, mp_uint_t *quo_len) {
    mpz_dig_t *orig_num_dig = num_dig;
    mpz_dig_t *orig_quo_dig = quo_dig;
    mpz_dig_t norm_shift = 0;
    mpz_dbl_dig_t lead_den_digit;

    // handle simple cases
    {
        int cmp = micropy_mpn_cmp(mp_state, num_dig, *num_len, den_dig, den_len);
        if (cmp == 0) {
            *num_len = 0;
            quo_dig[0] = 1;
            *quo_len = 1;
            return;
        } else if (cmp < 0) {
            // numerator remains the same
            *quo_len = 0;
            return;
        }
    }

    // We need to normalise the denominator (leading bit of leading digit is 1)
    // so that the division routine works.  Since the denominator memory is
    // read-only we do the normalisation on the fly, each time a digit of the
    // denominator is needed.  We need to know is how many bits to shift by.

    // count number of leading zeros in leading digit of denominator
    {
        mpz_dig_t d = den_dig[den_len - 1];
        while ((d & DIG_MSB) == 0) {
            d <<= 1;
            ++norm_shift;
        }
    }

    // now need to shift numerator by same amount as denominator
    // first, increase length of numerator in case we need more room to shift
    num_dig[*num_len] = 0;
    ++(*num_len);
    for (mpz_dig_t *num = num_dig, carry = 0; num < num_dig + *num_len; ++num) {
        mpz_dig_t n = *num;
        *num = ((n << norm_shift) | carry) & DIG_MASK;
        carry = (mpz_dbl_dig_t)n >> (DIG_SIZE - norm_shift);
    }

    // cache the leading digit of the denominator
    lead_den_digit = (mpz_dbl_dig_t)den_dig[den_len - 1] << norm_shift;
    if (den_len >= 2) {
        lead_den_digit |= (mpz_dbl_dig_t)den_dig[den_len - 2] >> (DIG_SIZE - norm_shift);
    }

    // point num_dig to last digit in numerator
    num_dig += *num_len - 1;

    // calculate number of digits in quotient
    *quo_len = *num_len - den_len;

    // point to last digit to store for quotient
    quo_dig += *quo_len - 1;

    // keep going while we have enough digits to divide
    while (*num_len > den_len) {
        mpz_dbl_dig_t quo = ((mpz_dbl_dig_t)*num_dig << DIG_SIZE) | num_dig[-1];

        // get approximate quotient
        quo /= lead_den_digit;

        // Multiply quo by den and subtract from num to get remainder.
        // We have different code here to handle different compile-time
        // configurations of mpz:
        //
        //   1. DIG_SIZE is stricly less than half the number of bits
        //      available in mpz_dbl_dig_t.  In this case we can use a
        //      slightly more optimal (in time and space) routine that
        //      uses the extra bits in mpz_dbl_dig_signed_t to store a
        //      sign bit.
        //
        //   2. DIG_SIZE is exactly half the number of bits available in
        //      mpz_dbl_dig_t.  In this (common) case we need to be careful
        //      not to overflow the borrow variable.  And the shifting of
        //      borrow needs some special logic (it's a shift right with
        //      round up).

        if (DIG_SIZE < 8 * sizeof(mpz_dbl_dig_t) / 2) {
            const mpz_dig_t *d = den_dig;
            mpz_dbl_dig_t d_norm = 0;
            mpz_dbl_dig_signed_t borrow = 0;

            for (mpz_dig_t *n = num_dig - den_len; n < num_dig; ++n, ++d) {
                d_norm = ((mpz_dbl_dig_t)*d << norm_shift) | (d_norm >> DIG_SIZE);
                borrow += (mpz_dbl_dig_t)*n - (mpz_dbl_dig_t)quo * (d_norm & DIG_MASK); // will overflow if DIG_SIZE >= 8*sizeof(mpz_dbl_dig_t)/2
                *n = borrow & DIG_MASK;
                borrow >>= DIG_SIZE;
            }
            borrow += *num_dig; // will overflow if DIG_SIZE >= 8*sizeof(mpz_dbl_dig_t)/2
            *num_dig = borrow & DIG_MASK;
            borrow >>= DIG_SIZE;

            // adjust quotient if it is too big
            for (; borrow != 0; --quo) {
                d = den_dig;
                d_norm = 0;
                mpz_dbl_dig_t carry = 0;
                for (mpz_dig_t *n = num_dig - den_len; n < num_dig; ++n, ++d) {
                    d_norm = ((mpz_dbl_dig_t)*d << norm_shift) | (d_norm >> DIG_SIZE);
                    carry += (mpz_dbl_dig_t)*n + (d_norm & DIG_MASK);
                    *n = carry & DIG_MASK;
                    carry >>= DIG_SIZE;
                }
                carry += *num_dig;
                *num_dig = carry & DIG_MASK;
                carry >>= DIG_SIZE;

                borrow += carry;
            }
        } else { // DIG_SIZE == 8 * sizeof(mpz_dbl_dig_t) / 2
            const mpz_dig_t *d = den_dig;
            mpz_dbl_dig_t d_norm = 0;
            mpz_dbl_dig_t borrow = 0;

            for (mpz_dig_t *n = num_dig - den_len; n < num_dig; ++n, ++d) {
                d_norm = ((mpz_dbl_dig_t)*d << norm_shift) | (d_norm >> DIG_SIZE);
                mpz_dbl_dig_t x = (mpz_dbl_dig_t)quo * (d_norm & DIG_MASK);
                if (x >= *n || *n - x <= borrow) {
                    borrow += (mpz_dbl_dig_t)x - (mpz_dbl_dig_t)*n;
                    *n = (-borrow) & DIG_MASK;
                    borrow = (borrow >> DIG_SIZE) + ((borrow & DIG_MASK) == 0 ? 0 : 1); // shift-right with round-up
                } else {
                    *n = ((mpz_dbl_dig_t)*n - (mpz_dbl_dig_t)x - (mpz_dbl_dig_t)borrow) & DIG_MASK;
                    borrow = 0;
                }
            }
            if (borrow >= *num_dig) {
                borrow -= (mpz_dbl_dig_t)*num_dig;
                *num_dig = (-borrow) & DIG_MASK;
                borrow = (borrow >> DIG_SIZE) + ((borrow & DIG_MASK) == 0 ? 0 : 1); // shift-right with round-up
            } else {
                *num_dig = (*num_dig - borrow) & DIG_MASK;
                borrow = 0;
            }

            // adjust quotient if it is too big
            for (; borrow != 0; --quo) {
                d = den_dig;
                d_norm = 0;
                mpz_dbl_dig_t carry = 0;
                for (mpz_dig_t *n = num_dig - den_len; n < num_dig; ++n, ++d) {
                    d_norm = ((mpz_dbl_dig_t)*d << norm_shift) | (d_norm >> DIG_SIZE);
                    carry += (mpz_dbl_dig_t)*n + (d_norm & DIG_MASK);
                    *n = carry & DIG_MASK;
                    carry >>= DIG_SIZE;
                }
                carry += (mpz_dbl_dig_t)*num_dig;
                *num_dig = carry & DIG_MASK;
                carry >>= DIG_SIZE;

                //assert(borrow >= carry); // enable this to check the logic
                borrow -= carry;
            }
        }

        // store this digit of the quotient
        *quo_dig = quo & DIG_MASK;
        --quo_dig;

        // move down to next digit of numerator
        --num_dig;
        --(*num_len);
    }

    // unnormalise numerator (remainder now)
    for (mpz_dig_t *num = orig_num_dig + *num_len - 1, carry = 0; num >= orig_num_dig; --num) {
        mpz_dig_t n = *num;
        *num = ((n >> norm_shift) | carry) & DIG_MASK;
        carry = (mpz_dbl_dig_t)n << (DIG_SIZE - norm_shift);
    }

    // strip trailing zeros

    while (*quo_len > 0 && orig_quo_dig[*quo_len - 1] == 0) {
        --(*quo_len);
    }

    while (*num_len > 0 && orig_num_dig[*num_len - 1] == 0) {
        --(*num_len);
    }
}

#define MIN_ALLOC (2)

STATIC const uint8_t log_base2_floor[] = {
    0,
    0, 1, 1, 2,
    2, 2, 2, 3,
    3, 3, 3, 3,
    3, 3, 3, 4,
    4, 4, 4, 4,
    4, 4, 4, 4,
    4, 4, 4, 4,
    4, 4, 4, 5
};

void micropy_mpz_init_zero(struct _mp_state_ctx_t *mp_state, mpz_t *z) {
    z->neg = 0;
    z->fixed_dig = 0;
    z->alloc = 0;
    z->len = 0;
    z->dig = NULL;
}

void micropy_mpz_init_from_int(struct _mp_state_ctx_t *mp_state, mpz_t *z, mp_int_t val) {
    micropy_mpz_init_zero(mp_state, z);
    micropy_mpz_set_from_int(mp_state, z, val);
}

void micropy_mpz_init_fixed_from_int(struct _mp_state_ctx_t *mp_state, mpz_t *z, mpz_dig_t *dig, mp_uint_t alloc, mp_int_t val) {
    z->neg = 0;
    z->fixed_dig = 1;
    z->alloc = alloc;
    z->len = 0;
    z->dig = dig;
    micropy_mpz_set_from_int(mp_state, z, val);
}

void micropy_mpz_deinit(struct _mp_state_ctx_t *mp_state, mpz_t *z) {
    if (z != NULL && !z->fixed_dig) {
        micropy_m_del(mp_state, mpz_dig_t, z->dig, z->alloc);
    }
}

#if 0
these functions are unused

mpz_t *micropy_mpz_zero(struct _mp_state_ctx_t *mp_state) {
    mpz_t *z = micropy_m_new_obj(mp_state, mpz_t);
    micropy_mpz_init_zero(mp_state, z);
    return z;
}

mpz_t *micropy_mpz_from_int(struct _mp_state_ctx_t *mp_state, mp_int_t val) {
    mpz_t *z = micropy_mpz_zero(mp_state);
    micropy_mpz_set_from_int(mp_state, z, val);
    return z;
}

mpz_t *micropy_mpz_from_ll(struct _mp_state_ctx_t *mp_state, long long val, bool is_signed) {
    mpz_t *z = micropy_mpz_zero(mp_state);
    micropy_mpz_set_from_ll(mp_state, z, val, is_signed);
    return z;
}

#if MICROPY_PY_BUILTINS_FLOAT
mpz_t *micropy_mpz_from_float(struct _mp_state_ctx_t *mp_state, mp_float_t val) {
    mpz_t *z = micropy_mpz_zero(mp_state);
    micropy_mpz_set_from_float(mp_state, z, val);
    return z;
}
#endif

mpz_t *micropy_mpz_from_str(struct _mp_state_ctx_t *mp_state, const char *str, mp_uint_t len, bool neg, mp_uint_t base) {
    mpz_t *z = micropy_mpz_zero(mp_state);
    micropy_mpz_set_from_str(mp_state, z, str, len, neg, base);
    return z;
}
#endif

STATIC void micropy_mpz_free(struct _mp_state_ctx_t *mp_state, mpz_t *z) {
    if (z != NULL) {
        micropy_m_del(mp_state, mpz_dig_t, z->dig, z->alloc);
        micropy_m_del_obj(mp_state, mpz_t, z);
    }
}

STATIC void micropy_mpz_need_dig(struct _mp_state_ctx_t *mp_state, mpz_t *z, mp_uint_t need) {
    if (need < MIN_ALLOC) {
        need = MIN_ALLOC;
    }

    if (z->dig == NULL || z->alloc < need) {
        if (z->fixed_dig) {
            // cannot reallocate fixed buffers
            assert(0);
            return;
        }
        z->dig = micropy_m_renew(mp_state, mpz_dig_t, z->dig, z->alloc, need);
        z->alloc = need;
    }
}

STATIC mpz_t *micropy_mpz_clone(struct _mp_state_ctx_t *mp_state, const mpz_t *src) {
    mpz_t *z = micropy_m_new_obj(mp_state, mpz_t);
    z->neg = src->neg;
    z->fixed_dig = 0;
    z->alloc = src->alloc;
    z->len = src->len;
    if (src->dig == NULL) {
        z->dig = NULL;
    } else {
        z->dig = micropy_m_new(mp_state, mpz_dig_t, z->alloc);
        memcpy(z->dig, src->dig, src->alloc * sizeof(mpz_dig_t));
    }
    return z;
}

/* sets dest = src
   can have dest, src the same
*/
void micropy_mpz_set(struct _mp_state_ctx_t *mp_state, mpz_t *dest, const mpz_t *src) {
    micropy_mpz_need_dig(mp_state, dest, src->len);
    dest->neg = src->neg;
    dest->len = src->len;
    memcpy(dest->dig, src->dig, src->len * sizeof(mpz_dig_t));
}

void micropy_mpz_set_from_int(struct _mp_state_ctx_t *mp_state, mpz_t *z, mp_int_t val) {
    if (val == 0) {
        z->len = 0;
        return;
    }

    micropy_mpz_need_dig(mp_state, z, MPZ_NUM_DIG_FOR_INT);

    mp_uint_t uval;
    if (val < 0) {
        z->neg = 1;
        uval = -val;
    } else {
        z->neg = 0;
        uval = val;
    }

    z->len = 0;
    while (uval > 0) {
        z->dig[z->len++] = uval & DIG_MASK;
        uval >>= DIG_SIZE;
    }
}

void micropy_mpz_set_from_ll(struct _mp_state_ctx_t *mp_state, mpz_t *z, long long val, bool is_signed) {
    micropy_mpz_need_dig(mp_state, z, MPZ_NUM_DIG_FOR_LL);

    unsigned long long uval;
    if (is_signed && val < 0) {
        z->neg = 1;
        uval = -val;
    } else {
        z->neg = 0;
        uval = val;
    }

    z->len = 0;
    while (uval > 0) {
        z->dig[z->len++] = uval & DIG_MASK;
        uval >>= DIG_SIZE;
    }
}

#if MICROPY_PY_BUILTINS_FLOAT
void micropy_mpz_set_from_float(struct _mp_state_ctx_t *mp_state, mpz_t *z, mp_float_t src) {
#if MICROPY_FLOAT_IMPL == MICROPY_FLOAT_IMPL_DOUBLE
typedef uint64_t mp_float_int_t;
#elif MICROPY_FLOAT_IMPL == MICROPY_FLOAT_IMPL_FLOAT
typedef uint32_t mp_float_int_t;
#endif
    union {
        mp_float_t f;
        #if MP_ENDIANNESS_LITTLE
        struct { mp_float_int_t frc:MP_FLOAT_FRAC_BITS, exp:MP_FLOAT_EXP_BITS, sgn:1; } p;
        #else
        struct { mp_float_int_t sgn:1, exp:MP_FLOAT_EXP_BITS, frc:MP_FLOAT_FRAC_BITS; } p;
        #endif
    } u = {src};

    z->neg = u.p.sgn;
    if (u.p.exp == 0) {
        // value == 0 || value < 1
        micropy_mpz_set_from_int(mp_state, z, 0);
    } else if (u.p.exp == ((1 << MP_FLOAT_EXP_BITS) - 1)) {
        // u.p.frc == 0 indicates inf, else NaN
        // should be handled by caller
        micropy_mpz_set_from_int(mp_state, z, 0);
    } else {
        const int adj_exp = (int)u.p.exp - MP_FLOAT_EXP_BIAS;
        if (adj_exp < 0) {
            // value < 1 , truncates to 0
            micropy_mpz_set_from_int(mp_state, z, 0);
        } else if (adj_exp == 0) {
            // 1 <= value < 2 , so truncates to 1
            micropy_mpz_set_from_int(mp_state, z, 1);
        } else {
            // 2 <= value
            const int dig_cnt = (adj_exp + 1 + (DIG_SIZE - 1)) / DIG_SIZE;
            const unsigned int rem = adj_exp % DIG_SIZE;
            int dig_ind, shft;
            mp_float_int_t frc = u.p.frc | ((mp_float_int_t)1 << MP_FLOAT_FRAC_BITS);

            if (adj_exp < MP_FLOAT_FRAC_BITS) {
                shft = 0;
                dig_ind = 0;
                frc >>= MP_FLOAT_FRAC_BITS - adj_exp;
            } else {
                shft = (rem - MP_FLOAT_FRAC_BITS) % DIG_SIZE;
                dig_ind = (adj_exp - MP_FLOAT_FRAC_BITS) / DIG_SIZE;
            }
            micropy_mpz_need_dig(mp_state, z, dig_cnt);
            z->len = dig_cnt;
            if (dig_ind != 0) {
                memset(z->dig, 0, dig_ind * sizeof(mpz_dig_t));
            }
            if (shft != 0) {
                z->dig[dig_ind++] = (frc << shft) & DIG_MASK;
                frc >>= DIG_SIZE - shft;
            }
#if DIG_SIZE < (MP_FLOAT_FRAC_BITS + 1)
            while (dig_ind != dig_cnt) {
                z->dig[dig_ind++] = frc & DIG_MASK;
                frc >>= DIG_SIZE;
            }
#else
            if (dig_ind != dig_cnt) {
                z->dig[dig_ind] = frc;
            }
#endif
        }
    }
}
#endif

// returns number of bytes from str that were processed
mp_uint_t micropy_mpz_set_from_str(struct _mp_state_ctx_t *mp_state, mpz_t *z, const char *str, mp_uint_t len, bool neg, mp_uint_t base) {
    assert(base < 36);

    const char *cur = str;
    const char *top = str + len;

    micropy_mpz_need_dig(mp_state, z, len * 8 / DIG_SIZE + 1);

    if (neg) {
        z->neg = 1;
    } else {
        z->neg = 0;
    }

    z->len = 0;
    for (; cur < top; ++cur) { // XXX UTF8 next char
        //mp_uint_t v = char_to_numeric(cur#); // XXX UTF8 get char
        mp_uint_t v = *cur;
        if ('0' <= v && v <= '9') {
            v -= '0';
        } else if ('A' <= v && v <= 'Z') {
            v -= 'A' - 10;
        } else if ('a' <= v && v <= 'z') {
            v -= 'a' - 10;
        } else {
            break;
        }
        if (v >= base) {
            break;
        }
        z->len = micropy_mpn_mul_dig_add_dig(mp_state, z->dig, z->len, base, v);
    }

    return cur - str;
}

bool micropy_mpz_is_zero(struct _mp_state_ctx_t *mp_state, const mpz_t *z) {
    return z->len == 0;
}

#if 0
these functions are unused

bool micropy_mpz_is_pos(struct _mp_state_ctx_t *mp_state, const mpz_t *z) {
    return z->len > 0 && z->neg == 0;
}

bool micropy_mpz_is_neg(struct _mp_state_ctx_t *mp_state, const mpz_t *z) {
    return z->len > 0 && z->neg != 0;
}

bool micropy_mpz_is_odd(struct _mp_state_ctx_t *mp_state, const mpz_t *z) {
    return z->len > 0 && (z->dig[0] & 1) != 0;
}

bool micropy_mpz_is_even(struct _mp_state_ctx_t *mp_state, const mpz_t *z) {
    return z->len == 0 || (z->dig[0] & 1) == 0;
}
#endif

int micropy_mpz_cmp(struct _mp_state_ctx_t *mp_state, const mpz_t *z1, const mpz_t *z2) {
    // to catch comparison of -0 with +0
    if (z1->len == 0 && z2->len == 0) {
        return 0;
    }
    int cmp = (int)z2->neg - (int)z1->neg;
    if (cmp != 0) {
        return cmp;
    }
    cmp = micropy_mpn_cmp(mp_state, z1->dig, z1->len, z2->dig, z2->len);
    if (z1->neg != 0) {
        cmp = -cmp;
    }
    return cmp;
}

#if 0
// obsolete
// compares mpz with an integer that fits within DIG_SIZE bits
mp_int_t micropy_mpz_cmp_sml_int(struct _mp_state_ctx_t *mp_state, const mpz_t *z, mp_int_t sml_int) {
    mp_int_t cmp;
    if (z->neg == 0) {
        if (sml_int < 0) return 1;
        if (sml_int == 0) {
            if (z->len == 0) return 0;
            return 1;
        }
        if (z->len == 0) return -1;
        assert(sml_int < (1 << DIG_SIZE));
        if (z->len != 1) return 1;
        cmp = z->dig[0] - sml_int;
    } else {
        if (sml_int > 0) return -1;
        if (sml_int == 0) {
            if (z->len == 0) return 0;
            return -1;
        }
        if (z->len == 0) return 1;
        assert(sml_int > -(1 << DIG_SIZE));
        if (z->len != 1) return -1;
        cmp = -z->dig[0] - sml_int;
    }
    if (cmp < 0) return -1;
    if (cmp > 0) return 1;
    return 0;
}
#endif

#if 0
these functions are unused

/* returns abs(z)
*/
mpz_t *micropy_mpz_abs(struct _mp_state_ctx_t *mp_state, const mpz_t *z) {
    mpz_t *z2 = micropy_mpz_clone(mp_state, z);
    z2->neg = 0;
    return z2;
}

/* returns -z
*/
mpz_t *micropy_mpz_neg(struct _mp_state_ctx_t *mp_state, const mpz_t *z) {
    mpz_t *z2 = micropy_mpz_clone(mp_state, z);
    z2->neg = 1 - z2->neg;
    return z2;
}

/* returns lhs + rhs
   can have lhs, rhs the same
*/
mpz_t *micropy_mpz_add(struct _mp_state_ctx_t *mp_state, const mpz_t *lhs, const mpz_t *rhs) {
    mpz_t *z = micropy_mpz_zero(mp_state);
    micropy_mpz_add_inpl(mp_state, z, lhs, rhs);
    return z;
}

/* returns lhs - rhs
   can have lhs, rhs the same
*/
mpz_t *micropy_mpz_sub(struct _mp_state_ctx_t *mp_state, const mpz_t *lhs, const mpz_t *rhs) {
    mpz_t *z = micropy_mpz_zero(mp_state);
    micropy_mpz_sub_inpl(mp_state, z, lhs, rhs);
    return z;
}

/* returns lhs * rhs
   can have lhs, rhs the same
*/
mpz_t *micropy_mpz_mul(struct _mp_state_ctx_t *mp_state, const mpz_t *lhs, const mpz_t *rhs) {
    mpz_t *z = micropy_mpz_zero(mp_state);
    micropy_mpz_mul_inpl(mp_state, z, lhs, rhs);
    return z;
}

/* returns lhs ** rhs
   can have lhs, rhs the same
*/
mpz_t *micropy_mpz_pow(struct _mp_state_ctx_t *mp_state, const mpz_t *lhs, const mpz_t *rhs) {
    mpz_t *z = micropy_mpz_zero(mp_state);
    micropy_mpz_pow_inpl(mp_state, z, lhs, rhs);
    return z;
}

/* computes new integers in quo and rem such that:
       quo * rhs + rem = lhs
       0 <= rem < rhs
   can have lhs, rhs the same
*/
void micropy_mpz_divmod(struct _mp_state_ctx_t *mp_state, const mpz_t *lhs, const mpz_t *rhs, mpz_t **quo, mpz_t **rem) {
    *quo = micropy_mpz_zero(mp_state);
    *rem = micropy_mpz_zero(mp_state);
    micropy_mpz_divmod_inpl(mp_state, *quo, *rem, lhs, rhs);
}
#endif

/* computes dest = abs(z)
   can have dest, z the same
*/
void micropy_mpz_abs_inpl(struct _mp_state_ctx_t *mp_state, mpz_t *dest, const mpz_t *z) {
    if (dest != z) {
        micropy_mpz_set(mp_state, dest, z);
    }
    dest->neg = 0;
}

/* computes dest = -z
   can have dest, z the same
*/
void micropy_mpz_neg_inpl(struct _mp_state_ctx_t *mp_state, mpz_t *dest, const mpz_t *z) {
    if (dest != z) {
        micropy_mpz_set(mp_state, dest, z);
    }
    dest->neg = 1 - dest->neg;
}

/* computes dest = ~z (= -z - 1)
   can have dest, z the same
*/
void micropy_mpz_not_inpl(struct _mp_state_ctx_t *mp_state, mpz_t *dest, const mpz_t *z) {
    if (dest != z) {
        micropy_mpz_set(mp_state, dest, z);
    }
    if (dest->len == 0) {
        micropy_mpz_need_dig(mp_state, dest, 1);
        dest->dig[0] = 1;
        dest->len = 1;
        dest->neg = 1;
    } else if (dest->neg) {
        dest->neg = 0;
        mpz_dig_t k = 1;
        dest->len = micropy_mpn_sub(mp_state, dest->dig, dest->dig, dest->len, &k, 1);
    } else {
        micropy_mpz_need_dig(mp_state, dest, dest->len + 1);
        mpz_dig_t k = 1;
        dest->len = micropy_mpn_add(mp_state, dest->dig, dest->dig, dest->len, &k, 1);
        dest->neg = 1;
    }
}

/* computes dest = lhs << rhs
   can have dest, lhs the same
*/
void micropy_mpz_shl_inpl(struct _mp_state_ctx_t *mp_state, mpz_t *dest, const mpz_t *lhs, mp_uint_t rhs) {
    if (lhs->len == 0 || rhs == 0) {
        micropy_mpz_set(mp_state, dest, lhs);
    } else {
        micropy_mpz_need_dig(mp_state, dest, lhs->len + (rhs + DIG_SIZE - 1) / DIG_SIZE);
        dest->len = micropy_mpn_shl(mp_state, dest->dig, lhs->dig, lhs->len, rhs);
        dest->neg = lhs->neg;
    }
}

/* computes dest = lhs >> rhs
   can have dest, lhs the same
*/
void micropy_mpz_shr_inpl(struct _mp_state_ctx_t *mp_state, mpz_t *dest, const mpz_t *lhs, mp_uint_t rhs) {
    if (lhs->len == 0 || rhs == 0) {
        micropy_mpz_set(mp_state, dest, lhs);
    } else {
        micropy_mpz_need_dig(mp_state, dest, lhs->len);
        dest->len = micropy_mpn_shr(mp_state, dest->dig, lhs->dig, lhs->len, rhs);
        dest->neg = lhs->neg;
        if (dest->neg) {
            // arithmetic shift right, rounding to negative infinity
            mp_uint_t n_whole = rhs / DIG_SIZE;
            mp_uint_t n_part = rhs % DIG_SIZE;
            mpz_dig_t round_up = 0;
            for (mp_uint_t i = 0; i < lhs->len && i < n_whole; i++) {
                if (lhs->dig[i] != 0) {
                    round_up = 1;
                    break;
                }
            }
            if (n_whole < lhs->len && (lhs->dig[n_whole] & ((1 << n_part) - 1)) != 0) {
                round_up = 1;
            }
            if (round_up) {
                if (dest->len == 0) {
                    // dest == 0, so need to add 1 by hand (answer will be -1)
                    dest->dig[0] = 1;
                    dest->len = 1;
                } else {
                    // dest > 0, so can use mpn_add to add 1
                    dest->len = micropy_mpn_add(mp_state, dest->dig, dest->dig, dest->len, &round_up, 1);
                }
            }
        }
    }
}

/* computes dest = lhs + rhs
   can have dest, lhs, rhs the same
*/
void micropy_mpz_add_inpl(struct _mp_state_ctx_t *mp_state, mpz_t *dest, const mpz_t *lhs, const mpz_t *rhs) {
    if (micropy_mpn_cmp(mp_state, lhs->dig, lhs->len, rhs->dig, rhs->len) < 0) {
        const mpz_t *temp = lhs;
        lhs = rhs;
        rhs = temp;
    }

    if (lhs->neg == rhs->neg) {
        micropy_mpz_need_dig(mp_state, dest, lhs->len + 1);
        dest->len = micropy_mpn_add(mp_state, dest->dig, lhs->dig, lhs->len, rhs->dig, rhs->len);
    } else {
        micropy_mpz_need_dig(mp_state, dest, lhs->len);
        dest->len = micropy_mpn_sub(mp_state, dest->dig, lhs->dig, lhs->len, rhs->dig, rhs->len);
    }

    dest->neg = lhs->neg;
}

/* computes dest = lhs - rhs
   can have dest, lhs, rhs the same
*/
void micropy_mpz_sub_inpl(struct _mp_state_ctx_t *mp_state, mpz_t *dest, const mpz_t *lhs, const mpz_t *rhs) {
    bool neg = false;

    if (micropy_mpn_cmp(mp_state, lhs->dig, lhs->len, rhs->dig, rhs->len) < 0) {
        const mpz_t *temp = lhs;
        lhs = rhs;
        rhs = temp;
        neg = true;
    }

    if (lhs->neg != rhs->neg) {
        micropy_mpz_need_dig(mp_state, dest, lhs->len + 1);
        dest->len = micropy_mpn_add(mp_state, dest->dig, lhs->dig, lhs->len, rhs->dig, rhs->len);
    } else {
        micropy_mpz_need_dig(mp_state, dest, lhs->len);
        dest->len = micropy_mpn_sub(mp_state, dest->dig, lhs->dig, lhs->len, rhs->dig, rhs->len);
    }

    if (neg) {
        dest->neg = 1 - lhs->neg;
    } else {
        dest->neg = lhs->neg;
    }
}

/* computes dest = lhs & rhs
   can have dest, lhs, rhs the same
*/
void micropy_mpz_and_inpl(struct _mp_state_ctx_t *mp_state, mpz_t *dest, const mpz_t *lhs, const mpz_t *rhs) {
    // make sure lhs has the most digits
    if (lhs->len < rhs->len) {
        const mpz_t *temp = lhs;
        lhs = rhs;
        rhs = temp;
    }

    #if MICROPY_OPT_MPZ_BITWISE

    if ((0 == lhs->neg) && (0 == rhs->neg)) {
        micropy_mpz_need_dig(mp_state, dest, lhs->len);
        dest->len = micropy_mpn_and(mp_state, dest->dig, lhs->dig, rhs->dig, rhs->len);
        dest->neg = 0;
    } else {
        micropy_mpz_need_dig(mp_state, dest, lhs->len + 1);
        dest->len = micropy_mpn_and_neg(mp_state, dest->dig, lhs->dig, lhs->len, rhs->dig, rhs->len,
                                 lhs->neg == rhs->neg, 0 != lhs->neg, 0 != rhs->neg);
        dest->neg = lhs->neg & rhs->neg;
    }

    #else

    micropy_mpz_need_dig(mp_state, dest, lhs->len + (lhs->neg || rhs->neg));
    dest->len = micropy_mpn_and_neg(mp_state, dest->dig, lhs->dig, lhs->len, rhs->dig, rhs->len,
                             (lhs->neg == rhs->neg) ? lhs->neg : 0, lhs->neg, rhs->neg);
    dest->neg = lhs->neg & rhs->neg;

    #endif
}

/* computes dest = lhs | rhs
   can have dest, lhs, rhs the same
*/
void micropy_mpz_or_inpl(struct _mp_state_ctx_t *mp_state, mpz_t *dest, const mpz_t *lhs, const mpz_t *rhs) {
    // make sure lhs has the most digits
    if (lhs->len < rhs->len) {
        const mpz_t *temp = lhs;
        lhs = rhs;
        rhs = temp;
    }

    #if MICROPY_OPT_MPZ_BITWISE

    if ((0 == lhs->neg) && (0 == rhs->neg)) {
        micropy_mpz_need_dig(mp_state, dest, lhs->len);
        dest->len = micropy_mpn_or(mp_state, dest->dig, lhs->dig, lhs->len, rhs->dig, rhs->len);
        dest->neg = 0;
    } else {
        micropy_mpz_need_dig(mp_state, dest, lhs->len + 1);
        dest->len = micropy_mpn_or_neg(mp_state, dest->dig, lhs->dig, lhs->len, rhs->dig, rhs->len,
                                 0 != lhs->neg, 0 != rhs->neg);
        dest->neg = 1;
    }

    #else

    micropy_mpz_need_dig(mp_state, dest, lhs->len + (lhs->neg || rhs->neg));
    dest->len = micropy_mpn_or_neg(mp_state, dest->dig, lhs->dig, lhs->len, rhs->dig, rhs->len,
                             (lhs->neg || rhs->neg), lhs->neg, rhs->neg);
    dest->neg = lhs->neg | rhs->neg;

    #endif
}

/* computes dest = lhs ^ rhs
   can have dest, lhs, rhs the same
*/
void micropy_mpz_xor_inpl(struct _mp_state_ctx_t *mp_state, mpz_t *dest, const mpz_t *lhs, const mpz_t *rhs) {
    // make sure lhs has the most digits
    if (lhs->len < rhs->len) {
        const mpz_t *temp = lhs;
        lhs = rhs;
        rhs = temp;
    }

    #if MICROPY_OPT_MPZ_BITWISE

    if (lhs->neg == rhs->neg) {
        micropy_mpz_need_dig(mp_state, dest, lhs->len);
        if (lhs->neg == 0) {
            dest->len = micropy_mpn_xor(mp_state, dest->dig, lhs->dig, lhs->len, rhs->dig, rhs->len);
        } else {
            dest->len = micropy_mpn_xor_neg(mp_state, dest->dig, lhs->dig, lhs->len, rhs->dig, rhs->len, 0, 0, 0);
        }
        dest->neg = 0;
    } else {
        micropy_mpz_need_dig(mp_state, dest, lhs->len + 1);
        dest->len = micropy_mpn_xor_neg(mp_state, dest->dig, lhs->dig, lhs->len, rhs->dig, rhs->len, 1,
                                0 == lhs->neg, 0 == rhs->neg);
        dest->neg = 1;
    }

    #else

    micropy_mpz_need_dig(mp_state, dest, lhs->len + (lhs->neg || rhs->neg));
    dest->len = micropy_mpn_xor_neg(mp_state, dest->dig, lhs->dig, lhs->len, rhs->dig, rhs->len,
                             (lhs->neg != rhs->neg), 0 == lhs->neg, 0 == rhs->neg);
    dest->neg = lhs->neg ^ rhs->neg;

    #endif
}

/* computes dest = lhs * rhs
   can have dest, lhs, rhs the same
*/
void micropy_mpz_mul_inpl(struct _mp_state_ctx_t *mp_state, mpz_t *dest, const mpz_t *lhs, const mpz_t *rhs) {
    if (lhs->len == 0 || rhs->len == 0) {
        micropy_mpz_set_from_int(mp_state, dest, 0);
        return;
    }

    mpz_t *temp = NULL;
    if (lhs == dest) {
        lhs = temp = micropy_mpz_clone(mp_state, lhs);
        if (rhs == dest) {
            rhs = lhs;
        }
    } else if (rhs == dest) {
        rhs = temp = micropy_mpz_clone(mp_state, rhs);
    }

    micropy_mpz_need_dig(mp_state, dest, lhs->len + rhs->len); // min mem l+r-1, max mem l+r
    memset(dest->dig, 0, dest->alloc * sizeof(mpz_dig_t));
    dest->len = micropy_mpn_mul(mp_state, dest->dig, lhs->dig, lhs->len, rhs->dig, rhs->len);

    if (lhs->neg == rhs->neg) {
        dest->neg = 0;
    } else {
        dest->neg = 1;
    }

    micropy_mpz_free(mp_state, temp);
}

/* computes dest = lhs ** rhs
   can have dest, lhs, rhs the same
*/
void micropy_mpz_pow_inpl(struct _mp_state_ctx_t *mp_state, mpz_t *dest, const mpz_t *lhs, const mpz_t *rhs) {
    if (lhs->len == 0 || rhs->neg != 0) {
        micropy_mpz_set_from_int(mp_state, dest, 0);
        return;
    }

    if (rhs->len == 0) {
        micropy_mpz_set_from_int(mp_state, dest, 1);
        return;
    }

    mpz_t *x = micropy_mpz_clone(mp_state, lhs);
    mpz_t *n = micropy_mpz_clone(mp_state, rhs);

    micropy_mpz_set_from_int(mp_state, dest, 1);

    while (n->len > 0) {
        if ((n->dig[0] & 1) != 0) {
            micropy_mpz_mul_inpl(mp_state, dest, dest, x);
        }
        n->len = micropy_mpn_shr(mp_state, n->dig, n->dig, n->len, 1);
        if (n->len == 0) {
            break;
        }
        micropy_mpz_mul_inpl(mp_state, x, x, x);
    }

    micropy_mpz_free(mp_state, x);
    micropy_mpz_free(mp_state, n);
}

#if 0
these functions are unused

/* computes dest = (lhs ** rhs) % mod
   can have dest, lhs, rhs the same; mod can't be the same as dest
*/
void micropy_mpz_pow3_inpl(struct _mp_state_ctx_t *mp_state, mpz_t *dest, const mpz_t *lhs, const mpz_t *rhs, const mpz_t *mod) {
    if (lhs->len == 0 || rhs->neg != 0) {
        micropy_mpz_set_from_int(mp_state, dest, 0);
        return;
    }

    if (rhs->len == 0) {
        micropy_mpz_set_from_int(mp_state, dest, 1);
        return;
    }

    mpz_t *x = micropy_mpz_clone(mp_state, lhs);
    mpz_t *n = micropy_mpz_clone(mp_state, rhs);
    mpz_t quo; micropy_mpz_init_zero(mp_state, &quo);

    micropy_mpz_set_from_int(mp_state, dest, 1);

    while (n->len > 0) {
        if ((n->dig[0] & 1) != 0) {
            micropy_mpz_mul_inpl(mp_state, dest, dest, x);
            micropy_mpz_divmod_inpl(mp_state, &quo, dest, dest, mod);
        }
        n->len = micropy_mpn_shr(mp_state, n->dig, n->dig, n->len, 1);
        if (n->len == 0) {
            break;
        }
        micropy_mpz_mul_inpl(mp_state, x, x, x);
        micropy_mpz_divmod_inpl(mp_state, &quo, x, x, mod);
    }

    micropy_mpz_deinit(mp_state, &quo);
    micropy_mpz_free(mp_state, x);
    micropy_mpz_free(mp_state, n);
}

/* computes gcd(z1, z2)
   based on Knuth's modified gcd algorithm (I think?)
   gcd(z1, z2) >= 0
   gcd(0, 0) = 0
   gcd(z, 0) = abs(z)
*/
mpz_t *micropy_mpz_gcd(struct _mp_state_ctx_t *mp_state, const mpz_t *z1, const mpz_t *z2) {
    if (z1->len == 0) {
        mpz_t *a = micropy_mpz_clone(mp_state, z2);
        a->neg = 0;
        return a;
    } else if (z2->len == 0) {
        mpz_t *a = micropy_mpz_clone(mp_state, z1);
        a->neg = 0;
        return a;
    }

    mpz_t *a = micropy_mpz_clone(mp_state, z1);
    mpz_t *b = micropy_mpz_clone(mp_state, z2);
    mpz_t c; micropy_mpz_init_zero(mp_state, &c);
    a->neg = 0;
    b->neg = 0;

    for (;;) {
        if (micropy_mpz_cmp(mp_state, a, b) < 0) {
            if (a->len == 0) {
                micropy_mpz_free(mp_state, a);
                micropy_mpz_deinit(mp_state, &c);
                return b;
            }
            mpz_t *t = a; a = b; b = t;
        }
        if (!(b->len >= 2 || (b->len == 1 && b->dig[0] > 1))) { // compute b > 0; could be mpz_cmp_small_int(b, 1) > 0
            break;
        }
        micropy_mpz_set(mp_state, &c, b);
        do {
            micropy_mpz_add_inpl(mp_state, &c, &c, &c);
        } while (micropy_mpz_cmp(mp_state, &c, a) <= 0);
        c.len = micropy_mpn_shr(mp_state, c.dig, c.dig, c.len, 1);
        micropy_mpz_sub_inpl(mp_state, a, a, &c);
    }

    micropy_mpz_deinit(mp_state, &c);

    if (b->len == 1 && b->dig[0] == 1) { // compute b == 1; could be mpz_cmp_small_int(b, 1) == 0
        micropy_mpz_free(mp_state, a);
        return b;
    } else {
        micropy_mpz_free(mp_state, b);
        return a;
    }
}

/* computes lcm(z1, z2)
     = micropy_abs(mp_state, z1) / micropy_gcd(mp_state, z1, z2) * micropy_abs(mp_state, z2)
  lcm(z1, z1) >= 0
  lcm(0, 0) = 0
  lcm(z, 0) = 0
*/
mpz_t *micropy_mpz_lcm(struct _mp_state_ctx_t *mp_state, const mpz_t *z1, const mpz_t *z2) {
    if (z1->len == 0 || z2->len == 0) {
        return micropy_mpz_zero(mp_state);
    }

    mpz_t *gcd = micropy_mpz_gcd(mp_state, z1, z2);
    mpz_t *quo = micropy_mpz_zero(mp_state);
    mpz_t *rem = micropy_mpz_zero(mp_state);
    micropy_mpz_divmod_inpl(mp_state, quo, rem, z1, gcd);
    micropy_mpz_mul_inpl(mp_state, rem, quo, z2);
    micropy_mpz_free(mp_state, gcd);
    micropy_mpz_free(mp_state, quo);
    rem->neg = 0;
    return rem;
}
#endif

/* computes new integers in quo and rem such that:
       quo * rhs + rem = lhs
       0 <= rem < rhs
   can have lhs, rhs the same
*/
void micropy_mpz_divmod_inpl(struct _mp_state_ctx_t *mp_state, mpz_t *dest_quo, mpz_t *dest_rem, const mpz_t *lhs, const mpz_t *rhs) {
    if (rhs->len == 0) {
        micropy_mpz_set_from_int(mp_state, dest_quo, 0);
        micropy_mpz_set_from_int(mp_state, dest_rem, 0);
        return;
    }

    micropy_mpz_need_dig(mp_state, dest_quo, lhs->len + 1); // +1 necessary?
    memset(dest_quo->dig, 0, (lhs->len + 1) * sizeof(mpz_dig_t));
    dest_quo->len = 0;
    micropy_mpz_need_dig(mp_state, dest_rem, lhs->len + 1); // +1 necessary?
    micropy_mpz_set(mp_state, dest_rem, lhs);
    micropy_mpn_div(mp_state, dest_rem->dig, &dest_rem->len, rhs->dig, rhs->len, dest_quo->dig, &dest_quo->len);

    // check signs and do Python style modulo
    if (lhs->neg != rhs->neg) {
        dest_quo->neg = 1;
        if (!micropy_mpz_is_zero(mp_state, dest_rem)) {
            mpz_t mpzone; micropy_mpz_init_from_int(mp_state, &mpzone, -1);
            micropy_mpz_add_inpl(mp_state, dest_quo, dest_quo, &mpzone);
            micropy_mpz_add_inpl(mp_state, dest_rem, dest_rem, rhs);
        }
    }
}

#if 0
these functions are unused

/* computes floor(lhs / rhs)
   can have lhs, rhs the same
*/
mpz_t *micropy_mpz_div(struct _mp_state_ctx_t *mp_state, const mpz_t *lhs, const mpz_t *rhs) {
    mpz_t *quo = micropy_mpz_zero(mp_state);
    mpz_t rem; micropy_mpz_init_zero(mp_state, &rem);
    micropy_mpz_divmod_inpl(mp_state, quo, &rem, lhs, rhs);
    micropy_mpz_deinit(mp_state, &rem);
    return quo;
}

/* computes lhs % rhs ( >= 0)
   can have lhs, rhs the same
*/
mpz_t *micropy_mpz_mod(struct _mp_state_ctx_t *mp_state, const mpz_t *lhs, const mpz_t *rhs) {
    mpz_t quo; micropy_mpz_init_zero(mp_state, &quo);
    mpz_t *rem = micropy_mpz_zero(mp_state);
    micropy_mpz_divmod_inpl(mp_state, &quo, rem, lhs, rhs);
    micropy_mpz_deinit(mp_state, &quo);
    return rem;
}
#endif

// must return actual int value if it fits in mp_int_t
mp_int_t micropy_mpz_hash(struct _mp_state_ctx_t *mp_state, const mpz_t *z) {
    mp_int_t val = 0;
    mpz_dig_t *d = z->dig + z->len;

    while (d-- > z->dig) {
        val = (val << DIG_SIZE) | *d;
    }

    if (z->neg != 0) {
        val = -val;
    }

    return val;
}

bool micropy_mpz_as_int_checked(struct _mp_state_ctx_t *mp_state, const mpz_t *i, mp_int_t *value) {
    mp_uint_t val = 0;
    mpz_dig_t *d = i->dig + i->len;

    while (d-- > i->dig) {
        if (val > (~(WORD_MSBIT_HIGH) >> DIG_SIZE)) {
            // will overflow
            return false;
        }
        val = (val << DIG_SIZE) | *d;
    }

    if (i->neg != 0) {
        val = -val;
    }

    *value = val;
    return true;
}

bool micropy_mpz_as_uint_checked(struct _mp_state_ctx_t *mp_state, const mpz_t *i, mp_uint_t *value) {
    if (i->neg != 0) {
        // can't represent signed values
        return false;
    }

    mp_uint_t val = 0;
    mpz_dig_t *d = i->dig + i->len;

    while (d-- > i->dig) {
        if (val > (~(WORD_MSBIT_HIGH) >> (DIG_SIZE - 1))) {
            // will overflow
            return false;
        }
        val = (val << DIG_SIZE) | *d;
    }

    *value = val;
    return true;
}

// writes at most len bytes to buf (so buf should be zeroed before calling)
void micropy_mpz_as_bytes(struct _mp_state_ctx_t *mp_state, const mpz_t *z, bool big_endian, mp_uint_t len, byte *buf) {
    byte *b = buf;
    if (big_endian) {
        b += len;
    }
    mpz_dig_t *zdig = z->dig;
    int bits = 0;
    mpz_dbl_dig_t d = 0;
    mpz_dbl_dig_t carry = 1;
    for (mp_uint_t zlen = z->len; zlen > 0; --zlen) {
        bits += DIG_SIZE;
        d = (d << DIG_SIZE) | *zdig++;
        for (; bits >= 8; bits -= 8, d >>= 8) {
            mpz_dig_t val = d;
            if (z->neg) {
                val = (~val & 0xff) + carry;
                carry = val >> 8;
            }
            if (big_endian) {
                *--b = val;
                if (b == buf) {
                    return;
                }
            } else {
                *b++ = val;
                if (b == buf + len) {
                    return;
                }
            }
        }
    }
}

#if MICROPY_PY_BUILTINS_FLOAT
mp_float_t micropy_mpz_as_float(struct _mp_state_ctx_t *mp_state, const mpz_t *i) {
    mp_float_t val = 0;
    mpz_dig_t *d = i->dig + i->len;

    while (d-- > i->dig) {
        val = val * DIG_BASE + *d;
    }

    if (i->neg != 0) {
        val = -val;
    }

    return val;
}
#endif

mp_uint_t micropy_mpz_as_str_size(struct _mp_state_ctx_t *mp_state, const mpz_t *i, mp_uint_t base, const char *prefix, char comma) {
    if (base < 2 || base > 32) {
        return 0;
    }

    mp_uint_t num_digits = i->len * DIG_SIZE / log_base2_floor[base] + 1;
    mp_uint_t num_commas = comma ? num_digits / 3: 0;
    mp_uint_t prefix_len = prefix ? strlen(prefix) : 0;

    return num_digits + num_commas + prefix_len + 2; // +1 for sign, +1 for null byte
}

#if 0
this function is unused
char *micropy_mpz_as_str(struct _mp_state_ctx_t *mp_state, const mpz_t *i, mp_uint_t base) {
    char *s = micropy_m_new(mp_state, char, micropy_mpz_as_str_size(mp_state, i, base, NULL, '\0'));
    micropy_mpz_as_str_inpl(mp_state, i, base, NULL, 'a', '\0', s);
    return s;
}
#endif

// assumes enough space as calculated by mpz_as_str_size
// returns length of string, not including null byte
mp_uint_t micropy_mpz_as_str_inpl(struct _mp_state_ctx_t *mp_state, const mpz_t *i, mp_uint_t base, const char *prefix, char base_char, char comma, char *str) {
    if (str == NULL || base < 2 || base > 32) {
        str[0] = 0;
        return 0;
    }

    mp_uint_t ilen = i->len;

    char *s = str;
    if (ilen == 0) {
        if (prefix) {
            while (*prefix)
                *s++ = *prefix++;
        }
        *s++ = '0';
        *s = '\0';
        return s - str;
    }

    // make a copy of mpz digits, so we can do the div/mod calculation
    mpz_dig_t *dig = micropy_m_new(mp_state, mpz_dig_t, ilen);
    memcpy(dig, i->dig, ilen * sizeof(mpz_dig_t));

    // convert
    char *last_comma = str;
    bool done;
    do {
        mpz_dig_t *d = dig + ilen;
        mpz_dbl_dig_t a = 0;

        // compute next remainder
        while (--d >= dig) {
            a = (a << DIG_SIZE) | *d;
            *d = a / base;
            a %= base;
        }

        // convert to character
        a += '0';
        if (a > '9') {
            a += base_char - '9' - 1;
        }
        *s++ = a;

        // check if number is zero
        done = true;
        for (d = dig; d < dig + ilen; ++d) {
            if (*d != 0) {
                done = false;
                break;
            }
        }
        if (comma && (s - last_comma) == 3) {
            *s++ = comma;
            last_comma = s;
        }
    }
    while (!done);

    // free the copy of the digits array
    micropy_m_del(mp_state, mpz_dig_t, dig, ilen);

    if (prefix) {
        const char *p = &prefix[strlen(prefix)];
        while (p > prefix) {
            *s++ = *--p;
        }
    }
    if (i->neg != 0) {
        *s++ = '-';
    }

    // reverse string
    for (char *u = str, *v = s - 1; u < v; ++u, --v) {
        char temp = *u;
        *u = *v;
        *v = temp;
    }

    *s = '\0'; // null termination

    return s - str;
}

#endif // MICROPY_LONGINT_IMPL == MICROPY_LONGINT_IMPL_MPZ
/*
 * This file is part of the Micro Python project, http://micropython.org/
 *
 * The MIT License (MIT)
 *
 * Copyright (c) 2013, 2014 Damien P. George
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

#include <assert.h>
#include <stdio.h>
#include <string.h>

//#include "py/mpstate.h"
//#include "py/gc.h"
//#include "py/obj.h"
//#include "py/runtime.h"

#if MICROPY_ENABLE_GC

#if 0 // print debugging info
#define DEBUG_PRINT (1)
#define DEBUG_printf DEBUG_printf
#else // don't print debugging info
#define DEBUG_PRINT (0)
#define DEBUG_printf(...) (void)0
#endif

// make this 1 to dump the heap each time it changes
#define EXTENSIVE_HEAP_PROFILING (0)

#define WORDS_PER_BLOCK ((MICROPY_BYTES_PER_GC_BLOCK) / BYTES_PER_WORD)
#define BYTES_PER_BLOCK (MICROPY_BYTES_PER_GC_BLOCK)

// ATB = allocation table byte
// 0b00 = FREE -- free block
// 0b01 = HEAD -- head of a chain of blocks
// 0b10 = TAIL -- in the tail of a chain of blocks
// 0b11 = MARK -- marked head block

#define AT_FREE (0)
#define AT_HEAD (1)
#define AT_TAIL (2)
#define AT_MARK (3)

#define BLOCKS_PER_ATB (4)
#define ATB_MASK_0 (0x03)
#define ATB_MASK_1 (0x0c)
#define ATB_MASK_2 (0x30)
#define ATB_MASK_3 (0xc0)

#define ATB_0_IS_FREE(a) (((a) & ATB_MASK_0) == 0)
#define ATB_1_IS_FREE(a) (((a) & ATB_MASK_1) == 0)
#define ATB_2_IS_FREE(a) (((a) & ATB_MASK_2) == 0)
#define ATB_3_IS_FREE(a) (((a) & ATB_MASK_3) == 0)

#define BLOCK_SHIFT(block) (2 * ((block) & (BLOCKS_PER_ATB - 1)))
#define ATB_GET_KIND(block) (((mp_state)->mem.gc_alloc_table_start[(block) / BLOCKS_PER_ATB] >> BLOCK_SHIFT(block)) & 3)
#define ATB_ANY_TO_FREE(block) do { (mp_state)->mem.gc_alloc_table_start[(block) / BLOCKS_PER_ATB] &= (~(AT_MARK << BLOCK_SHIFT(block))); } while (0)
#define ATB_FREE_TO_HEAD(block) do { (mp_state)->mem.gc_alloc_table_start[(block) / BLOCKS_PER_ATB] |= (AT_HEAD << BLOCK_SHIFT(block)); } while (0)
#define ATB_FREE_TO_TAIL(block) do { (mp_state)->mem.gc_alloc_table_start[(block) / BLOCKS_PER_ATB] |= (AT_TAIL << BLOCK_SHIFT(block)); } while (0)
#define ATB_HEAD_TO_MARK(block) do { (mp_state)->mem.gc_alloc_table_start[(block) / BLOCKS_PER_ATB] |= (AT_MARK << BLOCK_SHIFT(block)); } while (0)
#define ATB_MARK_TO_HEAD(block) do { (mp_state)->mem.gc_alloc_table_start[(block) / BLOCKS_PER_ATB] &= (~(AT_TAIL << BLOCK_SHIFT(block))); } while (0)

#define BLOCK_FROM_PTR(ptr) (((byte*)(ptr) - (mp_state)->mem.gc_pool_start) / BYTES_PER_BLOCK)
#define PTR_FROM_BLOCK(block) (((block) * BYTES_PER_BLOCK + (uintptr_t)(mp_state)->mem.gc_pool_start))
#define ATB_FROM_BLOCK(bl) ((bl) / BLOCKS_PER_ATB)

#if MICROPY_ENABLE_FINALISER
// FTB = finaliser table byte
// if set, then the corresponding block may have a finaliser

#define BLOCKS_PER_FTB (8)

#define FTB_GET(block) (((mp_state)->mem.gc_finaliser_table_start[(block) / BLOCKS_PER_FTB] >> ((block) & 7)) & 1)
#define FTB_SET(block) do { (mp_state)->mem.gc_finaliser_table_start[(block) / BLOCKS_PER_FTB] |= (1 << ((block) & 7)); } while (0)
#define FTB_CLEAR(block) do { (mp_state)->mem.gc_finaliser_table_start[(block) / BLOCKS_PER_FTB] &= (~(1 << ((block) & 7))); } while (0)
#endif

// TODO waste less memory; currently requires that all entries in alloc_table have a corresponding block in pool
void micropy_gc_init(struct _mp_state_ctx_t *mp_state, void *start, void *end) {
    // align end pointer on block boundary
    end = (void*)((uintptr_t)end & (~(BYTES_PER_BLOCK - 1)));
    DEBUG_printf("Initializing GC heap: %p..%p = " UINT_FMT " bytes\n", start, end, (byte*)end - (byte*)start);

    // calculate parameters for GC (T=total, A=alloc table, F=finaliser table, P=pool; all in bytes):
    // T = A + F + P
    //     F = A * BLOCKS_PER_ATB / BLOCKS_PER_FTB
    //     P = A * BLOCKS_PER_ATB * BYTES_PER_BLOCK
    // => T = A * (1 + BLOCKS_PER_ATB / BLOCKS_PER_FTB + BLOCKS_PER_ATB * BYTES_PER_BLOCK)
    size_t total_byte_len = (byte*)end - (byte*)start;
#if MICROPY_ENABLE_FINALISER
    (mp_state)->mem.gc_alloc_table_byte_len = total_byte_len * BITS_PER_BYTE / (BITS_PER_BYTE + BITS_PER_BYTE * BLOCKS_PER_ATB / BLOCKS_PER_FTB + BITS_PER_BYTE * BLOCKS_PER_ATB * BYTES_PER_BLOCK);
#else
    (mp_state)->mem.gc_alloc_table_byte_len = total_byte_len / (1 + BITS_PER_BYTE / 2 * BYTES_PER_BLOCK);
#endif

    (mp_state)->mem.gc_alloc_table_start = (byte*)start;

#if MICROPY_ENABLE_FINALISER
    size_t gc_finaliser_table_byte_len = ((mp_state)->mem.gc_alloc_table_byte_len * BLOCKS_PER_ATB + BLOCKS_PER_FTB - 1) / BLOCKS_PER_FTB;
    (mp_state)->mem.gc_finaliser_table_start = (mp_state)->mem.gc_alloc_table_start + (mp_state)->mem.gc_alloc_table_byte_len;
#endif

    size_t gc_pool_block_len = (mp_state)->mem.gc_alloc_table_byte_len * BLOCKS_PER_ATB;
    (mp_state)->mem.gc_pool_start = (byte*)end - gc_pool_block_len * BYTES_PER_BLOCK;
    (mp_state)->mem.gc_pool_end = end;

#if MICROPY_ENABLE_FINALISER
    assert((mp_state)->mem.gc_pool_start >= (mp_state)->mem.gc_finaliser_table_start + gc_finaliser_table_byte_len);
#endif

    // clear ATBs
    memset((mp_state)->mem.gc_alloc_table_start, 0, (mp_state)->mem.gc_alloc_table_byte_len);

#if MICROPY_ENABLE_FINALISER
    // clear FTBs
    memset((mp_state)->mem.gc_finaliser_table_start, 0, gc_finaliser_table_byte_len);
#endif

    // set last free ATB index to start of heap
    (mp_state)->mem.gc_last_free_atb_index = 0;

    // unlock the GC
    (mp_state)->mem.gc_lock_depth = 0;

    // allow auto collection
    (mp_state)->mem.gc_auto_collect_enabled = 1;

    DEBUG_printf("GC layout:\n");
    DEBUG_printf("  alloc table at %p, length " UINT_FMT " bytes, " UINT_FMT " blocks\n", (mp_state)->mem.gc_alloc_table_start, (mp_state)->mem.gc_alloc_table_byte_len, (mp_state)->mem.gc_alloc_table_byte_len * BLOCKS_PER_ATB);
#if MICROPY_ENABLE_FINALISER
    DEBUG_printf("  finaliser table at %p, length " UINT_FMT " bytes, " UINT_FMT " blocks\n", (mp_state)->mem.gc_finaliser_table_start, gc_finaliser_table_byte_len, gc_finaliser_table_byte_len * BLOCKS_PER_FTB);
#endif
    DEBUG_printf("  pool at %p, length " UINT_FMT " bytes, " UINT_FMT " blocks\n", (mp_state)->mem.gc_pool_start, gc_pool_block_len * BYTES_PER_BLOCK, gc_pool_block_len);
}

void micropy_gc_lock(struct _mp_state_ctx_t *mp_state) {
    (mp_state)->mem.gc_lock_depth++;
}

void micropy_gc_unlock(struct _mp_state_ctx_t *mp_state) {
    (mp_state)->mem.gc_lock_depth--;
}

bool micropy_gc_is_locked(struct _mp_state_ctx_t *mp_state) {
    return (mp_state)->mem.gc_lock_depth != 0;
}

// ptr should be of type void*
#define VERIFY_PTR(ptr) ( \
        ((uintptr_t)(ptr) & (BYTES_PER_BLOCK - 1)) == 0      /* must be aligned on a block */ \
        && ptr >= (void*)(mp_state)->mem.gc_pool_start     /* must be above start of pool */ \
        && ptr < (void*)(mp_state)->mem.gc_pool_end        /* must be below end of pool */ \
    )

// ptr should be of type void*
#define VERIFY_MARK_AND_PUSH(ptr) \
    do { \
        if (VERIFY_PTR(ptr)) { \
            size_t _block = BLOCK_FROM_PTR(ptr); \
            if (ATB_GET_KIND(_block) == AT_HEAD) { \
                /* an unmarked head, mark it, and push it on gc stack */ \
                DEBUG_printf("gc_mark(%p)\n", ptr); \
                ATB_HEAD_TO_MARK(_block); \
                if ((mp_state)->mem.gc_sp < &(mp_state)->mem.gc_stack[MICROPY_ALLOC_GC_STACK_SIZE]) { \
                    *(mp_state)->mem.gc_sp++ = _block; \
                } else { \
                    (mp_state)->mem.gc_stack_overflow = 1; \
                } \
            } \
        } \
    } while (0)

STATIC void micropy_gc_drain_stack(struct _mp_state_ctx_t *mp_state) {
    while ((mp_state)->mem.gc_sp > (mp_state)->mem.gc_stack) {
        // pop the next block off the stack
        size_t block = *--(mp_state)->mem.gc_sp;

        // work out number of consecutive blocks in the chain starting with this one
        size_t n_blocks = 0;
        do {
            n_blocks += 1;
        } while (ATB_GET_KIND(block + n_blocks) == AT_TAIL);

        // check this block's children
        void **ptrs = (void**)PTR_FROM_BLOCK(block);
        for (size_t i = n_blocks * BYTES_PER_BLOCK / sizeof(void*); i > 0; i--, ptrs++) {
            void *ptr = *ptrs;
            VERIFY_MARK_AND_PUSH(ptr);
        }
    }
}

STATIC void micropy_gc_deal_with_stack_overflow(struct _mp_state_ctx_t *mp_state) {
    while ((mp_state)->mem.gc_stack_overflow) {
        (mp_state)->mem.gc_stack_overflow = 0;
        (mp_state)->mem.gc_sp = (mp_state)->mem.gc_stack;

        // scan entire memory looking for blocks which have been marked but not their children
        for (size_t block = 0; block < (mp_state)->mem.gc_alloc_table_byte_len * BLOCKS_PER_ATB; block++) {
            // trace (again) if mark bit set
            if (ATB_GET_KIND(block) == AT_MARK) {
                *(mp_state)->mem.gc_sp++ = block;
                micropy_gc_drain_stack(mp_state);
            }
        }
    }
}

STATIC void micropy_gc_sweep(struct _mp_state_ctx_t *mp_state) {
    #if MICROPY_PY_GC_COLLECT_RETVAL
    (mp_state)->mem.gc_collected = 0;
    #endif
    // free unmarked heads and their tails
    int free_tail = 0;
    for (size_t block = 0; block < (mp_state)->mem.gc_alloc_table_byte_len * BLOCKS_PER_ATB; block++) {
        switch (ATB_GET_KIND(block)) {
            case AT_HEAD:
#if MICROPY_ENABLE_FINALISER
                if (FTB_GET(block)) {
                    mp_obj_base_t *obj = (mp_obj_base_t*)PTR_FROM_BLOCK(block);
                    if (obj->type != NULL) {
                        // if the object has a type then see if it has a __del__ method
                        mp_obj_t dest[2];
                        micropy_load_method_maybe(mp_state, MP_OBJ_FROM_PTR(obj), MP_QSTR___del__, dest);
                        if (dest[0] != MP_OBJ_NULL) {
                            // load_method returned a method
                            micropy_call_method_n_kw(mp_state, 0, 0, dest);
                        }
                    }
                    // clear finaliser flag
                    FTB_CLEAR(block);
                }
#endif
                free_tail = 1;
                DEBUG_printf("gc_sweep(%x)\n", PTR_FROM_BLOCK(block));
                #if MICROPY_PY_GC_COLLECT_RETVAL
                (mp_state)->mem.gc_collected++;
                #endif
                // fall through to free the head

            case AT_TAIL:
                if (free_tail) {
                    ATB_ANY_TO_FREE(block);
                }
                break;

            case AT_MARK:
                ATB_MARK_TO_HEAD(block);
                free_tail = 0;
                break;
        }
    }
}

void micropy_gc_collect_start(struct _mp_state_ctx_t *mp_state) {
    micropy_gc_lock(mp_state);
    (mp_state)->mem.gc_stack_overflow = 0;
    (mp_state)->mem.gc_sp = (mp_state)->mem.gc_stack;
    // Trace root pointers.  This relies on the root pointers being organised
    // correctly in the mp_state_ctx structure.  We scan nlr_top, dict_locals,
    // dict_globals, then the root pointer section of mp_state_vm.
    void **ptrs = (void**)(void*)&mp_state->dict_locals;
    micropy_gc_collect_root(mp_state, ptrs, offsetof(mp_state_ctx_t, vm.stack_top) / sizeof(void*));
}

void micropy_gc_collect_root(struct _mp_state_ctx_t *mp_state, void **ptrs, size_t len) {
    for (size_t i = 0; i < len; i++) {
        void *ptr = ptrs[i];
        VERIFY_MARK_AND_PUSH(ptr);
        micropy_gc_drain_stack(mp_state);
    }
}

void micropy_gc_collect_end(struct _mp_state_ctx_t *mp_state) {
    micropy_gc_deal_with_stack_overflow(mp_state);
    micropy_gc_sweep(mp_state);
    (mp_state)->mem.gc_last_free_atb_index = 0;
    micropy_gc_unlock(mp_state);
}

void micropy_gc_info(struct _mp_state_ctx_t *mp_state, gc_info_t *info) {
    info->total = (mp_state)->mem.gc_pool_end - (mp_state)->mem.gc_pool_start;
    info->used = 0;
    info->free = 0;
    info->num_1block = 0;
    info->num_2block = 0;
    info->max_block = 0;
    for (size_t block = 0, len = 0; block < (mp_state)->mem.gc_alloc_table_byte_len * BLOCKS_PER_ATB; block++) {
        size_t kind = ATB_GET_KIND(block);
        if (kind == AT_FREE || kind == AT_HEAD) {
            if (len == 1) {
                info->num_1block += 1;
            } else if (len == 2) {
                info->num_2block += 1;
            }
            if (len > info->max_block) {
                info->max_block = len;
            }
        }
        switch (kind) {
            case AT_FREE:
                info->free += 1;
                len = 0;
                break;

            case AT_HEAD:
                info->used += 1;
                len = 1;
                break;

            case AT_TAIL:
                info->used += 1;
                len += 1;
                break;

            case AT_MARK:
                // shouldn't happen
                break;
        }
    }

    info->used *= BYTES_PER_BLOCK;
    info->free *= BYTES_PER_BLOCK;
}

void *micropy_gc_alloc(struct _mp_state_ctx_t *mp_state, size_t n_bytes, bool has_finaliser) {
    size_t n_blocks = ((n_bytes + BYTES_PER_BLOCK - 1) & (~(BYTES_PER_BLOCK - 1))) / BYTES_PER_BLOCK;
    DEBUG_printf("gc_alloc(" UINT_FMT " bytes -> " UINT_FMT " blocks)\n", n_bytes, n_blocks);

    // check if GC is locked
    if ((mp_state)->mem.gc_lock_depth > 0) {
        return NULL;
    }

    // check for 0 allocation
    if (n_blocks == 0) {
        return NULL;
    }

    size_t i;
    size_t end_block;
    size_t start_block;
    size_t n_free = 0;
    int collected = !(mp_state)->mem.gc_auto_collect_enabled;
    for (;;) {

        // look for a run of n_blocks available blocks
        for (i = (mp_state)->mem.gc_last_free_atb_index; i < (mp_state)->mem.gc_alloc_table_byte_len; i++) {
            byte a = (mp_state)->mem.gc_alloc_table_start[i];
            if (ATB_0_IS_FREE(a)) { if (++n_free >= n_blocks) { i = i * BLOCKS_PER_ATB + 0; goto found; } } else { n_free = 0; }
            if (ATB_1_IS_FREE(a)) { if (++n_free >= n_blocks) { i = i * BLOCKS_PER_ATB + 1; goto found; } } else { n_free = 0; }
            if (ATB_2_IS_FREE(a)) { if (++n_free >= n_blocks) { i = i * BLOCKS_PER_ATB + 2; goto found; } } else { n_free = 0; }
            if (ATB_3_IS_FREE(a)) { if (++n_free >= n_blocks) { i = i * BLOCKS_PER_ATB + 3; goto found; } } else { n_free = 0; }
        }

        // nothing found!
        if (collected) {
            return NULL;
        }
        DEBUG_printf("gc_alloc(" UINT_FMT "): no free mem, triggering GC\n", n_bytes);
        micropy_gc_collect(mp_state);
        collected = 1;
    }

    // found, ending at block i inclusive
found:
    // get starting and end blocks, both inclusive
    end_block = i;
    start_block = i - n_free + 1;

    // Set last free ATB index to block after last block we found, for start of
    // next scan.  To reduce fragmentation, we only do this if we were looking
    // for a single free block, which guarantees that there are no free blocks
    // before this one.  Also, whenever we free or shink a block we must check
    // if this index needs adjusting (see gc_realloc and gc_free).
    if (n_free == 1) {
        (mp_state)->mem.gc_last_free_atb_index = (i + 1) / BLOCKS_PER_ATB;
    }

    // mark first block as used head
    ATB_FREE_TO_HEAD(start_block);

    // mark rest of blocks as used tail
    // TODO for a run of many blocks can make this more efficient
    for (size_t bl = start_block + 1; bl <= end_block; bl++) {
        ATB_FREE_TO_TAIL(bl);
    }

    // get pointer to first block
    void *ret_ptr = (void*)((mp_state)->mem.gc_pool_start + start_block * BYTES_PER_BLOCK);
    DEBUG_printf("gc_alloc(%p)\n", ret_ptr);

    // zero out the additional bytes of the newly allocated blocks
    // This is needed because the blocks may have previously held pointers
    // to the heap and will not be set to something else if the caller
    // doesn't actually use the entire block.  As such they will continue
    // to point to the heap and may prevent other blocks from being reclaimed.
    memset((byte*)ret_ptr + n_bytes, 0, (end_block - start_block + 1) * BYTES_PER_BLOCK - n_bytes);

    #if MICROPY_ENABLE_FINALISER
    if (has_finaliser) {
        // clear type pointer in case it is never set
        ((mp_obj_base_t*)ret_ptr)->type = NULL;
        // set mp_obj flag only if it has a finaliser
        FTB_SET(start_block);
    }
    #else
    (void)has_finaliser;
    #endif

    #if EXTENSIVE_HEAP_PROFILING
    micropy_gc_dump_alloc_table(mp_state);
    #endif

    return ret_ptr;
}

/*
void *micropy_gc_alloc(struct _mp_state_ctx_t *mp_state, mp_uint_t n_bytes) {
    return _gc_alloc(n_bytes, false);
}

void *micropy_gc_alloc_with_finaliser(struct _mp_state_ctx_t *mp_state, mp_uint_t n_bytes) {
    return _gc_alloc(n_bytes, true);
}
*/

// force the freeing of a piece of memory
// TODO: freeing here does not call finaliser
void micropy_gc_free(struct _mp_state_ctx_t *mp_state, void *ptr) {
    if ((mp_state)->mem.gc_lock_depth > 0) {
        // TODO how to deal with this error?
        return;
    }

    DEBUG_printf("gc_free(%p)\n", ptr);

    if (VERIFY_PTR(ptr)) {
        size_t block = BLOCK_FROM_PTR(ptr);
        if (ATB_GET_KIND(block) == AT_HEAD) {
            #if MICROPY_ENABLE_FINALISER
            FTB_CLEAR(block);
            #endif
            // set the last_free pointer to this block if it's earlier in the heap
            if (block / BLOCKS_PER_ATB < (mp_state)->mem.gc_last_free_atb_index) {
                (mp_state)->mem.gc_last_free_atb_index = block / BLOCKS_PER_ATB;
            }

            // free head and all of its tail blocks
            do {
                ATB_ANY_TO_FREE(block);
                block += 1;
            } while (ATB_GET_KIND(block) == AT_TAIL);

            #if EXTENSIVE_HEAP_PROFILING
            micropy_gc_dump_alloc_table(mp_state);
            #endif
        } else {
            assert(!"bad free");
        }
    } else if (ptr != NULL) {
        assert(!"bad free");
    }
}

size_t micropy_gc_nbytes(struct _mp_state_ctx_t *mp_state, const void *ptr) {
    if (VERIFY_PTR(ptr)) {
        size_t block = BLOCK_FROM_PTR(ptr);
        if (ATB_GET_KIND(block) == AT_HEAD) {
            // work out number of consecutive blocks in the chain starting with this on
            size_t n_blocks = 0;
            do {
                n_blocks += 1;
            } while (ATB_GET_KIND(block + n_blocks) == AT_TAIL);
            return n_blocks * BYTES_PER_BLOCK;
        }
    }

    // invalid pointer
    return 0;
}

#if 0
// old, simple realloc that didn't expand memory in place
void *micropy_gc_realloc(struct _mp_state_ctx_t *mp_state, void *ptr, mp_uint_t n_bytes) {
    mp_uint_t n_existing = micropy_gc_nbytes(mp_state, ptr);
    if (n_bytes <= n_existing) {
        return ptr;
    } else {
        bool has_finaliser;
        if (ptr == NULL) {
            has_finaliser = false;
        } else {
#if MICROPY_ENABLE_FINALISER
            has_finaliser = FTB_GET(BLOCK_FROM_PTR((mp_uint_t)ptr));
#else
            has_finaliser = false;
#endif
        }
        void *ptr2 = micropy_gc_alloc(mp_state, n_bytes, has_finaliser);
        if (ptr2 == NULL) {
            return ptr2;
        }
        memcpy(ptr2, ptr, n_existing);
        micropy_gc_free(mp_state, ptr);
        return ptr2;
    }
}

#else // Alternative gc_realloc impl

void *micropy_gc_realloc(struct _mp_state_ctx_t *mp_state, void *ptr_in, size_t n_bytes, bool allow_move) {
    if ((mp_state)->mem.gc_lock_depth > 0) {
        return NULL;
    }

    // check for pure allocation
    if (ptr_in == NULL) {
        return micropy_gc_alloc(mp_state, n_bytes, false);
    }

    // check for pure free
    if (n_bytes == 0) {
        micropy_gc_free(mp_state, ptr_in);
        return NULL;
    }

    void *ptr = ptr_in;

    // sanity check the ptr
    if (!VERIFY_PTR(ptr)) {
        return NULL;
    }

    // get first block
    size_t block = BLOCK_FROM_PTR(ptr);

    // sanity check the ptr is pointing to the head of a block
    if (ATB_GET_KIND(block) != AT_HEAD) {
        return NULL;
    }

    // compute number of new blocks that are requested
    size_t new_blocks = (n_bytes + BYTES_PER_BLOCK - 1) / BYTES_PER_BLOCK;

    // Get the total number of consecutive blocks that are already allocated to
    // this chunk of memory, and then count the number of free blocks following
    // it.  Stop if we reach the end of the heap, or if we find enough extra
    // free blocks to satisfy the realloc.  Note that we need to compute the
    // total size of the existing memory chunk so we can correctly and
    // efficiently shrink it (see below for shrinking code).
    size_t n_free   = 0;
    size_t n_blocks = 1; // counting HEAD block
    size_t max_block = (mp_state)->mem.gc_alloc_table_byte_len * BLOCKS_PER_ATB;
    for (size_t bl = block + n_blocks; bl < max_block; bl++) {
        byte block_type = ATB_GET_KIND(bl);
        if (block_type == AT_TAIL) {
            n_blocks++;
            continue;
        }
        if (block_type == AT_FREE) {
            n_free++;
            if (n_blocks + n_free >= new_blocks) {
                // stop as soon as we find enough blocks for n_bytes
                break;
            }
            continue;
        }
        break;
    }

    // return original ptr if it already has the requested number of blocks
    if (new_blocks == n_blocks) {
        return ptr_in;
    }

    // check if we can shrink the allocated area
    if (new_blocks < n_blocks) {
        // free unneeded tail blocks
        for (size_t bl = block + new_blocks, count = n_blocks - new_blocks; count > 0; bl++, count--) {
            ATB_ANY_TO_FREE(bl);
        }

        // set the last_free pointer to end of this block if it's earlier in the heap
        if ((block + new_blocks) / BLOCKS_PER_ATB < (mp_state)->mem.gc_last_free_atb_index) {
            (mp_state)->mem.gc_last_free_atb_index = (block + new_blocks) / BLOCKS_PER_ATB;
        }

        #if EXTENSIVE_HEAP_PROFILING
        micropy_gc_dump_alloc_table(mp_state);
        #endif

        return ptr_in;
    }

    // check if we can expand in place
    if (new_blocks <= n_blocks + n_free) {
        // mark few more blocks as used tail
        for (size_t bl = block + n_blocks; bl < block + new_blocks; bl++) {
            assert(ATB_GET_KIND(bl) == AT_FREE);
            ATB_FREE_TO_TAIL(bl);
        }

        // zero out the additional bytes of the newly allocated blocks (see comment above in gc_alloc)
        memset((byte*)ptr_in + n_bytes, 0, new_blocks * BYTES_PER_BLOCK - n_bytes);

        #if EXTENSIVE_HEAP_PROFILING
        micropy_gc_dump_alloc_table(mp_state);
        #endif

        return ptr_in;
    }

    if (!allow_move) {
        // not allowed to move memory block so return failure
        return NULL;
    }

    // can't resize inplace; try to find a new contiguous chain
    void *ptr_out = micropy_gc_alloc(mp_state, n_bytes,
#if MICROPY_ENABLE_FINALISER
        FTB_GET(block)
#else
        false
#endif
    );

    // check that the alloc succeeded
    if (ptr_out == NULL) {
        return NULL;
    }

    DEBUG_printf("gc_realloc(%p -> %p)\n", ptr_in, ptr_out);
    memcpy(ptr_out, ptr_in, n_blocks * BYTES_PER_BLOCK);
    micropy_gc_free(mp_state, ptr_in);
    return ptr_out;
}
#endif // Alternative gc_realloc impl

void micropy_gc_dump_info(struct _mp_state_ctx_t *mp_state) {
    gc_info_t info;
    micropy_gc_info(mp_state, &info);
    micropy_printf(mp_state, &mp_plat_print, "GC: total: %u, used: %u, free: %u\n",
        (uint)info.total, (uint)info.used, (uint)info.free);
    micropy_printf(mp_state, &mp_plat_print, " No. of 1-blocks: %u, 2-blocks: %u, max blk sz: %u\n",
           (uint)info.num_1block, (uint)info.num_2block, (uint)info.max_block);
}

void micropy_gc_dump_alloc_table(struct _mp_state_ctx_t *mp_state) {
    static const size_t DUMP_BYTES_PER_LINE = 64;
    #if !EXTENSIVE_HEAP_PROFILING
    // When comparing heap output we don't want to print the starting
    // pointer of the heap because it changes from run to run.
    micropy_printf(mp_state, &mp_plat_print, "GC memory layout; from %p:", (mp_state)->mem.gc_pool_start);
    #endif
    for (size_t bl = 0; bl < (mp_state)->mem.gc_alloc_table_byte_len * BLOCKS_PER_ATB; bl++) {
        if (bl % DUMP_BYTES_PER_LINE == 0) {
            // a new line of blocks
            {
                // check if this line contains only free blocks
                size_t bl2 = bl;
                while (bl2 < (mp_state)->mem.gc_alloc_table_byte_len * BLOCKS_PER_ATB && ATB_GET_KIND(bl2) == AT_FREE) {
                    bl2++;
                }
                if (bl2 - bl >= 2 * DUMP_BYTES_PER_LINE) {
                    // there are at least 2 lines containing only free blocks, so abbreviate their printing
                    micropy_printf(mp_state, &mp_plat_print, "\n       (%u lines all free)", (uint)(bl2 - bl) / DUMP_BYTES_PER_LINE);
                    bl = bl2 & (~(DUMP_BYTES_PER_LINE - 1));
                    if (bl >= (mp_state)->mem.gc_alloc_table_byte_len * BLOCKS_PER_ATB) {
                        // got to end of heap
                        break;
                    }
                }
            }
            // print header for new line of blocks
            // (the cast to uint32_t is for 16-bit ports)
            //mp_printf(&mp_plat_print, "\n%05x: ", (uint)(PTR_FROM_BLOCK(bl) & (uint32_t)0xfffff));
            micropy_printf(mp_state, &mp_plat_print, "\n%05x: ", (uint)((bl * BYTES_PER_BLOCK) & (uint32_t)0xfffff));
        }
        int c = ' ';
        switch (ATB_GET_KIND(bl)) {
            case AT_FREE: c = '.'; break;
            /* this prints out if the object is reachable from BSS or STACK (for unix only)
            case AT_HEAD: {
                c = 'h';
                void **ptrs = (void**)(void*)&mp_state_ctx;
                mp_uint_t len = offsetof(mp_state_ctx_t, vm.stack_top) / sizeof(mp_uint_t);
                for (mp_uint_t i = 0; i < len; i++) {
                    mp_uint_t ptr = (mp_uint_t)ptrs[i];
                    if (VERIFY_PTR(ptr) && BLOCK_FROM_PTR(ptr) == bl) {
                        c = 'B';
                        break;
                    }
                }
                if (c == 'h') {
                    ptrs = (void**)&c;
                    len = ((mp_uint_t)(mp_state)->vm.stack_top - (mp_uint_t)&c) / sizeof(mp_uint_t);
                    for (mp_uint_t i = 0; i < len; i++) {
                        mp_uint_t ptr = (mp_uint_t)ptrs[i];
                        if (VERIFY_PTR(ptr) && BLOCK_FROM_PTR(ptr) == bl) {
                            c = 'S';
                            break;
                        }
                    }
                }
                break;
            }
            */
            /* this prints the uPy object type of the head block */
            case AT_HEAD: {
                void **ptr = (void**)((mp_state)->mem.gc_pool_start + bl * BYTES_PER_BLOCK);
                if (*ptr == &mp_type_tuple) { c = 'T'; }
                else if (*ptr == &mp_type_list) { c = 'L'; }
                else if (*ptr == &mp_type_dict) { c = 'D'; }
                else if (*ptr == &mp_type_str || *ptr == &mp_type_bytes) { c = 'S'; }
                #if MICROPY_PY_BUILTINS_BYTEARRAY
                else if (*ptr == &mp_type_bytearray) { c = 'A'; }
                #endif
                #if MICROPY_PY_ARRAY
                else if (*ptr == &mp_type_array) { c = 'A'; }
                #endif
                #if MICROPY_PY_BUILTINS_FLOAT
                else if (*ptr == &mp_type_float) { c = 'F'; }
                #endif
                else if (*ptr == &mp_type_fun_bc) { c = 'B'; }
                else if (*ptr == &mp_type_module) { c = 'M'; }
                else {
                    c = 'h';
                    #if 0
                    // This code prints "Q" for qstr-pool data, and "q" for qstr-str
                    // data.  It can be useful to see how qstrs are being allocated,
                    // but is disabled by default because it is very slow.
                    for (qstr_pool_t *pool = (mp_state)->vm.last_pool; c == 'h' && pool != NULL; pool = pool->prev) {
                        if ((qstr_pool_t*)ptr == pool) {
                            c = 'Q';
                            break;
                        }
                        for (const byte **q = pool->qstrs, **q_top = pool->qstrs + pool->len; q < q_top; q++) {
                            if ((const byte*)ptr == *q) {
                                c = 'q';
                                break;
                            }
                        }
                    }
                    #endif
                }
                break;
            }
            case AT_TAIL: c = '='; break;
            case AT_MARK: c = 'm'; break;
        }
        micropy_printf(mp_state, &mp_plat_print, "%c", c);
    }
    micropy_print_str(mp_state, &mp_plat_print, "\n");
}

#if DEBUG_PRINT
void micropy_gc_test(struct _mp_state_ctx_t *mp_state) {
    mp_uint_t len = 500;
    mp_uint_t *heap = malloc(len);
    micropy_gc_init(mp_state, heap, heap + len / sizeof(mp_uint_t));
    void *ptrs[100];
    {
        mp_uint_t **p = micropy_gc_alloc(mp_state, 16, false);
        p[0] = micropy_gc_alloc(mp_state, 64, false);
        p[1] = micropy_gc_alloc(mp_state, 1, false);
        p[2] = micropy_gc_alloc(mp_state, 1, false);
        p[3] = micropy_gc_alloc(mp_state, 1, false);
        mp_uint_t ***p2 = micropy_gc_alloc(mp_state, 16, false);
        p2[0] = p;
        p2[1] = p;
        ptrs[0] = p2;
    }
    for (int i = 0; i < 25; i+=2) {
        mp_uint_t *p = micropy_gc_alloc(mp_state, i, false);
        printf("p=%p\n", p);
        if (i & 3) {
            //ptrs[i] = p;
        }
    }

    printf("Before GC:\n");
    micropy_gc_dump_alloc_table(mp_state);
    printf("Starting GC...\n");
    micropy_gc_collect_start(mp_state);
    micropy_gc_collect_root(mp_state, ptrs, sizeof(ptrs) / sizeof(void*));
    micropy_gc_collect_end(mp_state);
    printf("After GC:\n");
    micropy_gc_dump_alloc_table(mp_state);
}
#endif

#endif // MICROPY_ENABLE_GC
/*
 * This file is part of the Micro Python project, http://micropython.org/
 *
 * The MIT License (MIT)
 *
 * Copyright (c) 2013, 2014 Damien P. George
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

//#include "py/nlr.h"

#if MICROPY_NLR_SETJMP

void micropy_nlr_setjmp_jump(struct _mp_state_ctx_t *mp_state, void *val) {
    nlr_buf_t *buf = (mp_state)->vm.nlr_top;
    (mp_state)->vm.nlr_top = buf->prev;
    buf->ret_val = val;
    longjmp(buf->jmpbuf, 1);
}

#endif
/*
 * This file is part of the Micro Python project, http://micropython.org/
 *
 * The MIT License (MIT)
 *
 * Copyright (c) 2013, 2014 Damien P. George
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

#include <stdio.h>
#include <assert.h>

//#include "py/mpstate.h"
//#include "py/lexer.h"
//#include "py/runtime.h"

#if MICROPY_ENABLE_COMPILER

#define TAB_SIZE (8)

// TODO seems that CPython allows NULL byte in the input stream
// don't know if that's intentional or not, but we don't allow it

// TODO replace with a call to a standard function
STATIC bool micropy_str_strn_equal(struct _mp_state_ctx_t *mp_state, const char *str, const char *strn, mp_uint_t len) {
    mp_uint_t i = 0;

    while (i < len && *str == *strn) {
        ++i;
        ++str;
        ++strn;
    }

    return i == len && *str == 0;
}

#define CUR_CHAR(lex) ((lex)->chr0)

STATIC bool micropy_is_end(struct _mp_state_ctx_t *mp_state, mp_lexer_t *lex) {
    return lex->chr0 == MP_LEXER_EOF;
}

STATIC bool micropy_is_physical_newline(struct _mp_state_ctx_t *mp_state, mp_lexer_t *lex) {
    return lex->chr0 == '\n';
}

STATIC bool micropy_is_char(struct _mp_state_ctx_t *mp_state, mp_lexer_t *lex, byte c) {
    return lex->chr0 == c;
}

STATIC bool micropy_is_char_or(struct _mp_state_ctx_t *mp_state, mp_lexer_t *lex, byte c1, byte c2) {
    return lex->chr0 == c1 || lex->chr0 == c2;
}

STATIC bool micropy_is_char_or3(struct _mp_state_ctx_t *mp_state, mp_lexer_t *lex, byte c1, byte c2, byte c3) {
    return lex->chr0 == c1 || lex->chr0 == c2 || lex->chr0 == c3;
}

/*
STATIC bool micropy_is_char_following(struct _mp_state_ctx_t *mp_state, mp_lexer_t *lex, byte c) {
    return lex->chr1 == c;
}
*/

STATIC bool micropy_is_char_following_or(struct _mp_state_ctx_t *mp_state, mp_lexer_t *lex, byte c1, byte c2) {
    return lex->chr1 == c1 || lex->chr1 == c2;
}

STATIC bool micropy_is_char_following_following_or(struct _mp_state_ctx_t *mp_state, mp_lexer_t *lex, byte c1, byte c2) {
    return lex->chr2 == c1 || lex->chr2 == c2;
}

STATIC bool micropy_is_char_and(struct _mp_state_ctx_t *mp_state, mp_lexer_t *lex, byte c1, byte c2) {
    return lex->chr0 == c1 && lex->chr1 == c2;
}

STATIC bool micropy_is_whitespace(struct _mp_state_ctx_t *mp_state, mp_lexer_t *lex) {
    return unichar_isspace(lex->chr0);
}

STATIC bool micropy_is_letter(struct _mp_state_ctx_t *mp_state, mp_lexer_t *lex) {
    return unichar_isalpha(lex->chr0);
}

STATIC bool micropy_is_digit(struct _mp_state_ctx_t *mp_state, mp_lexer_t *lex) {
    return unichar_isdigit(lex->chr0);
}

STATIC bool micropy_is_following_digit(struct _mp_state_ctx_t *mp_state, mp_lexer_t *lex) {
    return unichar_isdigit(lex->chr1);
}

STATIC bool micropy_is_following_base_char(struct _mp_state_ctx_t *mp_state, mp_lexer_t *lex) {
    const unichar chr1 = lex->chr1 | 0x20;
    return chr1 == 'b' || chr1 == 'o' || chr1 == 'x';
}

STATIC bool micropy_is_following_odigit(struct _mp_state_ctx_t *mp_state, mp_lexer_t *lex) {
    return lex->chr1 >= '0' && lex->chr1 <= '7';
}

// to easily parse utf-8 identifiers we allow any raw byte with high bit set
STATIC bool micropy_is_head_of_identifier(struct _mp_state_ctx_t *mp_state, mp_lexer_t *lex) {
    return micropy_is_letter(mp_state, lex) || lex->chr0 == '_' || lex->chr0 >= 0x80;
}

STATIC bool micropy_is_tail_of_identifier(struct _mp_state_ctx_t *mp_state, mp_lexer_t *lex) {
    return micropy_is_head_of_identifier(mp_state, lex) || micropy_is_digit(mp_state, lex);
}

STATIC void micropy_next_char(struct _mp_state_ctx_t *mp_state, mp_lexer_t *lex) {
    if (lex->chr0 == MP_LEXER_EOF) {
        return;
    }

    if (lex->chr0 == '\n') {
        // a new line
        ++lex->line;
        lex->column = 1;
    } else if (lex->chr0 == '\t') {
        // a tab
        lex->column = (((lex->column - 1 + TAB_SIZE) / TAB_SIZE) * TAB_SIZE) + 1;
    } else {
        // a character worth one column
        ++lex->column;
    }

    lex->chr0 = lex->chr1;
    lex->chr1 = lex->chr2;
    lex->chr2 = lex->stream_next_byte(mp_state, lex->stream_data);

    if (lex->chr0 == '\r') {
        // CR is a new line, converted to LF
        lex->chr0 = '\n';
        if (lex->chr1 == '\n') {
            // CR LF is a single new line
            lex->chr1 = lex->chr2;
            lex->chr2 = lex->stream_next_byte(mp_state, lex->stream_data);
        }
    }

    if (lex->chr2 == MP_LEXER_EOF) {
        // EOF, check if we need to insert a newline at end of file
        if (lex->chr1 != MP_LEXER_EOF && lex->chr1 != '\n') {
            // if lex->chr1 == '\r' then this makes a CR LF which will be converted to LF above
            // otherwise it just inserts a LF
            lex->chr2 = '\n';
        }
    }
}

STATIC void micropy_indent_push(struct _mp_state_ctx_t *mp_state, mp_lexer_t *lex, mp_uint_t indent) {
    if (lex->num_indent_level >= lex->alloc_indent_level) {
        // TODO use m_renew_maybe and somehow indicate an error if it fails... probably by using MP_TOKEN_MEMORY_ERROR
        lex->indent_level = micropy_m_renew(mp_state, uint16_t, lex->indent_level, lex->alloc_indent_level, lex->alloc_indent_level + MICROPY_ALLOC_LEXEL_INDENT_INC);
        lex->alloc_indent_level += MICROPY_ALLOC_LEXEL_INDENT_INC;
    }
    lex->indent_level[lex->num_indent_level++] = indent;
}

STATIC mp_uint_t micropy_indent_top(struct _mp_state_ctx_t *mp_state, mp_lexer_t *lex) {
    return lex->indent_level[lex->num_indent_level - 1];
}

STATIC void micropy_indent_pop(struct _mp_state_ctx_t *mp_state, mp_lexer_t *lex) {
    lex->num_indent_level -= 1;
}

// some tricky operator encoding:
//     <op>  = begin with <op>, if this opchar matches then begin here
//     e<op> = end with <op>, if this opchar matches then end
//     E<op> = mandatory end with <op>, this opchar must match, then end
//     c<op> = continue with <op>, if this opchar matches then continue matching
// this means if the start of two ops are the same then they are equal til the last char

STATIC const char *const tok_enc =
    "()[]{},:;@~" // singles
    "<e=c<e="     // < <= << <<=
    ">e=c>e="     // > >= >> >>=
    "*e=c*e="     // * *= ** **=
    "+e="         // + +=
    "-e=e>"       // - -= ->
    "&e="         // & &=
    "|e="         // | |=
    "/e=c/e="     // / /= // //=
    "%e="         // % %=
    "^e="         // ^ ^=
    "=e="         // = ==
    "!E=";        // !=

// TODO static assert that number of tokens is less than 256 so we can safely make this table with byte sized entries
STATIC const uint8_t tok_enc_kind[] = {
    MP_TOKEN_DEL_PAREN_OPEN, MP_TOKEN_DEL_PAREN_CLOSE,
    MP_TOKEN_DEL_BRACKET_OPEN, MP_TOKEN_DEL_BRACKET_CLOSE,
    MP_TOKEN_DEL_BRACE_OPEN, MP_TOKEN_DEL_BRACE_CLOSE,
    MP_TOKEN_DEL_COMMA, MP_TOKEN_DEL_COLON, MP_TOKEN_DEL_SEMICOLON, MP_TOKEN_DEL_AT, MP_TOKEN_OP_TILDE,

    MP_TOKEN_OP_LESS, MP_TOKEN_OP_LESS_EQUAL, MP_TOKEN_OP_DBL_LESS, MP_TOKEN_DEL_DBL_LESS_EQUAL,
    MP_TOKEN_OP_MORE, MP_TOKEN_OP_MORE_EQUAL, MP_TOKEN_OP_DBL_MORE, MP_TOKEN_DEL_DBL_MORE_EQUAL,
    MP_TOKEN_OP_STAR, MP_TOKEN_DEL_STAR_EQUAL, MP_TOKEN_OP_DBL_STAR, MP_TOKEN_DEL_DBL_STAR_EQUAL,
    MP_TOKEN_OP_PLUS, MP_TOKEN_DEL_PLUS_EQUAL,
    MP_TOKEN_OP_MINUS, MP_TOKEN_DEL_MINUS_EQUAL, MP_TOKEN_DEL_MINUS_MORE,
    MP_TOKEN_OP_AMPERSAND, MP_TOKEN_DEL_AMPERSAND_EQUAL,
    MP_TOKEN_OP_PIPE, MP_TOKEN_DEL_PIPE_EQUAL,
    MP_TOKEN_OP_SLASH, MP_TOKEN_DEL_SLASH_EQUAL, MP_TOKEN_OP_DBL_SLASH, MP_TOKEN_DEL_DBL_SLASH_EQUAL,
    MP_TOKEN_OP_PERCENT, MP_TOKEN_DEL_PERCENT_EQUAL,
    MP_TOKEN_OP_CARET, MP_TOKEN_DEL_CARET_EQUAL,
    MP_TOKEN_DEL_EQUAL, MP_TOKEN_OP_DBL_EQUAL,
    MP_TOKEN_OP_NOT_EQUAL,
};

// must have the same order as enum in lexer.h
STATIC const char *const tok_kw[] = {
    "False",
    "None",
    "True",
    "and",
    "as",
    "assert",
    #if MICROPY_PY_ASYNC_AWAIT
    "async",
    "await",
    #endif
    "break",
    "class",
    "continue",
    "def",
    "del",
    "elif",
    "else",
    "except",
    "finally",
    "for",
    "from",
    "global",
    "if",
    "import",
    "in",
    "is",
    "lambda",
    "nonlocal",
    "not",
    "or",
    "pass",
    "raise",
    "return",
    "try",
    "while",
    "with",
    "yield",
    "__debug__",
};

// This is called with CUR_CHAR() before first hex digit, and should return with
// it pointing to last hex digit
// num_digits must be greater than zero
STATIC bool micropy_get_hex(struct _mp_state_ctx_t *mp_state, mp_lexer_t *lex, mp_uint_t num_digits, mp_uint_t *result) {
    mp_uint_t num = 0;
    while (num_digits-- != 0) {
        micropy_next_char(mp_state, lex);
        unichar c = CUR_CHAR(lex);
        if (!unichar_isxdigit(c)) {
            return false;
        }
        num = (num << 4) + unichar_xdigit_value(c);
    }
    *result = num;
    return true;
}

STATIC void micropy_lexer_next_token_into(struct _mp_state_ctx_t *mp_state, mp_lexer_t *lex, bool first_token) {
    // start new token text
    micropy_vstr_reset(mp_state, &lex->vstr);

    // skip white space and comments
    bool had_physical_newline = false;
    while (!micropy_is_end(mp_state, lex)) {
        if (micropy_is_physical_newline(mp_state, lex)) {
            had_physical_newline = true;
            micropy_next_char(mp_state, lex);
        } else if (micropy_is_whitespace(mp_state, lex)) {
            micropy_next_char(mp_state, lex);
        } else if (micropy_is_char(mp_state, lex, '#')) {
            micropy_next_char(mp_state, lex);
            while (!micropy_is_end(mp_state, lex) && !micropy_is_physical_newline(mp_state, lex)) {
                micropy_next_char(mp_state, lex);
            }
            // had_physical_newline will be set on next loop
        } else if (micropy_is_char(mp_state, lex, '\\')) {
            // backslash (outside string literals) must appear just before a physical newline
            micropy_next_char(mp_state, lex);
            if (!micropy_is_physical_newline(mp_state, lex)) {
                // SyntaxError: unexpected character after line continuation character
                lex->tok_line = lex->line;
                lex->tok_column = lex->column;
                lex->tok_kind = MP_TOKEN_BAD_LINE_CONTINUATION;
                return;
            } else {
                micropy_next_char(mp_state, lex);
            }
        } else {
            break;
        }
    }

    // set token source information
    lex->tok_line = lex->line;
    lex->tok_column = lex->column;

    if (first_token && lex->line == 1 && lex->column != 1) {
        // check that the first token is in the first column
        // if first token is not on first line, we get a physical newline and
        // this check is done as part of normal indent/dedent checking below
        // (done to get equivalence with CPython)
        lex->tok_kind = MP_TOKEN_INDENT;

    } else if (lex->emit_dent < 0) {
        lex->tok_kind = MP_TOKEN_DEDENT;
        lex->emit_dent += 1;

    } else if (lex->emit_dent > 0) {
        lex->tok_kind = MP_TOKEN_INDENT;
        lex->emit_dent -= 1;

    } else if (had_physical_newline && lex->nested_bracket_level == 0) {
        lex->tok_kind = MP_TOKEN_NEWLINE;

        mp_uint_t num_spaces = lex->column - 1;
        lex->emit_dent = 0;
        if (num_spaces == micropy_indent_top(mp_state, lex)) {
        } else if (num_spaces > micropy_indent_top(mp_state, lex)) {
            micropy_indent_push(mp_state, lex, num_spaces);
            lex->emit_dent += 1;
        } else {
            while (num_spaces < micropy_indent_top(mp_state, lex)) {
                micropy_indent_pop(mp_state, lex);
                lex->emit_dent -= 1;
            }
            if (num_spaces != micropy_indent_top(mp_state, lex)) {
                lex->tok_kind = MP_TOKEN_DEDENT_MISMATCH;
            }
        }

    } else if (micropy_is_end(mp_state, lex)) {
        if (micropy_indent_top(mp_state, lex) > 0) {
            lex->tok_kind = MP_TOKEN_NEWLINE;
            lex->emit_dent = 0;
            while (micropy_indent_top(mp_state, lex) > 0) {
                micropy_indent_pop(mp_state, lex);
                lex->emit_dent -= 1;
            }
        } else {
            lex->tok_kind = MP_TOKEN_END;
        }

    } else if (micropy_is_char_or(mp_state, lex, '\'', '\"')
               || (micropy_is_char_or3(mp_state, lex, 'r', 'u', 'b') && micropy_is_char_following_or(mp_state, lex, '\'', '\"'))
               || ((micropy_is_char_and(mp_state, lex, 'r', 'b') || micropy_is_char_and(mp_state, lex, 'b', 'r')) && micropy_is_char_following_following_or(mp_state, lex, '\'', '\"'))) {
        // a string or bytes literal

        // parse type codes
        bool is_raw = false;
        bool is_bytes = false;
        if (micropy_is_char(mp_state, lex, 'u')) {
            micropy_next_char(mp_state, lex);
        } else if (micropy_is_char(mp_state, lex, 'b')) {
            is_bytes = true;
            micropy_next_char(mp_state, lex);
            if (micropy_is_char(mp_state, lex, 'r')) {
                is_raw = true;
                micropy_next_char(mp_state, lex);
            }
        } else if (micropy_is_char(mp_state, lex, 'r')) {
            is_raw = true;
            micropy_next_char(mp_state, lex);
            if (micropy_is_char(mp_state, lex, 'b')) {
                is_bytes = true;
                micropy_next_char(mp_state, lex);
            }
        }

        // set token kind
        if (is_bytes) {
            lex->tok_kind = MP_TOKEN_BYTES;
        } else {
            lex->tok_kind = MP_TOKEN_STRING;
        }

        // get first quoting character
        char quote_char = '\'';
        if (micropy_is_char(mp_state, lex, '\"')) {
            quote_char = '\"';
        }
        micropy_next_char(mp_state, lex);

        // work out if it's a single or triple quoted literal
        mp_uint_t num_quotes;
        if (micropy_is_char_and(mp_state, lex, quote_char, quote_char)) {
            // triple quotes
            micropy_next_char(mp_state, lex);
            micropy_next_char(mp_state, lex);
            num_quotes = 3;
        } else {
            // single quotes
            num_quotes = 1;
        }

        // parse the literal
        mp_uint_t n_closing = 0;
        while (!micropy_is_end(mp_state, lex) && (num_quotes > 1 || !micropy_is_char(mp_state, lex, '\n')) && n_closing < num_quotes) {
            if (micropy_is_char(mp_state, lex, quote_char)) {
                n_closing += 1;
                micropy_vstr_add_char(mp_state, &lex->vstr, CUR_CHAR(lex));
            } else {
                n_closing = 0;
                if (micropy_is_char(mp_state, lex, '\\')) {
                    micropy_next_char(mp_state, lex);
                    unichar c = CUR_CHAR(lex);
                    if (is_raw) {
                        // raw strings allow escaping of quotes, but the backslash is also emitted
                        micropy_vstr_add_char(mp_state, &lex->vstr, '\\');
                    } else {
                        switch (c) {
                            case MP_LEXER_EOF: break; // TODO a proper error message?
                            case '\n': c = MP_LEXER_EOF; break; // TODO check this works correctly (we are supposed to ignore it
                            case '\\': break;
                            case '\'': break;
                            case '"': break;
                            case 'a': c = 0x07; break;
                            case 'b': c = 0x08; break;
                            case 't': c = 0x09; break;
                            case 'n': c = 0x0a; break;
                            case 'v': c = 0x0b; break;
                            case 'f': c = 0x0c; break;
                            case 'r': c = 0x0d; break;
                            case 'u':
                            case 'U':
                                if (is_bytes) {
                                    // b'\u1234' == b'\\u1234'
                                    micropy_vstr_add_char(mp_state, &lex->vstr, '\\');
                                    break;
                                }
                                // Otherwise fall through.
                            case 'x':
                            {
                                mp_uint_t num = 0;
                                if (!micropy_get_hex(mp_state, lex, (c == 'x' ? 2 : c == 'u' ? 4 : 8), &num)) {
                                    // not enough hex chars for escape sequence
                                    lex->tok_kind = MP_TOKEN_INVALID;
                                }
                                c = num;
                                break;
                            }
                            case 'N':
                                // Supporting '\N{LATIN SMALL LETTER A}' == 'a' would require keeping the
                                // entire Unicode name table in the core. As of Unicode 6.3.0, that's nearly
                                // 3MB of text; even gzip-compressed and with minimal structure, it'll take
                                // roughly half a meg of storage. This form of Unicode escape may be added
                                // later on, but it's definitely not a priority right now. -- CJA 20140607
                                micropy_not_implemented(mp_state, "unicode name escapes");
                                break;
                            default:
                                if (c >= '0' && c <= '7') {
                                    // Octal sequence, 1-3 chars
                                    mp_uint_t digits = 3;
                                    mp_uint_t num = c - '0';
                                    while (micropy_is_following_odigit(mp_state, lex) && --digits != 0) {
                                        micropy_next_char(mp_state, lex);
                                        num = num * 8 + (CUR_CHAR(lex) - '0');
                                    }
                                    c = num;
                                } else {
                                    // unrecognised escape character; CPython lets this through verbatim as '\' and then the character
                                    micropy_vstr_add_char(mp_state, &lex->vstr, '\\');
                                }
                                break;
                        }
                    }
                    if (c != MP_LEXER_EOF) {
                        if (MICROPY_PY_BUILTINS_STR_UNICODE_DYNAMIC) {
                            if (c < 0x110000 && !is_bytes) {
                                micropy_vstr_add_char(mp_state, &lex->vstr, c);
                            } else if (c < 0x100 && is_bytes) {
                                micropy_vstr_add_byte(mp_state, &lex->vstr, c);
                            } else {
                                // unicode character out of range
                                // this raises a generic SyntaxError; could provide more info
                                lex->tok_kind = MP_TOKEN_INVALID;
                            }
                        } else {
                            // without unicode everything is just added as an 8-bit byte
                            if (c < 0x100) {
                                micropy_vstr_add_byte(mp_state, &lex->vstr, c);
                            } else {
                                // 8-bit character out of range
                                // this raises a generic SyntaxError; could provide more info
                                lex->tok_kind = MP_TOKEN_INVALID;
                            }
                        }
                    }
                } else {
                    // Add the "character" as a byte so that we remain 8-bit clean.
                    // This way, strings are parsed correctly whether or not they contain utf-8 chars.
                    micropy_vstr_add_byte(mp_state, &lex->vstr, CUR_CHAR(lex));
                }
            }
            micropy_next_char(mp_state, lex);
        }

        // check we got the required end quotes
        if (n_closing < num_quotes) {
            lex->tok_kind = MP_TOKEN_LONELY_STRING_OPEN;
        }

        // cut off the end quotes from the token text
        micropy_vstr_cut_tail_bytes(mp_state, &lex->vstr, n_closing);

    } else if (micropy_is_head_of_identifier(mp_state, lex)) {
        lex->tok_kind = MP_TOKEN_NAME;

        // get first char (add as byte to remain 8-bit clean and support utf-8)
        micropy_vstr_add_byte(mp_state, &lex->vstr, CUR_CHAR(lex));
        micropy_next_char(mp_state, lex);

        // get tail chars
        while (!micropy_is_end(mp_state, lex) && micropy_is_tail_of_identifier(mp_state, lex)) {
            micropy_vstr_add_byte(mp_state, &lex->vstr, CUR_CHAR(lex));
            micropy_next_char(mp_state, lex);
        }

    } else if (micropy_is_digit(mp_state, lex) || (micropy_is_char(mp_state, lex, '.') && micropy_is_following_digit(mp_state, lex))) {
        bool forced_integer = false;
        if (micropy_is_char(mp_state, lex, '.')) {
            lex->tok_kind = MP_TOKEN_FLOAT_OR_IMAG;
        } else {
            lex->tok_kind = MP_TOKEN_INTEGER;
            if (micropy_is_char(mp_state, lex, '0') && micropy_is_following_base_char(mp_state, lex)) {
                forced_integer = true;
            }
        }

        // get first char
        micropy_vstr_add_char(mp_state, &lex->vstr, CUR_CHAR(lex));
        micropy_next_char(mp_state, lex);

        // get tail chars
        while (!micropy_is_end(mp_state, lex)) {
            if (!forced_integer && micropy_is_char_or(mp_state, lex, 'e', 'E')) {
                lex->tok_kind = MP_TOKEN_FLOAT_OR_IMAG;
                micropy_vstr_add_char(mp_state, &lex->vstr, 'e');
                micropy_next_char(mp_state, lex);
                if (micropy_is_char(mp_state, lex, '+') || micropy_is_char(mp_state, lex, '-')) {
                    micropy_vstr_add_char(mp_state, &lex->vstr, CUR_CHAR(lex));
                    micropy_next_char(mp_state, lex);
                }
            } else if (micropy_is_letter(mp_state, lex) || micropy_is_digit(mp_state, lex) || micropy_is_char(mp_state, lex, '.')) {
                if (micropy_is_char_or3(mp_state, lex, '.', 'j', 'J')) {
                    lex->tok_kind = MP_TOKEN_FLOAT_OR_IMAG;
                }
                micropy_vstr_add_char(mp_state, &lex->vstr, CUR_CHAR(lex));
                micropy_next_char(mp_state, lex);
            } else {
                break;
            }
        }

    } else if (micropy_is_char(mp_state, lex, '.')) {
        // special handling for . and ... operators, because .. is not a valid operator

        // get first char
        micropy_vstr_add_char(mp_state, &lex->vstr, '.');
        micropy_next_char(mp_state, lex);

        if (micropy_is_char_and(mp_state, lex, '.', '.')) {
            micropy_vstr_add_char(mp_state, &lex->vstr, '.');
            micropy_vstr_add_char(mp_state, &lex->vstr, '.');
            micropy_next_char(mp_state, lex);
            micropy_next_char(mp_state, lex);
            lex->tok_kind = MP_TOKEN_ELLIPSIS;
        } else {
            lex->tok_kind = MP_TOKEN_DEL_PERIOD;
        }

    } else {
        // search for encoded delimiter or operator

        const char *t = tok_enc;
        mp_uint_t tok_enc_index = 0;
        for (; *t != 0 && !micropy_is_char(mp_state, lex, *t); t += 1) {
            if (*t == 'e' || *t == 'c') {
                t += 1;
            } else if (*t == 'E') {
                tok_enc_index -= 1;
                t += 1;
            }
            tok_enc_index += 1;
        }

        micropy_next_char(mp_state, lex);

        if (*t == 0) {
            // didn't match any delimiter or operator characters
            lex->tok_kind = MP_TOKEN_INVALID;

        } else {
            // matched a delimiter or operator character

            // get the maximum characters for a valid token
            t += 1;
            mp_uint_t t_index = tok_enc_index;
            for (;;) {
                for (; *t == 'e'; t += 1) {
                    t += 1;
                    t_index += 1;
                    if (micropy_is_char(mp_state, lex, *t)) {
                        micropy_next_char(mp_state, lex);
                        tok_enc_index = t_index;
                        break;
                    }
                }

                if (*t == 'E') {
                    t += 1;
                    if (micropy_is_char(mp_state, lex, *t)) {
                        micropy_next_char(mp_state, lex);
                        tok_enc_index = t_index;
                    } else {
                        lex->tok_kind = MP_TOKEN_INVALID;
                        goto tok_enc_no_match;
                    }
                    break;
                }

                if (*t == 'c') {
                    t += 1;
                    t_index += 1;
                    if (micropy_is_char(mp_state, lex, *t)) {
                        micropy_next_char(mp_state, lex);
                        tok_enc_index = t_index;
                        t += 1;
                    } else {
                        break;
                    }
                } else {
                    break;
                }
            }

            // set token kind
            lex->tok_kind = tok_enc_kind[tok_enc_index];

            tok_enc_no_match:

            // compute bracket level for implicit line joining
            if (lex->tok_kind == MP_TOKEN_DEL_PAREN_OPEN || lex->tok_kind == MP_TOKEN_DEL_BRACKET_OPEN || lex->tok_kind == MP_TOKEN_DEL_BRACE_OPEN) {
                lex->nested_bracket_level += 1;
            } else if (lex->tok_kind == MP_TOKEN_DEL_PAREN_CLOSE || lex->tok_kind == MP_TOKEN_DEL_BRACKET_CLOSE || lex->tok_kind == MP_TOKEN_DEL_BRACE_CLOSE) {
                lex->nested_bracket_level -= 1;
            }
        }
    }

    // check for keywords
    if (lex->tok_kind == MP_TOKEN_NAME) {
        // We check for __debug__ here and convert it to its value.  This is so
        // the parser gives a syntax error on, eg, x.__debug__.  Otherwise, we
        // need to check for this special token in many places in the compiler.
        // TODO improve speed of these string comparisons
        //for (mp_int_t i = 0; tok_kw[i] != NULL; i++) {
        for (size_t i = 0; i < MP_ARRAY_SIZE(tok_kw); i++) {
            if (micropy_str_strn_equal(mp_state, tok_kw[i], lex->vstr.buf, lex->vstr.len)) {
                if (i == MP_ARRAY_SIZE(tok_kw) - 1) {
                    // tok_kw[MP_ARRAY_SIZE(tok_kw) - 1] == "__debug__"
                    lex->tok_kind = ((mp_state)->vm.mp_optimise_value == 0 ? MP_TOKEN_KW_TRUE : MP_TOKEN_KW_FALSE);
                } else {
                    lex->tok_kind = MP_TOKEN_KW_FALSE + i;
                }
                break;
            }
        }
    }
}

mp_lexer_t *micropy_lexer_new(struct _mp_state_ctx_t *mp_state, qstr src_name, void *stream_data, mp_lexer_stream_next_byte_t stream_next_byte, mp_lexer_stream_close_t stream_close) {
    mp_lexer_t *lex = micropy_m_new_obj_maybe(mp_state, mp_lexer_t);

    // check for memory allocation error
    if (lex == NULL) {
        if (stream_close) {
            stream_close(mp_state, stream_data);
        }
        return NULL;
    }

    lex->source_name = src_name;
    lex->stream_data = stream_data;
    lex->stream_next_byte = stream_next_byte;
    lex->stream_close = stream_close;
    lex->line = 1;
    lex->column = 1;
    lex->emit_dent = 0;
    lex->nested_bracket_level = 0;
    lex->alloc_indent_level = MICROPY_ALLOC_LEXER_INDENT_INIT;
    lex->num_indent_level = 1;
    lex->indent_level = micropy_m_new_maybe(mp_state, uint16_t, lex->alloc_indent_level);
    micropy_vstr_init(mp_state, &lex->vstr, 32);

    // check for memory allocation error
    if (lex->indent_level == NULL || micropy_vstr_had_error(mp_state, &lex->vstr)) {
        micropy_lexer_free(mp_state, lex);
        return NULL;
    }

    // store sentinel for first indentation level
    lex->indent_level[0] = 0;

    // preload characters
    lex->chr0 = stream_next_byte(mp_state, stream_data);
    lex->chr1 = stream_next_byte(mp_state, stream_data);
    lex->chr2 = stream_next_byte(mp_state, stream_data);

    // if input stream is 0, 1 or 2 characters long and doesn't end in a newline, then insert a newline at the end
    if (lex->chr0 == MP_LEXER_EOF) {
        lex->chr0 = '\n';
    } else if (lex->chr1 == MP_LEXER_EOF) {
        if (lex->chr0 == '\r') {
            lex->chr0 = '\n';
        } else if (lex->chr0 != '\n') {
            lex->chr1 = '\n';
        }
    } else if (lex->chr2 == MP_LEXER_EOF) {
        if (lex->chr1 == '\r') {
            lex->chr1 = '\n';
        } else if (lex->chr1 != '\n') {
            lex->chr2 = '\n';
        }
    }

    // preload first token
    micropy_lexer_next_token_into(mp_state, lex, true);

    return lex;
}

void micropy_lexer_free(struct _mp_state_ctx_t *mp_state, mp_lexer_t *lex) {
    if (lex) {
        if (lex->stream_close) {
            lex->stream_close(mp_state, lex->stream_data);
        }
        micropy_vstr_clear(mp_state, &lex->vstr);
        micropy_m_del(mp_state, uint16_t, lex->indent_level, lex->alloc_indent_level);
        micropy_m_del_obj(mp_state, mp_lexer_t, lex);
    }
}

void micropy_lexer_to_next(struct _mp_state_ctx_t *mp_state, mp_lexer_t *lex) {
    micropy_lexer_next_token_into(mp_state, lex, false);
}

#if MICROPY_DEBUG_PRINTERS
void micropy_lexer_show_token(struct _mp_state_ctx_t *mp_state, const mp_lexer_t *lex) {
    printf("(" UINT_FMT ":" UINT_FMT ") kind:%u str:%p len:%zu", lex->tok_line, lex->tok_column, lex->tok_kind, lex->vstr.buf, lex->vstr.len);
    if (lex->vstr.len > 0) {
        const byte *i = (const byte *)lex->vstr.buf;
        const byte *j = (const byte *)i + lex->vstr.len;
        printf(" ");
        while (i < j) {
            unichar c = utf8_get_char(i);
            i = utf8_next_char(i);
            if (unichar_isprint(c)) {
                printf("%c", (int)c);
            } else {
                printf("?");
            }
        }
    }
    printf("\n");
}
#endif

#endif // MICROPY_ENABLE_COMPILER
/*
 * This file is part of the Micro Python project, http://micropython.org/
 *
 * The MIT License (MIT)
 *
 * Copyright (c) 2013, 2014 Damien P. George
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

//#include "py/lexer.h"

#if MICROPY_ENABLE_COMPILER

typedef struct _mp_lexer_str_buf_t {
    mp_uint_t free_len;         // if > 0, src_beg will be freed when done by: m_free(src_beg, free_len)
    const char *src_beg;        // beginning of source
    const char *src_cur;        // current location in source
    const char *src_end;        // end (exclusive) of source
} mp_lexer_str_buf_t;

STATIC mp_uint_t micropy_str_buf_next_byte(struct _mp_state_ctx_t *mp_state, mp_lexer_str_buf_t *sb) {
    if (sb->src_cur < sb->src_end) {
        return *sb->src_cur++;
    } else {
        return MP_LEXER_EOF;
    }
}

STATIC void micropy_str_buf_free(struct _mp_state_ctx_t *mp_state, mp_lexer_str_buf_t *sb) {
    if (sb->free_len > 0) {
        micropy_m_del(mp_state, char, (char*)sb->src_beg, sb->free_len);
    }
    micropy_m_del_obj(mp_state, mp_lexer_str_buf_t, sb);
}

mp_lexer_t *micropy_lexer_new_from_str_len(struct _mp_state_ctx_t *mp_state, qstr src_name, const char *str, mp_uint_t len, mp_uint_t free_len) {
    mp_lexer_str_buf_t *sb = micropy_m_new_obj_maybe(mp_state, mp_lexer_str_buf_t);
    if (sb == NULL) {
        return NULL;
    }
    sb->free_len = free_len;
    sb->src_beg = str;
    sb->src_cur = str;
    sb->src_end = str + len;
    return micropy_lexer_new(mp_state, src_name, sb, (mp_lexer_stream_next_byte_t)micropy_str_buf_next_byte, (mp_lexer_stream_close_t)micropy_str_buf_free);
}

#endif // MICROPY_ENABLE_COMPILER
/*
 * This file is part of the Micro Python project, http://micropython.org/
 *
 * The MIT License (MIT)
 *
 * Copyright (c) 2013, 2014 Damien P. George
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

//#include "py/mpconfig.h"

#if MICROPY_HELPER_LEXER_UNIX

#include <stdio.h>
#include <stdint.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <sys/types.h>

//#include "py/lexer.h"

typedef struct _mp_lexer_file_buf_t {
    int fd;
    bool close_fd;
    byte buf[20];
    mp_uint_t len;
    mp_uint_t pos;
} mp_lexer_file_buf_t;

STATIC mp_uint_t micropy_file_buf_next_byte(struct _mp_state_ctx_t *mp_state, mp_lexer_file_buf_t *fb) {
    if (fb->pos >= fb->len) {
        if (fb->len == 0) {
            return MP_LEXER_EOF;
        } else {
            int n = read(fb->fd, fb->buf, sizeof(fb->buf));
            if (n <= 0) {
                fb->len = 0;
                return MP_LEXER_EOF;
            }
            fb->len = n;
            fb->pos = 0;
        }
    }
    return fb->buf[fb->pos++];
}

STATIC void micropy_file_buf_close(struct _mp_state_ctx_t *mp_state, mp_lexer_file_buf_t *fb) {
    if (fb->close_fd) {
        close(fb->fd);
    }
    micropy_m_del_obj(mp_state, mp_lexer_file_buf_t, fb);
}

mp_lexer_t *micropy_lexer_new_from_fd(struct _mp_state_ctx_t *mp_state, qstr filename, int fd, bool close_fd) {
    mp_lexer_file_buf_t *fb = micropy_m_new_obj_maybe(mp_state, mp_lexer_file_buf_t);
    if (fb == NULL) {
        if (close_fd) {
            close(fd);
        }
        return NULL;
    }
    fb->fd = fd;
    fb->close_fd = close_fd;
    int n = read(fb->fd, fb->buf, sizeof(fb->buf));
    fb->len = n;
    fb->pos = 0;
    return micropy_lexer_new(mp_state, filename, fb, (mp_lexer_stream_next_byte_t)micropy_file_buf_next_byte, (mp_lexer_stream_close_t)micropy_file_buf_close);
}

mp_lexer_t *micropy_lexer_new_from_file(struct _mp_state_ctx_t *mp_state, const char *filename) {
    int fd = open(filename, O_RDONLY);
    if (fd < 0) {
        return NULL;
    }
    return micropy_lexer_new_from_fd(mp_state, micropy_qstr_from_str(mp_state, filename), fd, true);
}

#endif // MICROPY_HELPER_LEXER_UNIX
/*
 * This file is part of the Micro Python project, http://micropython.org/
 *
 * The MIT License (MIT)
 *
 * Copyright (c) 2013-2015 Damien P. George
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <unistd.h> // for ssize_t
#include <assert.h>
#include <string.h>

//#include "py/nlr.h"
//#include "py/lexer.h"
//#include "py/parse.h"
//#include "py/parsenum.h"
//#include "py/runtime0.h"
//#include "py/runtime.h"
//#include "py/objint.h"
//#include "py/builtin.h"

#if MICROPY_ENABLE_COMPILER

#define RULE_ACT_ARG_MASK       (0x0f)
#define RULE_ACT_KIND_MASK      (0x30)
#define RULE_ACT_ALLOW_IDENT    (0x40)
#define RULE_ACT_ADD_BLANK      (0x80)
#define RULE_ACT_OR             (0x10)
#define RULE_ACT_AND            (0x20)
#define RULE_ACT_LIST           (0x30)

#define RULE_ARG_KIND_MASK      (0xf000)
#define RULE_ARG_ARG_MASK       (0x0fff)
#define RULE_ARG_TOK            (0x1000)
#define RULE_ARG_RULE           (0x2000)
#define RULE_ARG_OPT_RULE       (0x3000)

// (un)comment to use rule names; for debugging
//#define USE_RULE_NAME (1)

typedef struct _rule_t {
    byte rule_id;
    byte act;
#ifdef USE_RULE_NAME
    const char *rule_name;
#endif
    uint16_t arg[];
} rule_t;

enum {
#define DEF_RULE(rule, comp, kind, ...) RULE_##rule,
/*
 * This file is part of the Micro Python project, http://micropython.org/
 *
 * The MIT License (MIT)
 *
 * Copyright (c) 2013-2015 Damien P. George
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

// rules for writing rules:
// - zero_or_more is implemented using opt_rule around a one_or_more rule
// - don't put opt_rule in arguments of or rule; instead, wrap the call to this or rule in opt_rule

// # Start symbols for the grammar:
// #       single_input is a single interactive statement;
// #       file_input is a module or sequence of commands read from an input file;
// #       eval_input is the input for the eval() functions.
// # NB: compound_stmt in single_input is followed by extra NEWLINE! --> not in Micro Python
// single_input: NEWLINE | simple_stmt | compound_stmt
// file_input: (NEWLINE | stmt)* ENDMARKER
// eval_input: testlist NEWLINE* ENDMARKER

DEF_RULE(single_input, nc, or(3), tok(NEWLINE), rule(simple_stmt), rule(compound_stmt))
DEF_RULE(file_input, c(generic_all_nodes), and_ident(1), opt_rule(file_input_2))
DEF_RULE(file_input_2, c(generic_all_nodes), one_or_more, rule(file_input_3))
DEF_RULE(file_input_3, nc, or(2), tok(NEWLINE), rule(stmt))
DEF_RULE(eval_input, nc, and_ident(2), rule(testlist), opt_rule(eval_input_2))
DEF_RULE(eval_input_2, nc, and(1), tok(NEWLINE))

// decorator: '@' dotted_name [ '(' [arglist] ')' ] NEWLINE
// decorators: decorator+
// decorated: decorators (classdef | funcdef | async_funcdef)
// funcdef: 'def' NAME parameters ['->' test] ':' suite
// async_funcdef: 'async' funcdef
// parameters: '(' [typedargslist] ')'
// typedargslist: tfpdef ['=' test] (',' tfpdef ['=' test])* [',' ['*' [tfpdef] (',' tfpdef ['=' test])* [',' '**' tfpdef] | '**' tfpdef]] | '*' [tfpdef] (',' tfpdef ['=' test])* [',' '**' tfpdef] | '**' tfpdef
// tfpdef: NAME [':' test]
// varargslist: vfpdef ['=' test] (',' vfpdef ['=' test])* [',' ['*' [vfpdef] (',' vfpdef ['=' test])* [',' '**' vfpdef] | '**' vfpdef]] |  '*' [vfpdef] (',' vfpdef ['=' test])* [',' '**' vfpdef] | '**' vfpdef
// vfpdef: NAME

DEF_RULE(decorator, nc, and(4), tok(DEL_AT), rule(dotted_name), opt_rule(trailer_paren), tok(NEWLINE))
DEF_RULE(decorators, nc, one_or_more, rule(decorator))
DEF_RULE(decorated, c(decorated), and_ident(2), rule(decorators), rule(decorated_body))
#if MICROPY_PY_ASYNC_AWAIT
DEF_RULE(decorated_body, nc, or(3), rule(classdef), rule(funcdef), rule(async_funcdef))
DEF_RULE(async_funcdef, nc, and(2), tok(KW_ASYNC), rule(funcdef))
#else
DEF_RULE(decorated_body, nc, or(2), rule(classdef), rule(funcdef))
#endif
DEF_RULE(funcdef, c(funcdef), and_blank(8), tok(KW_DEF), tok(NAME), tok(DEL_PAREN_OPEN), opt_rule(typedargslist), tok(DEL_PAREN_CLOSE), opt_rule(funcdefrettype), tok(DEL_COLON), rule(suite))
DEF_RULE(funcdefrettype, nc, and_ident(2), tok(DEL_MINUS_MORE), rule(test))
// note: typedargslist lets through more than is allowed, compiler does further checks
DEF_RULE(typedargslist, nc, list_with_end, rule(typedargslist_item), tok(DEL_COMMA))
DEF_RULE(typedargslist_item, nc, or(3), rule(typedargslist_name), rule(typedargslist_star), rule(typedargslist_dbl_star))
DEF_RULE(typedargslist_name, nc, and_ident(3), tok(NAME), opt_rule(typedargslist_colon), opt_rule(typedargslist_equal))
DEF_RULE(typedargslist_star, nc, and(2), tok(OP_STAR), opt_rule(tfpdef))
DEF_RULE(typedargslist_dbl_star, nc, and(3), tok(OP_DBL_STAR), tok(NAME), opt_rule(typedargslist_colon))
DEF_RULE(typedargslist_colon, nc, and_ident(2), tok(DEL_COLON), rule(test))
DEF_RULE(typedargslist_equal, nc, and_ident(2), tok(DEL_EQUAL), rule(test))
DEF_RULE(tfpdef, nc, and(2), tok(NAME), opt_rule(typedargslist_colon))
// note: varargslist lets through more than is allowed, compiler does further checks
DEF_RULE(varargslist, nc, list_with_end, rule(varargslist_item), tok(DEL_COMMA))
DEF_RULE(varargslist_item, nc, or(3), rule(varargslist_name), rule(varargslist_star), rule(varargslist_dbl_star))
DEF_RULE(varargslist_name, nc, and_ident(2), tok(NAME), opt_rule(varargslist_equal))
DEF_RULE(varargslist_star, nc, and(2), tok(OP_STAR), opt_rule(vfpdef))
DEF_RULE(varargslist_dbl_star, nc, and(2), tok(OP_DBL_STAR), tok(NAME))
DEF_RULE(varargslist_equal, nc, and_ident(2), tok(DEL_EQUAL), rule(test))
DEF_RULE(vfpdef, nc, and_ident(1), tok(NAME))

// stmt: compound_stmt | simple_stmt

DEF_RULE(stmt, nc, or(2), rule(compound_stmt), rule(simple_stmt))

// simple_stmt: small_stmt (';' small_stmt)* [';'] NEWLINE

DEF_RULE(simple_stmt, nc, and_ident(2), rule(simple_stmt_2), tok(NEWLINE))
DEF_RULE(simple_stmt_2, c(generic_all_nodes), list_with_end, rule(small_stmt), tok(DEL_SEMICOLON))

// small_stmt: expr_stmt | del_stmt | pass_stmt | flow_stmt | import_stmt | global_stmt | nonlocal_stmt | assert_stmt
// expr_stmt: testlist_star_expr (augassign (yield_expr|testlist) | ('=' (yield_expr|testlist_star_expr))*)
// testlist_star_expr: (test|star_expr) (',' (test|star_expr))* [',']
// augassign: '+=' | '-=' | '*=' | '/=' | '%=' | '&=' | '|=' | '^=' | '<<=' | '>>=' | '**=' | '//='
// # For normal assignments, additional restrictions enforced by the interpreter

DEF_RULE(small_stmt, nc, or(8), rule(del_stmt), rule(pass_stmt), rule(flow_stmt), rule(import_stmt), rule(global_stmt), rule(nonlocal_stmt), rule(assert_stmt), rule(expr_stmt))
DEF_RULE(expr_stmt, c(expr_stmt), and(2), rule(testlist_star_expr), opt_rule(expr_stmt_2))
DEF_RULE(expr_stmt_2, nc, or(2), rule(expr_stmt_augassign), rule(expr_stmt_assign_list))
DEF_RULE(expr_stmt_augassign, nc, and_ident(2), rule(augassign), rule(expr_stmt_6))
DEF_RULE(expr_stmt_assign_list, nc, one_or_more, rule(expr_stmt_assign))
DEF_RULE(expr_stmt_assign, nc, and_ident(2), tok(DEL_EQUAL), rule(expr_stmt_6))
DEF_RULE(expr_stmt_6, nc, or(2), rule(yield_expr), rule(testlist_star_expr))
DEF_RULE(testlist_star_expr, c(generic_tuple), list_with_end, rule(testlist_star_expr_2), tok(DEL_COMMA))
DEF_RULE(testlist_star_expr_2, nc, or(2), rule(star_expr), rule(test))
DEF_RULE(augassign, nc, or(12), tok(DEL_PLUS_EQUAL), tok(DEL_MINUS_EQUAL), tok(DEL_STAR_EQUAL), tok(DEL_SLASH_EQUAL), tok(DEL_PERCENT_EQUAL), tok(DEL_AMPERSAND_EQUAL), tok(DEL_PIPE_EQUAL), tok(DEL_CARET_EQUAL), tok(DEL_DBL_LESS_EQUAL), tok(DEL_DBL_MORE_EQUAL), tok(DEL_DBL_STAR_EQUAL), tok(DEL_DBL_SLASH_EQUAL))

// del_stmt: 'del' exprlist
// pass_stmt: 'pass'
// flow_stmt: break_stmt | continue_stmt | return_stmt | raise_stmt | yield_stmt
// break_stmt: 'break'
// continue_stmt: 'continue'
// return_stmt: 'return' [testlist]
// yield_stmt: yield_expr
// raise_stmt: 'raise' [test ['from' test]]

DEF_RULE(del_stmt, c(del_stmt), and(2), tok(KW_DEL), rule(exprlist))
DEF_RULE(pass_stmt, c(generic_all_nodes), and(1), tok(KW_PASS))
DEF_RULE(flow_stmt, nc, or(5), rule(break_stmt), rule(continue_stmt), rule(return_stmt), rule(raise_stmt), rule(yield_stmt))
DEF_RULE(break_stmt, c(break_stmt), and(1), tok(KW_BREAK))
DEF_RULE(continue_stmt, c(continue_stmt), and(1), tok(KW_CONTINUE))
DEF_RULE(return_stmt, c(return_stmt), and(2), tok(KW_RETURN), opt_rule(testlist))
DEF_RULE(yield_stmt, c(yield_stmt), and(1), rule(yield_expr))
DEF_RULE(raise_stmt, c(raise_stmt), and(2), tok(KW_RAISE), opt_rule(raise_stmt_arg))
DEF_RULE(raise_stmt_arg, nc, and_ident(2), rule(test), opt_rule(raise_stmt_from))
DEF_RULE(raise_stmt_from, nc, and_ident(2), tok(KW_FROM), rule(test))

// import_stmt: import_name | import_from
// import_name: 'import' dotted_as_names
// import_from: 'from' (('.' | '...')* dotted_name | ('.' | '...')+) 'import' ('*' | '(' import_as_names ')' | import_as_names)
// import_as_name: NAME ['as' NAME]
// dotted_as_name: dotted_name ['as' NAME]
// import_as_names: import_as_name (',' import_as_name)* [',']
// dotted_as_names: dotted_as_name (',' dotted_as_name)*
// dotted_name: NAME ('.' NAME)*
// global_stmt: 'global' NAME (',' NAME)*
// nonlocal_stmt: 'nonlocal' NAME (',' NAME)*
// assert_stmt: 'assert' test [',' test]

DEF_RULE(import_stmt, nc, or(2), rule(import_name), rule(import_from))
DEF_RULE(import_name, c(import_name), and(2), tok(KW_IMPORT), rule(dotted_as_names))
DEF_RULE(import_from, c(import_from), and(4), tok(KW_FROM), rule(import_from_2), tok(KW_IMPORT), rule(import_from_3))
DEF_RULE(import_from_2, nc, or(2), rule(dotted_name), rule(import_from_2b))
DEF_RULE(import_from_2b, nc, and_ident(2), rule(one_or_more_period_or_ellipsis), opt_rule(dotted_name))
DEF_RULE(import_from_3, nc, or(3), tok(OP_STAR), rule(import_as_names_paren), rule(import_as_names))
DEF_RULE(import_as_names_paren, nc, and_ident(3), tok(DEL_PAREN_OPEN), rule(import_as_names), tok(DEL_PAREN_CLOSE))
DEF_RULE(one_or_more_period_or_ellipsis, nc, one_or_more, rule(period_or_ellipsis))
DEF_RULE(period_or_ellipsis, nc, or(2), tok(DEL_PERIOD), tok(ELLIPSIS))
DEF_RULE(import_as_name, nc, and(2), tok(NAME), opt_rule(as_name))
DEF_RULE(dotted_as_name, nc, and_ident(2), rule(dotted_name), opt_rule(as_name))
DEF_RULE(as_name, nc, and_ident(2), tok(KW_AS), tok(NAME))
DEF_RULE(import_as_names, nc, list_with_end, rule(import_as_name), tok(DEL_COMMA))
DEF_RULE(dotted_as_names, nc, list, rule(dotted_as_name), tok(DEL_COMMA))
DEF_RULE(dotted_name, nc, list, tok(NAME), tok(DEL_PERIOD))
DEF_RULE(global_stmt, c(global_stmt), and(2), tok(KW_GLOBAL), rule(name_list))
DEF_RULE(nonlocal_stmt, c(nonlocal_stmt), and(2), tok(KW_NONLOCAL), rule(name_list))
DEF_RULE(name_list, nc, list, tok(NAME), tok(DEL_COMMA))
DEF_RULE(assert_stmt, c(assert_stmt), and(3), tok(KW_ASSERT), rule(test), opt_rule(assert_stmt_extra))
DEF_RULE(assert_stmt_extra, nc, and_ident(2), tok(DEL_COMMA), rule(test))

// compound_stmt: if_stmt | while_stmt | for_stmt | try_stmt | with_stmt | funcdef | classdef | decorated | async_stmt
// if_stmt: 'if' test ':' suite ('elif' test ':' suite)* ['else' ':' suite]
// while_stmt: 'while' test ':' suite ['else' ':' suite]
// for_stmt: 'for' exprlist 'in' testlist ':' suite ['else' ':' suite]
// try_stmt: 'try' ':' suite ((except_clause ':' suite)+ ['else' ':' suite] ['finally' ':' suite] | 'finally' ':' suite)
// # NB compile.c makes sure that the default except clause is last
// except_clause: 'except' [test ['as' NAME]]
// with_stmt: 'with' with_item (',' with_item)* ':' suite
// with_item: test ['as' expr]
// suite: simple_stmt | NEWLINE INDENT stmt+ DEDENT
// async_stmt: 'async' (funcdef | with_stmt | for_stmt)

#if MICROPY_PY_ASYNC_AWAIT
DEF_RULE(compound_stmt, nc, or(9), rule(if_stmt), rule(while_stmt), rule(for_stmt), rule(try_stmt), rule(with_stmt), rule(funcdef), rule(classdef), rule(decorated), rule(async_stmt))
DEF_RULE(async_stmt, c(async_stmt), and(2), tok(KW_ASYNC), rule(async_stmt_2))
DEF_RULE(async_stmt_2, nc, or(3), rule(funcdef), rule(with_stmt), rule(for_stmt))
#else
DEF_RULE(compound_stmt, nc, or(8), rule(if_stmt), rule(while_stmt), rule(for_stmt), rule(try_stmt), rule(with_stmt), rule(funcdef), rule(classdef), rule(decorated))
#endif
DEF_RULE(if_stmt, c(if_stmt), and(6), tok(KW_IF), rule(test), tok(DEL_COLON), rule(suite), opt_rule(if_stmt_elif_list), opt_rule(else_stmt))
DEF_RULE(if_stmt_elif_list, nc, one_or_more, rule(if_stmt_elif))
DEF_RULE(if_stmt_elif, nc, and(4), tok(KW_ELIF), rule(test), tok(DEL_COLON), rule(suite))
DEF_RULE(while_stmt, c(while_stmt), and(5), tok(KW_WHILE), rule(test), tok(DEL_COLON), rule(suite), opt_rule(else_stmt))
DEF_RULE(for_stmt, c(for_stmt), and(7), tok(KW_FOR), rule(exprlist), tok(KW_IN), rule(testlist), tok(DEL_COLON), rule(suite), opt_rule(else_stmt))
DEF_RULE(try_stmt, c(try_stmt), and(4), tok(KW_TRY), tok(DEL_COLON), rule(suite), rule(try_stmt_2))
DEF_RULE(try_stmt_2, nc, or(2), rule(try_stmt_except_and_more), rule(try_stmt_finally))
DEF_RULE(try_stmt_except_and_more, nc, and_ident(3), rule(try_stmt_except_list), opt_rule(else_stmt), opt_rule(try_stmt_finally))
DEF_RULE(try_stmt_except, nc, and(4), tok(KW_EXCEPT), opt_rule(try_stmt_as_name), tok(DEL_COLON), rule(suite))
DEF_RULE(try_stmt_as_name, nc, and_ident(2), rule(test), opt_rule(as_name))
DEF_RULE(try_stmt_except_list, nc, one_or_more, rule(try_stmt_except))
DEF_RULE(try_stmt_finally, nc, and(3), tok(KW_FINALLY), tok(DEL_COLON), rule(suite))
DEF_RULE(else_stmt, nc, and_ident(3), tok(KW_ELSE), tok(DEL_COLON), rule(suite))
DEF_RULE(with_stmt, c(with_stmt), and(4), tok(KW_WITH), rule(with_stmt_list), tok(DEL_COLON), rule(suite))
DEF_RULE(with_stmt_list, nc, list, rule(with_item), tok(DEL_COMMA))
DEF_RULE(with_item, nc, and_ident(2), rule(test), opt_rule(with_item_as))
DEF_RULE(with_item_as, nc, and_ident(2), tok(KW_AS), rule(expr))
DEF_RULE(suite, nc, or(2), rule(suite_block), rule(simple_stmt))
DEF_RULE(suite_block, nc, and_ident(4), tok(NEWLINE), tok(INDENT), rule(suite_block_stmts), tok(DEDENT))
DEF_RULE(suite_block_stmts, c(generic_all_nodes), one_or_more, rule(stmt))

// test: or_test ['if' or_test 'else' test] | lambdef
// test_nocond: or_test | lambdef_nocond
// lambdef: 'lambda' [varargslist] ':' test
// lambdef_nocond: 'lambda' [varargslist] ':' test_nocond

DEF_RULE(test, nc, or(2), rule(lambdef), rule(test_if_expr))
DEF_RULE(test_if_expr, c(test_if_expr), and_ident(2), rule(or_test), opt_rule(test_if_else))
DEF_RULE(test_if_else, nc, and(4), tok(KW_IF), rule(or_test), tok(KW_ELSE), rule(test))
DEF_RULE(test_nocond, nc, or(2), rule(lambdef_nocond), rule(or_test))
DEF_RULE(lambdef, c(lambdef), and_blank(4), tok(KW_LAMBDA), opt_rule(varargslist), tok(DEL_COLON), rule(test))
DEF_RULE(lambdef_nocond, c(lambdef), and_blank(4), tok(KW_LAMBDA), opt_rule(varargslist), tok(DEL_COLON), rule(test_nocond))

// or_test: and_test ('or' and_test)*
// and_test: not_test ('and' not_test)*
// not_test: 'not' not_test | comparison
// comparison: expr (comp_op expr)*
// comp_op: '<'|'>'|'=='|'>='|'<='|'!='|'in'|'not' 'in'|'is'|'is' 'not'
// star_expr: '*' expr
// expr: xor_expr ('|' xor_expr)*
// xor_expr: and_expr ('^' and_expr)*
// and_expr: shift_expr ('&' shift_expr)*
// shift_expr: arith_expr (('<<'|'>>') arith_expr)*
// arith_expr: term (('+'|'-') term)*
// term: factor (('*'|'/'|'%'|'//') factor)*
// factor: ('+'|'-'|'~') factor | power
// power: atom_expr ['**' factor]
// atom_expr: 'await' atom trailer* | atom trailer*

DEF_RULE(or_test, c(or_test), list, rule(and_test), tok(KW_OR))
DEF_RULE(and_test, c(and_test), list, rule(not_test), tok(KW_AND))
DEF_RULE(not_test, nc, or(2), rule(not_test_2), rule(comparison))
DEF_RULE(not_test_2, c(not_test_2), and(2), tok(KW_NOT), rule(not_test))
DEF_RULE(comparison, c(comparison), list, rule(expr), rule(comp_op))
DEF_RULE(comp_op, nc, or(9), tok(OP_LESS), tok(OP_MORE), tok(OP_DBL_EQUAL), tok(OP_LESS_EQUAL), tok(OP_MORE_EQUAL), tok(OP_NOT_EQUAL), tok(KW_IN), rule(comp_op_not_in), rule(comp_op_is))
DEF_RULE(comp_op_not_in, nc, and(2), tok(KW_NOT), tok(KW_IN))
DEF_RULE(comp_op_is, nc, and(2), tok(KW_IS), opt_rule(comp_op_is_not))
DEF_RULE(comp_op_is_not, nc, and(1), tok(KW_NOT))
DEF_RULE(star_expr, c(star_expr), and(2), tok(OP_STAR), rule(expr))
DEF_RULE(expr, c(expr), list, rule(xor_expr), tok(OP_PIPE))
DEF_RULE(xor_expr, c(xor_expr), list, rule(and_expr), tok(OP_CARET))
DEF_RULE(and_expr, c(and_expr), list, rule(shift_expr), tok(OP_AMPERSAND))
DEF_RULE(shift_expr, c(shift_expr), list, rule(arith_expr), rule(shift_op))
DEF_RULE(shift_op, nc, or(2), tok(OP_DBL_LESS), tok(OP_DBL_MORE))
DEF_RULE(arith_expr, c(arith_expr), list, rule(term), rule(arith_op))
DEF_RULE(arith_op, nc, or(2), tok(OP_PLUS), tok(OP_MINUS))
DEF_RULE(term, c(term), list, rule(factor), rule(term_op))
DEF_RULE(term_op, nc, or(4), tok(OP_STAR), tok(OP_SLASH), tok(OP_PERCENT), tok(OP_DBL_SLASH))
DEF_RULE(factor, nc, or(2), rule(factor_2), rule(power))
DEF_RULE(factor_2, c(factor_2), and_ident(2), rule(factor_op), rule(factor))
DEF_RULE(factor_op, nc, or(3), tok(OP_PLUS), tok(OP_MINUS), tok(OP_TILDE))
DEF_RULE(power, c(power), and_ident(2), rule(atom_expr), opt_rule(power_dbl_star))
#if MICROPY_PY_ASYNC_AWAIT
DEF_RULE(atom_expr, nc, or(2), rule(atom_expr_await), rule(atom_expr_normal))
DEF_RULE(atom_expr_await, c(atom_expr_await), and(3), tok(KW_AWAIT), rule(atom), opt_rule(atom_expr_trailers))
#else
DEF_RULE(atom_expr, nc, or(1), rule(atom_expr_normal))
#endif
DEF_RULE(atom_expr_normal, c(atom_expr_normal), and_ident(2), rule(atom), opt_rule(atom_expr_trailers))
DEF_RULE(atom_expr_trailers, c(atom_expr_trailers), one_or_more, rule(trailer))
DEF_RULE(power_dbl_star, nc, and_ident(2), tok(OP_DBL_STAR), rule(factor))

// atom: '(' [yield_expr|testlist_comp] ')' | '[' [testlist_comp] ']' | '{' [dictorsetmaker] '}' | NAME | NUMBER | STRING+ | '...' | 'None' | 'True' | 'False'
// testlist_comp: (test|star_expr) ( comp_for | (',' (test|star_expr))* [','] )
// trailer: '(' [arglist] ')' | '[' subscriptlist ']' | '.' NAME

DEF_RULE(atom, nc, or(11), tok(NAME), tok(INTEGER), tok(FLOAT_OR_IMAG), rule(atom_string), tok(ELLIPSIS), tok(KW_NONE), tok(KW_TRUE), tok(KW_FALSE), rule(atom_paren), rule(atom_bracket), rule(atom_brace))
DEF_RULE(atom_string, c(atom_string), one_or_more, rule(string_or_bytes))
DEF_RULE(string_or_bytes, nc, or(2), tok(STRING), tok(BYTES))
DEF_RULE(atom_paren, c(atom_paren), and(3), tok(DEL_PAREN_OPEN), opt_rule(atom_2b), tok(DEL_PAREN_CLOSE))
DEF_RULE(atom_2b, nc, or(2), rule(yield_expr), rule(testlist_comp))
DEF_RULE(atom_bracket, c(atom_bracket), and(3), tok(DEL_BRACKET_OPEN), opt_rule(testlist_comp), tok(DEL_BRACKET_CLOSE))
DEF_RULE(atom_brace, c(atom_brace), and(3), tok(DEL_BRACE_OPEN), opt_rule(dictorsetmaker), tok(DEL_BRACE_CLOSE))
DEF_RULE(testlist_comp, nc, and_ident(2), rule(testlist_comp_2), opt_rule(testlist_comp_3))
DEF_RULE(testlist_comp_2, nc, or(2), rule(star_expr), rule(test))
DEF_RULE(testlist_comp_3, nc, or(2), rule(comp_for), rule(testlist_comp_3b))
DEF_RULE(testlist_comp_3b, nc, and_ident(2), tok(DEL_COMMA), opt_rule(testlist_comp_3c))
DEF_RULE(testlist_comp_3c, nc, list_with_end, rule(testlist_comp_2), tok(DEL_COMMA))
DEF_RULE(trailer, nc, or(3), rule(trailer_paren), rule(trailer_bracket), rule(trailer_period))
DEF_RULE(trailer_paren, c(trailer_paren), and(3), tok(DEL_PAREN_OPEN), opt_rule(arglist), tok(DEL_PAREN_CLOSE))
DEF_RULE(trailer_bracket, c(trailer_bracket), and(3), tok(DEL_BRACKET_OPEN), rule(subscriptlist), tok(DEL_BRACKET_CLOSE))
DEF_RULE(trailer_period, c(trailer_period), and(2), tok(DEL_PERIOD), tok(NAME))

// subscriptlist: subscript (',' subscript)* [',']
// subscript: test | [test] ':' [test] [sliceop]
// sliceop: ':' [test]

#if MICROPY_PY_BUILTINS_SLICE
DEF_RULE(subscriptlist, c(generic_tuple), list_with_end, rule(subscript), tok(DEL_COMMA))
DEF_RULE(subscript, nc, or(2), rule(subscript_3), rule(subscript_2))
DEF_RULE(subscript_2, c(subscript_2), and_ident(2), rule(test), opt_rule(subscript_3))
DEF_RULE(subscript_3, c(subscript_3), and(2), tok(DEL_COLON), opt_rule(subscript_3b))
DEF_RULE(subscript_3b, nc, or(2), rule(subscript_3c), rule(subscript_3d))
DEF_RULE(subscript_3c, nc, and(2), tok(DEL_COLON), opt_rule(test))
DEF_RULE(subscript_3d, nc, and_ident(2), rule(test), opt_rule(sliceop))
DEF_RULE(sliceop, nc, and(2), tok(DEL_COLON), opt_rule(test))
#else
DEF_RULE(subscriptlist, c(generic_tuple), list_with_end, rule(test), tok(DEL_COMMA))
#endif

// exprlist: (expr|star_expr) (',' (expr|star_expr))* [',']
// testlist: test (',' test)* [',']
// dictorsetmaker: (test ':' test (comp_for | (',' test ':' test)* [','])) | (test (comp_for | (',' test)* [',']))

DEF_RULE(exprlist, nc, list_with_end, rule(exprlist_2), tok(DEL_COMMA))
DEF_RULE(exprlist_2, nc, or(2), rule(star_expr), rule(expr))
DEF_RULE(testlist, c(generic_tuple), list_with_end, rule(test), tok(DEL_COMMA))
// TODO dictorsetmaker lets through more than is allowed
DEF_RULE(dictorsetmaker, nc, and_ident(2), rule(dictorsetmaker_item), opt_rule(dictorsetmaker_tail))
#if MICROPY_PY_BUILTINS_SET
DEF_RULE(dictorsetmaker_item, c(dictorsetmaker_item), and_ident(2), rule(test), opt_rule(dictorsetmaker_colon))
DEF_RULE(dictorsetmaker_colon, nc, and_ident(2), tok(DEL_COLON), rule(test))
#else
DEF_RULE(dictorsetmaker_item, c(dictorsetmaker_item), and(3), rule(test), tok(DEL_COLON), rule(test))
#endif
DEF_RULE(dictorsetmaker_tail, nc, or(2), rule(comp_for), rule(dictorsetmaker_list))
DEF_RULE(dictorsetmaker_list, nc, and(2), tok(DEL_COMMA), opt_rule(dictorsetmaker_list2))
DEF_RULE(dictorsetmaker_list2, nc, list_with_end, rule(dictorsetmaker_item), tok(DEL_COMMA))

// classdef: 'class' NAME ['(' [arglist] ')'] ':' suite

DEF_RULE(classdef, c(classdef), and_blank(5), tok(KW_CLASS), tok(NAME), opt_rule(classdef_2), tok(DEL_COLON), rule(suite))
DEF_RULE(classdef_2, nc, and_ident(3), tok(DEL_PAREN_OPEN), opt_rule(arglist), tok(DEL_PAREN_CLOSE))

// arglist: (argument ',')* (argument [','] | '*' test (',' argument)* [',' '**' test] | '**' test)

// TODO arglist lets through more than is allowed, compiler needs to do further verification
DEF_RULE(arglist, nc, list_with_end, rule(arglist_2), tok(DEL_COMMA))
DEF_RULE(arglist_2, nc, or(3), rule(arglist_star), rule(arglist_dbl_star), rule(argument))
DEF_RULE(arglist_star, nc, and(2), tok(OP_STAR), rule(test))
DEF_RULE(arglist_dbl_star, nc, and(2), tok(OP_DBL_STAR), rule(test))

// # The reason that keywords are test nodes instead of NAME is that using NAME
// # results in an ambiguity. ast.c makes sure it's a NAME.
// argument: test [comp_for] | test '=' test  # Really [keyword '='] test
// comp_iter: comp_for | comp_if
// comp_for: 'for' exprlist 'in' or_test [comp_iter]
// comp_if: 'if' test_nocond [comp_iter]

DEF_RULE(argument, nc, and_ident(2), rule(test), opt_rule(argument_2))
DEF_RULE(argument_2, nc, or(2), rule(comp_for), rule(argument_3))
DEF_RULE(argument_3, nc, and_ident(2), tok(DEL_EQUAL), rule(test))
DEF_RULE(comp_iter, nc, or(2), rule(comp_for), rule(comp_if))
DEF_RULE(comp_for, nc, and_blank(5), tok(KW_FOR), rule(exprlist), tok(KW_IN), rule(or_test), opt_rule(comp_iter))
DEF_RULE(comp_if, nc, and(3), tok(KW_IF), rule(test_nocond), opt_rule(comp_iter))

// # not used in grammar, but may appear in "node" passed from Parser to Compiler
// encoding_decl: NAME

// yield_expr: 'yield' [yield_arg]
// yield_arg: 'from' test | testlist

DEF_RULE(yield_expr, c(yield_expr), and(2), tok(KW_YIELD), opt_rule(yield_arg))
DEF_RULE(yield_arg, nc, or(2), rule(yield_arg_from), rule(testlist))
DEF_RULE(yield_arg_from, nc, and(2), tok(KW_FROM), rule(test))
#undef DEF_RULE
    RULE_maximum_number_of,
    RULE_string, // special node for non-interned string
    RULE_bytes, // special node for non-interned bytes
    RULE_const_object, // special node for a constant, generic Python object
};

#define or(n)                   (RULE_ACT_OR | n)
#define and(n)                  (RULE_ACT_AND | n)
#define and_ident(n)            (RULE_ACT_AND | n | RULE_ACT_ALLOW_IDENT)
#define and_blank(n)            (RULE_ACT_AND | n | RULE_ACT_ADD_BLANK)
#define one_or_more             (RULE_ACT_LIST | 2)
#define list                    (RULE_ACT_LIST | 1)
#define list_with_end           (RULE_ACT_LIST | 3)
#define tok(t)                  (RULE_ARG_TOK | MP_TOKEN_##t)
#define rule(r)                 (RULE_ARG_RULE | RULE_##r)
#define opt_rule(r)             (RULE_ARG_OPT_RULE | RULE_##r)
#ifdef USE_RULE_NAME
#define DEF_RULE(rule, comp, kind, ...) static const rule_t rule_##rule = { RULE_##rule, kind, #rule, { __VA_ARGS__ } };
#else
#define DEF_RULE(rule, comp, kind, ...) static const rule_t rule_##rule = { RULE_##rule, kind, { __VA_ARGS__ } };
#endif
/*
 * This file is part of the Micro Python project, http://micropython.org/
 *
 * The MIT License (MIT)
 *
 * Copyright (c) 2013-2015 Damien P. George
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

// rules for writing rules:
// - zero_or_more is implemented using opt_rule around a one_or_more rule
// - don't put opt_rule in arguments of or rule; instead, wrap the call to this or rule in opt_rule

// # Start symbols for the grammar:
// #       single_input is a single interactive statement;
// #       file_input is a module or sequence of commands read from an input file;
// #       eval_input is the input for the eval() functions.
// # NB: compound_stmt in single_input is followed by extra NEWLINE! --> not in Micro Python
// single_input: NEWLINE | simple_stmt | compound_stmt
// file_input: (NEWLINE | stmt)* ENDMARKER
// eval_input: testlist NEWLINE* ENDMARKER

DEF_RULE(single_input, nc, or(3), tok(NEWLINE), rule(simple_stmt), rule(compound_stmt))
DEF_RULE(file_input, c(generic_all_nodes), and_ident(1), opt_rule(file_input_2))
DEF_RULE(file_input_2, c(generic_all_nodes), one_or_more, rule(file_input_3))
DEF_RULE(file_input_3, nc, or(2), tok(NEWLINE), rule(stmt))
DEF_RULE(eval_input, nc, and_ident(2), rule(testlist), opt_rule(eval_input_2))
DEF_RULE(eval_input_2, nc, and(1), tok(NEWLINE))

// decorator: '@' dotted_name [ '(' [arglist] ')' ] NEWLINE
// decorators: decorator+
// decorated: decorators (classdef | funcdef | async_funcdef)
// funcdef: 'def' NAME parameters ['->' test] ':' suite
// async_funcdef: 'async' funcdef
// parameters: '(' [typedargslist] ')'
// typedargslist: tfpdef ['=' test] (',' tfpdef ['=' test])* [',' ['*' [tfpdef] (',' tfpdef ['=' test])* [',' '**' tfpdef] | '**' tfpdef]] | '*' [tfpdef] (',' tfpdef ['=' test])* [',' '**' tfpdef] | '**' tfpdef
// tfpdef: NAME [':' test]
// varargslist: vfpdef ['=' test] (',' vfpdef ['=' test])* [',' ['*' [vfpdef] (',' vfpdef ['=' test])* [',' '**' vfpdef] | '**' vfpdef]] |  '*' [vfpdef] (',' vfpdef ['=' test])* [',' '**' vfpdef] | '**' vfpdef
// vfpdef: NAME

DEF_RULE(decorator, nc, and(4), tok(DEL_AT), rule(dotted_name), opt_rule(trailer_paren), tok(NEWLINE))
DEF_RULE(decorators, nc, one_or_more, rule(decorator))
DEF_RULE(decorated, c(decorated), and_ident(2), rule(decorators), rule(decorated_body))
#if MICROPY_PY_ASYNC_AWAIT
DEF_RULE(decorated_body, nc, or(3), rule(classdef), rule(funcdef), rule(async_funcdef))
DEF_RULE(async_funcdef, nc, and(2), tok(KW_ASYNC), rule(funcdef))
#else
DEF_RULE(decorated_body, nc, or(2), rule(classdef), rule(funcdef))
#endif
DEF_RULE(funcdef, c(funcdef), and_blank(8), tok(KW_DEF), tok(NAME), tok(DEL_PAREN_OPEN), opt_rule(typedargslist), tok(DEL_PAREN_CLOSE), opt_rule(funcdefrettype), tok(DEL_COLON), rule(suite))
DEF_RULE(funcdefrettype, nc, and_ident(2), tok(DEL_MINUS_MORE), rule(test))
// note: typedargslist lets through more than is allowed, compiler does further checks
DEF_RULE(typedargslist, nc, list_with_end, rule(typedargslist_item), tok(DEL_COMMA))
DEF_RULE(typedargslist_item, nc, or(3), rule(typedargslist_name), rule(typedargslist_star), rule(typedargslist_dbl_star))
DEF_RULE(typedargslist_name, nc, and_ident(3), tok(NAME), opt_rule(typedargslist_colon), opt_rule(typedargslist_equal))
DEF_RULE(typedargslist_star, nc, and(2), tok(OP_STAR), opt_rule(tfpdef))
DEF_RULE(typedargslist_dbl_star, nc, and(3), tok(OP_DBL_STAR), tok(NAME), opt_rule(typedargslist_colon))
DEF_RULE(typedargslist_colon, nc, and_ident(2), tok(DEL_COLON), rule(test))
DEF_RULE(typedargslist_equal, nc, and_ident(2), tok(DEL_EQUAL), rule(test))
DEF_RULE(tfpdef, nc, and(2), tok(NAME), opt_rule(typedargslist_colon))
// note: varargslist lets through more than is allowed, compiler does further checks
DEF_RULE(varargslist, nc, list_with_end, rule(varargslist_item), tok(DEL_COMMA))
DEF_RULE(varargslist_item, nc, or(3), rule(varargslist_name), rule(varargslist_star), rule(varargslist_dbl_star))
DEF_RULE(varargslist_name, nc, and_ident(2), tok(NAME), opt_rule(varargslist_equal))
DEF_RULE(varargslist_star, nc, and(2), tok(OP_STAR), opt_rule(vfpdef))
DEF_RULE(varargslist_dbl_star, nc, and(2), tok(OP_DBL_STAR), tok(NAME))
DEF_RULE(varargslist_equal, nc, and_ident(2), tok(DEL_EQUAL), rule(test))
DEF_RULE(vfpdef, nc, and_ident(1), tok(NAME))

// stmt: compound_stmt | simple_stmt

DEF_RULE(stmt, nc, or(2), rule(compound_stmt), rule(simple_stmt))

// simple_stmt: small_stmt (';' small_stmt)* [';'] NEWLINE

DEF_RULE(simple_stmt, nc, and_ident(2), rule(simple_stmt_2), tok(NEWLINE))
DEF_RULE(simple_stmt_2, c(generic_all_nodes), list_with_end, rule(small_stmt), tok(DEL_SEMICOLON))

// small_stmt: expr_stmt | del_stmt | pass_stmt | flow_stmt | import_stmt | global_stmt | nonlocal_stmt | assert_stmt
// expr_stmt: testlist_star_expr (augassign (yield_expr|testlist) | ('=' (yield_expr|testlist_star_expr))*)
// testlist_star_expr: (test|star_expr) (',' (test|star_expr))* [',']
// augassign: '+=' | '-=' | '*=' | '/=' | '%=' | '&=' | '|=' | '^=' | '<<=' | '>>=' | '**=' | '//='
// # For normal assignments, additional restrictions enforced by the interpreter

DEF_RULE(small_stmt, nc, or(8), rule(del_stmt), rule(pass_stmt), rule(flow_stmt), rule(import_stmt), rule(global_stmt), rule(nonlocal_stmt), rule(assert_stmt), rule(expr_stmt))
DEF_RULE(expr_stmt, c(expr_stmt), and(2), rule(testlist_star_expr), opt_rule(expr_stmt_2))
DEF_RULE(expr_stmt_2, nc, or(2), rule(expr_stmt_augassign), rule(expr_stmt_assign_list))
DEF_RULE(expr_stmt_augassign, nc, and_ident(2), rule(augassign), rule(expr_stmt_6))
DEF_RULE(expr_stmt_assign_list, nc, one_or_more, rule(expr_stmt_assign))
DEF_RULE(expr_stmt_assign, nc, and_ident(2), tok(DEL_EQUAL), rule(expr_stmt_6))
DEF_RULE(expr_stmt_6, nc, or(2), rule(yield_expr), rule(testlist_star_expr))
DEF_RULE(testlist_star_expr, c(generic_tuple), list_with_end, rule(testlist_star_expr_2), tok(DEL_COMMA))
DEF_RULE(testlist_star_expr_2, nc, or(2), rule(star_expr), rule(test))
DEF_RULE(augassign, nc, or(12), tok(DEL_PLUS_EQUAL), tok(DEL_MINUS_EQUAL), tok(DEL_STAR_EQUAL), tok(DEL_SLASH_EQUAL), tok(DEL_PERCENT_EQUAL), tok(DEL_AMPERSAND_EQUAL), tok(DEL_PIPE_EQUAL), tok(DEL_CARET_EQUAL), tok(DEL_DBL_LESS_EQUAL), tok(DEL_DBL_MORE_EQUAL), tok(DEL_DBL_STAR_EQUAL), tok(DEL_DBL_SLASH_EQUAL))

// del_stmt: 'del' exprlist
// pass_stmt: 'pass'
// flow_stmt: break_stmt | continue_stmt | return_stmt | raise_stmt | yield_stmt
// break_stmt: 'break'
// continue_stmt: 'continue'
// return_stmt: 'return' [testlist]
// yield_stmt: yield_expr
// raise_stmt: 'raise' [test ['from' test]]

DEF_RULE(del_stmt, c(del_stmt), and(2), tok(KW_DEL), rule(exprlist))
DEF_RULE(pass_stmt, c(generic_all_nodes), and(1), tok(KW_PASS))
DEF_RULE(flow_stmt, nc, or(5), rule(break_stmt), rule(continue_stmt), rule(return_stmt), rule(raise_stmt), rule(yield_stmt))
DEF_RULE(break_stmt, c(break_stmt), and(1), tok(KW_BREAK))
DEF_RULE(continue_stmt, c(continue_stmt), and(1), tok(KW_CONTINUE))
DEF_RULE(return_stmt, c(return_stmt), and(2), tok(KW_RETURN), opt_rule(testlist))
DEF_RULE(yield_stmt, c(yield_stmt), and(1), rule(yield_expr))
DEF_RULE(raise_stmt, c(raise_stmt), and(2), tok(KW_RAISE), opt_rule(raise_stmt_arg))
DEF_RULE(raise_stmt_arg, nc, and_ident(2), rule(test), opt_rule(raise_stmt_from))
DEF_RULE(raise_stmt_from, nc, and_ident(2), tok(KW_FROM), rule(test))

// import_stmt: import_name | import_from
// import_name: 'import' dotted_as_names
// import_from: 'from' (('.' | '...')* dotted_name | ('.' | '...')+) 'import' ('*' | '(' import_as_names ')' | import_as_names)
// import_as_name: NAME ['as' NAME]
// dotted_as_name: dotted_name ['as' NAME]
// import_as_names: import_as_name (',' import_as_name)* [',']
// dotted_as_names: dotted_as_name (',' dotted_as_name)*
// dotted_name: NAME ('.' NAME)*
// global_stmt: 'global' NAME (',' NAME)*
// nonlocal_stmt: 'nonlocal' NAME (',' NAME)*
// assert_stmt: 'assert' test [',' test]

DEF_RULE(import_stmt, nc, or(2), rule(import_name), rule(import_from))
DEF_RULE(import_name, c(import_name), and(2), tok(KW_IMPORT), rule(dotted_as_names))
DEF_RULE(import_from, c(import_from), and(4), tok(KW_FROM), rule(import_from_2), tok(KW_IMPORT), rule(import_from_3))
DEF_RULE(import_from_2, nc, or(2), rule(dotted_name), rule(import_from_2b))
DEF_RULE(import_from_2b, nc, and_ident(2), rule(one_or_more_period_or_ellipsis), opt_rule(dotted_name))
DEF_RULE(import_from_3, nc, or(3), tok(OP_STAR), rule(import_as_names_paren), rule(import_as_names))
DEF_RULE(import_as_names_paren, nc, and_ident(3), tok(DEL_PAREN_OPEN), rule(import_as_names), tok(DEL_PAREN_CLOSE))
DEF_RULE(one_or_more_period_or_ellipsis, nc, one_or_more, rule(period_or_ellipsis))
DEF_RULE(period_or_ellipsis, nc, or(2), tok(DEL_PERIOD), tok(ELLIPSIS))
DEF_RULE(import_as_name, nc, and(2), tok(NAME), opt_rule(as_name))
DEF_RULE(dotted_as_name, nc, and_ident(2), rule(dotted_name), opt_rule(as_name))
DEF_RULE(as_name, nc, and_ident(2), tok(KW_AS), tok(NAME))
DEF_RULE(import_as_names, nc, list_with_end, rule(import_as_name), tok(DEL_COMMA))
DEF_RULE(dotted_as_names, nc, list, rule(dotted_as_name), tok(DEL_COMMA))
DEF_RULE(dotted_name, nc, list, tok(NAME), tok(DEL_PERIOD))
DEF_RULE(global_stmt, c(global_stmt), and(2), tok(KW_GLOBAL), rule(name_list))
DEF_RULE(nonlocal_stmt, c(nonlocal_stmt), and(2), tok(KW_NONLOCAL), rule(name_list))
DEF_RULE(name_list, nc, list, tok(NAME), tok(DEL_COMMA))
DEF_RULE(assert_stmt, c(assert_stmt), and(3), tok(KW_ASSERT), rule(test), opt_rule(assert_stmt_extra))
DEF_RULE(assert_stmt_extra, nc, and_ident(2), tok(DEL_COMMA), rule(test))

// compound_stmt: if_stmt | while_stmt | for_stmt | try_stmt | with_stmt | funcdef | classdef | decorated | async_stmt
// if_stmt: 'if' test ':' suite ('elif' test ':' suite)* ['else' ':' suite]
// while_stmt: 'while' test ':' suite ['else' ':' suite]
// for_stmt: 'for' exprlist 'in' testlist ':' suite ['else' ':' suite]
// try_stmt: 'try' ':' suite ((except_clause ':' suite)+ ['else' ':' suite] ['finally' ':' suite] | 'finally' ':' suite)
// # NB compile.c makes sure that the default except clause is last
// except_clause: 'except' [test ['as' NAME]]
// with_stmt: 'with' with_item (',' with_item)* ':' suite
// with_item: test ['as' expr]
// suite: simple_stmt | NEWLINE INDENT stmt+ DEDENT
// async_stmt: 'async' (funcdef | with_stmt | for_stmt)

#if MICROPY_PY_ASYNC_AWAIT
DEF_RULE(compound_stmt, nc, or(9), rule(if_stmt), rule(while_stmt), rule(for_stmt), rule(try_stmt), rule(with_stmt), rule(funcdef), rule(classdef), rule(decorated), rule(async_stmt))
DEF_RULE(async_stmt, c(async_stmt), and(2), tok(KW_ASYNC), rule(async_stmt_2))
DEF_RULE(async_stmt_2, nc, or(3), rule(funcdef), rule(with_stmt), rule(for_stmt))
#else
DEF_RULE(compound_stmt, nc, or(8), rule(if_stmt), rule(while_stmt), rule(for_stmt), rule(try_stmt), rule(with_stmt), rule(funcdef), rule(classdef), rule(decorated))
#endif
DEF_RULE(if_stmt, c(if_stmt), and(6), tok(KW_IF), rule(test), tok(DEL_COLON), rule(suite), opt_rule(if_stmt_elif_list), opt_rule(else_stmt))
DEF_RULE(if_stmt_elif_list, nc, one_or_more, rule(if_stmt_elif))
DEF_RULE(if_stmt_elif, nc, and(4), tok(KW_ELIF), rule(test), tok(DEL_COLON), rule(suite))
DEF_RULE(while_stmt, c(while_stmt), and(5), tok(KW_WHILE), rule(test), tok(DEL_COLON), rule(suite), opt_rule(else_stmt))
DEF_RULE(for_stmt, c(for_stmt), and(7), tok(KW_FOR), rule(exprlist), tok(KW_IN), rule(testlist), tok(DEL_COLON), rule(suite), opt_rule(else_stmt))
DEF_RULE(try_stmt, c(try_stmt), and(4), tok(KW_TRY), tok(DEL_COLON), rule(suite), rule(try_stmt_2))
DEF_RULE(try_stmt_2, nc, or(2), rule(try_stmt_except_and_more), rule(try_stmt_finally))
DEF_RULE(try_stmt_except_and_more, nc, and_ident(3), rule(try_stmt_except_list), opt_rule(else_stmt), opt_rule(try_stmt_finally))
DEF_RULE(try_stmt_except, nc, and(4), tok(KW_EXCEPT), opt_rule(try_stmt_as_name), tok(DEL_COLON), rule(suite))
DEF_RULE(try_stmt_as_name, nc, and_ident(2), rule(test), opt_rule(as_name))
DEF_RULE(try_stmt_except_list, nc, one_or_more, rule(try_stmt_except))
DEF_RULE(try_stmt_finally, nc, and(3), tok(KW_FINALLY), tok(DEL_COLON), rule(suite))
DEF_RULE(else_stmt, nc, and_ident(3), tok(KW_ELSE), tok(DEL_COLON), rule(suite))
DEF_RULE(with_stmt, c(with_stmt), and(4), tok(KW_WITH), rule(with_stmt_list), tok(DEL_COLON), rule(suite))
DEF_RULE(with_stmt_list, nc, list, rule(with_item), tok(DEL_COMMA))
DEF_RULE(with_item, nc, and_ident(2), rule(test), opt_rule(with_item_as))
DEF_RULE(with_item_as, nc, and_ident(2), tok(KW_AS), rule(expr))
DEF_RULE(suite, nc, or(2), rule(suite_block), rule(simple_stmt))
DEF_RULE(suite_block, nc, and_ident(4), tok(NEWLINE), tok(INDENT), rule(suite_block_stmts), tok(DEDENT))
DEF_RULE(suite_block_stmts, c(generic_all_nodes), one_or_more, rule(stmt))

// test: or_test ['if' or_test 'else' test] | lambdef
// test_nocond: or_test | lambdef_nocond
// lambdef: 'lambda' [varargslist] ':' test
// lambdef_nocond: 'lambda' [varargslist] ':' test_nocond

DEF_RULE(test, nc, or(2), rule(lambdef), rule(test_if_expr))
DEF_RULE(test_if_expr, c(test_if_expr), and_ident(2), rule(or_test), opt_rule(test_if_else))
DEF_RULE(test_if_else, nc, and(4), tok(KW_IF), rule(or_test), tok(KW_ELSE), rule(test))
DEF_RULE(test_nocond, nc, or(2), rule(lambdef_nocond), rule(or_test))
DEF_RULE(lambdef, c(lambdef), and_blank(4), tok(KW_LAMBDA), opt_rule(varargslist), tok(DEL_COLON), rule(test))
DEF_RULE(lambdef_nocond, c(lambdef), and_blank(4), tok(KW_LAMBDA), opt_rule(varargslist), tok(DEL_COLON), rule(test_nocond))

// or_test: and_test ('or' and_test)*
// and_test: not_test ('and' not_test)*
// not_test: 'not' not_test | comparison
// comparison: expr (comp_op expr)*
// comp_op: '<'|'>'|'=='|'>='|'<='|'!='|'in'|'not' 'in'|'is'|'is' 'not'
// star_expr: '*' expr
// expr: xor_expr ('|' xor_expr)*
// xor_expr: and_expr ('^' and_expr)*
// and_expr: shift_expr ('&' shift_expr)*
// shift_expr: arith_expr (('<<'|'>>') arith_expr)*
// arith_expr: term (('+'|'-') term)*
// term: factor (('*'|'/'|'%'|'//') factor)*
// factor: ('+'|'-'|'~') factor | power
// power: atom_expr ['**' factor]
// atom_expr: 'await' atom trailer* | atom trailer*

DEF_RULE(or_test, c(or_test), list, rule(and_test), tok(KW_OR))
DEF_RULE(and_test, c(and_test), list, rule(not_test), tok(KW_AND))
DEF_RULE(not_test, nc, or(2), rule(not_test_2), rule(comparison))
DEF_RULE(not_test_2, c(not_test_2), and(2), tok(KW_NOT), rule(not_test))
DEF_RULE(comparison, c(comparison), list, rule(expr), rule(comp_op))
DEF_RULE(comp_op, nc, or(9), tok(OP_LESS), tok(OP_MORE), tok(OP_DBL_EQUAL), tok(OP_LESS_EQUAL), tok(OP_MORE_EQUAL), tok(OP_NOT_EQUAL), tok(KW_IN), rule(comp_op_not_in), rule(comp_op_is))
DEF_RULE(comp_op_not_in, nc, and(2), tok(KW_NOT), tok(KW_IN))
DEF_RULE(comp_op_is, nc, and(2), tok(KW_IS), opt_rule(comp_op_is_not))
DEF_RULE(comp_op_is_not, nc, and(1), tok(KW_NOT))
DEF_RULE(star_expr, c(star_expr), and(2), tok(OP_STAR), rule(expr))
DEF_RULE(expr, c(expr), list, rule(xor_expr), tok(OP_PIPE))
DEF_RULE(xor_expr, c(xor_expr), list, rule(and_expr), tok(OP_CARET))
DEF_RULE(and_expr, c(and_expr), list, rule(shift_expr), tok(OP_AMPERSAND))
DEF_RULE(shift_expr, c(shift_expr), list, rule(arith_expr), rule(shift_op))
DEF_RULE(shift_op, nc, or(2), tok(OP_DBL_LESS), tok(OP_DBL_MORE))
DEF_RULE(arith_expr, c(arith_expr), list, rule(term), rule(arith_op))
DEF_RULE(arith_op, nc, or(2), tok(OP_PLUS), tok(OP_MINUS))
DEF_RULE(term, c(term), list, rule(factor), rule(term_op))
DEF_RULE(term_op, nc, or(4), tok(OP_STAR), tok(OP_SLASH), tok(OP_PERCENT), tok(OP_DBL_SLASH))
DEF_RULE(factor, nc, or(2), rule(factor_2), rule(power))
DEF_RULE(factor_2, c(factor_2), and_ident(2), rule(factor_op), rule(factor))
DEF_RULE(factor_op, nc, or(3), tok(OP_PLUS), tok(OP_MINUS), tok(OP_TILDE))
DEF_RULE(power, c(power), and_ident(2), rule(atom_expr), opt_rule(power_dbl_star))
#if MICROPY_PY_ASYNC_AWAIT
DEF_RULE(atom_expr, nc, or(2), rule(atom_expr_await), rule(atom_expr_normal))
DEF_RULE(atom_expr_await, c(atom_expr_await), and(3), tok(KW_AWAIT), rule(atom), opt_rule(atom_expr_trailers))
#else
DEF_RULE(atom_expr, nc, or(1), rule(atom_expr_normal))
#endif
DEF_RULE(atom_expr_normal, c(atom_expr_normal), and_ident(2), rule(atom), opt_rule(atom_expr_trailers))
DEF_RULE(atom_expr_trailers, c(atom_expr_trailers), one_or_more, rule(trailer))
DEF_RULE(power_dbl_star, nc, and_ident(2), tok(OP_DBL_STAR), rule(factor))

// atom: '(' [yield_expr|testlist_comp] ')' | '[' [testlist_comp] ']' | '{' [dictorsetmaker] '}' | NAME | NUMBER | STRING+ | '...' | 'None' | 'True' | 'False'
// testlist_comp: (test|star_expr) ( comp_for | (',' (test|star_expr))* [','] )
// trailer: '(' [arglist] ')' | '[' subscriptlist ']' | '.' NAME

DEF_RULE(atom, nc, or(11), tok(NAME), tok(INTEGER), tok(FLOAT_OR_IMAG), rule(atom_string), tok(ELLIPSIS), tok(KW_NONE), tok(KW_TRUE), tok(KW_FALSE), rule(atom_paren), rule(atom_bracket), rule(atom_brace))
DEF_RULE(atom_string, c(atom_string), one_or_more, rule(string_or_bytes))
DEF_RULE(string_or_bytes, nc, or(2), tok(STRING), tok(BYTES))
DEF_RULE(atom_paren, c(atom_paren), and(3), tok(DEL_PAREN_OPEN), opt_rule(atom_2b), tok(DEL_PAREN_CLOSE))
DEF_RULE(atom_2b, nc, or(2), rule(yield_expr), rule(testlist_comp))
DEF_RULE(atom_bracket, c(atom_bracket), and(3), tok(DEL_BRACKET_OPEN), opt_rule(testlist_comp), tok(DEL_BRACKET_CLOSE))
DEF_RULE(atom_brace, c(atom_brace), and(3), tok(DEL_BRACE_OPEN), opt_rule(dictorsetmaker), tok(DEL_BRACE_CLOSE))
DEF_RULE(testlist_comp, nc, and_ident(2), rule(testlist_comp_2), opt_rule(testlist_comp_3))
DEF_RULE(testlist_comp_2, nc, or(2), rule(star_expr), rule(test))
DEF_RULE(testlist_comp_3, nc, or(2), rule(comp_for), rule(testlist_comp_3b))
DEF_RULE(testlist_comp_3b, nc, and_ident(2), tok(DEL_COMMA), opt_rule(testlist_comp_3c))
DEF_RULE(testlist_comp_3c, nc, list_with_end, rule(testlist_comp_2), tok(DEL_COMMA))
DEF_RULE(trailer, nc, or(3), rule(trailer_paren), rule(trailer_bracket), rule(trailer_period))
DEF_RULE(trailer_paren, c(trailer_paren), and(3), tok(DEL_PAREN_OPEN), opt_rule(arglist), tok(DEL_PAREN_CLOSE))
DEF_RULE(trailer_bracket, c(trailer_bracket), and(3), tok(DEL_BRACKET_OPEN), rule(subscriptlist), tok(DEL_BRACKET_CLOSE))
DEF_RULE(trailer_period, c(trailer_period), and(2), tok(DEL_PERIOD), tok(NAME))

// subscriptlist: subscript (',' subscript)* [',']
// subscript: test | [test] ':' [test] [sliceop]
// sliceop: ':' [test]

#if MICROPY_PY_BUILTINS_SLICE
DEF_RULE(subscriptlist, c(generic_tuple), list_with_end, rule(subscript), tok(DEL_COMMA))
DEF_RULE(subscript, nc, or(2), rule(subscript_3), rule(subscript_2))
DEF_RULE(subscript_2, c(subscript_2), and_ident(2), rule(test), opt_rule(subscript_3))
DEF_RULE(subscript_3, c(subscript_3), and(2), tok(DEL_COLON), opt_rule(subscript_3b))
DEF_RULE(subscript_3b, nc, or(2), rule(subscript_3c), rule(subscript_3d))
DEF_RULE(subscript_3c, nc, and(2), tok(DEL_COLON), opt_rule(test))
DEF_RULE(subscript_3d, nc, and_ident(2), rule(test), opt_rule(sliceop))
DEF_RULE(sliceop, nc, and(2), tok(DEL_COLON), opt_rule(test))
#else
DEF_RULE(subscriptlist, c(generic_tuple), list_with_end, rule(test), tok(DEL_COMMA))
#endif

// exprlist: (expr|star_expr) (',' (expr|star_expr))* [',']
// testlist: test (',' test)* [',']
// dictorsetmaker: (test ':' test (comp_for | (',' test ':' test)* [','])) | (test (comp_for | (',' test)* [',']))

DEF_RULE(exprlist, nc, list_with_end, rule(exprlist_2), tok(DEL_COMMA))
DEF_RULE(exprlist_2, nc, or(2), rule(star_expr), rule(expr))
DEF_RULE(testlist, c(generic_tuple), list_with_end, rule(test), tok(DEL_COMMA))
// TODO dictorsetmaker lets through more than is allowed
DEF_RULE(dictorsetmaker, nc, and_ident(2), rule(dictorsetmaker_item), opt_rule(dictorsetmaker_tail))
#if MICROPY_PY_BUILTINS_SET
DEF_RULE(dictorsetmaker_item, c(dictorsetmaker_item), and_ident(2), rule(test), opt_rule(dictorsetmaker_colon))
DEF_RULE(dictorsetmaker_colon, nc, and_ident(2), tok(DEL_COLON), rule(test))
#else
DEF_RULE(dictorsetmaker_item, c(dictorsetmaker_item), and(3), rule(test), tok(DEL_COLON), rule(test))
#endif
DEF_RULE(dictorsetmaker_tail, nc, or(2), rule(comp_for), rule(dictorsetmaker_list))
DEF_RULE(dictorsetmaker_list, nc, and(2), tok(DEL_COMMA), opt_rule(dictorsetmaker_list2))
DEF_RULE(dictorsetmaker_list2, nc, list_with_end, rule(dictorsetmaker_item), tok(DEL_COMMA))

// classdef: 'class' NAME ['(' [arglist] ')'] ':' suite

DEF_RULE(classdef, c(classdef), and_blank(5), tok(KW_CLASS), tok(NAME), opt_rule(classdef_2), tok(DEL_COLON), rule(suite))
DEF_RULE(classdef_2, nc, and_ident(3), tok(DEL_PAREN_OPEN), opt_rule(arglist), tok(DEL_PAREN_CLOSE))

// arglist: (argument ',')* (argument [','] | '*' test (',' argument)* [',' '**' test] | '**' test)

// TODO arglist lets through more than is allowed, compiler needs to do further verification
DEF_RULE(arglist, nc, list_with_end, rule(arglist_2), tok(DEL_COMMA))
DEF_RULE(arglist_2, nc, or(3), rule(arglist_star), rule(arglist_dbl_star), rule(argument))
DEF_RULE(arglist_star, nc, and(2), tok(OP_STAR), rule(test))
DEF_RULE(arglist_dbl_star, nc, and(2), tok(OP_DBL_STAR), rule(test))

// # The reason that keywords are test nodes instead of NAME is that using NAME
// # results in an ambiguity. ast.c makes sure it's a NAME.
// argument: test [comp_for] | test '=' test  # Really [keyword '='] test
// comp_iter: comp_for | comp_if
// comp_for: 'for' exprlist 'in' or_test [comp_iter]
// comp_if: 'if' test_nocond [comp_iter]

DEF_RULE(argument, nc, and_ident(2), rule(test), opt_rule(argument_2))
DEF_RULE(argument_2, nc, or(2), rule(comp_for), rule(argument_3))
DEF_RULE(argument_3, nc, and_ident(2), tok(DEL_EQUAL), rule(test))
DEF_RULE(comp_iter, nc, or(2), rule(comp_for), rule(comp_if))
DEF_RULE(comp_for, nc, and_blank(5), tok(KW_FOR), rule(exprlist), tok(KW_IN), rule(or_test), opt_rule(comp_iter))
DEF_RULE(comp_if, nc, and(3), tok(KW_IF), rule(test_nocond), opt_rule(comp_iter))

// # not used in grammar, but may appear in "node" passed from Parser to Compiler
// encoding_decl: NAME

// yield_expr: 'yield' [yield_arg]
// yield_arg: 'from' test | testlist

DEF_RULE(yield_expr, c(yield_expr), and(2), tok(KW_YIELD), opt_rule(yield_arg))
DEF_RULE(yield_arg, nc, or(2), rule(yield_arg_from), rule(testlist))
DEF_RULE(yield_arg_from, nc, and(2), tok(KW_FROM), rule(test))
#undef or
#undef and
#undef list
#undef list_with_end
#undef tok
#undef rule
#undef opt_rule
#undef one_or_more
#undef DEF_RULE

STATIC const rule_t *const rules[] = {
#define DEF_RULE(rule, comp, kind, ...) &rule_##rule,
/*
 * This file is part of the Micro Python project, http://micropython.org/
 *
 * The MIT License (MIT)
 *
 * Copyright (c) 2013-2015 Damien P. George
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

// rules for writing rules:
// - zero_or_more is implemented using opt_rule around a one_or_more rule
// - don't put opt_rule in arguments of or rule; instead, wrap the call to this or rule in opt_rule

// # Start symbols for the grammar:
// #       single_input is a single interactive statement;
// #       file_input is a module or sequence of commands read from an input file;
// #       eval_input is the input for the eval() functions.
// # NB: compound_stmt in single_input is followed by extra NEWLINE! --> not in Micro Python
// single_input: NEWLINE | simple_stmt | compound_stmt
// file_input: (NEWLINE | stmt)* ENDMARKER
// eval_input: testlist NEWLINE* ENDMARKER

DEF_RULE(single_input, nc, or(3), tok(NEWLINE), rule(simple_stmt), rule(compound_stmt))
DEF_RULE(file_input, c(generic_all_nodes), and_ident(1), opt_rule(file_input_2))
DEF_RULE(file_input_2, c(generic_all_nodes), one_or_more, rule(file_input_3))
DEF_RULE(file_input_3, nc, or(2), tok(NEWLINE), rule(stmt))
DEF_RULE(eval_input, nc, and_ident(2), rule(testlist), opt_rule(eval_input_2))
DEF_RULE(eval_input_2, nc, and(1), tok(NEWLINE))

// decorator: '@' dotted_name [ '(' [arglist] ')' ] NEWLINE
// decorators: decorator+
// decorated: decorators (classdef | funcdef | async_funcdef)
// funcdef: 'def' NAME parameters ['->' test] ':' suite
// async_funcdef: 'async' funcdef
// parameters: '(' [typedargslist] ')'
// typedargslist: tfpdef ['=' test] (',' tfpdef ['=' test])* [',' ['*' [tfpdef] (',' tfpdef ['=' test])* [',' '**' tfpdef] | '**' tfpdef]] | '*' [tfpdef] (',' tfpdef ['=' test])* [',' '**' tfpdef] | '**' tfpdef
// tfpdef: NAME [':' test]
// varargslist: vfpdef ['=' test] (',' vfpdef ['=' test])* [',' ['*' [vfpdef] (',' vfpdef ['=' test])* [',' '**' vfpdef] | '**' vfpdef]] |  '*' [vfpdef] (',' vfpdef ['=' test])* [',' '**' vfpdef] | '**' vfpdef
// vfpdef: NAME

DEF_RULE(decorator, nc, and(4), tok(DEL_AT), rule(dotted_name), opt_rule(trailer_paren), tok(NEWLINE))
DEF_RULE(decorators, nc, one_or_more, rule(decorator))
DEF_RULE(decorated, c(decorated), and_ident(2), rule(decorators), rule(decorated_body))
#if MICROPY_PY_ASYNC_AWAIT
DEF_RULE(decorated_body, nc, or(3), rule(classdef), rule(funcdef), rule(async_funcdef))
DEF_RULE(async_funcdef, nc, and(2), tok(KW_ASYNC), rule(funcdef))
#else
DEF_RULE(decorated_body, nc, or(2), rule(classdef), rule(funcdef))
#endif
DEF_RULE(funcdef, c(funcdef), and_blank(8), tok(KW_DEF), tok(NAME), tok(DEL_PAREN_OPEN), opt_rule(typedargslist), tok(DEL_PAREN_CLOSE), opt_rule(funcdefrettype), tok(DEL_COLON), rule(suite))
DEF_RULE(funcdefrettype, nc, and_ident(2), tok(DEL_MINUS_MORE), rule(test))
// note: typedargslist lets through more than is allowed, compiler does further checks
DEF_RULE(typedargslist, nc, list_with_end, rule(typedargslist_item), tok(DEL_COMMA))
DEF_RULE(typedargslist_item, nc, or(3), rule(typedargslist_name), rule(typedargslist_star), rule(typedargslist_dbl_star))
DEF_RULE(typedargslist_name, nc, and_ident(3), tok(NAME), opt_rule(typedargslist_colon), opt_rule(typedargslist_equal))
DEF_RULE(typedargslist_star, nc, and(2), tok(OP_STAR), opt_rule(tfpdef))
DEF_RULE(typedargslist_dbl_star, nc, and(3), tok(OP_DBL_STAR), tok(NAME), opt_rule(typedargslist_colon))
DEF_RULE(typedargslist_colon, nc, and_ident(2), tok(DEL_COLON), rule(test))
DEF_RULE(typedargslist_equal, nc, and_ident(2), tok(DEL_EQUAL), rule(test))
DEF_RULE(tfpdef, nc, and(2), tok(NAME), opt_rule(typedargslist_colon))
// note: varargslist lets through more than is allowed, compiler does further checks
DEF_RULE(varargslist, nc, list_with_end, rule(varargslist_item), tok(DEL_COMMA))
DEF_RULE(varargslist_item, nc, or(3), rule(varargslist_name), rule(varargslist_star), rule(varargslist_dbl_star))
DEF_RULE(varargslist_name, nc, and_ident(2), tok(NAME), opt_rule(varargslist_equal))
DEF_RULE(varargslist_star, nc, and(2), tok(OP_STAR), opt_rule(vfpdef))
DEF_RULE(varargslist_dbl_star, nc, and(2), tok(OP_DBL_STAR), tok(NAME))
DEF_RULE(varargslist_equal, nc, and_ident(2), tok(DEL_EQUAL), rule(test))
DEF_RULE(vfpdef, nc, and_ident(1), tok(NAME))

// stmt: compound_stmt | simple_stmt

DEF_RULE(stmt, nc, or(2), rule(compound_stmt), rule(simple_stmt))

// simple_stmt: small_stmt (';' small_stmt)* [';'] NEWLINE

DEF_RULE(simple_stmt, nc, and_ident(2), rule(simple_stmt_2), tok(NEWLINE))
DEF_RULE(simple_stmt_2, c(generic_all_nodes), list_with_end, rule(small_stmt), tok(DEL_SEMICOLON))

// small_stmt: expr_stmt | del_stmt | pass_stmt | flow_stmt | import_stmt | global_stmt | nonlocal_stmt | assert_stmt
// expr_stmt: testlist_star_expr (augassign (yield_expr|testlist) | ('=' (yield_expr|testlist_star_expr))*)
// testlist_star_expr: (test|star_expr) (',' (test|star_expr))* [',']
// augassign: '+=' | '-=' | '*=' | '/=' | '%=' | '&=' | '|=' | '^=' | '<<=' | '>>=' | '**=' | '//='
// # For normal assignments, additional restrictions enforced by the interpreter

DEF_RULE(small_stmt, nc, or(8), rule(del_stmt), rule(pass_stmt), rule(flow_stmt), rule(import_stmt), rule(global_stmt), rule(nonlocal_stmt), rule(assert_stmt), rule(expr_stmt))
DEF_RULE(expr_stmt, c(expr_stmt), and(2), rule(testlist_star_expr), opt_rule(expr_stmt_2))
DEF_RULE(expr_stmt_2, nc, or(2), rule(expr_stmt_augassign), rule(expr_stmt_assign_list))
DEF_RULE(expr_stmt_augassign, nc, and_ident(2), rule(augassign), rule(expr_stmt_6))
DEF_RULE(expr_stmt_assign_list, nc, one_or_more, rule(expr_stmt_assign))
DEF_RULE(expr_stmt_assign, nc, and_ident(2), tok(DEL_EQUAL), rule(expr_stmt_6))
DEF_RULE(expr_stmt_6, nc, or(2), rule(yield_expr), rule(testlist_star_expr))
DEF_RULE(testlist_star_expr, c(generic_tuple), list_with_end, rule(testlist_star_expr_2), tok(DEL_COMMA))
DEF_RULE(testlist_star_expr_2, nc, or(2), rule(star_expr), rule(test))
DEF_RULE(augassign, nc, or(12), tok(DEL_PLUS_EQUAL), tok(DEL_MINUS_EQUAL), tok(DEL_STAR_EQUAL), tok(DEL_SLASH_EQUAL), tok(DEL_PERCENT_EQUAL), tok(DEL_AMPERSAND_EQUAL), tok(DEL_PIPE_EQUAL), tok(DEL_CARET_EQUAL), tok(DEL_DBL_LESS_EQUAL), tok(DEL_DBL_MORE_EQUAL), tok(DEL_DBL_STAR_EQUAL), tok(DEL_DBL_SLASH_EQUAL))

// del_stmt: 'del' exprlist
// pass_stmt: 'pass'
// flow_stmt: break_stmt | continue_stmt | return_stmt | raise_stmt | yield_stmt
// break_stmt: 'break'
// continue_stmt: 'continue'
// return_stmt: 'return' [testlist]
// yield_stmt: yield_expr
// raise_stmt: 'raise' [test ['from' test]]

DEF_RULE(del_stmt, c(del_stmt), and(2), tok(KW_DEL), rule(exprlist))
DEF_RULE(pass_stmt, c(generic_all_nodes), and(1), tok(KW_PASS))
DEF_RULE(flow_stmt, nc, or(5), rule(break_stmt), rule(continue_stmt), rule(return_stmt), rule(raise_stmt), rule(yield_stmt))
DEF_RULE(break_stmt, c(break_stmt), and(1), tok(KW_BREAK))
DEF_RULE(continue_stmt, c(continue_stmt), and(1), tok(KW_CONTINUE))
DEF_RULE(return_stmt, c(return_stmt), and(2), tok(KW_RETURN), opt_rule(testlist))
DEF_RULE(yield_stmt, c(yield_stmt), and(1), rule(yield_expr))
DEF_RULE(raise_stmt, c(raise_stmt), and(2), tok(KW_RAISE), opt_rule(raise_stmt_arg))
DEF_RULE(raise_stmt_arg, nc, and_ident(2), rule(test), opt_rule(raise_stmt_from))
DEF_RULE(raise_stmt_from, nc, and_ident(2), tok(KW_FROM), rule(test))

// import_stmt: import_name | import_from
// import_name: 'import' dotted_as_names
// import_from: 'from' (('.' | '...')* dotted_name | ('.' | '...')+) 'import' ('*' | '(' import_as_names ')' | import_as_names)
// import_as_name: NAME ['as' NAME]
// dotted_as_name: dotted_name ['as' NAME]
// import_as_names: import_as_name (',' import_as_name)* [',']
// dotted_as_names: dotted_as_name (',' dotted_as_name)*
// dotted_name: NAME ('.' NAME)*
// global_stmt: 'global' NAME (',' NAME)*
// nonlocal_stmt: 'nonlocal' NAME (',' NAME)*
// assert_stmt: 'assert' test [',' test]

DEF_RULE(import_stmt, nc, or(2), rule(import_name), rule(import_from))
DEF_RULE(import_name, c(import_name), and(2), tok(KW_IMPORT), rule(dotted_as_names))
DEF_RULE(import_from, c(import_from), and(4), tok(KW_FROM), rule(import_from_2), tok(KW_IMPORT), rule(import_from_3))
DEF_RULE(import_from_2, nc, or(2), rule(dotted_name), rule(import_from_2b))
DEF_RULE(import_from_2b, nc, and_ident(2), rule(one_or_more_period_or_ellipsis), opt_rule(dotted_name))
DEF_RULE(import_from_3, nc, or(3), tok(OP_STAR), rule(import_as_names_paren), rule(import_as_names))
DEF_RULE(import_as_names_paren, nc, and_ident(3), tok(DEL_PAREN_OPEN), rule(import_as_names), tok(DEL_PAREN_CLOSE))
DEF_RULE(one_or_more_period_or_ellipsis, nc, one_or_more, rule(period_or_ellipsis))
DEF_RULE(period_or_ellipsis, nc, or(2), tok(DEL_PERIOD), tok(ELLIPSIS))
DEF_RULE(import_as_name, nc, and(2), tok(NAME), opt_rule(as_name))
DEF_RULE(dotted_as_name, nc, and_ident(2), rule(dotted_name), opt_rule(as_name))
DEF_RULE(as_name, nc, and_ident(2), tok(KW_AS), tok(NAME))
DEF_RULE(import_as_names, nc, list_with_end, rule(import_as_name), tok(DEL_COMMA))
DEF_RULE(dotted_as_names, nc, list, rule(dotted_as_name), tok(DEL_COMMA))
DEF_RULE(dotted_name, nc, list, tok(NAME), tok(DEL_PERIOD))
DEF_RULE(global_stmt, c(global_stmt), and(2), tok(KW_GLOBAL), rule(name_list))
DEF_RULE(nonlocal_stmt, c(nonlocal_stmt), and(2), tok(KW_NONLOCAL), rule(name_list))
DEF_RULE(name_list, nc, list, tok(NAME), tok(DEL_COMMA))
DEF_RULE(assert_stmt, c(assert_stmt), and(3), tok(KW_ASSERT), rule(test), opt_rule(assert_stmt_extra))
DEF_RULE(assert_stmt_extra, nc, and_ident(2), tok(DEL_COMMA), rule(test))

// compound_stmt: if_stmt | while_stmt | for_stmt | try_stmt | with_stmt | funcdef | classdef | decorated | async_stmt
// if_stmt: 'if' test ':' suite ('elif' test ':' suite)* ['else' ':' suite]
// while_stmt: 'while' test ':' suite ['else' ':' suite]
// for_stmt: 'for' exprlist 'in' testlist ':' suite ['else' ':' suite]
// try_stmt: 'try' ':' suite ((except_clause ':' suite)+ ['else' ':' suite] ['finally' ':' suite] | 'finally' ':' suite)
// # NB compile.c makes sure that the default except clause is last
// except_clause: 'except' [test ['as' NAME]]
// with_stmt: 'with' with_item (',' with_item)* ':' suite
// with_item: test ['as' expr]
// suite: simple_stmt | NEWLINE INDENT stmt+ DEDENT
// async_stmt: 'async' (funcdef | with_stmt | for_stmt)

#if MICROPY_PY_ASYNC_AWAIT
DEF_RULE(compound_stmt, nc, or(9), rule(if_stmt), rule(while_stmt), rule(for_stmt), rule(try_stmt), rule(with_stmt), rule(funcdef), rule(classdef), rule(decorated), rule(async_stmt))
DEF_RULE(async_stmt, c(async_stmt), and(2), tok(KW_ASYNC), rule(async_stmt_2))
DEF_RULE(async_stmt_2, nc, or(3), rule(funcdef), rule(with_stmt), rule(for_stmt))
#else
DEF_RULE(compound_stmt, nc, or(8), rule(if_stmt), rule(while_stmt), rule(for_stmt), rule(try_stmt), rule(with_stmt), rule(funcdef), rule(classdef), rule(decorated))
#endif
DEF_RULE(if_stmt, c(if_stmt), and(6), tok(KW_IF), rule(test), tok(DEL_COLON), rule(suite), opt_rule(if_stmt_elif_list), opt_rule(else_stmt))
DEF_RULE(if_stmt_elif_list, nc, one_or_more, rule(if_stmt_elif))
DEF_RULE(if_stmt_elif, nc, and(4), tok(KW_ELIF), rule(test), tok(DEL_COLON), rule(suite))
DEF_RULE(while_stmt, c(while_stmt), and(5), tok(KW_WHILE), rule(test), tok(DEL_COLON), rule(suite), opt_rule(else_stmt))
DEF_RULE(for_stmt, c(for_stmt), and(7), tok(KW_FOR), rule(exprlist), tok(KW_IN), rule(testlist), tok(DEL_COLON), rule(suite), opt_rule(else_stmt))
DEF_RULE(try_stmt, c(try_stmt), and(4), tok(KW_TRY), tok(DEL_COLON), rule(suite), rule(try_stmt_2))
DEF_RULE(try_stmt_2, nc, or(2), rule(try_stmt_except_and_more), rule(try_stmt_finally))
DEF_RULE(try_stmt_except_and_more, nc, and_ident(3), rule(try_stmt_except_list), opt_rule(else_stmt), opt_rule(try_stmt_finally))
DEF_RULE(try_stmt_except, nc, and(4), tok(KW_EXCEPT), opt_rule(try_stmt_as_name), tok(DEL_COLON), rule(suite))
DEF_RULE(try_stmt_as_name, nc, and_ident(2), rule(test), opt_rule(as_name))
DEF_RULE(try_stmt_except_list, nc, one_or_more, rule(try_stmt_except))
DEF_RULE(try_stmt_finally, nc, and(3), tok(KW_FINALLY), tok(DEL_COLON), rule(suite))
DEF_RULE(else_stmt, nc, and_ident(3), tok(KW_ELSE), tok(DEL_COLON), rule(suite))
DEF_RULE(with_stmt, c(with_stmt), and(4), tok(KW_WITH), rule(with_stmt_list), tok(DEL_COLON), rule(suite))
DEF_RULE(with_stmt_list, nc, list, rule(with_item), tok(DEL_COMMA))
DEF_RULE(with_item, nc, and_ident(2), rule(test), opt_rule(with_item_as))
DEF_RULE(with_item_as, nc, and_ident(2), tok(KW_AS), rule(expr))
DEF_RULE(suite, nc, or(2), rule(suite_block), rule(simple_stmt))
DEF_RULE(suite_block, nc, and_ident(4), tok(NEWLINE), tok(INDENT), rule(suite_block_stmts), tok(DEDENT))
DEF_RULE(suite_block_stmts, c(generic_all_nodes), one_or_more, rule(stmt))

// test: or_test ['if' or_test 'else' test] | lambdef
// test_nocond: or_test | lambdef_nocond
// lambdef: 'lambda' [varargslist] ':' test
// lambdef_nocond: 'lambda' [varargslist] ':' test_nocond

DEF_RULE(test, nc, or(2), rule(lambdef), rule(test_if_expr))
DEF_RULE(test_if_expr, c(test_if_expr), and_ident(2), rule(or_test), opt_rule(test_if_else))
DEF_RULE(test_if_else, nc, and(4), tok(KW_IF), rule(or_test), tok(KW_ELSE), rule(test))
DEF_RULE(test_nocond, nc, or(2), rule(lambdef_nocond), rule(or_test))
DEF_RULE(lambdef, c(lambdef), and_blank(4), tok(KW_LAMBDA), opt_rule(varargslist), tok(DEL_COLON), rule(test))
DEF_RULE(lambdef_nocond, c(lambdef), and_blank(4), tok(KW_LAMBDA), opt_rule(varargslist), tok(DEL_COLON), rule(test_nocond))

// or_test: and_test ('or' and_test)*
// and_test: not_test ('and' not_test)*
// not_test: 'not' not_test | comparison
// comparison: expr (comp_op expr)*
// comp_op: '<'|'>'|'=='|'>='|'<='|'!='|'in'|'not' 'in'|'is'|'is' 'not'
// star_expr: '*' expr
// expr: xor_expr ('|' xor_expr)*
// xor_expr: and_expr ('^' and_expr)*
// and_expr: shift_expr ('&' shift_expr)*
// shift_expr: arith_expr (('<<'|'>>') arith_expr)*
// arith_expr: term (('+'|'-') term)*
// term: factor (('*'|'/'|'%'|'//') factor)*
// factor: ('+'|'-'|'~') factor | power
// power: atom_expr ['**' factor]
// atom_expr: 'await' atom trailer* | atom trailer*

DEF_RULE(or_test, c(or_test), list, rule(and_test), tok(KW_OR))
DEF_RULE(and_test, c(and_test), list, rule(not_test), tok(KW_AND))
DEF_RULE(not_test, nc, or(2), rule(not_test_2), rule(comparison))
DEF_RULE(not_test_2, c(not_test_2), and(2), tok(KW_NOT), rule(not_test))
DEF_RULE(comparison, c(comparison), list, rule(expr), rule(comp_op))
DEF_RULE(comp_op, nc, or(9), tok(OP_LESS), tok(OP_MORE), tok(OP_DBL_EQUAL), tok(OP_LESS_EQUAL), tok(OP_MORE_EQUAL), tok(OP_NOT_EQUAL), tok(KW_IN), rule(comp_op_not_in), rule(comp_op_is))
DEF_RULE(comp_op_not_in, nc, and(2), tok(KW_NOT), tok(KW_IN))
DEF_RULE(comp_op_is, nc, and(2), tok(KW_IS), opt_rule(comp_op_is_not))
DEF_RULE(comp_op_is_not, nc, and(1), tok(KW_NOT))
DEF_RULE(star_expr, c(star_expr), and(2), tok(OP_STAR), rule(expr))
DEF_RULE(expr, c(expr), list, rule(xor_expr), tok(OP_PIPE))
DEF_RULE(xor_expr, c(xor_expr), list, rule(and_expr), tok(OP_CARET))
DEF_RULE(and_expr, c(and_expr), list, rule(shift_expr), tok(OP_AMPERSAND))
DEF_RULE(shift_expr, c(shift_expr), list, rule(arith_expr), rule(shift_op))
DEF_RULE(shift_op, nc, or(2), tok(OP_DBL_LESS), tok(OP_DBL_MORE))
DEF_RULE(arith_expr, c(arith_expr), list, rule(term), rule(arith_op))
DEF_RULE(arith_op, nc, or(2), tok(OP_PLUS), tok(OP_MINUS))
DEF_RULE(term, c(term), list, rule(factor), rule(term_op))
DEF_RULE(term_op, nc, or(4), tok(OP_STAR), tok(OP_SLASH), tok(OP_PERCENT), tok(OP_DBL_SLASH))
DEF_RULE(factor, nc, or(2), rule(factor_2), rule(power))
DEF_RULE(factor_2, c(factor_2), and_ident(2), rule(factor_op), rule(factor))
DEF_RULE(factor_op, nc, or(3), tok(OP_PLUS), tok(OP_MINUS), tok(OP_TILDE))
DEF_RULE(power, c(power), and_ident(2), rule(atom_expr), opt_rule(power_dbl_star))
#if MICROPY_PY_ASYNC_AWAIT
DEF_RULE(atom_expr, nc, or(2), rule(atom_expr_await), rule(atom_expr_normal))
DEF_RULE(atom_expr_await, c(atom_expr_await), and(3), tok(KW_AWAIT), rule(atom), opt_rule(atom_expr_trailers))
#else
DEF_RULE(atom_expr, nc, or(1), rule(atom_expr_normal))
#endif
DEF_RULE(atom_expr_normal, c(atom_expr_normal), and_ident(2), rule(atom), opt_rule(atom_expr_trailers))
DEF_RULE(atom_expr_trailers, c(atom_expr_trailers), one_or_more, rule(trailer))
DEF_RULE(power_dbl_star, nc, and_ident(2), tok(OP_DBL_STAR), rule(factor))

// atom: '(' [yield_expr|testlist_comp] ')' | '[' [testlist_comp] ']' | '{' [dictorsetmaker] '}' | NAME | NUMBER | STRING+ | '...' | 'None' | 'True' | 'False'
// testlist_comp: (test|star_expr) ( comp_for | (',' (test|star_expr))* [','] )
// trailer: '(' [arglist] ')' | '[' subscriptlist ']' | '.' NAME

DEF_RULE(atom, nc, or(11), tok(NAME), tok(INTEGER), tok(FLOAT_OR_IMAG), rule(atom_string), tok(ELLIPSIS), tok(KW_NONE), tok(KW_TRUE), tok(KW_FALSE), rule(atom_paren), rule(atom_bracket), rule(atom_brace))
DEF_RULE(atom_string, c(atom_string), one_or_more, rule(string_or_bytes))
DEF_RULE(string_or_bytes, nc, or(2), tok(STRING), tok(BYTES))
DEF_RULE(atom_paren, c(atom_paren), and(3), tok(DEL_PAREN_OPEN), opt_rule(atom_2b), tok(DEL_PAREN_CLOSE))
DEF_RULE(atom_2b, nc, or(2), rule(yield_expr), rule(testlist_comp))
DEF_RULE(atom_bracket, c(atom_bracket), and(3), tok(DEL_BRACKET_OPEN), opt_rule(testlist_comp), tok(DEL_BRACKET_CLOSE))
DEF_RULE(atom_brace, c(atom_brace), and(3), tok(DEL_BRACE_OPEN), opt_rule(dictorsetmaker), tok(DEL_BRACE_CLOSE))
DEF_RULE(testlist_comp, nc, and_ident(2), rule(testlist_comp_2), opt_rule(testlist_comp_3))
DEF_RULE(testlist_comp_2, nc, or(2), rule(star_expr), rule(test))
DEF_RULE(testlist_comp_3, nc, or(2), rule(comp_for), rule(testlist_comp_3b))
DEF_RULE(testlist_comp_3b, nc, and_ident(2), tok(DEL_COMMA), opt_rule(testlist_comp_3c))
DEF_RULE(testlist_comp_3c, nc, list_with_end, rule(testlist_comp_2), tok(DEL_COMMA))
DEF_RULE(trailer, nc, or(3), rule(trailer_paren), rule(trailer_bracket), rule(trailer_period))
DEF_RULE(trailer_paren, c(trailer_paren), and(3), tok(DEL_PAREN_OPEN), opt_rule(arglist), tok(DEL_PAREN_CLOSE))
DEF_RULE(trailer_bracket, c(trailer_bracket), and(3), tok(DEL_BRACKET_OPEN), rule(subscriptlist), tok(DEL_BRACKET_CLOSE))
DEF_RULE(trailer_period, c(trailer_period), and(2), tok(DEL_PERIOD), tok(NAME))

// subscriptlist: subscript (',' subscript)* [',']
// subscript: test | [test] ':' [test] [sliceop]
// sliceop: ':' [test]

#if MICROPY_PY_BUILTINS_SLICE
DEF_RULE(subscriptlist, c(generic_tuple), list_with_end, rule(subscript), tok(DEL_COMMA))
DEF_RULE(subscript, nc, or(2), rule(subscript_3), rule(subscript_2))
DEF_RULE(subscript_2, c(subscript_2), and_ident(2), rule(test), opt_rule(subscript_3))
DEF_RULE(subscript_3, c(subscript_3), and(2), tok(DEL_COLON), opt_rule(subscript_3b))
DEF_RULE(subscript_3b, nc, or(2), rule(subscript_3c), rule(subscript_3d))
DEF_RULE(subscript_3c, nc, and(2), tok(DEL_COLON), opt_rule(test))
DEF_RULE(subscript_3d, nc, and_ident(2), rule(test), opt_rule(sliceop))
DEF_RULE(sliceop, nc, and(2), tok(DEL_COLON), opt_rule(test))
#else
DEF_RULE(subscriptlist, c(generic_tuple), list_with_end, rule(test), tok(DEL_COMMA))
#endif

// exprlist: (expr|star_expr) (',' (expr|star_expr))* [',']
// testlist: test (',' test)* [',']
// dictorsetmaker: (test ':' test (comp_for | (',' test ':' test)* [','])) | (test (comp_for | (',' test)* [',']))

DEF_RULE(exprlist, nc, list_with_end, rule(exprlist_2), tok(DEL_COMMA))
DEF_RULE(exprlist_2, nc, or(2), rule(star_expr), rule(expr))
DEF_RULE(testlist, c(generic_tuple), list_with_end, rule(test), tok(DEL_COMMA))
// TODO dictorsetmaker lets through more than is allowed
DEF_RULE(dictorsetmaker, nc, and_ident(2), rule(dictorsetmaker_item), opt_rule(dictorsetmaker_tail))
#if MICROPY_PY_BUILTINS_SET
DEF_RULE(dictorsetmaker_item, c(dictorsetmaker_item), and_ident(2), rule(test), opt_rule(dictorsetmaker_colon))
DEF_RULE(dictorsetmaker_colon, nc, and_ident(2), tok(DEL_COLON), rule(test))
#else
DEF_RULE(dictorsetmaker_item, c(dictorsetmaker_item), and(3), rule(test), tok(DEL_COLON), rule(test))
#endif
DEF_RULE(dictorsetmaker_tail, nc, or(2), rule(comp_for), rule(dictorsetmaker_list))
DEF_RULE(dictorsetmaker_list, nc, and(2), tok(DEL_COMMA), opt_rule(dictorsetmaker_list2))
DEF_RULE(dictorsetmaker_list2, nc, list_with_end, rule(dictorsetmaker_item), tok(DEL_COMMA))

// classdef: 'class' NAME ['(' [arglist] ')'] ':' suite

DEF_RULE(classdef, c(classdef), and_blank(5), tok(KW_CLASS), tok(NAME), opt_rule(classdef_2), tok(DEL_COLON), rule(suite))
DEF_RULE(classdef_2, nc, and_ident(3), tok(DEL_PAREN_OPEN), opt_rule(arglist), tok(DEL_PAREN_CLOSE))

// arglist: (argument ',')* (argument [','] | '*' test (',' argument)* [',' '**' test] | '**' test)

// TODO arglist lets through more than is allowed, compiler needs to do further verification
DEF_RULE(arglist, nc, list_with_end, rule(arglist_2), tok(DEL_COMMA))
DEF_RULE(arglist_2, nc, or(3), rule(arglist_star), rule(arglist_dbl_star), rule(argument))
DEF_RULE(arglist_star, nc, and(2), tok(OP_STAR), rule(test))
DEF_RULE(arglist_dbl_star, nc, and(2), tok(OP_DBL_STAR), rule(test))

// # The reason that keywords are test nodes instead of NAME is that using NAME
// # results in an ambiguity. ast.c makes sure it's a NAME.
// argument: test [comp_for] | test '=' test  # Really [keyword '='] test
// comp_iter: comp_for | comp_if
// comp_for: 'for' exprlist 'in' or_test [comp_iter]
// comp_if: 'if' test_nocond [comp_iter]

DEF_RULE(argument, nc, and_ident(2), rule(test), opt_rule(argument_2))
DEF_RULE(argument_2, nc, or(2), rule(comp_for), rule(argument_3))
DEF_RULE(argument_3, nc, and_ident(2), tok(DEL_EQUAL), rule(test))
DEF_RULE(comp_iter, nc, or(2), rule(comp_for), rule(comp_if))
DEF_RULE(comp_for, nc, and_blank(5), tok(KW_FOR), rule(exprlist), tok(KW_IN), rule(or_test), opt_rule(comp_iter))
DEF_RULE(comp_if, nc, and(3), tok(KW_IF), rule(test_nocond), opt_rule(comp_iter))

// # not used in grammar, but may appear in "node" passed from Parser to Compiler
// encoding_decl: NAME

// yield_expr: 'yield' [yield_arg]
// yield_arg: 'from' test | testlist

DEF_RULE(yield_expr, c(yield_expr), and(2), tok(KW_YIELD), opt_rule(yield_arg))
DEF_RULE(yield_arg, nc, or(2), rule(yield_arg_from), rule(testlist))
DEF_RULE(yield_arg_from, nc, and(2), tok(KW_FROM), rule(test))
#undef DEF_RULE
};

typedef struct _rule_stack_t {
    size_t src_line : 8 * sizeof(size_t) - 8; // maximum bits storing source line number
    size_t rule_id : 8; // this must be large enough to fit largest rule number
    size_t arg_i; // this dictates the maximum nodes in a "list" of things
} rule_stack_t;

typedef struct _mp_parse_chunk_t {
    size_t alloc;
    union {
        size_t used;
        struct _mp_parse_chunk_t *next;
    } union_;
    byte data[];
} mp_parse_chunk_t;

typedef enum {
    PARSE_ERROR_NONE = 0,
    PARSE_ERROR_MEMORY,
    PARSE_ERROR_CONST,
} parse_error_t;

typedef struct _parser_t {
    parse_error_t parse_error;

    size_t rule_stack_alloc;
    size_t rule_stack_top;
    rule_stack_t *rule_stack;

    size_t result_stack_alloc;
    size_t result_stack_top;
    mp_parse_node_t *result_stack;

    mp_lexer_t *lexer;

    mp_parse_tree_t tree;
    mp_parse_chunk_t *cur_chunk;

    #if MICROPY_COMP_CONST
    mp_map_t consts;
    #endif
} parser_t;

STATIC void *micropy_parser_alloc(struct _mp_state_ctx_t *mp_state, parser_t *parser, size_t num_bytes) {
    // use a custom memory allocator to store parse nodes sequentially in large chunks

    mp_parse_chunk_t *chunk = parser->cur_chunk;

    if (chunk != NULL && chunk->union_.used + num_bytes > chunk->alloc) {
        // not enough room at end of previously allocated chunk so try to grow
        mp_parse_chunk_t *new_data = (mp_parse_chunk_t*)micropy_m_renew_maybe(mp_state, byte, chunk,
            sizeof(mp_parse_chunk_t) + chunk->alloc,
            sizeof(mp_parse_chunk_t) + chunk->alloc + num_bytes, false);
        if (new_data == NULL) {
            // could not grow existing memory; shrink it to fit previous
            (void)micropy_m_renew_maybe(mp_state, byte, chunk, sizeof(mp_parse_chunk_t) + chunk->alloc,
                sizeof(mp_parse_chunk_t) + chunk->union_.used, false);
            chunk->alloc = chunk->union_.used;
            chunk->union_.next = parser->tree.chunk;
            parser->tree.chunk = chunk;
            chunk = NULL;
        } else {
            // could grow existing memory
            chunk->alloc += num_bytes;
        }
    }

    if (chunk == NULL) {
        // no previous chunk, allocate a new chunk
        size_t alloc = MICROPY_ALLOC_PARSE_CHUNK_INIT;
        if (alloc < num_bytes) {
            alloc = num_bytes;
        }
        chunk = (mp_parse_chunk_t*)micropy_m_new(mp_state, byte, sizeof(mp_parse_chunk_t) + alloc);
        chunk->alloc = alloc;
        chunk->union_.used = 0;
        parser->cur_chunk = chunk;
    }

    byte *ret = chunk->data + chunk->union_.used;
    chunk->union_.used += num_bytes;
    return ret;
}

STATIC void micropy_push_rule(struct _mp_state_ctx_t *mp_state, parser_t *parser, size_t src_line, const rule_t *rule, size_t arg_i) {
    if (parser->parse_error) {
        return;
    }
    if (parser->rule_stack_top >= parser->rule_stack_alloc) {
        rule_stack_t *rs = micropy_m_renew_maybe(mp_state, rule_stack_t, parser->rule_stack, parser->rule_stack_alloc, parser->rule_stack_alloc + MICROPY_ALLOC_PARSE_RULE_INC, true);
        if (rs == NULL) {
            parser->parse_error = PARSE_ERROR_MEMORY;
            return;
        }
        parser->rule_stack = rs;
        parser->rule_stack_alloc += MICROPY_ALLOC_PARSE_RULE_INC;
    }
    rule_stack_t *rs = &parser->rule_stack[parser->rule_stack_top++];
    rs->src_line = src_line;
    rs->rule_id = rule->rule_id;
    rs->arg_i = arg_i;
}

STATIC void micropy_push_rule_from_arg(struct _mp_state_ctx_t *mp_state, parser_t *parser, size_t arg) {
    assert((arg & RULE_ARG_KIND_MASK) == RULE_ARG_RULE || (arg & RULE_ARG_KIND_MASK) == RULE_ARG_OPT_RULE);
    size_t rule_id = arg & RULE_ARG_ARG_MASK;
    assert(rule_id < RULE_maximum_number_of);
    micropy_push_rule(mp_state, parser, parser->lexer->tok_line, rules[rule_id], 0);
}

STATIC void micropy_pop_rule(struct _mp_state_ctx_t *mp_state, parser_t *parser, const rule_t **rule, size_t *arg_i, size_t *src_line) {
    assert(!parser->parse_error);
    parser->rule_stack_top -= 1;
    *rule = rules[parser->rule_stack[parser->rule_stack_top].rule_id];
    *arg_i = parser->rule_stack[parser->rule_stack_top].arg_i;
    *src_line = parser->rule_stack[parser->rule_stack_top].src_line;
}

mp_parse_node_t micropy_parse_node_new_leaf(struct _mp_state_ctx_t *mp_state, size_t kind, mp_int_t arg) {
    if (kind == MP_PARSE_NODE_SMALL_INT) {
        return (mp_parse_node_t)(kind | (arg << 1));
    }
    return (mp_parse_node_t)(kind | (arg << 4));
}

bool micropy_parse_node_get_int_maybe(struct _mp_state_ctx_t *mp_state, mp_parse_node_t pn, mp_obj_t *o) {
    if (MP_PARSE_NODE_IS_SMALL_INT(pn)) {
        *o = MP_OBJ_NEW_SMALL_INT(MP_PARSE_NODE_LEAF_SMALL_INT(pn));
        return true;
    } else if (MP_PARSE_NODE_IS_STRUCT_KIND(pn, RULE_const_object)) {
        mp_parse_node_struct_t *pns = (mp_parse_node_struct_t*)pn;
        #if MICROPY_OBJ_REPR == MICROPY_OBJ_REPR_D
        // nodes are 32-bit pointers, but need to extract 64-bit object
        *o = (uint64_t)pns->nodes[0] | ((uint64_t)pns->nodes[1] << 32);
        #else
        *o = (mp_obj_t)pns->nodes[0];
        #endif
        return MP_OBJ_IS_INT(*o);
    } else {
        return false;
    }
}

int micropy_parse_node_extract_list(struct _mp_state_ctx_t *mp_state, mp_parse_node_t *pn, size_t pn_kind, mp_parse_node_t **nodes) {
    if (MP_PARSE_NODE_IS_NULL(*pn)) {
        *nodes = NULL;
        return 0;
    } else if (MP_PARSE_NODE_IS_LEAF(*pn)) {
        *nodes = pn;
        return 1;
    } else {
        mp_parse_node_struct_t *pns = (mp_parse_node_struct_t*)(*pn);
        if (MP_PARSE_NODE_STRUCT_KIND(pns) != pn_kind) {
            *nodes = pn;
            return 1;
        } else {
            *nodes = pns->nodes;
            return MP_PARSE_NODE_STRUCT_NUM_NODES(pns);
        }
    }
}

#if MICROPY_DEBUG_PRINTERS
void micropy_parse_node_print(struct _mp_state_ctx_t *mp_state, mp_parse_node_t pn, size_t indent) {
    if (MP_PARSE_NODE_IS_STRUCT(pn)) {
        printf("[% 4d] ", (int)((mp_parse_node_struct_t*)pn)->source_line);
    } else {
        printf("       ");
    }
    for (size_t i = 0; i < indent; i++) {
        printf(" ");
    }
    if (MP_PARSE_NODE_IS_NULL(pn)) {
        printf("NULL\n");
    } else if (MP_PARSE_NODE_IS_SMALL_INT(pn)) {
        mp_int_t arg = MP_PARSE_NODE_LEAF_SMALL_INT(pn);
        printf("int(" INT_FMT ")\n", arg);
    } else if (MP_PARSE_NODE_IS_LEAF(pn)) {
        uintptr_t arg = MP_PARSE_NODE_LEAF_ARG(pn);
        switch (MP_PARSE_NODE_LEAF_KIND(pn)) {
            case MP_PARSE_NODE_ID: printf("id(%s)\n", micropy_qstr_str(mp_state, arg)); break;
            case MP_PARSE_NODE_STRING: printf("str(%s)\n", micropy_qstr_str(mp_state, arg)); break;
            case MP_PARSE_NODE_BYTES: printf("bytes(%s)\n", micropy_qstr_str(mp_state, arg)); break;
            case MP_PARSE_NODE_TOKEN: printf("tok(%u)\n", (uint)arg); break;
            default: assert(0);
        }
    } else {
        // node must be a mp_parse_node_struct_t
        mp_parse_node_struct_t *pns = (mp_parse_node_struct_t*)pn;
        if (MP_PARSE_NODE_STRUCT_KIND(pns) == RULE_string) {
            printf("literal micropy_str(mp_state, %.*s)\n", (int)pns->nodes[1], (char*)pns->nodes[0]);
        } else if (MP_PARSE_NODE_STRUCT_KIND(pns) == RULE_bytes) {
            printf("literal micropy_bytes(mp_state, %.*s)\n", (int)pns->nodes[1], (char*)pns->nodes[0]);
        } else if (MP_PARSE_NODE_STRUCT_KIND(pns) == RULE_const_object) {
            #if MICROPY_OBJ_REPR == MICROPY_OBJ_REPR_D
            printf("literal micropy_const(mp_state, %016llx)\n", (uint64_t)pns->nodes[0] | ((uint64_t)pns->nodes[1] << 32));
            #else
            printf("literal micropy_const(mp_state, %p)\n", (mp_obj_t)pns->nodes[0]);
            #endif
        } else {
            size_t n = MP_PARSE_NODE_STRUCT_NUM_NODES(pns);
#ifdef USE_RULE_NAME
            printf("%s(%u) (n=%u)\n", rules[MP_PARSE_NODE_STRUCT_KIND(pns)]->rule_name, (uint)MP_PARSE_NODE_STRUCT_KIND(pns), (uint)n);
#else
            printf("rule(%u) (n=%u)\n", (uint)MP_PARSE_NODE_STRUCT_KIND(pns), (uint)n);
#endif
            for (size_t i = 0; i < n; i++) {
                micropy_parse_node_print(mp_state, pns->nodes[i], indent + 2);
            }
        }
    }
}
#endif // MICROPY_DEBUG_PRINTERS

/*
STATIC void micropy_result_stack_show(struct _mp_state_ctx_t *mp_state, parser_t *parser) {
    printf("result stack, most recent first\n");
    for (ssize_t i = parser->result_stack_top - 1; i >= 0; i--) {
        micropy_parse_node_print(mp_state, parser->result_stack[i], 0);
    }
}
*/

STATIC mp_parse_node_t micropy_pop_result(struct _mp_state_ctx_t *mp_state, parser_t *parser) {
    if (parser->parse_error) {
        return MP_PARSE_NODE_NULL;
    }
    assert(parser->result_stack_top > 0);
    return parser->result_stack[--parser->result_stack_top];
}

STATIC mp_parse_node_t micropy_peek_result(struct _mp_state_ctx_t *mp_state, parser_t *parser, size_t pos) {
    if (parser->parse_error) {
        return MP_PARSE_NODE_NULL;
    }
    assert(parser->result_stack_top > pos);
    return parser->result_stack[parser->result_stack_top - 1 - pos];
}

STATIC void micropy_push_result_node(struct _mp_state_ctx_t *mp_state, parser_t *parser, mp_parse_node_t pn) {
    if (parser->parse_error) {
        return;
    }
    if (parser->result_stack_top >= parser->result_stack_alloc) {
        mp_parse_node_t *stack = micropy_m_renew_maybe(mp_state, mp_parse_node_t, parser->result_stack, parser->result_stack_alloc, parser->result_stack_alloc + MICROPY_ALLOC_PARSE_RESULT_INC, true);
        if (stack == NULL) {
            parser->parse_error = PARSE_ERROR_MEMORY;
            return;
        }
        parser->result_stack = stack;
        parser->result_stack_alloc += MICROPY_ALLOC_PARSE_RESULT_INC;
    }
    parser->result_stack[parser->result_stack_top++] = pn;
}

STATIC mp_parse_node_t micropy_make_node_string_bytes(struct _mp_state_ctx_t *mp_state, parser_t *parser, size_t src_line, size_t rule_kind, const char *str, size_t len) {
    mp_parse_node_struct_t *pn = micropy_parser_alloc(mp_state, parser, sizeof(mp_parse_node_struct_t) + sizeof(mp_parse_node_t) * 2);
    if (pn == NULL) {
        parser->parse_error = PARSE_ERROR_MEMORY;
        return MP_PARSE_NODE_NULL;
    }
    pn->source_line = src_line;
    pn->kind_num_nodes = rule_kind | (2 << 8);
    char *p = micropy_m_new(mp_state, char, len);
    memcpy(p, str, len);
    pn->nodes[0] = (uintptr_t)p;
    pn->nodes[1] = len;
    return (mp_parse_node_t)pn;
}

STATIC mp_parse_node_t micropy_make_node_const_object(struct _mp_state_ctx_t *mp_state, parser_t *parser, size_t src_line, mp_obj_t obj) {
    mp_parse_node_struct_t *pn = micropy_parser_alloc(mp_state, parser, sizeof(mp_parse_node_struct_t) + sizeof(mp_obj_t));
    if (pn == NULL) {
        parser->parse_error = PARSE_ERROR_MEMORY;
        return MP_PARSE_NODE_NULL;
    }
    pn->source_line = src_line;
    #if MICROPY_OBJ_REPR == MICROPY_OBJ_REPR_D
    // nodes are 32-bit pointers, but need to store 64-bit object
    pn->kind_num_nodes = RULE_const_object | (2 << 8);
    pn->nodes[0] = (uint64_t)obj;
    pn->nodes[1] = (uint64_t)obj >> 32;
    #else
    pn->kind_num_nodes = RULE_const_object | (1 << 8);
    pn->nodes[0] = (uintptr_t)obj;
    #endif
    return (mp_parse_node_t)pn;
}

STATIC void micropy_push_result_token(struct _mp_state_ctx_t *mp_state, parser_t *parser) {
    mp_parse_node_t pn;
    mp_lexer_t *lex = parser->lexer;
    if (lex->tok_kind == MP_TOKEN_NAME) {
        qstr id = micropy_qstr_from_strn(mp_state, lex->vstr.buf, lex->vstr.len);
        #if MICROPY_COMP_CONST
        // lookup identifier in table of dynamic constants
        mp_map_elem_t *elem = micropy_map_lookup(mp_state, &parser->consts, MP_OBJ_NEW_QSTR(id), MP_MAP_LOOKUP);
        if (elem != NULL) {
            pn = micropy_parse_node_new_leaf(mp_state, MP_PARSE_NODE_SMALL_INT, MP_OBJ_SMALL_INT_VALUE(elem->value));
        } else
        #endif
        {
            pn = micropy_parse_node_new_leaf(mp_state, MP_PARSE_NODE_ID, id);
        }
    } else if (lex->tok_kind == MP_TOKEN_INTEGER) {
        mp_obj_t o = micropy_parse_num_integer(mp_state, lex->vstr.buf, lex->vstr.len, 0, lex);
        if (MP_OBJ_IS_SMALL_INT(o)) {
            pn = micropy_parse_node_new_leaf(mp_state, MP_PARSE_NODE_SMALL_INT, MP_OBJ_SMALL_INT_VALUE(o));
        } else {
            pn = micropy_make_node_const_object(mp_state, parser, lex->tok_line, o);
        }
    } else if (lex->tok_kind == MP_TOKEN_FLOAT_OR_IMAG) {
        mp_obj_t o = micropy_parse_num_decimal(mp_state, lex->vstr.buf, lex->vstr.len, true, false, lex);
        pn = micropy_make_node_const_object(mp_state, parser, lex->tok_line, o);
    } else if (lex->tok_kind == MP_TOKEN_STRING || lex->tok_kind == MP_TOKEN_BYTES) {
        // Don't automatically intern all strings/bytes.  doc strings (which are usually large)
        // will be discarded by the compiler, and so we shouldn't intern them.
        qstr qst = MP_QSTR_NULL;
        if (lex->vstr.len <= MICROPY_ALLOC_PARSE_INTERN_STRING_LEN) {
            // intern short strings
            qst = micropy_qstr_from_strn(mp_state, lex->vstr.buf, lex->vstr.len);
        } else {
            // check if this string is already interned
            qst = micropy_qstr_find_strn(mp_state, lex->vstr.buf, lex->vstr.len);
        }
        if (qst != MP_QSTR_NULL) {
            // qstr exists, make a leaf node
            pn = micropy_parse_node_new_leaf(mp_state, lex->tok_kind == MP_TOKEN_STRING ? MP_PARSE_NODE_STRING : MP_PARSE_NODE_BYTES, qst);
        } else {
            // not interned, make a node holding a pointer to the string/bytes data
            pn = micropy_make_node_string_bytes(mp_state, parser, lex->tok_line, lex->tok_kind == MP_TOKEN_STRING ? RULE_string : RULE_bytes, lex->vstr.buf, lex->vstr.len);
        }
    } else {
        pn = micropy_parse_node_new_leaf(mp_state, MP_PARSE_NODE_TOKEN, lex->tok_kind);
    }
    micropy_push_result_node(mp_state, parser, pn);
}

#if MICROPY_COMP_MODULE_CONST
STATIC const mp_rom_map_elem_t mp_constants_table[] = {
    #if MICROPY_PY_UERRNO
    { MP_ROM_QSTR(MP_QSTR_errno), MP_ROM_PTR(&mp_module_uerrno) },
    #endif
    #if MICROPY_PY_UCTYPES
    { MP_ROM_QSTR(MP_QSTR_uctypes), MP_ROM_PTR(&mp_module_uctypes) },
    #endif
    // Extra constants as defined by a port
    MICROPY_PORT_CONSTANTS
};
STATIC MP_DEFINE_CONST_MAP(mp_constants_map, mp_constants_table);
#endif

#if MICROPY_COMP_CONST_FOLDING
STATIC bool micropy_fold_constants(struct _mp_state_ctx_t *mp_state, parser_t *parser, const rule_t *rule, size_t num_args) {
    // this code does folding of arbitrary integer expressions, eg 1 + 2 * 3 + 4
    // it does not do partial folding, eg 1 + 2 + x -> 3 + x

    mp_obj_t arg0;
    if (rule->rule_id == RULE_expr
        || rule->rule_id == RULE_xor_expr
        || rule->rule_id == RULE_and_expr) {
        // folding for binary ops: | ^ &
        mp_parse_node_t pn = micropy_peek_result(mp_state, parser, num_args - 1);
        if (!micropy_parse_node_get_int_maybe(mp_state, pn, &arg0)) {
            return false;
        }
        mp_binary_op_t op;
        if (rule->rule_id == RULE_expr) {
            op = MP_BINARY_OP_OR;
        } else if (rule->rule_id == RULE_xor_expr) {
            op = MP_BINARY_OP_XOR;
        } else {
            op = MP_BINARY_OP_AND;
        }
        for (ssize_t i = num_args - 2; i >= 0; --i) {
            pn = micropy_peek_result(mp_state, parser, i);
            mp_obj_t arg1;
            if (!micropy_parse_node_get_int_maybe(mp_state, pn, &arg1)) {
                return false;
            }
            arg0 = micropy_binary_op(mp_state, op, arg0, arg1);
        }
    } else if (rule->rule_id == RULE_shift_expr
        || rule->rule_id == RULE_arith_expr
        || rule->rule_id == RULE_term) {
        // folding for binary ops: << >> + - * / % //
        mp_parse_node_t pn = micropy_peek_result(mp_state, parser, num_args - 1);
        if (!micropy_parse_node_get_int_maybe(mp_state, pn, &arg0)) {
            return false;
        }
        for (ssize_t i = num_args - 2; i >= 1; i -= 2) {
            pn = micropy_peek_result(mp_state, parser, i - 1);
            mp_obj_t arg1;
            if (!micropy_parse_node_get_int_maybe(mp_state, pn, &arg1)) {
                return false;
            }
            mp_token_kind_t tok = MP_PARSE_NODE_LEAF_ARG(micropy_peek_result(mp_state, parser, i));
            static const uint8_t token_to_op[] = {
                MP_BINARY_OP_ADD,
                MP_BINARY_OP_SUBTRACT,
                MP_BINARY_OP_MULTIPLY,
                255,//MP_BINARY_OP_POWER,
                255,//MP_BINARY_OP_TRUE_DIVIDE,
                MP_BINARY_OP_FLOOR_DIVIDE,
                MP_BINARY_OP_MODULO,
                255,//MP_BINARY_OP_LESS
                MP_BINARY_OP_LSHIFT,
                255,//MP_BINARY_OP_MORE
                MP_BINARY_OP_RSHIFT,
            };
            mp_binary_op_t op = token_to_op[tok - MP_TOKEN_OP_PLUS];
            if (op == (mp_binary_op_t)255) {
                return false;
            }
            int rhs_sign = micropy_obj_int_sign(mp_state, arg1);
            if (op <= MP_BINARY_OP_RSHIFT) {
                // << and >> can't have negative rhs
                if (rhs_sign < 0) {
                    return false;
                }
            } else if (op >= MP_BINARY_OP_FLOOR_DIVIDE) {
                // % and // can't have zero rhs
                if (rhs_sign == 0) {
                    return false;
                }
            }
            arg0 = micropy_binary_op(mp_state, op, arg0, arg1);
        }
    } else if (rule->rule_id == RULE_factor_2) {
        // folding for unary ops: + - ~
        mp_parse_node_t pn = micropy_peek_result(mp_state, parser, 0);
        if (!micropy_parse_node_get_int_maybe(mp_state, pn, &arg0)) {
            return false;
        }
        mp_token_kind_t tok = MP_PARSE_NODE_LEAF_ARG(micropy_peek_result(mp_state, parser, 1));
        mp_unary_op_t op;
        if (tok == MP_TOKEN_OP_PLUS) {
            op = MP_UNARY_OP_POSITIVE;
        } else if (tok == MP_TOKEN_OP_MINUS) {
            op = MP_UNARY_OP_NEGATIVE;
        } else {
            assert(tok == MP_TOKEN_OP_TILDE); // should be
            op = MP_UNARY_OP_INVERT;
        }
        arg0 = micropy_unary_op(mp_state, op, arg0);

    #if MICROPY_COMP_CONST
    } else if (rule->rule_id == RULE_expr_stmt) {
        mp_parse_node_t pn1 = micropy_peek_result(mp_state, parser, 0);
        if (!MP_PARSE_NODE_IS_NULL(pn1)
            && !(MP_PARSE_NODE_IS_STRUCT_KIND(pn1, RULE_expr_stmt_augassign)
            || MP_PARSE_NODE_IS_STRUCT_KIND(pn1, RULE_expr_stmt_assign_list))) {
            // this node is of the form <x> = <y>
            mp_parse_node_t pn0 = micropy_peek_result(mp_state, parser, 1);
            if (MP_PARSE_NODE_IS_ID(pn0)
                && MP_PARSE_NODE_IS_STRUCT_KIND(pn1, RULE_atom_expr_normal)
                && MP_PARSE_NODE_IS_ID(((mp_parse_node_struct_t*)pn1)->nodes[0])
                && MP_PARSE_NODE_LEAF_ARG(((mp_parse_node_struct_t*)pn1)->nodes[0]) == MP_QSTR_const
                && MP_PARSE_NODE_IS_STRUCT_KIND(((mp_parse_node_struct_t*)pn1)->nodes[1], RULE_trailer_paren)
                ) {
                // code to assign dynamic constants: id = const(value)

                // get the id
                qstr id = MP_PARSE_NODE_LEAF_ARG(pn0);

                // get the value
                mp_parse_node_t pn_value = ((mp_parse_node_struct_t*)((mp_parse_node_struct_t*)pn1)->nodes[1])->nodes[0];
                if (!MP_PARSE_NODE_IS_SMALL_INT(pn_value)) {
                    parser->parse_error = PARSE_ERROR_CONST;
                    return false;
                }
                mp_int_t value = MP_PARSE_NODE_LEAF_SMALL_INT(pn_value);

                // store the value in the table of dynamic constants
                mp_map_elem_t *elem = micropy_map_lookup(mp_state, &parser->consts, MP_OBJ_NEW_QSTR(id), MP_MAP_LOOKUP_ADD_IF_NOT_FOUND);
                assert(elem->value == MP_OBJ_NULL);
                elem->value = MP_OBJ_NEW_SMALL_INT(value);

                // replace const(value) with value
                micropy_pop_result(mp_state, parser);
                micropy_push_result_node(mp_state, parser, pn_value);

                // finished folding this assignment, but we still want it to be part of the tree
                return false;
            }
        }
        return false;
    #endif

    #if MICROPY_COMP_MODULE_CONST
    } else if (rule->rule_id == RULE_atom_expr_normal) {
        mp_parse_node_t pn0 = micropy_peek_result(mp_state, parser, 1);
        mp_parse_node_t pn1 = micropy_peek_result(mp_state, parser, 0);
        if (!(MP_PARSE_NODE_IS_ID(pn0)
            && MP_PARSE_NODE_IS_STRUCT_KIND(pn1, RULE_trailer_period))) {
            return false;
        }
        // id1.id2
        // look it up in constant table, see if it can be replaced with an integer
        mp_parse_node_struct_t *pns1 = (mp_parse_node_struct_t*)pn1;
        assert(MP_PARSE_NODE_IS_ID(pns1->nodes[0]));
        qstr q_base = MP_PARSE_NODE_LEAF_ARG(pn0);
        qstr q_attr = MP_PARSE_NODE_LEAF_ARG(pns1->nodes[0]);
        mp_map_elem_t *elem = micropy_map_lookup(mp_state, (mp_map_t*)&mp_constants_map, MP_OBJ_NEW_QSTR(q_base), MP_MAP_LOOKUP);
        if (elem == NULL) {
            return false;
        }
        mp_obj_t dest[2];
        micropy_load_method_maybe(mp_state, elem->value, q_attr, dest);
        if (!(dest[0] != MP_OBJ_NULL && MP_OBJ_IS_INT(dest[0]) && dest[1] == MP_OBJ_NULL)) {
            return false;
        }
        arg0 = dest[0];
    #endif

    } else {
        return false;
    }

    // success folding this rule

    for (size_t i = num_args; i > 0; i--) {
        micropy_pop_result(mp_state, parser);
    }
    if (MP_OBJ_IS_SMALL_INT(arg0)) {
        micropy_push_result_node(mp_state, parser, micropy_parse_node_new_leaf(mp_state, MP_PARSE_NODE_SMALL_INT, MP_OBJ_SMALL_INT_VALUE(arg0)));
    } else {
        // TODO reuse memory for parse node struct?
        micropy_push_result_node(mp_state, parser, micropy_make_node_const_object(mp_state, parser, 0, arg0));
    }

    return true;
}
#endif

STATIC void micropy_push_result_rule(struct _mp_state_ctx_t *mp_state, parser_t *parser, size_t src_line, const rule_t *rule, size_t num_args) {
    // optimise away parenthesis around an expression if possible
    if (rule->rule_id == RULE_atom_paren) {
        // there should be just 1 arg for this rule
        mp_parse_node_t pn = micropy_peek_result(mp_state, parser, 0);
        if (MP_PARSE_NODE_IS_NULL(pn)) {
            // need to keep parenthesis for ()
        } else if (MP_PARSE_NODE_IS_STRUCT_KIND(pn, RULE_testlist_comp)) {
            // need to keep parenthesis for (a, b, ...)
        } else {
            // parenthesis around a single expression, so it's just the expression
            return;
        }
    }

    #if MICROPY_COMP_CONST_FOLDING
    if (micropy_fold_constants(mp_state, parser, rule, num_args)) {
        // we folded this rule so return straight away
        return;
    }
    #endif

    mp_parse_node_struct_t *pn = micropy_parser_alloc(mp_state, parser, sizeof(mp_parse_node_struct_t) + sizeof(mp_parse_node_t) * num_args);
    if (pn == NULL) {
        parser->parse_error = PARSE_ERROR_MEMORY;
        return;
    }
    pn->source_line = src_line;
    pn->kind_num_nodes = (rule->rule_id & 0xff) | (num_args << 8);
    for (size_t i = num_args; i > 0; i--) {
        pn->nodes[i - 1] = micropy_pop_result(mp_state, parser);
    }
    micropy_push_result_node(mp_state, parser, (mp_parse_node_t)pn);
}

mp_parse_tree_t micropy_parse(struct _mp_state_ctx_t *mp_state, mp_lexer_t *lex, mp_parse_input_kind_t input_kind) {

    // initialise parser and allocate memory for its stacks

    parser_t parser;

    parser.parse_error = PARSE_ERROR_NONE;

    parser.rule_stack_alloc = MICROPY_ALLOC_PARSE_RULE_INIT;
    parser.rule_stack_top = 0;
    parser.rule_stack = micropy_m_new_maybe(mp_state, rule_stack_t, parser.rule_stack_alloc);

    parser.result_stack_alloc = MICROPY_ALLOC_PARSE_RESULT_INIT;
    parser.result_stack_top = 0;
    parser.result_stack = micropy_m_new_maybe(mp_state, mp_parse_node_t, parser.result_stack_alloc);

    parser.lexer = lex;

    parser.tree.chunk = NULL;
    parser.cur_chunk = NULL;

    #if MICROPY_COMP_CONST
    micropy_map_init(mp_state, &parser.consts, 0);
    #endif

    // check if we could allocate the stacks
    if (parser.rule_stack == NULL || parser.result_stack == NULL) {
        goto memory_error;
    }

    // work out the top-level rule to use, and push it on the stack
    size_t top_level_rule;
    switch (input_kind) {
        case MP_PARSE_SINGLE_INPUT: top_level_rule = RULE_single_input; break;
        case MP_PARSE_EVAL_INPUT: top_level_rule = RULE_eval_input; break;
        default: top_level_rule = RULE_file_input;
    }
    micropy_push_rule(mp_state, &parser, lex->tok_line, rules[top_level_rule], 0);

    // parse!

    size_t n, i; // state for the current rule
    size_t rule_src_line; // source line for the first token matched by the current rule
    bool backtrack = false;
    const rule_t *rule = NULL;

    for (;;) {
        next_rule:
        if (parser.rule_stack_top == 0 || parser.parse_error) {
            break;
        }

        micropy_pop_rule(mp_state, &parser, &rule, &i, &rule_src_line);
        n = rule->act & RULE_ACT_ARG_MASK;

        /*
        // debugging
        printf("depth=%d ", parser.rule_stack_top);
        for (int j = 0; j < parser.rule_stack_top; ++j) {
            printf(" ");
        }
        printf("%s n=%d i=%d bt=%d\n", rule->rule_name, n, i, backtrack);
        */

        switch (rule->act & RULE_ACT_KIND_MASK) {
            case RULE_ACT_OR:
                if (i > 0 && !backtrack) {
                    goto next_rule;
                } else {
                    backtrack = false;
                }
                for (; i < n; ++i) {
                    uint16_t kind = rule->arg[i] & RULE_ARG_KIND_MASK;
                    if (kind == RULE_ARG_TOK) {
                        if (lex->tok_kind == (rule->arg[i] & RULE_ARG_ARG_MASK)) {
                            micropy_push_result_token(mp_state, &parser);
                            micropy_lexer_to_next(mp_state, lex);
                            goto next_rule;
                        }
                    } else {
                        assert(kind == RULE_ARG_RULE);
                        if (i + 1 < n) {
                            micropy_push_rule(mp_state, &parser, rule_src_line, rule, i + 1); // save this or-rule
                        }
                        micropy_push_rule_from_arg(mp_state, &parser, rule->arg[i]); // push child of or-rule
                        goto next_rule;
                    }
                }
                backtrack = true;
                break;

            case RULE_ACT_AND: {

                // failed, backtrack if we can, else syntax error
                if (backtrack) {
                    assert(i > 0);
                    if ((rule->arg[i - 1] & RULE_ARG_KIND_MASK) == RULE_ARG_OPT_RULE) {
                        // an optional rule that failed, so continue with next arg
                        micropy_push_result_node(mp_state, &parser, MP_PARSE_NODE_NULL);
                        backtrack = false;
                    } else {
                        // a mandatory rule that failed, so propagate backtrack
                        if (i > 1) {
                            // already eaten tokens so can't backtrack
                            goto syntax_error;
                        } else {
                            goto next_rule;
                        }
                    }
                }

                // progress through the rule
                for (; i < n; ++i) {
                    switch (rule->arg[i] & RULE_ARG_KIND_MASK) {
                        case RULE_ARG_TOK: {
                            // need to match a token
                            mp_token_kind_t tok_kind = rule->arg[i] & RULE_ARG_ARG_MASK;
                            if (lex->tok_kind == tok_kind) {
                                // matched token
                                if (tok_kind == MP_TOKEN_NAME) {
                                    micropy_push_result_token(mp_state, &parser);
                                }
                                micropy_lexer_to_next(mp_state, lex);
                            } else {
                                // failed to match token
                                if (i > 0) {
                                    // already eaten tokens so can't backtrack
                                    goto syntax_error;
                                } else {
                                    // this rule failed, so backtrack
                                    backtrack = true;
                                    goto next_rule;
                                }
                            }
                            break;
                        }
                        case RULE_ARG_RULE:
                        case RULE_ARG_OPT_RULE:
                        rule_and_no_other_choice:
                            micropy_push_rule(mp_state, &parser, rule_src_line, rule, i + 1); // save this and-rule
                            micropy_push_rule_from_arg(mp_state, &parser, rule->arg[i]); // push child of and-rule
                            goto next_rule;
                        default:
                            assert(0);
                            goto rule_and_no_other_choice; // to help flow control analysis
                    }
                }

                assert(i == n);

                // matched the rule, so now build the corresponding parse_node

                #if !MICROPY_ENABLE_DOC_STRING
                // this code discards lonely statements, such as doc strings
                if (input_kind != MP_PARSE_SINGLE_INPUT && rule->rule_id == RULE_expr_stmt && micropy_peek_result(mp_state, &parser, 0) == MP_PARSE_NODE_NULL) {
                    mp_parse_node_t p = micropy_peek_result(mp_state, &parser, 1);
                    if ((MP_PARSE_NODE_IS_LEAF(p) && !MP_PARSE_NODE_IS_ID(p)) || MP_PARSE_NODE_IS_STRUCT_KIND(p, RULE_string)) {
                        micropy_pop_result(mp_state, &parser); // MP_PARSE_NODE_NULL
                        mp_parse_node_t pn = micropy_pop_result(mp_state, &parser); // possibly RULE_string
                        if (MP_PARSE_NODE_IS_STRUCT(pn)) {
                            mp_parse_node_struct_t *pns = (mp_parse_node_struct_t *)pn;
                            if (MP_PARSE_NODE_STRUCT_KIND(pns) == RULE_string) {
                                micropy_m_del(mp_state, char, (char*)pns->nodes[0], (size_t)pns->nodes[1]);
                            }
                        }
                        micropy_push_result_rule(mp_state, &parser, rule_src_line, rules[RULE_pass_stmt], 0);
                        break;
                    }
                }
                #endif

                // count number of arguments for the parse node
                i = 0;
                size_t num_not_nil = 0;
                for (size_t x = n; x > 0;) {
                    --x;
                    if ((rule->arg[x] & RULE_ARG_KIND_MASK) == RULE_ARG_TOK) {
                        mp_token_kind_t tok_kind = rule->arg[x] & RULE_ARG_ARG_MASK;
                        if (tok_kind == MP_TOKEN_NAME) {
                            // only tokens which were names are pushed to stack
                            i += 1;
                            num_not_nil += 1;
                        }
                    } else {
                        // rules are always pushed
                        if (micropy_peek_result(mp_state, &parser, i) != MP_PARSE_NODE_NULL) {
                            num_not_nil += 1;
                        }
                        i += 1;
                    }
                }

                if (num_not_nil == 1 && (rule->act & RULE_ACT_ALLOW_IDENT)) {
                    // this rule has only 1 argument and should not be emitted
                    mp_parse_node_t pn = MP_PARSE_NODE_NULL;
                    for (size_t x = 0; x < i; ++x) {
                        mp_parse_node_t pn2 = micropy_pop_result(mp_state, &parser);
                        if (pn2 != MP_PARSE_NODE_NULL) {
                            pn = pn2;
                        }
                    }
                    micropy_push_result_node(mp_state, &parser, pn);
                } else {
                    // this rule must be emitted

                    if (rule->act & RULE_ACT_ADD_BLANK) {
                        // and add an extra blank node at the end (used by the compiler to store data)
                        micropy_push_result_node(mp_state, &parser, MP_PARSE_NODE_NULL);
                        i += 1;
                    }

                    micropy_push_result_rule(mp_state, &parser, rule_src_line, rule, i);
                }
                break;
            }

            case RULE_ACT_LIST: {
                // n=2 is: item item*
                // n=1 is: item (sep item)*
                // n=3 is: item (sep item)* [sep]
                bool had_trailing_sep;
                if (backtrack) {
                    list_backtrack:
                    had_trailing_sep = false;
                    if (n == 2) {
                        if (i == 1) {
                            // fail on item, first time round; propagate backtrack
                            goto next_rule;
                        } else {
                            // fail on item, in later rounds; finish with this rule
                            backtrack = false;
                        }
                    } else {
                        if (i == 1) {
                            // fail on item, first time round; propagate backtrack
                            goto next_rule;
                        } else if ((i & 1) == 1) {
                            // fail on item, in later rounds; have eaten tokens so can't backtrack
                            if (n == 3) {
                                // list allows trailing separator; finish parsing list
                                had_trailing_sep = true;
                                backtrack = false;
                            } else {
                                // list doesn't allowing trailing separator; fail
                                goto syntax_error;
                            }
                        } else {
                            // fail on separator; finish parsing list
                            backtrack = false;
                        }
                    }
                } else {
                    for (;;) {
                        size_t arg = rule->arg[i & 1 & n];
                        switch (arg & RULE_ARG_KIND_MASK) {
                            case RULE_ARG_TOK:
                                if (lex->tok_kind == (arg & RULE_ARG_ARG_MASK)) {
                                    if (i & 1 & n) {
                                        // separators which are tokens are not pushed to result stack
                                    } else {
                                        micropy_push_result_token(mp_state, &parser);
                                    }
                                    micropy_lexer_to_next(mp_state, lex);
                                    // got element of list, so continue parsing list
                                    i += 1;
                                } else {
                                    // couldn't get element of list
                                    i += 1;
                                    backtrack = true;
                                    goto list_backtrack;
                                }
                                break;
                            case RULE_ARG_RULE:
                            rule_list_no_other_choice:
                                micropy_push_rule(mp_state, &parser, rule_src_line, rule, i + 1); // save this list-rule
                                micropy_push_rule_from_arg(mp_state, &parser, arg); // push child of list-rule
                                goto next_rule;
                            default:
                                assert(0);
                                goto rule_list_no_other_choice; // to help flow control analysis
                        }
                    }
                }
                assert(i >= 1);

                // compute number of elements in list, result in i
                i -= 1;
                if ((n & 1) && (rule->arg[1] & RULE_ARG_KIND_MASK) == RULE_ARG_TOK) {
                    // don't count separators when they are tokens
                    i = (i + 1) / 2;
                }

                if (i == 1) {
                    // list matched single item
                    if (had_trailing_sep) {
                        // if there was a trailing separator, make a list of a single item
                        micropy_push_result_rule(mp_state, &parser, rule_src_line, rule, i);
                    } else {
                        // just leave single item on stack (ie don't wrap in a list)
                    }
                } else {
                    micropy_push_result_rule(mp_state, &parser, rule_src_line, rule, i);
                }
                break;
            }

            default:
                assert(0);
        }
    }

    #if MICROPY_COMP_CONST
    micropy_map_deinit(mp_state, &parser.consts);
    #endif

    // truncate final chunk and link into chain of chunks
    if (parser.cur_chunk != NULL) {
        (void)micropy_m_renew(mp_state, byte, parser.cur_chunk,
            sizeof(mp_parse_chunk_t) + parser.cur_chunk->alloc,
            sizeof(mp_parse_chunk_t) + parser.cur_chunk->union_.used);
        parser.cur_chunk->alloc = parser.cur_chunk->union_.used;
        parser.cur_chunk->union_.next = parser.tree.chunk;
        parser.tree.chunk = parser.cur_chunk;
    }

    mp_obj_t exc;

    if (parser.parse_error) {
        #if MICROPY_COMP_CONST
        if (parser.parse_error == PARSE_ERROR_CONST) {
            exc = micropy_obj_new_exception_msg(mp_state, &mp_type_SyntaxError,
                "constant must be an integer");
        } else
        #endif
        {
            assert(parser.parse_error == PARSE_ERROR_MEMORY);
        memory_error:
            exc = micropy_obj_new_exception_msg(mp_state, &mp_type_MemoryError,
                "parser could not allocate enough memory");
        }
        parser.tree.root = MP_PARSE_NODE_NULL;
    } else if (
        lex->tok_kind != MP_TOKEN_END // check we are at the end of the token stream
        || parser.result_stack_top == 0 // check that we got a node (can fail on empty input)
        ) {
    syntax_error:
        if (lex->tok_kind == MP_TOKEN_INDENT) {
            exc = micropy_obj_new_exception_msg(mp_state, &mp_type_IndentationError,
                "unexpected indent");
        } else if (lex->tok_kind == MP_TOKEN_DEDENT_MISMATCH) {
            exc = micropy_obj_new_exception_msg(mp_state, &mp_type_IndentationError,
                "unindent does not match any outer indentation level");
        } else {
            exc = micropy_obj_new_exception_msg(mp_state, &mp_type_SyntaxError,
                "invalid syntax");
        }
        parser.tree.root = MP_PARSE_NODE_NULL;
    } else {
        // no errors

        //result_stack_show(parser);
        //printf("rule stack alloc: %d\n", parser.rule_stack_alloc);
        //printf("result stack alloc: %d\n", parser.result_stack_alloc);
        //printf("number of parse nodes allocated: %d\n", num_parse_nodes_allocated);

        // get the root parse node that we created
        assert(parser.result_stack_top == 1);
        exc = MP_OBJ_NULL;
        parser.tree.root = parser.result_stack[0];
    }

    // free the memory that we don't need anymore
    micropy_m_del(mp_state, rule_stack_t, parser.rule_stack, parser.rule_stack_alloc);
    micropy_m_del(mp_state, mp_parse_node_t, parser.result_stack, parser.result_stack_alloc);
    // we also free the lexer on behalf of the caller (see below)

    if (exc != MP_OBJ_NULL) {
        // had an error so raise the exception
        // add traceback to give info about file name and location
        // we don't have a 'block' name, so just pass the NULL qstr to indicate this
        micropy_obj_exception_add_traceback(mp_state, exc, lex->source_name, lex->tok_line, MP_QSTR_NULL);
        micropy_lexer_free(mp_state, lex);
        micropy_nlr_raise(mp_state, exc);
    } else {
        micropy_lexer_free(mp_state, lex);
        return parser.tree;
    }
}

void micropy_parse_tree_clear(struct _mp_state_ctx_t *mp_state, mp_parse_tree_t *tree) {
    mp_parse_chunk_t *chunk = tree->chunk;
    while (chunk != NULL) {
        mp_parse_chunk_t *next = chunk->union_.next;
        micropy_m_del(mp_state, byte, chunk, sizeof(mp_parse_chunk_t) + chunk->alloc);
        chunk = next;
    }
}

#endif // MICROPY_ENABLE_COMPILER
/*
 * This file is part of the Micro Python project, http://micropython.org/
 *
 * The MIT License (MIT)
 *
 * Copyright (c) 2013, 2014 Damien P. George
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

#include <assert.h>

//#include "py/scope.h"

#if MICROPY_ENABLE_COMPILER

scope_t *micropy_scope_new(struct _mp_state_ctx_t *mp_state, scope_kind_t kind, mp_parse_node_t pn, qstr source_file, mp_uint_t emit_options) {
    scope_t *scope = micropy_m_new0(mp_state, scope_t, 1);
    scope->kind = kind;
    scope->pn = pn;
    scope->source_file = source_file;
    switch (kind) {
        case SCOPE_MODULE:
            scope->simple_name = MP_QSTR__lt_module_gt_;
            break;
        case SCOPE_FUNCTION:
        case SCOPE_CLASS:
            assert(MP_PARSE_NODE_IS_STRUCT(pn));
            scope->simple_name = MP_PARSE_NODE_LEAF_ARG(((mp_parse_node_struct_t*)pn)->nodes[0]);
            break;
        case SCOPE_LAMBDA:
            scope->simple_name = MP_QSTR__lt_lambda_gt_;
            break;
        case SCOPE_LIST_COMP:
            scope->simple_name = MP_QSTR__lt_listcomp_gt_;
            break;
        case SCOPE_DICT_COMP:
            scope->simple_name = MP_QSTR__lt_dictcomp_gt_;
            break;
        case SCOPE_SET_COMP:
            scope->simple_name = MP_QSTR__lt_setcomp_gt_;
            break;
        case SCOPE_GEN_EXPR:
            scope->simple_name = MP_QSTR__lt_genexpr_gt_;
            break;
        default:
            assert(0);
    }
    scope->raw_code = micropy_emit_glue_new_raw_code(mp_state);
    scope->emit_options = emit_options;
    scope->id_info_alloc = MICROPY_ALLOC_SCOPE_ID_INIT;
    scope->id_info = micropy_m_new(mp_state, id_info_t, scope->id_info_alloc);

    return scope;
}

void micropy_scope_free(struct _mp_state_ctx_t *mp_state, scope_t *scope) {
    micropy_m_del(mp_state, id_info_t, scope->id_info, scope->id_info_alloc);
    micropy_m_del(mp_state, scope_t, scope, 1);
}

id_info_t *micropy_scope_find_or_add_id(struct _mp_state_ctx_t *mp_state, scope_t *scope, qstr qst, bool *added) {
    id_info_t *id_info = micropy_scope_find(mp_state, scope, qst);
    if (id_info != NULL) {
        *added = false;
        return id_info;
    }

    // make sure we have enough memory
    if (scope->id_info_len >= scope->id_info_alloc) {
        scope->id_info = micropy_m_renew(mp_state, id_info_t, scope->id_info, scope->id_info_alloc, scope->id_info_alloc + MICROPY_ALLOC_SCOPE_ID_INC);
        scope->id_info_alloc += MICROPY_ALLOC_SCOPE_ID_INC;
    }

    // add new id to end of array of all ids; this seems to match CPython
    // important thing is that function arguments are first, but that is
    // handled by the compiler because it adds arguments before compiling the body
    id_info = &scope->id_info[scope->id_info_len++];

    id_info->kind = 0;
    id_info->flags = 0;
    id_info->local_num = 0;
    id_info->qst = qst;
    *added = true;
    return id_info;
}

id_info_t *micropy_scope_find(struct _mp_state_ctx_t *mp_state, scope_t *scope, qstr qst) {
    for (mp_uint_t i = 0; i < scope->id_info_len; i++) {
        if (scope->id_info[i].qst == qst) {
            return &scope->id_info[i];
        }
    }
    return NULL;
}

id_info_t *micropy_scope_find_global(struct _mp_state_ctx_t *mp_state, scope_t *scope, qstr qst) {
    while (scope->parent != NULL) {
        scope = scope->parent;
    }
    return micropy_scope_find(mp_state, scope, qst);
}

id_info_t *micropy_scope_find_local_in_parent(struct _mp_state_ctx_t *mp_state, scope_t *scope, qstr qst) {
    if (scope->parent == NULL) {
        return NULL;
    }
    for (scope_t *s = scope->parent; s->parent != NULL; s = s->parent) {
        id_info_t *id = micropy_scope_find(mp_state, s, qst);
        if (id != NULL) {
            return id;
        }
    }
    return NULL;
}

void micropy_scope_close_over_in_parents(struct _mp_state_ctx_t *mp_state, scope_t *scope, qstr qst) {
    assert(scope->parent != NULL); // we should have at least 1 parent
    for (scope_t *s = scope->parent; s->parent != NULL; s = s->parent) {
        bool added;
        id_info_t *id = micropy_scope_find_or_add_id(mp_state, s, qst, &added);
        if (added) {
            // variable not previously declared in this scope, so declare it as free and keep searching parents
            id->kind = ID_INFO_KIND_FREE;
        } else {
            // variable is declared in this scope, so finish
            switch (id->kind) {
                case ID_INFO_KIND_LOCAL: id->kind = ID_INFO_KIND_CELL; break; // variable local to this scope, close it over
                case ID_INFO_KIND_FREE: break; // variable already closed over in a parent scope
                case ID_INFO_KIND_CELL: break; // variable already closed over in this scope
                default: assert(0); // TODO
            }
            return;
        }
    }
    assert(0); // we should have found the variable in one of the parents
}

#endif // MICROPY_ENABLE_COMPILER
/*
 * This file is part of the Micro Python project, http://micropython.org/
 *
 * The MIT License (MIT)
 *
 * Copyright (c) 2013, 2014 Damien P. George
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

#include <assert.h>

//#include "py/emit.h"

#if MICROPY_ENABLE_COMPILER

void micropy_emit_common_get_id_for_load(struct _mp_state_ctx_t *mp_state, scope_t *scope, qstr qst) {
    // name adding/lookup
    bool added;
    id_info_t *id = micropy_scope_find_or_add_id(mp_state, scope, qst, &added);
    if (added) {
        id_info_t *id2 = micropy_scope_find_local_in_parent(mp_state, scope, qst);
        if (id2 != NULL && (id2->kind == ID_INFO_KIND_LOCAL || id2->kind == ID_INFO_KIND_CELL || id2->kind == ID_INFO_KIND_FREE)) {
            id->kind = ID_INFO_KIND_FREE;
            micropy_scope_close_over_in_parents(mp_state, scope, qst);
        } else {
            id->kind = ID_INFO_KIND_GLOBAL_IMPLICIT;
        }
    }
}

void micropy_emit_common_get_id_for_modification(struct _mp_state_ctx_t *mp_state, scope_t *scope, qstr qst) {
    // name adding/lookup
    bool added;
    id_info_t *id = micropy_scope_find_or_add_id(mp_state, scope, qst, &added);
    if (added) {
        if (scope->kind == SCOPE_MODULE || scope->kind == SCOPE_CLASS) {
            id->kind = ID_INFO_KIND_GLOBAL_IMPLICIT;
        } else {
            id->kind = ID_INFO_KIND_LOCAL;
        }
    } else if (scope->kind >= SCOPE_FUNCTION && scope->kind <= SCOPE_GEN_EXPR && id->kind == ID_INFO_KIND_GLOBAL_IMPLICIT) {
        // rebind as a local variable
        id->kind = ID_INFO_KIND_LOCAL;
    }
}

void micropy_emit_common_id_op(struct _mp_state_ctx_t *mp_state, emit_t *emit, const mp_emit_method_table_id_ops_t *emit_method_table, scope_t *scope, qstr qst) {
    // assumes pass is greater than 1, ie that all identifiers are defined in the scope

    id_info_t *id = micropy_scope_find(mp_state, scope, qst);
    assert(id != NULL);

    // call the emit backend with the correct code
    if (id->kind == ID_INFO_KIND_GLOBAL_IMPLICIT) {
        emit_method_table->name(mp_state, emit, qst);
    } else if (id->kind == ID_INFO_KIND_GLOBAL_EXPLICIT) {
        emit_method_table->global(mp_state, emit, qst);
    } else if (id->kind == ID_INFO_KIND_LOCAL) {
        emit_method_table->fast(mp_state, emit, qst, id->local_num);
    } else {
        assert(id->kind == ID_INFO_KIND_CELL || id->kind == ID_INFO_KIND_FREE);
        emit_method_table->deref(mp_state, emit, qst, id->local_num);
    }
}

#endif // MICROPY_ENABLE_COMPILER
/*
 * This file is part of the Micro Python project, http://micropython.org/
 *
 * The MIT License (MIT)
 *
 * Copyright (c) 2013, 2014 Damien P. George
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <string.h>
#include <assert.h>

//#include "py/mpstate.h"
//#include "py/emit.h"
//#include "py/bc0.h"

#if MICROPY_ENABLE_COMPILER

#define BYTES_FOR_INT ((BYTES_PER_WORD * 8 + 6) / 7)
#define DUMMY_DATA_SIZE (BYTES_FOR_INT)

struct _emit_t {
    // Accessed as mp_obj_t, so must be aligned as such, and we rely on the
    // memory allocator returning a suitably aligned pointer.
    // Should work for cases when mp_obj_t is 64-bit on a 32-bit machine.
    byte dummy_data[DUMMY_DATA_SIZE];

    pass_kind_t pass : 8;
    mp_uint_t last_emit_was_return_value : 8;

    int stack_size;

    scope_t *scope;

    mp_uint_t last_source_line_offset;
    mp_uint_t last_source_line;

    mp_uint_t max_num_labels;
    mp_uint_t *label_offsets;

    size_t code_info_offset;
    size_t code_info_size;
    size_t bytecode_offset;
    size_t bytecode_size;
    byte *code_base; // stores both byte code and code info

    #if MICROPY_PERSISTENT_CODE
    uint16_t ct_cur_obj;
    uint16_t ct_num_obj;
    uint16_t ct_cur_raw_code;
    #endif
    mp_uint_t *const_table;
};

emit_t *micropy_emit_bc_new(struct _mp_state_ctx_t *mp_state) {
    emit_t *emit = micropy_m_new0(mp_state, emit_t, 1);
    return emit;
}

void micropy_emit_bc_set_max_num_labels(struct _mp_state_ctx_t *mp_state, emit_t *emit, mp_uint_t max_num_labels) {
    emit->max_num_labels = max_num_labels;
    emit->label_offsets = micropy_m_new(mp_state, mp_uint_t, emit->max_num_labels);
}

void micropy_emit_bc_free(struct _mp_state_ctx_t *mp_state, emit_t *emit) {
    micropy_m_del(mp_state, mp_uint_t, emit->label_offsets, emit->max_num_labels);
    micropy_m_del_obj(mp_state, emit_t, emit);
}

typedef byte *(*emit_allocator_t)(struct _mp_state_ctx_t *mp_state, emit_t *emit, int nbytes);

STATIC void micropy_emit_write_uint(struct _mp_state_ctx_t *mp_state, emit_t *emit, emit_allocator_t allocator, mp_uint_t val) {
    // We store each 7 bits in a separate byte, and that's how many bytes needed
    byte buf[BYTES_FOR_INT];
    byte *p = buf + sizeof(buf);
    // We encode in little-ending order, but store in big-endian, to help decoding
    do {
        *--p = val & 0x7f;
        val >>= 7;
    } while (val != 0);
    byte *c = allocator(mp_state, emit, buf + sizeof(buf) - p);
    while (p != buf + sizeof(buf) - 1) {
        *c++ = *p++ | 0x80;
    }
    *c = *p;
}

// all functions must go through this one to emit code info
STATIC byte *micropy_emit_get_cur_to_write_code_info(struct _mp_state_ctx_t *mp_state, emit_t *emit, int num_bytes_to_write) {
    //printf("emit %d\n", num_bytes_to_write);
    if (emit->pass < MP_PASS_EMIT) {
        emit->code_info_offset += num_bytes_to_write;
        return emit->dummy_data;
    } else {
        assert(emit->code_info_offset + num_bytes_to_write <= emit->code_info_size);
        byte *c = emit->code_base + emit->code_info_offset;
        emit->code_info_offset += num_bytes_to_write;
        return c;
    }
}

STATIC void micropy_emit_write_code_info_byte(struct _mp_state_ctx_t *mp_state, emit_t* emit, byte val) {
    *micropy_emit_get_cur_to_write_code_info(mp_state, emit, 1) = val;
}

STATIC void micropy_emit_write_code_info_uint(struct _mp_state_ctx_t *mp_state, emit_t* emit, mp_uint_t val) {
    micropy_emit_write_uint(mp_state, emit, micropy_emit_get_cur_to_write_code_info, val);
}

STATIC void micropy_emit_write_code_info_qstr(struct _mp_state_ctx_t *mp_state, emit_t *emit, qstr qst) {
    #if MICROPY_PERSISTENT_CODE
    assert((qst >> 16) == 0);
    byte *c = micropy_emit_get_cur_to_write_code_info(mp_state, emit, 2);
    c[0] = qst;
    c[1] = qst >> 8;
    #else
    micropy_emit_write_uint(mp_state, emit, micropy_emit_get_cur_to_write_code_info, qst);
    #endif
}

#if MICROPY_ENABLE_SOURCE_LINE
STATIC void micropy_emit_write_code_info_bytes_lines(struct _mp_state_ctx_t *mp_state, emit_t *emit, mp_uint_t bytes_to_skip, mp_uint_t lines_to_skip) {
    assert(bytes_to_skip > 0 || lines_to_skip > 0);
    //printf("  %d %d\n", bytes_to_skip, lines_to_skip);
    while (bytes_to_skip > 0 || lines_to_skip > 0) {
        mp_uint_t b, l;
        if (lines_to_skip <= 6) {
            // use 0b0LLBBBBB encoding
            b = MIN(bytes_to_skip, 0x1f);
            l = MIN(lines_to_skip, 0x3);
            *micropy_emit_get_cur_to_write_code_info(mp_state, emit, 1) = b | (l << 5);
        } else {
            // use 0b1LLLBBBB 0bLLLLLLLL encoding (l's LSB in second byte)
            b = MIN(bytes_to_skip, 0xf);
            l = MIN(lines_to_skip, 0x7ff);
            byte *ci = micropy_emit_get_cur_to_write_code_info(mp_state, emit, 2);
            ci[0] = 0x80 | b | ((l >> 4) & 0x70);
            ci[1] = l;
        }
        bytes_to_skip -= b;
        lines_to_skip -= l;
    }
}
#endif

// all functions must go through this one to emit byte code
STATIC byte *micropy_emit_get_cur_to_write_bytecode(struct _mp_state_ctx_t *mp_state, emit_t *emit, int num_bytes_to_write) {
    //printf("emit %d\n", num_bytes_to_write);
    if (emit->pass < MP_PASS_EMIT) {
        emit->bytecode_offset += num_bytes_to_write;
        return emit->dummy_data;
    } else {
        assert(emit->bytecode_offset + num_bytes_to_write <= emit->bytecode_size);
        byte *c = emit->code_base + emit->code_info_size + emit->bytecode_offset;
        emit->bytecode_offset += num_bytes_to_write;
        return c;
    }
}

STATIC void micropy_emit_write_bytecode_byte(struct _mp_state_ctx_t *mp_state, emit_t *emit, byte b1) {
    byte *c = micropy_emit_get_cur_to_write_bytecode(mp_state, emit, 1);
    c[0] = b1;
}

STATIC void micropy_emit_write_bytecode_byte_byte(struct _mp_state_ctx_t *mp_state, emit_t* emit, byte b1, byte b2) {
    assert((b2 & (~0xff)) == 0);
    byte *c = micropy_emit_get_cur_to_write_bytecode(mp_state, emit, 2);
    c[0] = b1;
    c[1] = b2;
}

// Similar to emit_write_bytecode_uint(), just some extra handling to encode sign
STATIC void micropy_emit_write_bytecode_byte_int(struct _mp_state_ctx_t *mp_state, emit_t *emit, byte b1, mp_int_t num) {
    micropy_emit_write_bytecode_byte(mp_state, emit, b1);

    // We store each 7 bits in a separate byte, and that's how many bytes needed
    byte buf[BYTES_FOR_INT];
    byte *p = buf + sizeof(buf);
    // We encode in little-ending order, but store in big-endian, to help decoding
    do {
        *--p = num & 0x7f;
        num >>= 7;
    } while (num != 0 && num != -1);
    // Make sure that highest bit we stored (mask 0x40) matches sign
    // of the number. If not, store extra byte just to encode sign
    if (num == -1 && (*p & 0x40) == 0) {
        *--p = 0x7f;
    } else if (num == 0 && (*p & 0x40) != 0) {
        *--p = 0;
    }

    byte *c = micropy_emit_get_cur_to_write_bytecode(mp_state, emit, buf + sizeof(buf) - p);
    while (p != buf + sizeof(buf) - 1) {
        *c++ = *p++ | 0x80;
    }
    *c = *p;
}

STATIC void micropy_emit_write_bytecode_byte_uint(struct _mp_state_ctx_t *mp_state, emit_t *emit, byte b, mp_uint_t val) {
    micropy_emit_write_bytecode_byte(mp_state, emit, b);
    micropy_emit_write_uint(mp_state, emit, micropy_emit_get_cur_to_write_bytecode, val);
}

#if MICROPY_PERSISTENT_CODE
STATIC void micropy_emit_write_bytecode_byte_const(struct _mp_state_ctx_t *mp_state, emit_t *emit, byte b, mp_uint_t n, mp_uint_t c) {
    if (emit->pass == MP_PASS_EMIT) {
        emit->const_table[n] = c;
    }
    micropy_emit_write_bytecode_byte_uint(mp_state, emit, b, n);
}
#endif

STATIC void micropy_emit_write_bytecode_byte_qstr(struct _mp_state_ctx_t *mp_state, emit_t* emit, byte b, qstr qst) {
    #if MICROPY_PERSISTENT_CODE
    assert((qst >> 16) == 0);
    byte *c = micropy_emit_get_cur_to_write_bytecode(mp_state, emit, 3);
    c[0] = b;
    c[1] = qst;
    c[2] = qst >> 8;
    #else
    micropy_emit_write_bytecode_byte_uint(mp_state, emit, b, qst);
    #endif
}

STATIC void micropy_emit_write_bytecode_byte_obj(struct _mp_state_ctx_t *mp_state, emit_t *emit, byte b, mp_obj_t obj) {
    #if MICROPY_PERSISTENT_CODE
    micropy_emit_write_bytecode_byte_const(mp_state, emit, b,
        emit->scope->num_pos_args + emit->scope->num_kwonly_args
        + emit->ct_cur_obj++, (mp_uint_t)obj);
    #else
    // aligns the pointer so it is friendly to GC
    micropy_emit_write_bytecode_byte(mp_state, emit, b);
    emit->bytecode_offset = (size_t)MP_ALIGN(emit->bytecode_offset, sizeof(mp_obj_t));
    mp_obj_t *c = (mp_obj_t*)micropy_emit_get_cur_to_write_bytecode(mp_state, emit, sizeof(mp_obj_t));
    // Verify thar c is already uint-aligned
    assert(c == MP_ALIGN(c, sizeof(mp_obj_t)));
    *c = obj;
    #endif
}

STATIC void micropy_emit_write_bytecode_byte_raw_code(struct _mp_state_ctx_t *mp_state, emit_t *emit, byte b, mp_raw_code_t *rc) {
    #if MICROPY_PERSISTENT_CODE
    micropy_emit_write_bytecode_byte_const(mp_state, emit, b,
        emit->scope->num_pos_args + emit->scope->num_kwonly_args
        + emit->ct_num_obj + emit->ct_cur_raw_code++, (mp_uint_t)(uintptr_t)rc);
    #else
    // aligns the pointer so it is friendly to GC
    micropy_emit_write_bytecode_byte(mp_state, emit, b);
    emit->bytecode_offset = (size_t)MP_ALIGN(emit->bytecode_offset, sizeof(void*));
    void **c = (void**)micropy_emit_get_cur_to_write_bytecode(mp_state, emit, sizeof(void*));
    // Verify thar c is already uint-aligned
    assert(c == MP_ALIGN(c, sizeof(void*)));
    *c = rc;
    #endif
}

// unsigned labels are relative to ip following this instruction, stored as 16 bits
STATIC void micropy_emit_write_bytecode_byte_unsigned_label(struct _mp_state_ctx_t *mp_state, emit_t *emit, byte b1, mp_uint_t label) {
    mp_uint_t bytecode_offset;
    if (emit->pass < MP_PASS_EMIT) {
        bytecode_offset = 0;
    } else {
        bytecode_offset = emit->label_offsets[label] - emit->bytecode_offset - 3;
    }
    byte *c = micropy_emit_get_cur_to_write_bytecode(mp_state, emit, 3);
    c[0] = b1;
    c[1] = bytecode_offset;
    c[2] = bytecode_offset >> 8;
}

// signed labels are relative to ip following this instruction, stored as 16 bits, in excess
STATIC void micropy_emit_write_bytecode_byte_signed_label(struct _mp_state_ctx_t *mp_state, emit_t *emit, byte b1, mp_uint_t label) {
    int bytecode_offset;
    if (emit->pass < MP_PASS_EMIT) {
        bytecode_offset = 0;
    } else {
        bytecode_offset = emit->label_offsets[label] - emit->bytecode_offset - 3 + 0x8000;
    }
    byte *c = micropy_emit_get_cur_to_write_bytecode(mp_state, emit, 3);
    c[0] = b1;
    c[1] = bytecode_offset;
    c[2] = bytecode_offset >> 8;
}

#if MICROPY_EMIT_NATIVE
STATIC void micropy_emit_bc_set_native_type(struct _mp_state_ctx_t *mp_state, emit_t *emit, mp_uint_t op, mp_uint_t arg1, qstr arg2) {
    (void)emit;
    (void)op;
    (void)arg1;
    (void)arg2;
}
#endif

void micropy_emit_bc_start_pass(struct _mp_state_ctx_t *mp_state, emit_t *emit, pass_kind_t pass, scope_t *scope) {
    emit->pass = pass;
    emit->stack_size = 0;
    emit->last_emit_was_return_value = false;
    emit->scope = scope;
    emit->last_source_line_offset = 0;
    emit->last_source_line = 1;
    if (pass < MP_PASS_EMIT) {
        memset(emit->label_offsets, -1, emit->max_num_labels * sizeof(mp_uint_t));
    }
    emit->bytecode_offset = 0;
    emit->code_info_offset = 0;

    // Write local state size and exception stack size.
    {
        mp_uint_t n_state = scope->num_locals + scope->stack_size;
        if (n_state == 0) {
            // Need at least 1 entry in the state, in the case an exception is
            // propagated through this function, the exception is returned in
            // the highest slot in the state (fastn[0], see vm.c).
            n_state = 1;
        }
        micropy_emit_write_code_info_uint(mp_state, emit, n_state);
        micropy_emit_write_code_info_uint(mp_state, emit, scope->exc_stack_size);
    }

    // Write scope flags and number of arguments.
    // TODO check that num args all fit in a byte
    micropy_emit_write_code_info_byte(mp_state, emit, emit->scope->scope_flags);
    micropy_emit_write_code_info_byte(mp_state, emit, emit->scope->num_pos_args);
    micropy_emit_write_code_info_byte(mp_state, emit, emit->scope->num_kwonly_args);
    micropy_emit_write_code_info_byte(mp_state, emit, emit->scope->num_def_pos_args);

    // Write size of the rest of the code info.  We don't know how big this
    // variable uint will be on the MP_PASS_CODE_SIZE pass so we reserve 2 bytes
    // for it and hope that is enough!  TODO assert this or something.
    if (pass == MP_PASS_EMIT) {
        micropy_emit_write_code_info_uint(mp_state, emit, emit->code_info_size - emit->code_info_offset);
    } else  {
        micropy_emit_get_cur_to_write_code_info(mp_state, emit, 2);
    }

    // Write the name and source file of this function.
    micropy_emit_write_code_info_qstr(mp_state, emit, scope->simple_name);
    micropy_emit_write_code_info_qstr(mp_state, emit, scope->source_file);

    // bytecode prelude: initialise closed over variables
    for (int i = 0; i < scope->id_info_len; i++) {
        id_info_t *id = &scope->id_info[i];
        if (id->kind == ID_INFO_KIND_CELL) {
            assert(id->local_num < 255);
            micropy_emit_write_bytecode_byte(mp_state, emit, id->local_num); // write the local which should be converted to a cell
        }
    }
    micropy_emit_write_bytecode_byte(mp_state, emit, 255); // end of list sentinel

    #if MICROPY_PERSISTENT_CODE
    emit->ct_cur_obj = 0;
    emit->ct_cur_raw_code = 0;
    #endif

    if (pass == MP_PASS_EMIT) {
        // Write argument names (needed to resolve positional args passed as
        // keywords).  We store them as full word-sized objects for efficient access
        // in mp_setup_code_state this is the start of the prelude and is guaranteed
        // to be aligned on a word boundary.

        // For a given argument position (indexed by i) we need to find the
        // corresponding id_info which is a parameter, as it has the correct
        // qstr name to use as the argument name.  Note that it's not a simple
        // 1-1 mapping (ie i!=j in general) because of possible closed-over
        // variables.  In the case that the argument i has no corresponding
        // parameter we use "*" as its name (since no argument can ever be named
        // "*").  We could use a blank qstr but "*" is better for debugging.
        // Note: there is some wasted RAM here for the case of storing a qstr
        // for each closed-over variable, and maybe there is a better way to do
        // it, but that would require changes to mp_setup_code_state.
        for (int i = 0; i < scope->num_pos_args + scope->num_kwonly_args; i++) {
            qstr qst = MP_QSTR__star_;
            for (int j = 0; j < scope->id_info_len; ++j) {
                id_info_t *id = &scope->id_info[j];
                if ((id->flags & ID_FLAG_IS_PARAM) && id->local_num == i) {
                    qst = id->qst;
                    break;
                }
            }
            emit->const_table[i] = (mp_uint_t)MP_OBJ_NEW_QSTR(qst);
        }
    }
}

void micropy_emit_bc_end_pass(struct _mp_state_ctx_t *mp_state, emit_t *emit) {
    if (emit->pass == MP_PASS_SCOPE) {
        return;
    }

    // check stack is back to zero size
    if (emit->stack_size != 0) {
        micropy_printf(mp_state, &mp_plat_print, "ERROR: stack size not back to zero; got %d\n", emit->stack_size);
    }

    micropy_emit_write_code_info_byte(mp_state, emit, 0); // end of line number info

    #if MICROPY_PERSISTENT_CODE
    assert(emit->pass <= MP_PASS_STACK_SIZE || (emit->ct_num_obj == emit->ct_cur_obj));
    emit->ct_num_obj = emit->ct_cur_obj;
    #endif

    if (emit->pass == MP_PASS_CODE_SIZE) {
        #if !MICROPY_PERSISTENT_CODE
        // so bytecode is aligned
        emit->code_info_offset = (size_t)MP_ALIGN(emit->code_info_offset, sizeof(mp_uint_t));
        #endif

        // calculate size of total code-info + bytecode, in bytes
        emit->code_info_size = emit->code_info_offset;
        emit->bytecode_size = emit->bytecode_offset;
        emit->code_base = micropy_m_new0(mp_state, byte, emit->code_info_size + emit->bytecode_size);

        #if MICROPY_PERSISTENT_CODE
        emit->const_table = micropy_m_new0(mp_state, mp_uint_t,
            emit->scope->num_pos_args + emit->scope->num_kwonly_args
            + emit->ct_cur_obj + emit->ct_cur_raw_code);
        #else
        emit->const_table = micropy_m_new0(mp_state, mp_uint_t,
            emit->scope->num_pos_args + emit->scope->num_kwonly_args);
        #endif

    } else if (emit->pass == MP_PASS_EMIT) {
        micropy_emit_glue_assign_bytecode(mp_state, emit->scope->raw_code, emit->code_base,
            emit->code_info_size + emit->bytecode_size,
            emit->const_table,
            #if MICROPY_PERSISTENT_CODE_SAVE
            emit->ct_cur_obj, emit->ct_cur_raw_code,
            #endif
            emit->scope->scope_flags);
    }
}

bool micropy_emit_bc_last_emit_was_return_value(struct _mp_state_ctx_t *mp_state, emit_t *emit) {
    return emit->last_emit_was_return_value;
}

void micropy_emit_bc_adjust_stack_size(struct _mp_state_ctx_t *mp_state, emit_t *emit, mp_int_t delta) {
    emit->stack_size += delta;
}

void micropy_emit_bc_set_source_line(struct _mp_state_ctx_t *mp_state, emit_t *emit, mp_uint_t source_line) {
    //printf("source: line %d -> %d  offset %d -> %d\n", emit->last_source_line, source_line, emit->last_source_line_offset, emit->bytecode_offset);
#if MICROPY_ENABLE_SOURCE_LINE
    if ((mp_state)->vm.mp_optimise_value >= 3) {
        // If we compile with -O3, don't store line numbers.
        return;
    }
    if (source_line > emit->last_source_line) {
        mp_uint_t bytes_to_skip = emit->bytecode_offset - emit->last_source_line_offset;
        mp_uint_t lines_to_skip = source_line - emit->last_source_line;
        micropy_emit_write_code_info_bytes_lines(mp_state, emit, bytes_to_skip, lines_to_skip);
        emit->last_source_line_offset = emit->bytecode_offset;
        emit->last_source_line = source_line;
    }
#else
    (void)emit;
    (void)source_line;
#endif
}

STATIC void micropy_emit_bc_pre(struct _mp_state_ctx_t *mp_state, emit_t *emit, mp_int_t stack_size_delta) {
    if (emit->pass == MP_PASS_SCOPE) {
        return;
    }
    assert((mp_int_t)emit->stack_size + stack_size_delta >= 0);
    emit->stack_size += stack_size_delta;
    if (emit->stack_size > emit->scope->stack_size) {
        emit->scope->stack_size = emit->stack_size;
    }
    emit->last_emit_was_return_value = false;
}

void micropy_emit_bc_label_assign(struct _mp_state_ctx_t *mp_state, emit_t *emit, mp_uint_t l) {
    micropy_emit_bc_pre(mp_state, emit, 0);
    if (emit->pass == MP_PASS_SCOPE) {
        return;
    }
    assert(l < emit->max_num_labels);
    if (emit->pass < MP_PASS_EMIT) {
        // assign label offset
        assert(emit->label_offsets[l] == (mp_uint_t)-1);
        emit->label_offsets[l] = emit->bytecode_offset;
    } else {
        // ensure label offset has not changed from MP_PASS_CODE_SIZE to MP_PASS_EMIT
        //printf("l%d: (at %d vs %d)\n", l, emit->bytecode_offset, emit->label_offsets[l]);
        assert(emit->label_offsets[l] == emit->bytecode_offset);
    }
}

void micropy_emit_bc_import_name(struct _mp_state_ctx_t *mp_state, emit_t *emit, qstr qst) {
    micropy_emit_bc_pre(mp_state, emit, -1);
    micropy_emit_write_bytecode_byte_qstr(mp_state, emit, MP_BC_IMPORT_NAME, qst);
}

void micropy_emit_bc_import_from(struct _mp_state_ctx_t *mp_state, emit_t *emit, qstr qst) {
    micropy_emit_bc_pre(mp_state, emit, 1);
    micropy_emit_write_bytecode_byte_qstr(mp_state, emit, MP_BC_IMPORT_FROM, qst);
}

void micropy_emit_bc_import_star(struct _mp_state_ctx_t *mp_state, emit_t *emit) {
    micropy_emit_bc_pre(mp_state, emit, -1);
    micropy_emit_write_bytecode_byte(mp_state, emit, MP_BC_IMPORT_STAR);
}

void micropy_emit_bc_load_const_tok(struct _mp_state_ctx_t *mp_state, emit_t *emit, mp_token_kind_t tok) {
    micropy_emit_bc_pre(mp_state, emit, 1);
    switch (tok) {
        case MP_TOKEN_KW_FALSE: micropy_emit_write_bytecode_byte(mp_state, emit, MP_BC_LOAD_CONST_FALSE); break;
        case MP_TOKEN_KW_NONE: micropy_emit_write_bytecode_byte(mp_state, emit, MP_BC_LOAD_CONST_NONE); break;
        case MP_TOKEN_KW_TRUE: micropy_emit_write_bytecode_byte(mp_state, emit, MP_BC_LOAD_CONST_TRUE); break;
        no_other_choice:
        case MP_TOKEN_ELLIPSIS: micropy_emit_write_bytecode_byte_obj(mp_state, emit, MP_BC_LOAD_CONST_OBJ, MP_OBJ_FROM_PTR(&mp_const_ellipsis_obj)); break;
        default: assert(0); goto no_other_choice; // to help flow control analysis
    }
}

void micropy_emit_bc_load_const_small_int(struct _mp_state_ctx_t *mp_state, emit_t *emit, mp_int_t arg) {
    micropy_emit_bc_pre(mp_state, emit, 1);
    if (-16 <= arg && arg <= 47) {
        micropy_emit_write_bytecode_byte(mp_state, emit, MP_BC_LOAD_CONST_SMALL_INT_MULTI + 16 + arg);
    } else {
        micropy_emit_write_bytecode_byte_int(mp_state, emit, MP_BC_LOAD_CONST_SMALL_INT, arg);
    }
}

void micropy_emit_bc_load_const_str(struct _mp_state_ctx_t *mp_state, emit_t *emit, qstr qst) {
    micropy_emit_bc_pre(mp_state, emit, 1);
    micropy_emit_write_bytecode_byte_qstr(mp_state, emit, MP_BC_LOAD_CONST_STRING, qst);
}

void micropy_emit_bc_load_const_obj(struct _mp_state_ctx_t *mp_state, emit_t *emit, mp_obj_t obj) {
    micropy_emit_bc_pre(mp_state, emit, 1);
    micropy_emit_write_bytecode_byte_obj(mp_state, emit, MP_BC_LOAD_CONST_OBJ, obj);
}

void micropy_emit_bc_load_null(struct _mp_state_ctx_t *mp_state, emit_t *emit) {
    micropy_emit_bc_pre(mp_state, emit, 1);
    micropy_emit_write_bytecode_byte(mp_state, emit, MP_BC_LOAD_NULL);
};

void micropy_emit_bc_load_fast(struct _mp_state_ctx_t *mp_state, emit_t *emit, qstr qst, mp_uint_t local_num) {
    (void)qst;
    assert(local_num >= 0);
    micropy_emit_bc_pre(mp_state, emit, 1);
    if (local_num <= 15) {
        micropy_emit_write_bytecode_byte(mp_state, emit, MP_BC_LOAD_FAST_MULTI + local_num);
    } else {
        micropy_emit_write_bytecode_byte_uint(mp_state, emit, MP_BC_LOAD_FAST_N, local_num);
    }
}

void micropy_emit_bc_load_deref(struct _mp_state_ctx_t *mp_state, emit_t *emit, qstr qst, mp_uint_t local_num) {
    (void)qst;
    micropy_emit_bc_pre(mp_state, emit, 1);
    micropy_emit_write_bytecode_byte_uint(mp_state, emit, MP_BC_LOAD_DEREF, local_num);
}

void micropy_emit_bc_load_name(struct _mp_state_ctx_t *mp_state, emit_t *emit, qstr qst) {
    (void)qst;
    micropy_emit_bc_pre(mp_state, emit, 1);
    micropy_emit_write_bytecode_byte_qstr(mp_state, emit, MP_BC_LOAD_NAME, qst);
    if (MICROPY_OPT_CACHE_MAP_LOOKUP_IN_BYTECODE_DYNAMIC) {
        micropy_emit_write_bytecode_byte(mp_state, emit, 0);
    }
}

void micropy_emit_bc_load_global(struct _mp_state_ctx_t *mp_state, emit_t *emit, qstr qst) {
    (void)qst;
    micropy_emit_bc_pre(mp_state, emit, 1);
    micropy_emit_write_bytecode_byte_qstr(mp_state, emit, MP_BC_LOAD_GLOBAL, qst);
    if (MICROPY_OPT_CACHE_MAP_LOOKUP_IN_BYTECODE_DYNAMIC) {
        micropy_emit_write_bytecode_byte(mp_state, emit, 0);
    }
}

void micropy_emit_bc_load_attr(struct _mp_state_ctx_t *mp_state, emit_t *emit, qstr qst) {
    micropy_emit_bc_pre(mp_state, emit, 0);
    micropy_emit_write_bytecode_byte_qstr(mp_state, emit, MP_BC_LOAD_ATTR, qst);
    if (MICROPY_OPT_CACHE_MAP_LOOKUP_IN_BYTECODE_DYNAMIC) {
        micropy_emit_write_bytecode_byte(mp_state, emit, 0);
    }
}

void micropy_emit_bc_load_method(struct _mp_state_ctx_t *mp_state, emit_t *emit, qstr qst) {
    micropy_emit_bc_pre(mp_state, emit, 1);
    micropy_emit_write_bytecode_byte_qstr(mp_state, emit, MP_BC_LOAD_METHOD, qst);
}

void micropy_emit_bc_load_build_class(struct _mp_state_ctx_t *mp_state, emit_t *emit) {
    micropy_emit_bc_pre(mp_state, emit, 1);
    micropy_emit_write_bytecode_byte(mp_state, emit, MP_BC_LOAD_BUILD_CLASS);
}

void micropy_emit_bc_load_subscr(struct _mp_state_ctx_t *mp_state, emit_t *emit) {
    micropy_emit_bc_pre(mp_state, emit, -1);
    micropy_emit_write_bytecode_byte(mp_state, emit, MP_BC_LOAD_SUBSCR);
}

void micropy_emit_bc_store_fast(struct _mp_state_ctx_t *mp_state, emit_t *emit, qstr qst, mp_uint_t local_num) {
    (void)qst;
    assert(local_num >= 0);
    micropy_emit_bc_pre(mp_state, emit, -1);
    if (local_num <= 15) {
        micropy_emit_write_bytecode_byte(mp_state, emit, MP_BC_STORE_FAST_MULTI + local_num);
    } else {
        micropy_emit_write_bytecode_byte_uint(mp_state, emit, MP_BC_STORE_FAST_N, local_num);
    }
}

void micropy_emit_bc_store_deref(struct _mp_state_ctx_t *mp_state, emit_t *emit, qstr qst, mp_uint_t local_num) {
    (void)qst;
    micropy_emit_bc_pre(mp_state, emit, -1);
    micropy_emit_write_bytecode_byte_uint(mp_state, emit, MP_BC_STORE_DEREF, local_num);
}

void micropy_emit_bc_store_name(struct _mp_state_ctx_t *mp_state, emit_t *emit, qstr qst) {
    micropy_emit_bc_pre(mp_state, emit, -1);
    micropy_emit_write_bytecode_byte_qstr(mp_state, emit, MP_BC_STORE_NAME, qst);
}

void micropy_emit_bc_store_global(struct _mp_state_ctx_t *mp_state, emit_t *emit, qstr qst) {
    micropy_emit_bc_pre(mp_state, emit, -1);
    micropy_emit_write_bytecode_byte_qstr(mp_state, emit, MP_BC_STORE_GLOBAL, qst);
}

void micropy_emit_bc_store_attr(struct _mp_state_ctx_t *mp_state, emit_t *emit, qstr qst) {
    micropy_emit_bc_pre(mp_state, emit, -2);
    micropy_emit_write_bytecode_byte_qstr(mp_state, emit, MP_BC_STORE_ATTR, qst);
    if (MICROPY_OPT_CACHE_MAP_LOOKUP_IN_BYTECODE_DYNAMIC) {
        micropy_emit_write_bytecode_byte(mp_state, emit, 0);
    }
}

void micropy_emit_bc_store_subscr(struct _mp_state_ctx_t *mp_state, emit_t *emit) {
    micropy_emit_bc_pre(mp_state, emit, -3);
    micropy_emit_write_bytecode_byte(mp_state, emit, MP_BC_STORE_SUBSCR);
}

void micropy_emit_bc_delete_fast(struct _mp_state_ctx_t *mp_state, emit_t *emit, qstr qst, mp_uint_t local_num) {
    (void)qst;
    micropy_emit_write_bytecode_byte_uint(mp_state, emit, MP_BC_DELETE_FAST, local_num);
}

void micropy_emit_bc_delete_deref(struct _mp_state_ctx_t *mp_state, emit_t *emit, qstr qst, mp_uint_t local_num) {
    (void)qst;
    micropy_emit_write_bytecode_byte_uint(mp_state, emit, MP_BC_DELETE_DEREF, local_num);
}

void micropy_emit_bc_delete_name(struct _mp_state_ctx_t *mp_state, emit_t *emit, qstr qst) {
    micropy_emit_bc_pre(mp_state, emit, 0);
    micropy_emit_write_bytecode_byte_qstr(mp_state, emit, MP_BC_DELETE_NAME, qst);
}

void micropy_emit_bc_delete_global(struct _mp_state_ctx_t *mp_state, emit_t *emit, qstr qst) {
    micropy_emit_bc_pre(mp_state, emit, 0);
    micropy_emit_write_bytecode_byte_qstr(mp_state, emit, MP_BC_DELETE_GLOBAL, qst);
}

void micropy_emit_bc_delete_attr(struct _mp_state_ctx_t *mp_state, emit_t *emit, qstr qst) {
    micropy_emit_bc_load_null(mp_state, emit);
    micropy_emit_bc_rot_two(mp_state, emit);
    micropy_emit_bc_store_attr(mp_state, emit, qst);
}

void micropy_emit_bc_delete_subscr(struct _mp_state_ctx_t *mp_state, emit_t *emit) {
    micropy_emit_bc_load_null(mp_state, emit);
    micropy_emit_bc_rot_three(mp_state, emit);
    micropy_emit_bc_store_subscr(mp_state, emit);
}

void micropy_emit_bc_dup_top(struct _mp_state_ctx_t *mp_state, emit_t *emit) {
    micropy_emit_bc_pre(mp_state, emit, 1);
    micropy_emit_write_bytecode_byte(mp_state, emit, MP_BC_DUP_TOP);
}

void micropy_emit_bc_dup_top_two(struct _mp_state_ctx_t *mp_state, emit_t *emit) {
    micropy_emit_bc_pre(mp_state, emit, 2);
    micropy_emit_write_bytecode_byte(mp_state, emit, MP_BC_DUP_TOP_TWO);
}

void micropy_emit_bc_pop_top(struct _mp_state_ctx_t *mp_state, emit_t *emit) {
    micropy_emit_bc_pre(mp_state, emit, -1);
    micropy_emit_write_bytecode_byte(mp_state, emit, MP_BC_POP_TOP);
}

void micropy_emit_bc_rot_two(struct _mp_state_ctx_t *mp_state, emit_t *emit) {
    micropy_emit_bc_pre(mp_state, emit, 0);
    micropy_emit_write_bytecode_byte(mp_state, emit, MP_BC_ROT_TWO);
}

void micropy_emit_bc_rot_three(struct _mp_state_ctx_t *mp_state, emit_t *emit) {
    micropy_emit_bc_pre(mp_state, emit, 0);
    micropy_emit_write_bytecode_byte(mp_state, emit, MP_BC_ROT_THREE);
}

void micropy_emit_bc_jump(struct _mp_state_ctx_t *mp_state, emit_t *emit, mp_uint_t label) {
    micropy_emit_bc_pre(mp_state, emit, 0);
    micropy_emit_write_bytecode_byte_signed_label(mp_state, emit, MP_BC_JUMP, label);
}

void micropy_emit_bc_pop_jump_if(struct _mp_state_ctx_t *mp_state, emit_t *emit, bool cond, mp_uint_t label) {
    micropy_emit_bc_pre(mp_state, emit, -1);
    if (cond) {
        micropy_emit_write_bytecode_byte_signed_label(mp_state, emit, MP_BC_POP_JUMP_IF_TRUE, label);
    } else {
        micropy_emit_write_bytecode_byte_signed_label(mp_state, emit, MP_BC_POP_JUMP_IF_FALSE, label);
    }
}

void micropy_emit_bc_jump_if_or_pop(struct _mp_state_ctx_t *mp_state, emit_t *emit, bool cond, mp_uint_t label) {
    micropy_emit_bc_pre(mp_state, emit, -1);
    if (cond) {
        micropy_emit_write_bytecode_byte_signed_label(mp_state, emit, MP_BC_JUMP_IF_TRUE_OR_POP, label);
    } else {
        micropy_emit_write_bytecode_byte_signed_label(mp_state, emit, MP_BC_JUMP_IF_FALSE_OR_POP, label);
    }
}

void micropy_emit_bc_unwind_jump(struct _mp_state_ctx_t *mp_state, emit_t *emit, mp_uint_t label, mp_uint_t except_depth) {
    if (except_depth == 0) {
        micropy_emit_bc_pre(mp_state, emit, 0);
        if (label & MP_EMIT_BREAK_FROM_FOR) {
            // need to pop the iterator if we are breaking out of a for loop
            micropy_emit_write_bytecode_byte(mp_state, emit, MP_BC_POP_TOP);
        }
        micropy_emit_write_bytecode_byte_signed_label(mp_state, emit, MP_BC_JUMP, label & ~MP_EMIT_BREAK_FROM_FOR);
    } else {
        micropy_emit_write_bytecode_byte_signed_label(mp_state, emit, MP_BC_UNWIND_JUMP, label & ~MP_EMIT_BREAK_FROM_FOR);
        micropy_emit_write_bytecode_byte(mp_state, emit, ((label & MP_EMIT_BREAK_FROM_FOR) ? 0x80 : 0) | except_depth);
    }
}

void micropy_emit_bc_setup_with(struct _mp_state_ctx_t *mp_state, emit_t *emit, mp_uint_t label) {
    // TODO We can probably optimise the amount of needed stack space, since
    // we don't actually need 4 slots during the entire with block, only in
    // the cleanup handler in certain cases.  It needs some thinking.
    micropy_emit_bc_pre(mp_state, emit, 4);
    micropy_emit_write_bytecode_byte_unsigned_label(mp_state, emit, MP_BC_SETUP_WITH, label);
}

void micropy_emit_bc_with_cleanup(struct _mp_state_ctx_t *mp_state, emit_t *emit, mp_uint_t label) {
    micropy_emit_bc_pop_block(mp_state, emit);
    micropy_emit_bc_load_const_tok(mp_state, emit, MP_TOKEN_KW_NONE);
    micropy_emit_bc_label_assign(mp_state, emit, label);
    micropy_emit_bc_pre(mp_state, emit, -4);
    micropy_emit_write_bytecode_byte(mp_state, emit, MP_BC_WITH_CLEANUP);
}

void micropy_emit_bc_setup_except(struct _mp_state_ctx_t *mp_state, emit_t *emit, mp_uint_t label) {
    micropy_emit_bc_pre(mp_state, emit, 0);
    micropy_emit_write_bytecode_byte_unsigned_label(mp_state, emit, MP_BC_SETUP_EXCEPT, label);
}

void micropy_emit_bc_setup_finally(struct _mp_state_ctx_t *mp_state, emit_t *emit, mp_uint_t label) {
    micropy_emit_bc_pre(mp_state, emit, 0);
    micropy_emit_write_bytecode_byte_unsigned_label(mp_state, emit, MP_BC_SETUP_FINALLY, label);
}

void micropy_emit_bc_end_finally(struct _mp_state_ctx_t *mp_state, emit_t *emit) {
    micropy_emit_bc_pre(mp_state, emit, -1);
    micropy_emit_write_bytecode_byte(mp_state, emit, MP_BC_END_FINALLY);
}

void micropy_emit_bc_get_iter(struct _mp_state_ctx_t *mp_state, emit_t *emit) {
    micropy_emit_bc_pre(mp_state, emit, 0);
    micropy_emit_write_bytecode_byte(mp_state, emit, MP_BC_GET_ITER);
}

void micropy_emit_bc_for_iter(struct _mp_state_ctx_t *mp_state, emit_t *emit, mp_uint_t label) {
    micropy_emit_bc_pre(mp_state, emit, 1);
    micropy_emit_write_bytecode_byte_unsigned_label(mp_state, emit, MP_BC_FOR_ITER, label);
}

void micropy_emit_bc_for_iter_end(struct _mp_state_ctx_t *mp_state, emit_t *emit) {
    micropy_emit_bc_pre(mp_state, emit, -1);
}

void micropy_emit_bc_pop_block(struct _mp_state_ctx_t *mp_state, emit_t *emit) {
    micropy_emit_bc_pre(mp_state, emit, 0);
    micropy_emit_write_bytecode_byte(mp_state, emit, MP_BC_POP_BLOCK);
}

void micropy_emit_bc_pop_except(struct _mp_state_ctx_t *mp_state, emit_t *emit) {
    micropy_emit_bc_pre(mp_state, emit, 0);
    micropy_emit_write_bytecode_byte(mp_state, emit, MP_BC_POP_EXCEPT);
}

void micropy_emit_bc_unary_op(struct _mp_state_ctx_t *mp_state, emit_t *emit, mp_unary_op_t op) {
    micropy_emit_bc_pre(mp_state, emit, 0);
    micropy_emit_write_bytecode_byte(mp_state, emit, MP_BC_UNARY_OP_MULTI + op);
}

void micropy_emit_bc_binary_op(struct _mp_state_ctx_t *mp_state, emit_t *emit, mp_binary_op_t op) {
    bool invert = false;
    if (op == MP_BINARY_OP_NOT_IN) {
        invert = true;
        op = MP_BINARY_OP_IN;
    } else if (op == MP_BINARY_OP_IS_NOT) {
        invert = true;
        op = MP_BINARY_OP_IS;
    }
    micropy_emit_bc_pre(mp_state, emit, -1);
    micropy_emit_write_bytecode_byte(mp_state, emit, MP_BC_BINARY_OP_MULTI + op);
    if (invert) {
        micropy_emit_bc_pre(mp_state, emit, 0);
        micropy_emit_write_bytecode_byte(mp_state, emit, MP_BC_UNARY_OP_MULTI + MP_UNARY_OP_NOT);
    }
}

void micropy_emit_bc_build_tuple(struct _mp_state_ctx_t *mp_state, emit_t *emit, mp_uint_t n_args) {
    micropy_emit_bc_pre(mp_state, emit, 1 - n_args);
    micropy_emit_write_bytecode_byte_uint(mp_state, emit, MP_BC_BUILD_TUPLE, n_args);
}

void micropy_emit_bc_build_list(struct _mp_state_ctx_t *mp_state, emit_t *emit, mp_uint_t n_args) {
    micropy_emit_bc_pre(mp_state, emit, 1 - n_args);
    micropy_emit_write_bytecode_byte_uint(mp_state, emit, MP_BC_BUILD_LIST, n_args);
}

void micropy_emit_bc_list_append(struct _mp_state_ctx_t *mp_state, emit_t *emit, mp_uint_t list_stack_index) {
    micropy_emit_bc_pre(mp_state, emit, -1);
    micropy_emit_write_bytecode_byte_uint(mp_state, emit, MP_BC_LIST_APPEND, list_stack_index);
}

void micropy_emit_bc_build_map(struct _mp_state_ctx_t *mp_state, emit_t *emit, mp_uint_t n_args) {
    micropy_emit_bc_pre(mp_state, emit, 1);
    micropy_emit_write_bytecode_byte_uint(mp_state, emit, MP_BC_BUILD_MAP, n_args);
}

void micropy_emit_bc_store_map(struct _mp_state_ctx_t *mp_state, emit_t *emit) {
    micropy_emit_bc_pre(mp_state, emit, -2);
    micropy_emit_write_bytecode_byte(mp_state, emit, MP_BC_STORE_MAP);
}

void micropy_emit_bc_map_add(struct _mp_state_ctx_t *mp_state, emit_t *emit, mp_uint_t map_stack_index) {
    micropy_emit_bc_pre(mp_state, emit, -2);
    micropy_emit_write_bytecode_byte_uint(mp_state, emit, MP_BC_MAP_ADD, map_stack_index);
}

#if MICROPY_PY_BUILTINS_SET
void micropy_emit_bc_build_set(struct _mp_state_ctx_t *mp_state, emit_t *emit, mp_uint_t n_args) {
    micropy_emit_bc_pre(mp_state, emit, 1 - n_args);
    micropy_emit_write_bytecode_byte_uint(mp_state, emit, MP_BC_BUILD_SET, n_args);
}

void micropy_emit_bc_set_add(struct _mp_state_ctx_t *mp_state, emit_t *emit, mp_uint_t set_stack_index) {
    micropy_emit_bc_pre(mp_state, emit, -1);
    micropy_emit_write_bytecode_byte_uint(mp_state, emit, MP_BC_SET_ADD, set_stack_index);
}
#endif

#if MICROPY_PY_BUILTINS_SLICE
void micropy_emit_bc_build_slice(struct _mp_state_ctx_t *mp_state, emit_t *emit, mp_uint_t n_args) {
    micropy_emit_bc_pre(mp_state, emit, 1 - n_args);
    micropy_emit_write_bytecode_byte_uint(mp_state, emit, MP_BC_BUILD_SLICE, n_args);
}
#endif

void micropy_emit_bc_unpack_sequence(struct _mp_state_ctx_t *mp_state, emit_t *emit, mp_uint_t n_args) {
    micropy_emit_bc_pre(mp_state, emit, -1 + n_args);
    micropy_emit_write_bytecode_byte_uint(mp_state, emit, MP_BC_UNPACK_SEQUENCE, n_args);
}

void micropy_emit_bc_unpack_ex(struct _mp_state_ctx_t *mp_state, emit_t *emit, mp_uint_t n_left, mp_uint_t n_right) {
    micropy_emit_bc_pre(mp_state, emit, -1 + n_left + n_right + 1);
    micropy_emit_write_bytecode_byte_uint(mp_state, emit, MP_BC_UNPACK_EX, n_left | (n_right << 8));
}

void micropy_emit_bc_make_function(struct _mp_state_ctx_t *mp_state, emit_t *emit, scope_t *scope, mp_uint_t n_pos_defaults, mp_uint_t n_kw_defaults) {
    if (n_pos_defaults == 0 && n_kw_defaults == 0) {
        micropy_emit_bc_pre(mp_state, emit, 1);
        micropy_emit_write_bytecode_byte_raw_code(mp_state, emit, MP_BC_MAKE_FUNCTION, scope->raw_code);
    } else {
        micropy_emit_bc_pre(mp_state, emit, -1);
        micropy_emit_write_bytecode_byte_raw_code(mp_state, emit, MP_BC_MAKE_FUNCTION_DEFARGS, scope->raw_code);
    }
}

void micropy_emit_bc_make_closure(struct _mp_state_ctx_t *mp_state, emit_t *emit, scope_t *scope, mp_uint_t n_closed_over, mp_uint_t n_pos_defaults, mp_uint_t n_kw_defaults) {
    if (n_pos_defaults == 0 && n_kw_defaults == 0) {
        micropy_emit_bc_pre(mp_state, emit, -n_closed_over + 1);
        micropy_emit_write_bytecode_byte_raw_code(mp_state, emit, MP_BC_MAKE_CLOSURE, scope->raw_code);
        micropy_emit_write_bytecode_byte(mp_state, emit, n_closed_over);
    } else {
        assert(n_closed_over <= 255);
        micropy_emit_bc_pre(mp_state, emit, -2 - n_closed_over + 1);
        micropy_emit_write_bytecode_byte_raw_code(mp_state, emit, MP_BC_MAKE_CLOSURE_DEFARGS, scope->raw_code);
        micropy_emit_write_bytecode_byte(mp_state, emit, n_closed_over);
    }
}

STATIC void micropy_emit_bc_call_function_method_helper(struct _mp_state_ctx_t *mp_state, emit_t *emit, mp_int_t stack_adj, mp_uint_t bytecode_base, mp_uint_t n_positional, mp_uint_t n_keyword, mp_uint_t star_flags) {
    if (star_flags) {
        micropy_emit_bc_pre(mp_state, emit, stack_adj - (mp_int_t)n_positional - 2 * (mp_int_t)n_keyword - 2);
        micropy_emit_write_bytecode_byte_uint(mp_state, emit, bytecode_base + 1, (n_keyword << 8) | n_positional); // TODO make it 2 separate uints?
    } else {
        micropy_emit_bc_pre(mp_state, emit, stack_adj - (mp_int_t)n_positional - 2 * (mp_int_t)n_keyword);
        micropy_emit_write_bytecode_byte_uint(mp_state, emit, bytecode_base, (n_keyword << 8) | n_positional); // TODO make it 2 separate uints?
    }
}

void micropy_emit_bc_call_function(struct _mp_state_ctx_t *mp_state, emit_t *emit, mp_uint_t n_positional, mp_uint_t n_keyword, mp_uint_t star_flags) {
    micropy_emit_bc_call_function_method_helper(mp_state, emit, 0, MP_BC_CALL_FUNCTION, n_positional, n_keyword, star_flags);
}

void micropy_emit_bc_call_method(struct _mp_state_ctx_t *mp_state, emit_t *emit, mp_uint_t n_positional, mp_uint_t n_keyword, mp_uint_t star_flags) {
    micropy_emit_bc_call_function_method_helper(mp_state, emit, -1, MP_BC_CALL_METHOD, n_positional, n_keyword, star_flags);
}

void micropy_emit_bc_return_value(struct _mp_state_ctx_t *mp_state, emit_t *emit) {
    micropy_emit_bc_pre(mp_state, emit, -1);
    emit->last_emit_was_return_value = true;
    micropy_emit_write_bytecode_byte(mp_state, emit, MP_BC_RETURN_VALUE);
}

void micropy_emit_bc_raise_varargs(struct _mp_state_ctx_t *mp_state, emit_t *emit, mp_uint_t n_args) {
    assert(0 <= n_args && n_args <= 2);
    micropy_emit_bc_pre(mp_state, emit, -n_args);
    micropy_emit_write_bytecode_byte_byte(mp_state, emit, MP_BC_RAISE_VARARGS, n_args);
}

void micropy_emit_bc_yield_value(struct _mp_state_ctx_t *mp_state, emit_t *emit) {
    micropy_emit_bc_pre(mp_state, emit, 0);
    emit->scope->scope_flags |= MP_SCOPE_FLAG_GENERATOR;
    micropy_emit_write_bytecode_byte(mp_state, emit, MP_BC_YIELD_VALUE);
}

void micropy_emit_bc_yield_from(struct _mp_state_ctx_t *mp_state, emit_t *emit) {
    micropy_emit_bc_pre(mp_state, emit, -1);
    emit->scope->scope_flags |= MP_SCOPE_FLAG_GENERATOR;
    micropy_emit_write_bytecode_byte(mp_state, emit, MP_BC_YIELD_FROM);
}

void micropy_emit_bc_start_except_handler(struct _mp_state_ctx_t *mp_state, emit_t *emit) {
    micropy_emit_bc_adjust_stack_size(mp_state, emit, 6); // stack adjust for the 3 exception items, +3 for possible UNWIND_JUMP state
}

void micropy_emit_bc_end_except_handler(struct _mp_state_ctx_t *mp_state, emit_t *emit) {
    micropy_emit_bc_adjust_stack_size(mp_state, emit, -5); // stack adjust
}

#if MICROPY_EMIT_NATIVE
const emit_method_table_t emit_bc_method_table = {
    micropy_emit_bc_set_native_type,
    micropy_emit_bc_start_pass,
    micropy_emit_bc_end_pass,
    micropy_emit_bc_last_emit_was_return_value,
    micropy_emit_bc_adjust_stack_size,
    micropy_emit_bc_set_source_line,

    {
        micropy_emit_bc_load_fast,
        micropy_emit_bc_load_deref,
        micropy_emit_bc_load_name,
        micropy_emit_bc_load_global,
    },
    {
        micropy_emit_bc_store_fast,
        micropy_emit_bc_store_deref,
        micropy_emit_bc_store_name,
        micropy_emit_bc_store_global,
    },
    {
        micropy_emit_bc_delete_fast,
        micropy_emit_bc_delete_deref,
        micropy_emit_bc_delete_name,
        micropy_emit_bc_delete_global,
    },

    micropy_emit_bc_label_assign,
    micropy_emit_bc_import_name,
    micropy_emit_bc_import_from,
    micropy_emit_bc_import_star,
    micropy_emit_bc_load_const_tok,
    micropy_emit_bc_load_const_small_int,
    micropy_emit_bc_load_const_str,
    micropy_emit_bc_load_const_obj,
    micropy_emit_bc_load_null,
    micropy_emit_bc_load_attr,
    micropy_emit_bc_load_method,
    micropy_emit_bc_load_build_class,
    micropy_emit_bc_load_subscr,
    micropy_emit_bc_store_attr,
    micropy_emit_bc_store_subscr,
    micropy_emit_bc_delete_attr,
    micropy_emit_bc_delete_subscr,
    micropy_emit_bc_dup_top,
    micropy_emit_bc_dup_top_two,
    micropy_emit_bc_pop_top,
    micropy_emit_bc_rot_two,
    micropy_emit_bc_rot_three,
    micropy_emit_bc_jump,
    micropy_emit_bc_pop_jump_if,
    micropy_emit_bc_jump_if_or_pop,
    micropy_emit_bc_unwind_jump,
    micropy_emit_bc_unwind_jump,
    micropy_emit_bc_setup_with,
    micropy_emit_bc_with_cleanup,
    micropy_emit_bc_setup_except,
    micropy_emit_bc_setup_finally,
    micropy_emit_bc_end_finally,
    micropy_emit_bc_get_iter,
    micropy_emit_bc_for_iter,
    micropy_emit_bc_for_iter_end,
    micropy_emit_bc_pop_block,
    micropy_emit_bc_pop_except,
    micropy_emit_bc_unary_op,
    micropy_emit_bc_binary_op,
    micropy_emit_bc_build_tuple,
    micropy_emit_bc_build_list,
    micropy_emit_bc_list_append,
    micropy_emit_bc_build_map,
    micropy_emit_bc_store_map,
    micropy_emit_bc_map_add,
    #if MICROPY_PY_BUILTINS_SET
    micropy_emit_bc_build_set,
    micropy_emit_bc_set_add,
    #endif
    #if MICROPY_PY_BUILTINS_SLICE
    micropy_emit_bc_build_slice,
    #endif
    micropy_emit_bc_unpack_sequence,
    micropy_emit_bc_unpack_ex,
    micropy_emit_bc_make_function,
    micropy_emit_bc_make_closure,
    micropy_emit_bc_call_function,
    micropy_emit_bc_call_method,
    micropy_emit_bc_return_value,
    micropy_emit_bc_raise_varargs,
    micropy_emit_bc_yield_value,
    micropy_emit_bc_yield_from,

    micropy_emit_bc_start_except_handler,
    micropy_emit_bc_end_except_handler,
};
#else
const mp_emit_method_table_id_ops_t micropy_emit_bc_method_table_load_id_ops = {
    micropy_emit_bc_load_fast,
    micropy_emit_bc_load_deref,
    micropy_emit_bc_load_name,
    micropy_emit_bc_load_global,
};

const mp_emit_method_table_id_ops_t micropy_emit_bc_method_table_store_id_ops = {
    micropy_emit_bc_store_fast,
    micropy_emit_bc_store_deref,
    micropy_emit_bc_store_name,
    micropy_emit_bc_store_global,
};

const mp_emit_method_table_id_ops_t micropy_emit_bc_method_table_delete_id_ops = {
    micropy_emit_bc_delete_fast,
    micropy_emit_bc_delete_deref,
    micropy_emit_bc_delete_name,
    micropy_emit_bc_delete_global,
};
#endif

#endif //MICROPY_ENABLE_COMPILER
/*
 * This file is part of the Micro Python project, http://micropython.org/
 *
 * The MIT License (MIT)
 *
 * Copyright (c) 2013-2015 Damien P. George
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <string.h>
#include <assert.h>

//#include "py/scope.h"
//#include "py/emit.h"
//#include "py/compile.h"
//#include "py/runtime.h"

#if MICROPY_ENABLE_COMPILER

// TODO need to mangle __attr names

typedef enum {
#define DEF_RULE(rule, comp, kind, ...) PN_##rule,
/*
 * This file is part of the Micro Python project, http://micropython.org/
 *
 * The MIT License (MIT)
 *
 * Copyright (c) 2013-2015 Damien P. George
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

// rules for writing rules:
// - zero_or_more is implemented using opt_rule around a one_or_more rule
// - don't put opt_rule in arguments of or rule; instead, wrap the call to this or rule in opt_rule

// # Start symbols for the grammar:
// #       single_input is a single interactive statement;
// #       file_input is a module or sequence of commands read from an input file;
// #       eval_input is the input for the eval() functions.
// # NB: compound_stmt in single_input is followed by extra NEWLINE! --> not in Micro Python
// single_input: NEWLINE | simple_stmt | compound_stmt
// file_input: (NEWLINE | stmt)* ENDMARKER
// eval_input: testlist NEWLINE* ENDMARKER

DEF_RULE(single_input, nc, or(3), tok(NEWLINE), rule(simple_stmt), rule(compound_stmt))
DEF_RULE(file_input, c(generic_all_nodes), and_ident(1), opt_rule(file_input_2))
DEF_RULE(file_input_2, c(generic_all_nodes), one_or_more, rule(file_input_3))
DEF_RULE(file_input_3, nc, or(2), tok(NEWLINE), rule(stmt))
DEF_RULE(eval_input, nc, and_ident(2), rule(testlist), opt_rule(eval_input_2))
DEF_RULE(eval_input_2, nc, and(1), tok(NEWLINE))

// decorator: '@' dotted_name [ '(' [arglist] ')' ] NEWLINE
// decorators: decorator+
// decorated: decorators (classdef | funcdef | async_funcdef)
// funcdef: 'def' NAME parameters ['->' test] ':' suite
// async_funcdef: 'async' funcdef
// parameters: '(' [typedargslist] ')'
// typedargslist: tfpdef ['=' test] (',' tfpdef ['=' test])* [',' ['*' [tfpdef] (',' tfpdef ['=' test])* [',' '**' tfpdef] | '**' tfpdef]] | '*' [tfpdef] (',' tfpdef ['=' test])* [',' '**' tfpdef] | '**' tfpdef
// tfpdef: NAME [':' test]
// varargslist: vfpdef ['=' test] (',' vfpdef ['=' test])* [',' ['*' [vfpdef] (',' vfpdef ['=' test])* [',' '**' vfpdef] | '**' vfpdef]] |  '*' [vfpdef] (',' vfpdef ['=' test])* [',' '**' vfpdef] | '**' vfpdef
// vfpdef: NAME

DEF_RULE(decorator, nc, and(4), tok(DEL_AT), rule(dotted_name), opt_rule(trailer_paren), tok(NEWLINE))
DEF_RULE(decorators, nc, one_or_more, rule(decorator))
DEF_RULE(decorated, c(decorated), and_ident(2), rule(decorators), rule(decorated_body))
#if MICROPY_PY_ASYNC_AWAIT
DEF_RULE(decorated_body, nc, or(3), rule(classdef), rule(funcdef), rule(async_funcdef))
DEF_RULE(async_funcdef, nc, and(2), tok(KW_ASYNC), rule(funcdef))
#else
DEF_RULE(decorated_body, nc, or(2), rule(classdef), rule(funcdef))
#endif
DEF_RULE(funcdef, c(funcdef), and_blank(8), tok(KW_DEF), tok(NAME), tok(DEL_PAREN_OPEN), opt_rule(typedargslist), tok(DEL_PAREN_CLOSE), opt_rule(funcdefrettype), tok(DEL_COLON), rule(suite))
DEF_RULE(funcdefrettype, nc, and_ident(2), tok(DEL_MINUS_MORE), rule(test))
// note: typedargslist lets through more than is allowed, compiler does further checks
DEF_RULE(typedargslist, nc, list_with_end, rule(typedargslist_item), tok(DEL_COMMA))
DEF_RULE(typedargslist_item, nc, or(3), rule(typedargslist_name), rule(typedargslist_star), rule(typedargslist_dbl_star))
DEF_RULE(typedargslist_name, nc, and_ident(3), tok(NAME), opt_rule(typedargslist_colon), opt_rule(typedargslist_equal))
DEF_RULE(typedargslist_star, nc, and(2), tok(OP_STAR), opt_rule(tfpdef))
DEF_RULE(typedargslist_dbl_star, nc, and(3), tok(OP_DBL_STAR), tok(NAME), opt_rule(typedargslist_colon))
DEF_RULE(typedargslist_colon, nc, and_ident(2), tok(DEL_COLON), rule(test))
DEF_RULE(typedargslist_equal, nc, and_ident(2), tok(DEL_EQUAL), rule(test))
DEF_RULE(tfpdef, nc, and(2), tok(NAME), opt_rule(typedargslist_colon))
// note: varargslist lets through more than is allowed, compiler does further checks
DEF_RULE(varargslist, nc, list_with_end, rule(varargslist_item), tok(DEL_COMMA))
DEF_RULE(varargslist_item, nc, or(3), rule(varargslist_name), rule(varargslist_star), rule(varargslist_dbl_star))
DEF_RULE(varargslist_name, nc, and_ident(2), tok(NAME), opt_rule(varargslist_equal))
DEF_RULE(varargslist_star, nc, and(2), tok(OP_STAR), opt_rule(vfpdef))
DEF_RULE(varargslist_dbl_star, nc, and(2), tok(OP_DBL_STAR), tok(NAME))
DEF_RULE(varargslist_equal, nc, and_ident(2), tok(DEL_EQUAL), rule(test))
DEF_RULE(vfpdef, nc, and_ident(1), tok(NAME))

// stmt: compound_stmt | simple_stmt

DEF_RULE(stmt, nc, or(2), rule(compound_stmt), rule(simple_stmt))

// simple_stmt: small_stmt (';' small_stmt)* [';'] NEWLINE

DEF_RULE(simple_stmt, nc, and_ident(2), rule(simple_stmt_2), tok(NEWLINE))
DEF_RULE(simple_stmt_2, c(generic_all_nodes), list_with_end, rule(small_stmt), tok(DEL_SEMICOLON))

// small_stmt: expr_stmt | del_stmt | pass_stmt | flow_stmt | import_stmt | global_stmt | nonlocal_stmt | assert_stmt
// expr_stmt: testlist_star_expr (augassign (yield_expr|testlist) | ('=' (yield_expr|testlist_star_expr))*)
// testlist_star_expr: (test|star_expr) (',' (test|star_expr))* [',']
// augassign: '+=' | '-=' | '*=' | '/=' | '%=' | '&=' | '|=' | '^=' | '<<=' | '>>=' | '**=' | '//='
// # For normal assignments, additional restrictions enforced by the interpreter

DEF_RULE(small_stmt, nc, or(8), rule(del_stmt), rule(pass_stmt), rule(flow_stmt), rule(import_stmt), rule(global_stmt), rule(nonlocal_stmt), rule(assert_stmt), rule(expr_stmt))
DEF_RULE(expr_stmt, c(expr_stmt), and(2), rule(testlist_star_expr), opt_rule(expr_stmt_2))
DEF_RULE(expr_stmt_2, nc, or(2), rule(expr_stmt_augassign), rule(expr_stmt_assign_list))
DEF_RULE(expr_stmt_augassign, nc, and_ident(2), rule(augassign), rule(expr_stmt_6))
DEF_RULE(expr_stmt_assign_list, nc, one_or_more, rule(expr_stmt_assign))
DEF_RULE(expr_stmt_assign, nc, and_ident(2), tok(DEL_EQUAL), rule(expr_stmt_6))
DEF_RULE(expr_stmt_6, nc, or(2), rule(yield_expr), rule(testlist_star_expr))
DEF_RULE(testlist_star_expr, c(generic_tuple), list_with_end, rule(testlist_star_expr_2), tok(DEL_COMMA))
DEF_RULE(testlist_star_expr_2, nc, or(2), rule(star_expr), rule(test))
DEF_RULE(augassign, nc, or(12), tok(DEL_PLUS_EQUAL), tok(DEL_MINUS_EQUAL), tok(DEL_STAR_EQUAL), tok(DEL_SLASH_EQUAL), tok(DEL_PERCENT_EQUAL), tok(DEL_AMPERSAND_EQUAL), tok(DEL_PIPE_EQUAL), tok(DEL_CARET_EQUAL), tok(DEL_DBL_LESS_EQUAL), tok(DEL_DBL_MORE_EQUAL), tok(DEL_DBL_STAR_EQUAL), tok(DEL_DBL_SLASH_EQUAL))

// del_stmt: 'del' exprlist
// pass_stmt: 'pass'
// flow_stmt: break_stmt | continue_stmt | return_stmt | raise_stmt | yield_stmt
// break_stmt: 'break'
// continue_stmt: 'continue'
// return_stmt: 'return' [testlist]
// yield_stmt: yield_expr
// raise_stmt: 'raise' [test ['from' test]]

DEF_RULE(del_stmt, c(del_stmt), and(2), tok(KW_DEL), rule(exprlist))
DEF_RULE(pass_stmt, c(generic_all_nodes), and(1), tok(KW_PASS))
DEF_RULE(flow_stmt, nc, or(5), rule(break_stmt), rule(continue_stmt), rule(return_stmt), rule(raise_stmt), rule(yield_stmt))
DEF_RULE(break_stmt, c(break_stmt), and(1), tok(KW_BREAK))
DEF_RULE(continue_stmt, c(continue_stmt), and(1), tok(KW_CONTINUE))
DEF_RULE(return_stmt, c(return_stmt), and(2), tok(KW_RETURN), opt_rule(testlist))
DEF_RULE(yield_stmt, c(yield_stmt), and(1), rule(yield_expr))
DEF_RULE(raise_stmt, c(raise_stmt), and(2), tok(KW_RAISE), opt_rule(raise_stmt_arg))
DEF_RULE(raise_stmt_arg, nc, and_ident(2), rule(test), opt_rule(raise_stmt_from))
DEF_RULE(raise_stmt_from, nc, and_ident(2), tok(KW_FROM), rule(test))

// import_stmt: import_name | import_from
// import_name: 'import' dotted_as_names
// import_from: 'from' (('.' | '...')* dotted_name | ('.' | '...')+) 'import' ('*' | '(' import_as_names ')' | import_as_names)
// import_as_name: NAME ['as' NAME]
// dotted_as_name: dotted_name ['as' NAME]
// import_as_names: import_as_name (',' import_as_name)* [',']
// dotted_as_names: dotted_as_name (',' dotted_as_name)*
// dotted_name: NAME ('.' NAME)*
// global_stmt: 'global' NAME (',' NAME)*
// nonlocal_stmt: 'nonlocal' NAME (',' NAME)*
// assert_stmt: 'assert' test [',' test]

DEF_RULE(import_stmt, nc, or(2), rule(import_name), rule(import_from))
DEF_RULE(import_name, c(import_name), and(2), tok(KW_IMPORT), rule(dotted_as_names))
DEF_RULE(import_from, c(import_from), and(4), tok(KW_FROM), rule(import_from_2), tok(KW_IMPORT), rule(import_from_3))
DEF_RULE(import_from_2, nc, or(2), rule(dotted_name), rule(import_from_2b))
DEF_RULE(import_from_2b, nc, and_ident(2), rule(one_or_more_period_or_ellipsis), opt_rule(dotted_name))
DEF_RULE(import_from_3, nc, or(3), tok(OP_STAR), rule(import_as_names_paren), rule(import_as_names))
DEF_RULE(import_as_names_paren, nc, and_ident(3), tok(DEL_PAREN_OPEN), rule(import_as_names), tok(DEL_PAREN_CLOSE))
DEF_RULE(one_or_more_period_or_ellipsis, nc, one_or_more, rule(period_or_ellipsis))
DEF_RULE(period_or_ellipsis, nc, or(2), tok(DEL_PERIOD), tok(ELLIPSIS))
DEF_RULE(import_as_name, nc, and(2), tok(NAME), opt_rule(as_name))
DEF_RULE(dotted_as_name, nc, and_ident(2), rule(dotted_name), opt_rule(as_name))
DEF_RULE(as_name, nc, and_ident(2), tok(KW_AS), tok(NAME))
DEF_RULE(import_as_names, nc, list_with_end, rule(import_as_name), tok(DEL_COMMA))
DEF_RULE(dotted_as_names, nc, list, rule(dotted_as_name), tok(DEL_COMMA))
DEF_RULE(dotted_name, nc, list, tok(NAME), tok(DEL_PERIOD))
DEF_RULE(global_stmt, c(global_stmt), and(2), tok(KW_GLOBAL), rule(name_list))
DEF_RULE(nonlocal_stmt, c(nonlocal_stmt), and(2), tok(KW_NONLOCAL), rule(name_list))
DEF_RULE(name_list, nc, list, tok(NAME), tok(DEL_COMMA))
DEF_RULE(assert_stmt, c(assert_stmt), and(3), tok(KW_ASSERT), rule(test), opt_rule(assert_stmt_extra))
DEF_RULE(assert_stmt_extra, nc, and_ident(2), tok(DEL_COMMA), rule(test))

// compound_stmt: if_stmt | while_stmt | for_stmt | try_stmt | with_stmt | funcdef | classdef | decorated | async_stmt
// if_stmt: 'if' test ':' suite ('elif' test ':' suite)* ['else' ':' suite]
// while_stmt: 'while' test ':' suite ['else' ':' suite]
// for_stmt: 'for' exprlist 'in' testlist ':' suite ['else' ':' suite]
// try_stmt: 'try' ':' suite ((except_clause ':' suite)+ ['else' ':' suite] ['finally' ':' suite] | 'finally' ':' suite)
// # NB compile.c makes sure that the default except clause is last
// except_clause: 'except' [test ['as' NAME]]
// with_stmt: 'with' with_item (',' with_item)* ':' suite
// with_item: test ['as' expr]
// suite: simple_stmt | NEWLINE INDENT stmt+ DEDENT
// async_stmt: 'async' (funcdef | with_stmt | for_stmt)

#if MICROPY_PY_ASYNC_AWAIT
DEF_RULE(compound_stmt, nc, or(9), rule(if_stmt), rule(while_stmt), rule(for_stmt), rule(try_stmt), rule(with_stmt), rule(funcdef), rule(classdef), rule(decorated), rule(async_stmt))
DEF_RULE(async_stmt, c(async_stmt), and(2), tok(KW_ASYNC), rule(async_stmt_2))
DEF_RULE(async_stmt_2, nc, or(3), rule(funcdef), rule(with_stmt), rule(for_stmt))
#else
DEF_RULE(compound_stmt, nc, or(8), rule(if_stmt), rule(while_stmt), rule(for_stmt), rule(try_stmt), rule(with_stmt), rule(funcdef), rule(classdef), rule(decorated))
#endif
DEF_RULE(if_stmt, c(if_stmt), and(6), tok(KW_IF), rule(test), tok(DEL_COLON), rule(suite), opt_rule(if_stmt_elif_list), opt_rule(else_stmt))
DEF_RULE(if_stmt_elif_list, nc, one_or_more, rule(if_stmt_elif))
DEF_RULE(if_stmt_elif, nc, and(4), tok(KW_ELIF), rule(test), tok(DEL_COLON), rule(suite))
DEF_RULE(while_stmt, c(while_stmt), and(5), tok(KW_WHILE), rule(test), tok(DEL_COLON), rule(suite), opt_rule(else_stmt))
DEF_RULE(for_stmt, c(for_stmt), and(7), tok(KW_FOR), rule(exprlist), tok(KW_IN), rule(testlist), tok(DEL_COLON), rule(suite), opt_rule(else_stmt))
DEF_RULE(try_stmt, c(try_stmt), and(4), tok(KW_TRY), tok(DEL_COLON), rule(suite), rule(try_stmt_2))
DEF_RULE(try_stmt_2, nc, or(2), rule(try_stmt_except_and_more), rule(try_stmt_finally))
DEF_RULE(try_stmt_except_and_more, nc, and_ident(3), rule(try_stmt_except_list), opt_rule(else_stmt), opt_rule(try_stmt_finally))
DEF_RULE(try_stmt_except, nc, and(4), tok(KW_EXCEPT), opt_rule(try_stmt_as_name), tok(DEL_COLON), rule(suite))
DEF_RULE(try_stmt_as_name, nc, and_ident(2), rule(test), opt_rule(as_name))
DEF_RULE(try_stmt_except_list, nc, one_or_more, rule(try_stmt_except))
DEF_RULE(try_stmt_finally, nc, and(3), tok(KW_FINALLY), tok(DEL_COLON), rule(suite))
DEF_RULE(else_stmt, nc, and_ident(3), tok(KW_ELSE), tok(DEL_COLON), rule(suite))
DEF_RULE(with_stmt, c(with_stmt), and(4), tok(KW_WITH), rule(with_stmt_list), tok(DEL_COLON), rule(suite))
DEF_RULE(with_stmt_list, nc, list, rule(with_item), tok(DEL_COMMA))
DEF_RULE(with_item, nc, and_ident(2), rule(test), opt_rule(with_item_as))
DEF_RULE(with_item_as, nc, and_ident(2), tok(KW_AS), rule(expr))
DEF_RULE(suite, nc, or(2), rule(suite_block), rule(simple_stmt))
DEF_RULE(suite_block, nc, and_ident(4), tok(NEWLINE), tok(INDENT), rule(suite_block_stmts), tok(DEDENT))
DEF_RULE(suite_block_stmts, c(generic_all_nodes), one_or_more, rule(stmt))

// test: or_test ['if' or_test 'else' test] | lambdef
// test_nocond: or_test | lambdef_nocond
// lambdef: 'lambda' [varargslist] ':' test
// lambdef_nocond: 'lambda' [varargslist] ':' test_nocond

DEF_RULE(test, nc, or(2), rule(lambdef), rule(test_if_expr))
DEF_RULE(test_if_expr, c(test_if_expr), and_ident(2), rule(or_test), opt_rule(test_if_else))
DEF_RULE(test_if_else, nc, and(4), tok(KW_IF), rule(or_test), tok(KW_ELSE), rule(test))
DEF_RULE(test_nocond, nc, or(2), rule(lambdef_nocond), rule(or_test))
DEF_RULE(lambdef, c(lambdef), and_blank(4), tok(KW_LAMBDA), opt_rule(varargslist), tok(DEL_COLON), rule(test))
DEF_RULE(lambdef_nocond, c(lambdef), and_blank(4), tok(KW_LAMBDA), opt_rule(varargslist), tok(DEL_COLON), rule(test_nocond))

// or_test: and_test ('or' and_test)*
// and_test: not_test ('and' not_test)*
// not_test: 'not' not_test | comparison
// comparison: expr (comp_op expr)*
// comp_op: '<'|'>'|'=='|'>='|'<='|'!='|'in'|'not' 'in'|'is'|'is' 'not'
// star_expr: '*' expr
// expr: xor_expr ('|' xor_expr)*
// xor_expr: and_expr ('^' and_expr)*
// and_expr: shift_expr ('&' shift_expr)*
// shift_expr: arith_expr (('<<'|'>>') arith_expr)*
// arith_expr: term (('+'|'-') term)*
// term: factor (('*'|'/'|'%'|'//') factor)*
// factor: ('+'|'-'|'~') factor | power
// power: atom_expr ['**' factor]
// atom_expr: 'await' atom trailer* | atom trailer*

DEF_RULE(or_test, c(or_test), list, rule(and_test), tok(KW_OR))
DEF_RULE(and_test, c(and_test), list, rule(not_test), tok(KW_AND))
DEF_RULE(not_test, nc, or(2), rule(not_test_2), rule(comparison))
DEF_RULE(not_test_2, c(not_test_2), and(2), tok(KW_NOT), rule(not_test))
DEF_RULE(comparison, c(comparison), list, rule(expr), rule(comp_op))
DEF_RULE(comp_op, nc, or(9), tok(OP_LESS), tok(OP_MORE), tok(OP_DBL_EQUAL), tok(OP_LESS_EQUAL), tok(OP_MORE_EQUAL), tok(OP_NOT_EQUAL), tok(KW_IN), rule(comp_op_not_in), rule(comp_op_is))
DEF_RULE(comp_op_not_in, nc, and(2), tok(KW_NOT), tok(KW_IN))
DEF_RULE(comp_op_is, nc, and(2), tok(KW_IS), opt_rule(comp_op_is_not))
DEF_RULE(comp_op_is_not, nc, and(1), tok(KW_NOT))
DEF_RULE(star_expr, c(star_expr), and(2), tok(OP_STAR), rule(expr))
DEF_RULE(expr, c(expr), list, rule(xor_expr), tok(OP_PIPE))
DEF_RULE(xor_expr, c(xor_expr), list, rule(and_expr), tok(OP_CARET))
DEF_RULE(and_expr, c(and_expr), list, rule(shift_expr), tok(OP_AMPERSAND))
DEF_RULE(shift_expr, c(shift_expr), list, rule(arith_expr), rule(shift_op))
DEF_RULE(shift_op, nc, or(2), tok(OP_DBL_LESS), tok(OP_DBL_MORE))
DEF_RULE(arith_expr, c(arith_expr), list, rule(term), rule(arith_op))
DEF_RULE(arith_op, nc, or(2), tok(OP_PLUS), tok(OP_MINUS))
DEF_RULE(term, c(term), list, rule(factor), rule(term_op))
DEF_RULE(term_op, nc, or(4), tok(OP_STAR), tok(OP_SLASH), tok(OP_PERCENT), tok(OP_DBL_SLASH))
DEF_RULE(factor, nc, or(2), rule(factor_2), rule(power))
DEF_RULE(factor_2, c(factor_2), and_ident(2), rule(factor_op), rule(factor))
DEF_RULE(factor_op, nc, or(3), tok(OP_PLUS), tok(OP_MINUS), tok(OP_TILDE))
DEF_RULE(power, c(power), and_ident(2), rule(atom_expr), opt_rule(power_dbl_star))
#if MICROPY_PY_ASYNC_AWAIT
DEF_RULE(atom_expr, nc, or(2), rule(atom_expr_await), rule(atom_expr_normal))
DEF_RULE(atom_expr_await, c(atom_expr_await), and(3), tok(KW_AWAIT), rule(atom), opt_rule(atom_expr_trailers))
#else
DEF_RULE(atom_expr, nc, or(1), rule(atom_expr_normal))
#endif
DEF_RULE(atom_expr_normal, c(atom_expr_normal), and_ident(2), rule(atom), opt_rule(atom_expr_trailers))
DEF_RULE(atom_expr_trailers, c(atom_expr_trailers), one_or_more, rule(trailer))
DEF_RULE(power_dbl_star, nc, and_ident(2), tok(OP_DBL_STAR), rule(factor))

// atom: '(' [yield_expr|testlist_comp] ')' | '[' [testlist_comp] ']' | '{' [dictorsetmaker] '}' | NAME | NUMBER | STRING+ | '...' | 'None' | 'True' | 'False'
// testlist_comp: (test|star_expr) ( comp_for | (',' (test|star_expr))* [','] )
// trailer: '(' [arglist] ')' | '[' subscriptlist ']' | '.' NAME

DEF_RULE(atom, nc, or(11), tok(NAME), tok(INTEGER), tok(FLOAT_OR_IMAG), rule(atom_string), tok(ELLIPSIS), tok(KW_NONE), tok(KW_TRUE), tok(KW_FALSE), rule(atom_paren), rule(atom_bracket), rule(atom_brace))
DEF_RULE(atom_string, c(atom_string), one_or_more, rule(string_or_bytes))
DEF_RULE(string_or_bytes, nc, or(2), tok(STRING), tok(BYTES))
DEF_RULE(atom_paren, c(atom_paren), and(3), tok(DEL_PAREN_OPEN), opt_rule(atom_2b), tok(DEL_PAREN_CLOSE))
DEF_RULE(atom_2b, nc, or(2), rule(yield_expr), rule(testlist_comp))
DEF_RULE(atom_bracket, c(atom_bracket), and(3), tok(DEL_BRACKET_OPEN), opt_rule(testlist_comp), tok(DEL_BRACKET_CLOSE))
DEF_RULE(atom_brace, c(atom_brace), and(3), tok(DEL_BRACE_OPEN), opt_rule(dictorsetmaker), tok(DEL_BRACE_CLOSE))
DEF_RULE(testlist_comp, nc, and_ident(2), rule(testlist_comp_2), opt_rule(testlist_comp_3))
DEF_RULE(testlist_comp_2, nc, or(2), rule(star_expr), rule(test))
DEF_RULE(testlist_comp_3, nc, or(2), rule(comp_for), rule(testlist_comp_3b))
DEF_RULE(testlist_comp_3b, nc, and_ident(2), tok(DEL_COMMA), opt_rule(testlist_comp_3c))
DEF_RULE(testlist_comp_3c, nc, list_with_end, rule(testlist_comp_2), tok(DEL_COMMA))
DEF_RULE(trailer, nc, or(3), rule(trailer_paren), rule(trailer_bracket), rule(trailer_period))
DEF_RULE(trailer_paren, c(trailer_paren), and(3), tok(DEL_PAREN_OPEN), opt_rule(arglist), tok(DEL_PAREN_CLOSE))
DEF_RULE(trailer_bracket, c(trailer_bracket), and(3), tok(DEL_BRACKET_OPEN), rule(subscriptlist), tok(DEL_BRACKET_CLOSE))
DEF_RULE(trailer_period, c(trailer_period), and(2), tok(DEL_PERIOD), tok(NAME))

// subscriptlist: subscript (',' subscript)* [',']
// subscript: test | [test] ':' [test] [sliceop]
// sliceop: ':' [test]

#if MICROPY_PY_BUILTINS_SLICE
DEF_RULE(subscriptlist, c(generic_tuple), list_with_end, rule(subscript), tok(DEL_COMMA))
DEF_RULE(subscript, nc, or(2), rule(subscript_3), rule(subscript_2))
DEF_RULE(subscript_2, c(subscript_2), and_ident(2), rule(test), opt_rule(subscript_3))
DEF_RULE(subscript_3, c(subscript_3), and(2), tok(DEL_COLON), opt_rule(subscript_3b))
DEF_RULE(subscript_3b, nc, or(2), rule(subscript_3c), rule(subscript_3d))
DEF_RULE(subscript_3c, nc, and(2), tok(DEL_COLON), opt_rule(test))
DEF_RULE(subscript_3d, nc, and_ident(2), rule(test), opt_rule(sliceop))
DEF_RULE(sliceop, nc, and(2), tok(DEL_COLON), opt_rule(test))
#else
DEF_RULE(subscriptlist, c(generic_tuple), list_with_end, rule(test), tok(DEL_COMMA))
#endif

// exprlist: (expr|star_expr) (',' (expr|star_expr))* [',']
// testlist: test (',' test)* [',']
// dictorsetmaker: (test ':' test (comp_for | (',' test ':' test)* [','])) | (test (comp_for | (',' test)* [',']))

DEF_RULE(exprlist, nc, list_with_end, rule(exprlist_2), tok(DEL_COMMA))
DEF_RULE(exprlist_2, nc, or(2), rule(star_expr), rule(expr))
DEF_RULE(testlist, c(generic_tuple), list_with_end, rule(test), tok(DEL_COMMA))
// TODO dictorsetmaker lets through more than is allowed
DEF_RULE(dictorsetmaker, nc, and_ident(2), rule(dictorsetmaker_item), opt_rule(dictorsetmaker_tail))
#if MICROPY_PY_BUILTINS_SET
DEF_RULE(dictorsetmaker_item, c(dictorsetmaker_item), and_ident(2), rule(test), opt_rule(dictorsetmaker_colon))
DEF_RULE(dictorsetmaker_colon, nc, and_ident(2), tok(DEL_COLON), rule(test))
#else
DEF_RULE(dictorsetmaker_item, c(dictorsetmaker_item), and(3), rule(test), tok(DEL_COLON), rule(test))
#endif
DEF_RULE(dictorsetmaker_tail, nc, or(2), rule(comp_for), rule(dictorsetmaker_list))
DEF_RULE(dictorsetmaker_list, nc, and(2), tok(DEL_COMMA), opt_rule(dictorsetmaker_list2))
DEF_RULE(dictorsetmaker_list2, nc, list_with_end, rule(dictorsetmaker_item), tok(DEL_COMMA))

// classdef: 'class' NAME ['(' [arglist] ')'] ':' suite

DEF_RULE(classdef, c(classdef), and_blank(5), tok(KW_CLASS), tok(NAME), opt_rule(classdef_2), tok(DEL_COLON), rule(suite))
DEF_RULE(classdef_2, nc, and_ident(3), tok(DEL_PAREN_OPEN), opt_rule(arglist), tok(DEL_PAREN_CLOSE))

// arglist: (argument ',')* (argument [','] | '*' test (',' argument)* [',' '**' test] | '**' test)

// TODO arglist lets through more than is allowed, compiler needs to do further verification
DEF_RULE(arglist, nc, list_with_end, rule(arglist_2), tok(DEL_COMMA))
DEF_RULE(arglist_2, nc, or(3), rule(arglist_star), rule(arglist_dbl_star), rule(argument))
DEF_RULE(arglist_star, nc, and(2), tok(OP_STAR), rule(test))
DEF_RULE(arglist_dbl_star, nc, and(2), tok(OP_DBL_STAR), rule(test))

// # The reason that keywords are test nodes instead of NAME is that using NAME
// # results in an ambiguity. ast.c makes sure it's a NAME.
// argument: test [comp_for] | test '=' test  # Really [keyword '='] test
// comp_iter: comp_for | comp_if
// comp_for: 'for' exprlist 'in' or_test [comp_iter]
// comp_if: 'if' test_nocond [comp_iter]

DEF_RULE(argument, nc, and_ident(2), rule(test), opt_rule(argument_2))
DEF_RULE(argument_2, nc, or(2), rule(comp_for), rule(argument_3))
DEF_RULE(argument_3, nc, and_ident(2), tok(DEL_EQUAL), rule(test))
DEF_RULE(comp_iter, nc, or(2), rule(comp_for), rule(comp_if))
DEF_RULE(comp_for, nc, and_blank(5), tok(KW_FOR), rule(exprlist), tok(KW_IN), rule(or_test), opt_rule(comp_iter))
DEF_RULE(comp_if, nc, and(3), tok(KW_IF), rule(test_nocond), opt_rule(comp_iter))

// # not used in grammar, but may appear in "node" passed from Parser to Compiler
// encoding_decl: NAME

// yield_expr: 'yield' [yield_arg]
// yield_arg: 'from' test | testlist

DEF_RULE(yield_expr, c(yield_expr), and(2), tok(KW_YIELD), opt_rule(yield_arg))
DEF_RULE(yield_arg, nc, or(2), rule(yield_arg_from), rule(testlist))
DEF_RULE(yield_arg_from, nc, and(2), tok(KW_FROM), rule(test))
#undef DEF_RULE
    PN_maximum_number_of,
    PN_string, // special node for non-interned string
    PN_bytes, // special node for non-interned bytes
    PN_const_object, // special node for a constant, generic Python object
} pn_kind_t;

#define NEED_METHOD_TABLE MICROPY_EMIT_NATIVE

#if NEED_METHOD_TABLE

// we need a method table to do the lookup for the emitter functions
#define EMIT(fun) (comp->emit_method_table->fun(mp_state, comp->emit))
#define EMIT_ARG(fun, ...) (comp->emit_method_table->fun(mp_state, comp->emit, __VA_ARGS__))
#define EMIT_LOAD_FAST(qst, local_num) (comp->emit_method_table->load_id.fast(comp->emit, qst, local_num))
#define EMIT_LOAD_GLOBAL(qst) (comp->emit_method_table->load_id.global(comp->emit, qst))

#else

// if we only have the bytecode emitter enabled then we can do a direct call to the functions
#define EMIT(fun) (micropy_emit_bc_##fun(mp_state, comp->emit))
#define EMIT_ARG(fun, ...) (micropy_emit_bc_##fun(mp_state, comp->emit, __VA_ARGS__))
#define EMIT_LOAD_FAST(qst, local_num) (micropy_emit_bc_load_fast(mp_state, comp->emit, qst, local_num))
#define EMIT_LOAD_GLOBAL(qst) (micropy_emit_bc_load_global(mp_state, comp->emit, qst))

#endif

#define EMIT_INLINE_ASM(fun) (comp->emit_inline_asm_method_table->fun(comp->emit_inline_asm))
#define EMIT_INLINE_ASM_ARG(fun, ...) (comp->emit_inline_asm_method_table->fun(comp->emit_inline_asm, __VA_ARGS__))

// elements in this struct are ordered to make it compact
typedef struct _compiler_t {
    qstr source_file;

    uint8_t is_repl;
    uint8_t pass; // holds enum type pass_kind_t
    uint8_t func_arg_is_super; // used to compile special case of super() function call
    uint8_t have_star;

    // try to keep compiler clean from nlr
    mp_obj_t compile_error; // set to an exception object if there's an error
    size_t compile_error_line; // set to best guess of line of error

    uint next_label;

    uint16_t num_dict_params;
    uint16_t num_default_params;

    uint16_t break_label; // highest bit set indicates we are breaking out of a for loop
    uint16_t continue_label;
    uint16_t cur_except_level; // increased for SETUP_EXCEPT, SETUP_FINALLY; decreased for POP_BLOCK, POP_EXCEPT
    uint16_t break_continue_except_level;

    scope_t *scope_head;
    scope_t *scope_cur;

    emit_t *emit;                                   // current emitter
    #if NEED_METHOD_TABLE
    const emit_method_table_t *emit_method_table;   // current emit method table
    #endif

    #if MICROPY_EMIT_INLINE_THUMB
    emit_inline_asm_t *emit_inline_asm;                                   // current emitter for inline asm
    const emit_inline_asm_method_table_t *emit_inline_asm_method_table;   // current emit method table for inline asm
    #endif
} compiler_t;

STATIC void micropy_compile_error_set_line(struct _mp_state_ctx_t *mp_state, compiler_t *comp, mp_parse_node_t pn) {
    // if the line of the error is unknown then try to update it from the pn
    if (comp->compile_error_line == 0 && MP_PARSE_NODE_IS_STRUCT(pn)) {
        comp->compile_error_line = ((mp_parse_node_struct_t*)pn)->source_line;
    }
}

STATIC void micropy_compile_syntax_error(struct _mp_state_ctx_t *mp_state, compiler_t *comp, mp_parse_node_t pn, const char *msg) {
    // only register the error if there has been no other error
    if (comp->compile_error == MP_OBJ_NULL) {
        comp->compile_error = micropy_obj_new_exception_msg(mp_state, &mp_type_SyntaxError, msg);
        micropy_compile_error_set_line(mp_state, comp, pn);
    }
}

STATIC void micropy_compile_trailer_paren_helper(struct _mp_state_ctx_t *mp_state, compiler_t *comp, mp_parse_node_t pn_arglist, bool is_method_call, int n_positional_extra);
STATIC void micropy_compile_comprehension(struct _mp_state_ctx_t *mp_state, compiler_t *comp, mp_parse_node_struct_t *pns, scope_kind_t kind);
STATIC void micropy_compile_node(struct _mp_state_ctx_t *mp_state, compiler_t *comp, mp_parse_node_t pn);

STATIC uint micropy_comp_next_label(struct _mp_state_ctx_t *mp_state, compiler_t *comp) {
    return comp->next_label++;
}

STATIC void micropy_compile_increase_except_level(struct _mp_state_ctx_t *mp_state, compiler_t *comp) {
    comp->cur_except_level += 1;
    if (comp->cur_except_level > comp->scope_cur->exc_stack_size) {
        comp->scope_cur->exc_stack_size = comp->cur_except_level;
    }
}

STATIC void micropy_compile_decrease_except_level(struct _mp_state_ctx_t *mp_state, compiler_t *comp) {
    assert(comp->cur_except_level > 0);
    comp->cur_except_level -= 1;
}

STATIC scope_t *micropy_scope_new_and_link(struct _mp_state_ctx_t *mp_state, compiler_t *comp, scope_kind_t kind, mp_parse_node_t pn, uint emit_options) {
    scope_t *scope = micropy_scope_new(mp_state, kind, pn, comp->source_file, emit_options);
    scope->parent = comp->scope_cur;
    scope->next = NULL;
    if (comp->scope_head == NULL) {
        comp->scope_head = scope;
    } else {
        scope_t *s = comp->scope_head;
        while (s->next != NULL) {
            s = s->next;
        }
        s->next = scope;
    }
    return scope;
}

typedef void (*apply_list_fun_t)(struct _mp_state_ctx_t *mp_state, compiler_t *comp, mp_parse_node_t pn);

STATIC void micropy_apply_to_single_or_list(struct _mp_state_ctx_t *mp_state, compiler_t *comp, mp_parse_node_t pn, pn_kind_t pn_list_kind, apply_list_fun_t f) {
    if (MP_PARSE_NODE_IS_STRUCT_KIND(pn, pn_list_kind)) {
        mp_parse_node_struct_t *pns = (mp_parse_node_struct_t*)pn;
        int num_nodes = MP_PARSE_NODE_STRUCT_NUM_NODES(pns);
        for (int i = 0; i < num_nodes; i++) {
            f(mp_state, comp, pns->nodes[i]);
        }
    } else if (!MP_PARSE_NODE_IS_NULL(pn)) {
        f(mp_state, comp, pn);
    }
}

STATIC void micropy_compile_generic_all_nodes(struct _mp_state_ctx_t *mp_state, compiler_t *comp, mp_parse_node_struct_t *pns) {
    int num_nodes = MP_PARSE_NODE_STRUCT_NUM_NODES(pns);
    for (int i = 0; i < num_nodes; i++) {
        micropy_compile_node(mp_state, comp, pns->nodes[i]);
        if (comp->compile_error != MP_OBJ_NULL) {
            // add line info for the error in case it didn't have a line number
            micropy_compile_error_set_line(mp_state, comp, pns->nodes[i]);
            return;
        }
    }
}

STATIC void micropy_compile_load_id(struct _mp_state_ctx_t *mp_state, compiler_t *comp, qstr qst) {
    if (comp->pass == MP_PASS_SCOPE) {
        micropy_emit_common_get_id_for_load(mp_state, comp->scope_cur, qst);
    } else {
        #if NEED_METHOD_TABLE
        micropy_emit_common_id_op(mp_state, comp->emit, &comp->emit_method_table->load_id, comp->scope_cur, qst);
        #else
        micropy_emit_common_id_op(mp_state, comp->emit, &micropy_emit_bc_method_table_load_id_ops, comp->scope_cur, qst);
        #endif
    }
}

STATIC void micropy_compile_store_id(struct _mp_state_ctx_t *mp_state, compiler_t *comp, qstr qst) {
    if (comp->pass == MP_PASS_SCOPE) {
        micropy_emit_common_get_id_for_modification(mp_state, comp->scope_cur, qst);
    } else {
        #if NEED_METHOD_TABLE
        micropy_emit_common_id_op(mp_state, comp->emit, &comp->emit_method_table->store_id, comp->scope_cur, qst);
        #else
        micropy_emit_common_id_op(mp_state, comp->emit, &micropy_emit_bc_method_table_store_id_ops, comp->scope_cur, qst);
        #endif
    }
}

STATIC void micropy_compile_delete_id(struct _mp_state_ctx_t *mp_state, compiler_t *comp, qstr qst) {
    if (comp->pass == MP_PASS_SCOPE) {
        micropy_emit_common_get_id_for_modification(mp_state, comp->scope_cur, qst);
    } else {
        #if NEED_METHOD_TABLE
        micropy_emit_common_id_op(mp_state, comp->emit, &comp->emit_method_table->delete_id, comp->scope_cur, qst);
        #else
        micropy_emit_common_id_op(mp_state, comp->emit, &micropy_emit_bc_method_table_delete_id_ops, comp->scope_cur, qst);
        #endif
    }
}

STATIC void micropy_c_tuple(struct _mp_state_ctx_t *mp_state, compiler_t *comp, mp_parse_node_t pn, mp_parse_node_struct_t *pns_list) {
    int total = 0;
    if (!MP_PARSE_NODE_IS_NULL(pn)) {
        micropy_compile_node(mp_state, comp, pn);
        total += 1;
    }
    if (pns_list != NULL) {
        int n = MP_PARSE_NODE_STRUCT_NUM_NODES(pns_list);
        for (int i = 0; i < n; i++) {
            micropy_compile_node(mp_state, comp, pns_list->nodes[i]);
        }
        total += n;
    }
    EMIT_ARG(build_tuple, total);
}

STATIC void micropy_compile_generic_tuple(struct _mp_state_ctx_t *mp_state, compiler_t *comp, mp_parse_node_struct_t *pns) {
    // a simple tuple expression
    micropy_c_tuple(mp_state, comp, MP_PARSE_NODE_NULL, pns);
}

STATIC bool micropy_node_is_const_false(struct _mp_state_ctx_t *mp_state, mp_parse_node_t pn) {
    return MP_PARSE_NODE_IS_TOKEN_KIND(pn, MP_TOKEN_KW_FALSE)
        || (MP_PARSE_NODE_IS_SMALL_INT(pn) && MP_PARSE_NODE_LEAF_SMALL_INT(pn) == 0);
}

STATIC bool micropy_node_is_const_true(struct _mp_state_ctx_t *mp_state, mp_parse_node_t pn) {
    return MP_PARSE_NODE_IS_TOKEN_KIND(pn, MP_TOKEN_KW_TRUE)
        || (MP_PARSE_NODE_IS_SMALL_INT(pn) && MP_PARSE_NODE_LEAF_SMALL_INT(pn) != 0);
}

STATIC void micropy_c_if_cond(struct _mp_state_ctx_t *mp_state, compiler_t *comp, mp_parse_node_t pn, bool jump_if, int label) {
    if (micropy_node_is_const_false(mp_state, pn)) {
        if (jump_if == false) {
            EMIT_ARG(jump, label);
        }
        return;
    } else if (micropy_node_is_const_true(mp_state, pn)) {
        if (jump_if == true) {
            EMIT_ARG(jump, label);
        }
        return;
    } else if (MP_PARSE_NODE_IS_STRUCT(pn)) {
        mp_parse_node_struct_t *pns = (mp_parse_node_struct_t*)pn;
        int n = MP_PARSE_NODE_STRUCT_NUM_NODES(pns);
        if (MP_PARSE_NODE_STRUCT_KIND(pns) == PN_or_test) {
            if (jump_if == false) {
            and_or_logic1:;
                uint label2 = micropy_comp_next_label(mp_state, comp);
                for (int i = 0; i < n - 1; i++) {
                    micropy_c_if_cond(mp_state, comp, pns->nodes[i], !jump_if, label2);
                }
                micropy_c_if_cond(mp_state, comp, pns->nodes[n - 1], jump_if, label);
                EMIT_ARG(label_assign, label2);
            } else {
            and_or_logic2:
                for (int i = 0; i < n; i++) {
                    micropy_c_if_cond(mp_state, comp, pns->nodes[i], jump_if, label);
                }
            }
            return;
        } else if (MP_PARSE_NODE_STRUCT_KIND(pns) == PN_and_test) {
            if (jump_if == false) {
                goto and_or_logic2;
            } else {
                goto and_or_logic1;
            }
        } else if (MP_PARSE_NODE_STRUCT_KIND(pns) == PN_not_test_2) {
            micropy_c_if_cond(mp_state, comp, pns->nodes[0], !jump_if, label);
            return;
        } else if (MP_PARSE_NODE_STRUCT_KIND(pns) == PN_atom_paren) {
            // cond is something in parenthesis
            if (MP_PARSE_NODE_IS_NULL(pns->nodes[0])) {
                // empty tuple, acts as false for the condition
                if (jump_if == false) {
                    EMIT_ARG(jump, label);
                }
            } else {
                assert(MP_PARSE_NODE_IS_STRUCT_KIND(pns->nodes[0], PN_testlist_comp));
                // non-empty tuple, acts as true for the condition
                if (jump_if == true) {
                    EMIT_ARG(jump, label);
                }
            }
            return;
        }
    }

    // nothing special, fall back to default compiling for node and jump
    micropy_compile_node(mp_state, comp, pn);
    EMIT_ARG(pop_jump_if, jump_if, label);
}

typedef enum { ASSIGN_STORE, ASSIGN_AUG_LOAD, ASSIGN_AUG_STORE } assign_kind_t;
STATIC void micropy_c_assign(struct _mp_state_ctx_t *mp_state, compiler_t *comp, mp_parse_node_t pn, assign_kind_t kind);

STATIC void micropy_c_assign_atom_expr(struct _mp_state_ctx_t *mp_state, compiler_t *comp, mp_parse_node_struct_t *pns, assign_kind_t assign_kind) {
    if (assign_kind != ASSIGN_AUG_STORE) {
        micropy_compile_node(mp_state, comp, pns->nodes[0]);
    }

    if (MP_PARSE_NODE_IS_STRUCT(pns->nodes[1])) {
        mp_parse_node_struct_t *pns1 = (mp_parse_node_struct_t*)pns->nodes[1];
        if (MP_PARSE_NODE_STRUCT_KIND(pns1) == PN_atom_expr_trailers) {
            int n = MP_PARSE_NODE_STRUCT_NUM_NODES(pns1);
            if (assign_kind != ASSIGN_AUG_STORE) {
                for (int i = 0; i < n - 1; i++) {
                    micropy_compile_node(mp_state, comp, pns1->nodes[i]);
                }
            }
            assert(MP_PARSE_NODE_IS_STRUCT(pns1->nodes[n - 1]));
            pns1 = (mp_parse_node_struct_t*)pns1->nodes[n - 1];
        }
        if (MP_PARSE_NODE_STRUCT_KIND(pns1) == PN_trailer_bracket) {
            if (assign_kind == ASSIGN_AUG_STORE) {
                EMIT(rot_three);
                EMIT(store_subscr);
            } else {
                micropy_compile_node(mp_state, comp, pns1->nodes[0]);
                if (assign_kind == ASSIGN_AUG_LOAD) {
                    EMIT(dup_top_two);
                    EMIT(load_subscr);
                } else {
                    EMIT(store_subscr);
                }
            }
        } else if (MP_PARSE_NODE_STRUCT_KIND(pns1) == PN_trailer_period) {
            assert(MP_PARSE_NODE_IS_ID(pns1->nodes[0]));
            if (assign_kind == ASSIGN_AUG_LOAD) {
                EMIT(dup_top);
                EMIT_ARG(load_attr, MP_PARSE_NODE_LEAF_ARG(pns1->nodes[0]));
            } else {
                if (assign_kind == ASSIGN_AUG_STORE) {
                    EMIT(rot_two);
                }
                EMIT_ARG(store_attr, MP_PARSE_NODE_LEAF_ARG(pns1->nodes[0]));
            }
        } else {
            goto cannot_assign;
        }
    } else {
        goto cannot_assign;
    }

    return;

cannot_assign:
    micropy_compile_syntax_error(mp_state, comp, (mp_parse_node_t)pns, "can't assign to expression");
}

// we need to allow for a caller passing in 1 initial node (node_head) followed by an array of nodes (nodes_tail)
STATIC void micropy_c_assign_tuple(struct _mp_state_ctx_t *mp_state, compiler_t *comp, mp_parse_node_t node_head, uint num_tail, mp_parse_node_t *nodes_tail) {
    uint num_head = (node_head == MP_PARSE_NODE_NULL) ? 0 : 1;

    // look for star expression
    uint have_star_index = -1;
    if (num_head != 0 && MP_PARSE_NODE_IS_STRUCT_KIND(node_head, PN_star_expr)) {
        EMIT_ARG(unpack_ex, 0, num_tail);
        have_star_index = 0;
    }
    for (uint i = 0; i < num_tail; i++) {
        if (MP_PARSE_NODE_IS_STRUCT_KIND(nodes_tail[i], PN_star_expr)) {
            if (have_star_index == (uint)-1) {
                EMIT_ARG(unpack_ex, num_head + i, num_tail - i - 1);
                have_star_index = num_head + i;
            } else {
                micropy_compile_syntax_error(mp_state, comp, nodes_tail[i], "multiple *x in assignment");
                return;
            }
        }
    }
    if (have_star_index == (uint)-1) {
        EMIT_ARG(unpack_sequence, num_head + num_tail);
    }
    if (num_head != 0) {
        if (0 == have_star_index) {
            micropy_c_assign(mp_state, comp, ((mp_parse_node_struct_t*)node_head)->nodes[0], ASSIGN_STORE);
        } else {
            micropy_c_assign(mp_state, comp, node_head, ASSIGN_STORE);
        }
    }
    for (uint i = 0; i < num_tail; i++) {
        if (num_head + i == have_star_index) {
            micropy_c_assign(mp_state, comp, ((mp_parse_node_struct_t*)nodes_tail[i])->nodes[0], ASSIGN_STORE);
        } else {
            micropy_c_assign(mp_state, comp, nodes_tail[i], ASSIGN_STORE);
        }
    }
}

// assigns top of stack to pn
STATIC void micropy_c_assign(struct _mp_state_ctx_t *mp_state, compiler_t *comp, mp_parse_node_t pn, assign_kind_t assign_kind) {
    assert(!MP_PARSE_NODE_IS_NULL(pn));
    if (MP_PARSE_NODE_IS_LEAF(pn)) {
        if (MP_PARSE_NODE_IS_ID(pn)) {
            qstr arg = MP_PARSE_NODE_LEAF_ARG(pn);
            switch (assign_kind) {
                case ASSIGN_STORE:
                case ASSIGN_AUG_STORE:
                    micropy_compile_store_id(mp_state, comp, arg);
                    break;
                case ASSIGN_AUG_LOAD:
                default:
                    micropy_compile_load_id(mp_state, comp, arg);
                    break;
            }
        } else {
            micropy_compile_syntax_error(mp_state, comp, pn, "can't assign to literal");
            return;
        }
    } else {
        // pn must be a struct
        mp_parse_node_struct_t *pns = (mp_parse_node_struct_t*)pn;
        switch (MP_PARSE_NODE_STRUCT_KIND(pns)) {
            case PN_atom_expr_normal:
                // lhs is an index or attribute
                micropy_c_assign_atom_expr(mp_state, comp, pns, assign_kind);
                break;

            case PN_testlist_star_expr:
            case PN_exprlist:
                // lhs is a tuple
                if (assign_kind != ASSIGN_STORE) {
                    goto bad_aug;
                }
                micropy_c_assign_tuple(mp_state, comp, MP_PARSE_NODE_NULL, MP_PARSE_NODE_STRUCT_NUM_NODES(pns), pns->nodes);
                break;

            case PN_atom_paren:
                // lhs is something in parenthesis
                if (MP_PARSE_NODE_IS_NULL(pns->nodes[0])) {
                    // empty tuple
                    goto cannot_assign;
                } else {
                    assert(MP_PARSE_NODE_IS_STRUCT_KIND(pns->nodes[0], PN_testlist_comp));
                    if (assign_kind != ASSIGN_STORE) {
                        goto bad_aug;
                    }
                    pns = (mp_parse_node_struct_t*)pns->nodes[0];
                    goto testlist_comp;
                }
                break;

            case PN_atom_bracket:
                // lhs is something in brackets
                if (assign_kind != ASSIGN_STORE) {
                    goto bad_aug;
                }
                if (MP_PARSE_NODE_IS_NULL(pns->nodes[0])) {
                    // empty list, assignment allowed
                    micropy_c_assign_tuple(mp_state, comp, MP_PARSE_NODE_NULL, 0, NULL);
                } else if (MP_PARSE_NODE_IS_STRUCT_KIND(pns->nodes[0], PN_testlist_comp)) {
                    pns = (mp_parse_node_struct_t*)pns->nodes[0];
                    goto testlist_comp;
                } else {
                    // brackets around 1 item
                    micropy_c_assign_tuple(mp_state, comp, pns->nodes[0], 0, NULL);
                }
                break;

            default:
                goto cannot_assign;
        }
        return;

        testlist_comp:
        // lhs is a sequence
        if (MP_PARSE_NODE_IS_STRUCT(pns->nodes[1])) {
            mp_parse_node_struct_t *pns2 = (mp_parse_node_struct_t*)pns->nodes[1];
            if (MP_PARSE_NODE_STRUCT_KIND(pns2) == PN_testlist_comp_3b) {
                // sequence of one item, with trailing comma
                assert(MP_PARSE_NODE_IS_NULL(pns2->nodes[0]));
                micropy_c_assign_tuple(mp_state, comp, pns->nodes[0], 0, NULL);
            } else if (MP_PARSE_NODE_STRUCT_KIND(pns2) == PN_testlist_comp_3c) {
                // sequence of many items
                uint n = MP_PARSE_NODE_STRUCT_NUM_NODES(pns2);
                micropy_c_assign_tuple(mp_state, comp, pns->nodes[0], n, pns2->nodes);
            } else if (MP_PARSE_NODE_STRUCT_KIND(pns) == PN_comp_for) {
                // TODO can we ever get here? can it be compiled?
                goto cannot_assign;
            } else {
                // sequence with 2 items
                goto sequence_with_2_items;
            }
        } else {
            // sequence with 2 items
            sequence_with_2_items:
            micropy_c_assign_tuple(mp_state, comp, MP_PARSE_NODE_NULL, 2, pns->nodes);
        }
        return;
    }
    return;

    cannot_assign:
    micropy_compile_syntax_error(mp_state, comp, pn, "can't assign to expression");
    return;

    bad_aug:
    micropy_compile_syntax_error(mp_state, comp, pn, "illegal expression for augmented assignment");
}

// stuff for lambda and comprehensions and generators:
//  if n_pos_defaults > 0 then there is a tuple on the stack with the positional defaults
//  if n_kw_defaults > 0 then there is a dictionary on the stack with the keyword defaults
//  if both exist, the tuple is above the dictionary (ie the first pop gets the tuple)
STATIC void micropy_close_over_variables_etc(struct _mp_state_ctx_t *mp_state, compiler_t *comp, scope_t *this_scope, int n_pos_defaults, int n_kw_defaults) {
    assert(n_pos_defaults >= 0);
    assert(n_kw_defaults >= 0);

    // set flags
    if (n_kw_defaults > 0) {
        this_scope->scope_flags |= MP_SCOPE_FLAG_DEFKWARGS;
    }
    this_scope->num_def_pos_args = n_pos_defaults;

    // make closed over variables, if any
    // ensure they are closed over in the order defined in the outer scope (mainly to agree with CPython)
    int nfree = 0;
    if (comp->scope_cur->kind != SCOPE_MODULE) {
        for (int i = 0; i < comp->scope_cur->id_info_len; i++) {
            id_info_t *id = &comp->scope_cur->id_info[i];
            if (id->kind == ID_INFO_KIND_CELL || id->kind == ID_INFO_KIND_FREE) {
                for (int j = 0; j < this_scope->id_info_len; j++) {
                    id_info_t *id2 = &this_scope->id_info[j];
                    if (id2->kind == ID_INFO_KIND_FREE && id->qst == id2->qst) {
                        // in Micro Python we load closures using LOAD_FAST
                        EMIT_LOAD_FAST(id->qst, id->local_num);
                        nfree += 1;
                    }
                }
            }
        }
    }

    // make the function/closure
    if (nfree == 0) {
        EMIT_ARG(make_function, this_scope, n_pos_defaults, n_kw_defaults);
    } else {
        EMIT_ARG(make_closure, this_scope, nfree, n_pos_defaults, n_kw_defaults);
    }
}

STATIC void micropy_compile_funcdef_lambdef_param(struct _mp_state_ctx_t *mp_state, compiler_t *comp, mp_parse_node_t pn) {
    if (MP_PARSE_NODE_IS_STRUCT_KIND(pn, PN_typedargslist_star)
        || MP_PARSE_NODE_IS_STRUCT_KIND(pn, PN_varargslist_star)) {
        comp->have_star = true;
        /* don't need to distinguish bare from named star
        mp_parse_node_struct_t *pns = (mp_parse_node_struct_t*)pn;
        if (MP_PARSE_NODE_IS_NULL(pns->nodes[0])) {
            // bare star
        } else {
            // named star
        }
        */

    } else if (MP_PARSE_NODE_IS_STRUCT_KIND(pn, PN_typedargslist_dbl_star)
        || MP_PARSE_NODE_IS_STRUCT_KIND(pn, PN_varargslist_dbl_star)) {
        // named double star
        // TODO do we need to do anything with this?

    } else {
        mp_parse_node_t pn_id;
        mp_parse_node_t pn_colon;
        mp_parse_node_t pn_equal;
        if (MP_PARSE_NODE_IS_ID(pn)) {
            // this parameter is just an id

            pn_id = pn;
            pn_colon = MP_PARSE_NODE_NULL;
            pn_equal = MP_PARSE_NODE_NULL;

        } else if (MP_PARSE_NODE_IS_STRUCT_KIND(pn, PN_typedargslist_name)) {
            // this parameter has a colon and/or equal specifier

            mp_parse_node_struct_t *pns = (mp_parse_node_struct_t*)pn;
            pn_id = pns->nodes[0];
            pn_colon = pns->nodes[1];
            pn_equal = pns->nodes[2];

        } else {
            assert(MP_PARSE_NODE_IS_STRUCT_KIND(pn, PN_varargslist_name)); // should be
            // this parameter has an equal specifier

            mp_parse_node_struct_t *pns = (mp_parse_node_struct_t*)pn;
            pn_id = pns->nodes[0];
            pn_equal = pns->nodes[1];
        }

        if (MP_PARSE_NODE_IS_NULL(pn_equal)) {
            // this parameter does not have a default value

            // check for non-default parameters given after default parameters (allowed by parser, but not syntactically valid)
            if (!comp->have_star && comp->num_default_params != 0) {
                micropy_compile_syntax_error(mp_state, comp, pn, "non-default argument follows default argument");
                return;
            }

        } else {
            // this parameter has a default value
            // in CPython, None (and True, False?) as default parameters are loaded with LOAD_NAME; don't understandy why

            if (comp->have_star) {
                comp->num_dict_params += 1;
                // in Micro Python we put the default dict parameters into a dictionary using the bytecode
                if (comp->num_dict_params == 1) {
                    // in Micro Python we put the default positional parameters into a tuple using the bytecode
                    // we need to do this here before we start building the map for the default keywords
                    if (comp->num_default_params > 0) {
                        EMIT_ARG(build_tuple, comp->num_default_params);
                    } else {
                        EMIT(load_null); // sentinel indicating empty default positional args
                    }
                    // first default dict param, so make the map
                    EMIT_ARG(build_map, 0);
                }

                // compile value then key, then store it to the dict
                micropy_compile_node(mp_state, comp, pn_equal);
                EMIT_ARG(load_const_str, MP_PARSE_NODE_LEAF_ARG(pn_id));
                EMIT(store_map);
            } else {
                comp->num_default_params += 1;
                micropy_compile_node(mp_state, comp, pn_equal);
            }
        }

        // TODO pn_colon not implemented
        (void)pn_colon;
    }
}

STATIC void micropy_compile_funcdef_lambdef(struct _mp_state_ctx_t *mp_state, compiler_t *comp, scope_t *scope, mp_parse_node_t pn_params, pn_kind_t pn_list_kind) {
    // When we call compile_funcdef_lambdef_param below it can compile an arbitrary
    // expression for default arguments, which may contain a lambda.  The lambda will
    // call here in a nested way, so we must save and restore the relevant state.
    bool orig_have_star = comp->have_star;
    uint16_t orig_num_dict_params = comp->num_dict_params;
    uint16_t orig_num_default_params = comp->num_default_params;

    // compile default parameters
    comp->have_star = false;
    comp->num_dict_params = 0;
    comp->num_default_params = 0;
    micropy_apply_to_single_or_list(mp_state, comp, pn_params, pn_list_kind, micropy_compile_funcdef_lambdef_param);

    if (comp->compile_error != MP_OBJ_NULL) {
        return;
    }

    // in Micro Python we put the default positional parameters into a tuple using the bytecode
    // the default keywords args may have already made the tuple; if not, do it now
    if (comp->num_default_params > 0 && comp->num_dict_params == 0) {
        EMIT_ARG(build_tuple, comp->num_default_params);
        EMIT(load_null); // sentinel indicating empty default keyword args
    }

    // make the function
    micropy_close_over_variables_etc(mp_state, comp, scope, comp->num_default_params, comp->num_dict_params);

    // restore state
    comp->have_star = orig_have_star;
    comp->num_dict_params = orig_num_dict_params;
    comp->num_default_params = orig_num_default_params;
}

// leaves function object on stack
// returns function name
STATIC qstr micropy_compile_funcdef_helper(struct _mp_state_ctx_t *mp_state, compiler_t *comp, mp_parse_node_struct_t *pns, uint emit_options) {
    if (comp->pass == MP_PASS_SCOPE) {
        // create a new scope for this function
        scope_t *s = micropy_scope_new_and_link(mp_state, comp, SCOPE_FUNCTION, (mp_parse_node_t)pns, emit_options);
        // store the function scope so the compiling function can use it at each pass
        pns->nodes[4] = (mp_parse_node_t)s;
    }

    // get the scope for this function
    scope_t *fscope = (scope_t*)pns->nodes[4];

    // compile the function definition
    micropy_compile_funcdef_lambdef(mp_state, comp, fscope, pns->nodes[1], PN_typedargslist);

    // return its name (the 'f' in "def f(...):")
    return fscope->simple_name;
}

// leaves class object on stack
// returns class name
STATIC qstr micropy_compile_classdef_helper(struct _mp_state_ctx_t *mp_state, compiler_t *comp, mp_parse_node_struct_t *pns, uint emit_options) {
    if (comp->pass == MP_PASS_SCOPE) {
        // create a new scope for this class
        scope_t *s = micropy_scope_new_and_link(mp_state, comp, SCOPE_CLASS, (mp_parse_node_t)pns, emit_options);
        // store the class scope so the compiling function can use it at each pass
        pns->nodes[3] = (mp_parse_node_t)s;
    }

    EMIT(load_build_class);

    // scope for this class
    scope_t *cscope = (scope_t*)pns->nodes[3];

    // compile the class
    micropy_close_over_variables_etc(mp_state, comp, cscope, 0, 0);

    // get its name
    EMIT_ARG(load_const_str, cscope->simple_name);

    // nodes[1] has parent classes, if any
    // empty parenthesis (eg class C():) gets here as an empty PN_classdef_2 and needs special handling
    mp_parse_node_t parents = pns->nodes[1];
    if (MP_PARSE_NODE_IS_STRUCT_KIND(parents, PN_classdef_2)) {
        parents = MP_PARSE_NODE_NULL;
    }
    comp->func_arg_is_super = false;
    micropy_compile_trailer_paren_helper(mp_state, comp, parents, false, 2);

    // return its name (the 'C' in class C(...):")
    return cscope->simple_name;
}

// returns true if it was a built-in decorator (even if the built-in had an error)
STATIC bool micropy_compile_built_in_decorator(struct _mp_state_ctx_t *mp_state, compiler_t *comp, int name_len, mp_parse_node_t *name_nodes, uint *emit_options) {
    if (MP_PARSE_NODE_LEAF_ARG(name_nodes[0]) != MP_QSTR_micropython) {
        return false;
    }

    if (name_len != 2) {
        micropy_compile_syntax_error(mp_state, comp, name_nodes[0], "invalid micropython decorator");
        return true;
    }

    qstr attr = MP_PARSE_NODE_LEAF_ARG(name_nodes[1]);
    if (attr == MP_QSTR_bytecode) {
        *emit_options = MP_EMIT_OPT_BYTECODE;
#if MICROPY_EMIT_NATIVE
    } else if (attr == MP_QSTR_native) {
        *emit_options = MP_EMIT_OPT_NATIVE_PYTHON;
    } else if (attr == MP_QSTR_viper) {
        *emit_options = MP_EMIT_OPT_VIPER;
#endif
#if MICROPY_EMIT_INLINE_THUMB
    } else if (attr == MP_QSTR_asm_thumb) {
        *emit_options = MP_EMIT_OPT_ASM_THUMB;
#endif
    } else {
        micropy_compile_syntax_error(mp_state, comp, name_nodes[1], "invalid micropython decorator");
    }

    return true;
}

STATIC void micropy_compile_decorated(struct _mp_state_ctx_t *mp_state, compiler_t *comp, mp_parse_node_struct_t *pns) {
    // get the list of decorators
    mp_parse_node_t *nodes;
    int n = micropy_parse_node_extract_list(mp_state, &pns->nodes[0], PN_decorators, &nodes);

    // inherit emit options for this function/class definition
    uint emit_options = comp->scope_cur->emit_options;

    // compile each decorator
    int num_built_in_decorators = 0;
    for (int i = 0; i < n; i++) {
        assert(MP_PARSE_NODE_IS_STRUCT_KIND(nodes[i], PN_decorator)); // should be
        mp_parse_node_struct_t *pns_decorator = (mp_parse_node_struct_t*)nodes[i];

        // nodes[0] contains the decorator function, which is a dotted name
        mp_parse_node_t *name_nodes;
        int name_len = micropy_parse_node_extract_list(mp_state, &pns_decorator->nodes[0], PN_dotted_name, &name_nodes);

        // check for built-in decorators
        if (micropy_compile_built_in_decorator(mp_state, comp, name_len, name_nodes, &emit_options)) {
            // this was a built-in
            num_built_in_decorators += 1;

        } else {
            // not a built-in, compile normally

            // compile the decorator function
            micropy_compile_node(mp_state, comp, name_nodes[0]);
            for (int j = 1; j < name_len; j++) {
                assert(MP_PARSE_NODE_IS_ID(name_nodes[j])); // should be
                EMIT_ARG(load_attr, MP_PARSE_NODE_LEAF_ARG(name_nodes[j]));
            }

            // nodes[1] contains arguments to the decorator function, if any
            if (!MP_PARSE_NODE_IS_NULL(pns_decorator->nodes[1])) {
                // call the decorator function with the arguments in nodes[1]
                comp->func_arg_is_super = false;
                micropy_compile_node(mp_state, comp, pns_decorator->nodes[1]);
            }
        }
    }

    // compile the body (funcdef, async funcdef or classdef) and get its name
    mp_parse_node_struct_t *pns_body = (mp_parse_node_struct_t*)pns->nodes[1];
    qstr body_name = 0;
    if (MP_PARSE_NODE_STRUCT_KIND(pns_body) == PN_funcdef) {
        body_name = micropy_compile_funcdef_helper(mp_state, comp, pns_body, emit_options);
    #if MICROPY_PY_ASYNC_AWAIT
    } else if (MP_PARSE_NODE_STRUCT_KIND(pns_body) == PN_async_funcdef) {
        assert(MP_PARSE_NODE_IS_STRUCT(pns_body->nodes[0]));
        mp_parse_node_struct_t *pns0 = (mp_parse_node_struct_t*)pns_body->nodes[0];
        body_name = micropy_compile_funcdef_helper(mp_state, comp, pns0, emit_options);
        scope_t *fscope = (scope_t*)pns0->nodes[4];
        fscope->scope_flags |= MP_SCOPE_FLAG_GENERATOR;
    #endif
    } else {
        assert(MP_PARSE_NODE_STRUCT_KIND(pns_body) == PN_classdef); // should be
        body_name = micropy_compile_classdef_helper(mp_state, comp, pns_body, emit_options);
    }

    // call each decorator
    for (int i = 0; i < n - num_built_in_decorators; i++) {
        EMIT_ARG(call_function, 1, 0, 0);
    }

    // store func/class object into name
    micropy_compile_store_id(mp_state, comp, body_name);
}

STATIC void micropy_compile_funcdef(struct _mp_state_ctx_t *mp_state, compiler_t *comp, mp_parse_node_struct_t *pns) {
    qstr fname = micropy_compile_funcdef_helper(mp_state, comp, pns, comp->scope_cur->emit_options);
    // store function object into function name
    micropy_compile_store_id(mp_state, comp, fname);
}

STATIC void micropy_c_del_stmt(struct _mp_state_ctx_t *mp_state, compiler_t *comp, mp_parse_node_t pn) {
    if (MP_PARSE_NODE_IS_ID(pn)) {
        micropy_compile_delete_id(mp_state, comp, MP_PARSE_NODE_LEAF_ARG(pn));
    } else if (MP_PARSE_NODE_IS_STRUCT_KIND(pn, PN_atom_expr_normal)) {
        mp_parse_node_struct_t *pns = (mp_parse_node_struct_t*)pn;

        micropy_compile_node(mp_state, comp, pns->nodes[0]); // base of the atom_expr_normal node

        if (MP_PARSE_NODE_IS_STRUCT(pns->nodes[1])) {
            mp_parse_node_struct_t *pns1 = (mp_parse_node_struct_t*)pns->nodes[1];
            if (MP_PARSE_NODE_STRUCT_KIND(pns1) == PN_atom_expr_trailers) {
                int n = MP_PARSE_NODE_STRUCT_NUM_NODES(pns1);
                for (int i = 0; i < n - 1; i++) {
                    micropy_compile_node(mp_state, comp, pns1->nodes[i]);
                }
                assert(MP_PARSE_NODE_IS_STRUCT(pns1->nodes[n - 1]));
                pns1 = (mp_parse_node_struct_t*)pns1->nodes[n - 1];
            }
            if (MP_PARSE_NODE_STRUCT_KIND(pns1) == PN_trailer_bracket) {
                micropy_compile_node(mp_state, comp, pns1->nodes[0]);
                EMIT(delete_subscr);
            } else if (MP_PARSE_NODE_STRUCT_KIND(pns1) == PN_trailer_period) {
                assert(MP_PARSE_NODE_IS_ID(pns1->nodes[0]));
                EMIT_ARG(delete_attr, MP_PARSE_NODE_LEAF_ARG(pns1->nodes[0]));
            } else {
                goto cannot_delete;
            }
        } else {
            goto cannot_delete;
        }

    } else if (MP_PARSE_NODE_IS_STRUCT_KIND(pn, PN_atom_paren)) {
        pn = ((mp_parse_node_struct_t*)pn)->nodes[0];
        if (MP_PARSE_NODE_IS_NULL(pn)) {
            goto cannot_delete;
        } else {
            assert(MP_PARSE_NODE_IS_STRUCT_KIND(pn, PN_testlist_comp));
            mp_parse_node_struct_t *pns = (mp_parse_node_struct_t*)pn;
            // TODO perhaps factorise testlist_comp code with other uses of PN_testlist_comp

            if (MP_PARSE_NODE_IS_STRUCT(pns->nodes[1])) {
                mp_parse_node_struct_t *pns1 = (mp_parse_node_struct_t*)pns->nodes[1];
                if (MP_PARSE_NODE_STRUCT_KIND(pns1) == PN_testlist_comp_3b) {
                    // sequence of one item, with trailing comma
                    assert(MP_PARSE_NODE_IS_NULL(pns1->nodes[0]));
                    micropy_c_del_stmt(mp_state, comp, pns->nodes[0]);
                } else if (MP_PARSE_NODE_STRUCT_KIND(pns1) == PN_testlist_comp_3c) {
                    // sequence of many items
                    int n = MP_PARSE_NODE_STRUCT_NUM_NODES(pns1);
                    micropy_c_del_stmt(mp_state, comp, pns->nodes[0]);
                    for (int i = 0; i < n; i++) {
                        micropy_c_del_stmt(mp_state, comp, pns1->nodes[i]);
                    }
                } else if (MP_PARSE_NODE_STRUCT_KIND(pns) == PN_comp_for) {
                    // TODO not implemented; can't del comprehension? can we get here?
                    goto cannot_delete;
                } else {
                    // sequence with 2 items
                    goto sequence_with_2_items;
                }
            } else {
                // sequence with 2 items
                sequence_with_2_items:
                micropy_c_del_stmt(mp_state, comp, pns->nodes[0]);
                micropy_c_del_stmt(mp_state, comp, pns->nodes[1]);
            }
        }
    } else {
        // some arbitrary statment that we can't delete (eg del 1)
        goto cannot_delete;
    }

    return;

cannot_delete:
    micropy_compile_syntax_error(mp_state, comp, (mp_parse_node_t)pn, "can't delete expression");
}

STATIC void micropy_compile_del_stmt(struct _mp_state_ctx_t *mp_state, compiler_t *comp, mp_parse_node_struct_t *pns) {
    micropy_apply_to_single_or_list(mp_state, comp, pns->nodes[0], PN_exprlist, micropy_c_del_stmt);
}

STATIC void micropy_compile_break_stmt(struct _mp_state_ctx_t *mp_state, compiler_t *comp, mp_parse_node_struct_t *pns) {
    if (comp->break_label == 0) {
        micropy_compile_syntax_error(mp_state, comp, (mp_parse_node_t)pns, "'break' outside loop");
    }
    assert(comp->cur_except_level >= comp->break_continue_except_level);
    EMIT_ARG(break_loop, comp->break_label, comp->cur_except_level - comp->break_continue_except_level);
}

STATIC void micropy_compile_continue_stmt(struct _mp_state_ctx_t *mp_state, compiler_t *comp, mp_parse_node_struct_t *pns) {
    if (comp->continue_label == 0) {
        micropy_compile_syntax_error(mp_state, comp, (mp_parse_node_t)pns, "'continue' outside loop");
    }
    assert(comp->cur_except_level >= comp->break_continue_except_level);
    EMIT_ARG(continue_loop, comp->continue_label, comp->cur_except_level - comp->break_continue_except_level);
}

STATIC void micropy_compile_return_stmt(struct _mp_state_ctx_t *mp_state, compiler_t *comp, mp_parse_node_struct_t *pns) {
    if (comp->scope_cur->kind != SCOPE_FUNCTION) {
        micropy_compile_syntax_error(mp_state, comp, (mp_parse_node_t)pns, "'return' outside function");
        return;
    }
    if (MP_PARSE_NODE_IS_NULL(pns->nodes[0])) {
        // no argument to 'return', so return None
        EMIT_ARG(load_const_tok, MP_TOKEN_KW_NONE);
    } else if (MP_PARSE_NODE_IS_STRUCT_KIND(pns->nodes[0], PN_test_if_expr)) {
        // special case when returning an if-expression; to match CPython optimisation
        mp_parse_node_struct_t *pns_test_if_expr = (mp_parse_node_struct_t*)pns->nodes[0];
        mp_parse_node_struct_t *pns_test_if_else = (mp_parse_node_struct_t*)pns_test_if_expr->nodes[1];

        uint l_fail = micropy_comp_next_label(mp_state, comp);
        micropy_c_if_cond(mp_state, comp, pns_test_if_else->nodes[0], false, l_fail); // condition
        micropy_compile_node(mp_state, comp, pns_test_if_expr->nodes[0]); // success value
        EMIT(return_value);
        EMIT_ARG(label_assign, l_fail);
        micropy_compile_node(mp_state, comp, pns_test_if_else->nodes[1]); // failure value
    } else {
        micropy_compile_node(mp_state, comp, pns->nodes[0]);
    }
    EMIT(return_value);
}

STATIC void micropy_compile_yield_stmt(struct _mp_state_ctx_t *mp_state, compiler_t *comp, mp_parse_node_struct_t *pns) {
    micropy_compile_node(mp_state, comp, pns->nodes[0]);
    EMIT(pop_top);
}

STATIC void micropy_compile_raise_stmt(struct _mp_state_ctx_t *mp_state, compiler_t *comp, mp_parse_node_struct_t *pns) {
    if (MP_PARSE_NODE_IS_NULL(pns->nodes[0])) {
        // raise
        EMIT_ARG(raise_varargs, 0);
    } else if (MP_PARSE_NODE_IS_STRUCT_KIND(pns->nodes[0], PN_raise_stmt_arg)) {
        // raise x from y
        pns = (mp_parse_node_struct_t*)pns->nodes[0];
        micropy_compile_node(mp_state, comp, pns->nodes[0]);
        micropy_compile_node(mp_state, comp, pns->nodes[1]);
        EMIT_ARG(raise_varargs, 2);
    } else {
        // raise x
        micropy_compile_node(mp_state, comp, pns->nodes[0]);
        EMIT_ARG(raise_varargs, 1);
    }
}

// q_base holds the base of the name
// eg   a -> q_base=a
//      a.b.c -> q_base=a
STATIC void micropy_do_import_name(struct _mp_state_ctx_t *mp_state, compiler_t *comp, mp_parse_node_t pn, qstr *q_base) {
    bool is_as = false;
    if (MP_PARSE_NODE_IS_STRUCT_KIND(pn, PN_dotted_as_name)) {
        mp_parse_node_struct_t *pns = (mp_parse_node_struct_t*)pn;
        // a name of the form x as y; unwrap it
        *q_base = MP_PARSE_NODE_LEAF_ARG(pns->nodes[1]);
        pn = pns->nodes[0];
        is_as = true;
    }
    if (MP_PARSE_NODE_IS_NULL(pn)) {
        // empty name (eg, from . import x)
        *q_base = MP_QSTR_;
        EMIT_ARG(import_name, MP_QSTR_); // import the empty string
    } else if (MP_PARSE_NODE_IS_ID(pn)) {
        // just a simple name
        qstr q_full = MP_PARSE_NODE_LEAF_ARG(pn);
        if (!is_as) {
            *q_base = q_full;
        }
        EMIT_ARG(import_name, q_full);
    } else {
        assert(MP_PARSE_NODE_IS_STRUCT_KIND(pn, PN_dotted_name)); // should be
        mp_parse_node_struct_t *pns = (mp_parse_node_struct_t*)pn;
        {
            // a name of the form a.b.c
            if (!is_as) {
                *q_base = MP_PARSE_NODE_LEAF_ARG(pns->nodes[0]);
            }
            int n = MP_PARSE_NODE_STRUCT_NUM_NODES(pns);
            int len = n - 1;
            for (int i = 0; i < n; i++) {
                len += micropy_qstr_len(mp_state, MP_PARSE_NODE_LEAF_ARG(pns->nodes[i]));
            }
            byte *q_ptr;
            byte *str_dest = micropy_qstr_build_start(mp_state, len, &q_ptr);
            for (int i = 0; i < n; i++) {
                if (i > 0) {
                    *str_dest++ = '.';
                }
                size_t str_src_len;
                const byte *str_src = micropy_qstr_data(mp_state, MP_PARSE_NODE_LEAF_ARG(pns->nodes[i]), &str_src_len);
                memcpy(str_dest, str_src, str_src_len);
                str_dest += str_src_len;
            }
            qstr q_full = micropy_qstr_build_end(mp_state, q_ptr);
            EMIT_ARG(import_name, q_full);
            if (is_as) {
                for (int i = 1; i < n; i++) {
                    EMIT_ARG(load_attr, MP_PARSE_NODE_LEAF_ARG(pns->nodes[i]));
                }
            }
        }
    }
}

STATIC void micropy_compile_dotted_as_name(struct _mp_state_ctx_t *mp_state, compiler_t *comp, mp_parse_node_t pn) {
    EMIT_ARG(load_const_small_int, 0); // level 0 import
    EMIT_ARG(load_const_tok, MP_TOKEN_KW_NONE); // not importing from anything
    qstr q_base;
    micropy_do_import_name(mp_state, comp, pn, &q_base);
    micropy_compile_store_id(mp_state, comp, q_base);
}

STATIC void micropy_compile_import_name(struct _mp_state_ctx_t *mp_state, compiler_t *comp, mp_parse_node_struct_t *pns) {
    micropy_apply_to_single_or_list(mp_state, comp, pns->nodes[0], PN_dotted_as_names, micropy_compile_dotted_as_name);
}

STATIC void micropy_compile_import_from(struct _mp_state_ctx_t *mp_state, compiler_t *comp, mp_parse_node_struct_t *pns) {
    mp_parse_node_t pn_import_source = pns->nodes[0];

    // extract the preceeding .'s (if any) for a relative import, to compute the import level
    uint import_level = 0;
    do {
        mp_parse_node_t pn_rel;
        if (MP_PARSE_NODE_IS_TOKEN(pn_import_source) || MP_PARSE_NODE_IS_STRUCT_KIND(pn_import_source, PN_one_or_more_period_or_ellipsis)) {
            // This covers relative imports with dots only like "from .. import"
            pn_rel = pn_import_source;
            pn_import_source = MP_PARSE_NODE_NULL;
        } else if (MP_PARSE_NODE_IS_STRUCT_KIND(pn_import_source, PN_import_from_2b)) {
            // This covers relative imports starting with dot(s) like "from .foo import"
            mp_parse_node_struct_t *pns_2b = (mp_parse_node_struct_t*)pn_import_source;
            pn_rel = pns_2b->nodes[0];
            pn_import_source = pns_2b->nodes[1];
            assert(!MP_PARSE_NODE_IS_NULL(pn_import_source)); // should not be
        } else {
            // Not a relative import
            break;
        }

        // get the list of . and/or ...'s
        mp_parse_node_t *nodes;
        int n = micropy_parse_node_extract_list(mp_state, &pn_rel, PN_one_or_more_period_or_ellipsis, &nodes);

        // count the total number of .'s
        for (int i = 0; i < n; i++) {
            if (MP_PARSE_NODE_IS_TOKEN_KIND(nodes[i], MP_TOKEN_DEL_PERIOD)) {
                import_level++;
            } else {
                // should be an MP_TOKEN_ELLIPSIS
                import_level += 3;
            }
        }
    } while (0);

    if (MP_PARSE_NODE_IS_TOKEN_KIND(pns->nodes[1], MP_TOKEN_OP_STAR)) {
        EMIT_ARG(load_const_small_int, import_level);

        // build the "fromlist" tuple
        EMIT_ARG(load_const_str, MP_QSTR__star_);
        EMIT_ARG(build_tuple, 1);

        // do the import
        qstr dummy_q;
        micropy_do_import_name(mp_state, comp, pn_import_source, &dummy_q);
        EMIT(import_star);

    } else {
        EMIT_ARG(load_const_small_int, import_level);

        // build the "fromlist" tuple
        mp_parse_node_t *pn_nodes;
        int n = micropy_parse_node_extract_list(mp_state, &pns->nodes[1], PN_import_as_names, &pn_nodes);
        for (int i = 0; i < n; i++) {
            assert(MP_PARSE_NODE_IS_STRUCT_KIND(pn_nodes[i], PN_import_as_name));
            mp_parse_node_struct_t *pns3 = (mp_parse_node_struct_t*)pn_nodes[i];
            qstr id2 = MP_PARSE_NODE_LEAF_ARG(pns3->nodes[0]); // should be id
            EMIT_ARG(load_const_str, id2);
        }
        EMIT_ARG(build_tuple, n);

        // do the import
        qstr dummy_q;
        micropy_do_import_name(mp_state, comp, pn_import_source, &dummy_q);
        for (int i = 0; i < n; i++) {
            assert(MP_PARSE_NODE_IS_STRUCT_KIND(pn_nodes[i], PN_import_as_name));
            mp_parse_node_struct_t *pns3 = (mp_parse_node_struct_t*)pn_nodes[i];
            qstr id2 = MP_PARSE_NODE_LEAF_ARG(pns3->nodes[0]); // should be id
            EMIT_ARG(import_from, id2);
            if (MP_PARSE_NODE_IS_NULL(pns3->nodes[1])) {
                micropy_compile_store_id(mp_state, comp, id2);
            } else {
                micropy_compile_store_id(mp_state, comp, MP_PARSE_NODE_LEAF_ARG(pns3->nodes[1]));
            }
        }
        EMIT(pop_top);
    }
}

STATIC void micropy_compile_declare_global(struct _mp_state_ctx_t *mp_state, compiler_t *comp, mp_parse_node_t pn, qstr qst) {
    bool added;
    id_info_t *id_info = micropy_scope_find_or_add_id(mp_state, comp->scope_cur, qst, &added);
    if (!added && id_info->kind != ID_INFO_KIND_GLOBAL_EXPLICIT) {
        micropy_compile_syntax_error(mp_state, comp, pn, "identifier redefined as global");
        return;
    }
    id_info->kind = ID_INFO_KIND_GLOBAL_EXPLICIT;

    // if the id exists in the global scope, set its kind to EXPLICIT_GLOBAL
    id_info = micropy_scope_find_global(mp_state, comp->scope_cur, qst);
    if (id_info != NULL) {
        id_info->kind = ID_INFO_KIND_GLOBAL_EXPLICIT;
    }
}

STATIC void micropy_compile_global_stmt(struct _mp_state_ctx_t *mp_state, compiler_t *comp, mp_parse_node_struct_t *pns) {
    if (comp->pass == MP_PASS_SCOPE) {
        mp_parse_node_t *nodes;
        int n = micropy_parse_node_extract_list(mp_state, &pns->nodes[0], PN_name_list, &nodes);
        for (int i = 0; i < n; i++) {
            micropy_compile_declare_global(mp_state, comp, (mp_parse_node_t)pns, MP_PARSE_NODE_LEAF_ARG(nodes[i]));
        }
    }
}

STATIC void micropy_compile_declare_nonlocal(struct _mp_state_ctx_t *mp_state, compiler_t *comp, mp_parse_node_t pn, qstr qst) {
    bool added;
    id_info_t *id_info = micropy_scope_find_or_add_id(mp_state, comp->scope_cur, qst, &added);
    if (!added && id_info->kind != ID_INFO_KIND_FREE) {
        micropy_compile_syntax_error(mp_state, comp, pn, "identifier redefined as nonlocal");
        return;
    }
    id_info_t *id_info2 = micropy_scope_find_local_in_parent(mp_state, comp->scope_cur, qst);
    if (id_info2 == NULL || !(id_info2->kind == ID_INFO_KIND_LOCAL || id_info2->kind == ID_INFO_KIND_CELL || id_info2->kind == ID_INFO_KIND_FREE)) {
        micropy_compile_syntax_error(mp_state, comp, pn, "no binding for nonlocal found");
        return;
    }
    id_info->kind = ID_INFO_KIND_FREE;
    micropy_scope_close_over_in_parents(mp_state, comp->scope_cur, qst);
}

STATIC void micropy_compile_nonlocal_stmt(struct _mp_state_ctx_t *mp_state, compiler_t *comp, mp_parse_node_struct_t *pns) {
    if (comp->pass == MP_PASS_SCOPE) {
        if (comp->scope_cur->kind == SCOPE_MODULE) {
            micropy_compile_syntax_error(mp_state, comp, (mp_parse_node_t)pns, "can't declare nonlocal in outer code");
            return;
        }
        mp_parse_node_t *nodes;
        int n = micropy_parse_node_extract_list(mp_state, &pns->nodes[0], PN_name_list, &nodes);
        for (int i = 0; i < n; i++) {
            micropy_compile_declare_nonlocal(mp_state, comp, (mp_parse_node_t)pns, MP_PARSE_NODE_LEAF_ARG(nodes[i]));
        }
    }
}

STATIC void micropy_compile_assert_stmt(struct _mp_state_ctx_t *mp_state, compiler_t *comp, mp_parse_node_struct_t *pns) {
    uint l_end = micropy_comp_next_label(mp_state, comp);
    micropy_c_if_cond(mp_state, comp, pns->nodes[0], true, l_end);
    EMIT_LOAD_GLOBAL(MP_QSTR_AssertionError); // we load_global instead of load_id, to be consistent with CPython
    if (!MP_PARSE_NODE_IS_NULL(pns->nodes[1])) {
        // assertion message
        micropy_compile_node(mp_state, comp, pns->nodes[1]);
        EMIT_ARG(call_function, 1, 0, 0);
    }
    EMIT_ARG(raise_varargs, 1);
    EMIT_ARG(label_assign, l_end);
}

STATIC void micropy_compile_if_stmt(struct _mp_state_ctx_t *mp_state, compiler_t *comp, mp_parse_node_struct_t *pns) {
    // TODO proper and/or short circuiting

    uint l_end = micropy_comp_next_label(mp_state, comp);

    // optimisation: don't emit anything when "if False"
    if (!micropy_node_is_const_false(mp_state, pns->nodes[0])) {
        uint l_fail = micropy_comp_next_label(mp_state, comp);
        micropy_c_if_cond(mp_state, comp, pns->nodes[0], false, l_fail); // if condition

        micropy_compile_node(mp_state, comp, pns->nodes[1]); // if block

        // optimisation: skip everything else when "if True"
        if (micropy_node_is_const_true(mp_state, pns->nodes[0])) {
            goto done;
        }

        if (
            // optimisation: don't jump over non-existent elif/else blocks
            !(MP_PARSE_NODE_IS_NULL(pns->nodes[2]) && MP_PARSE_NODE_IS_NULL(pns->nodes[3]))
            // optimisation: don't jump if last instruction was return
            && !EMIT(last_emit_was_return_value)
            ) {
            // jump over elif/else blocks
            EMIT_ARG(jump, l_end);
        }

        EMIT_ARG(label_assign, l_fail);
    }

    // compile elif blocks (if any)
    mp_parse_node_t *pn_elif;
    int n_elif = micropy_parse_node_extract_list(mp_state, &pns->nodes[2], PN_if_stmt_elif_list, &pn_elif);
    for (int i = 0; i < n_elif; i++) {
        assert(MP_PARSE_NODE_IS_STRUCT_KIND(pn_elif[i], PN_if_stmt_elif)); // should be
        mp_parse_node_struct_t *pns_elif = (mp_parse_node_struct_t*)pn_elif[i];

        // optimisation: don't emit anything when "if False"
        if (!micropy_node_is_const_false(mp_state, pns_elif->nodes[0])) {
            uint l_fail = micropy_comp_next_label(mp_state, comp);
            micropy_c_if_cond(mp_state, comp, pns_elif->nodes[0], false, l_fail); // elif condition

            micropy_compile_node(mp_state, comp, pns_elif->nodes[1]); // elif block

            // optimisation: skip everything else when "elif True"
            if (micropy_node_is_const_true(mp_state, pns_elif->nodes[0])) {
                goto done;
            }

            // optimisation: don't jump if last instruction was return
            if (!EMIT(last_emit_was_return_value)) {
                EMIT_ARG(jump, l_end);
            }
            EMIT_ARG(label_assign, l_fail);
        }
    }

    // compile else block
    micropy_compile_node(mp_state, comp, pns->nodes[3]); // can be null

done:
    EMIT_ARG(label_assign, l_end);
}

#define START_BREAK_CONTINUE_BLOCK \
    uint16_t old_break_label = comp->break_label; \
    uint16_t old_continue_label = comp->continue_label; \
    uint16_t old_break_continue_except_level = comp->break_continue_except_level; \
    uint break_label = micropy_comp_next_label(mp_state, comp); \
    uint continue_label = micropy_comp_next_label(mp_state, comp); \
    comp->break_label = break_label; \
    comp->continue_label = continue_label; \
    comp->break_continue_except_level = comp->cur_except_level;

#define END_BREAK_CONTINUE_BLOCK \
    comp->break_label = old_break_label; \
    comp->continue_label = old_continue_label; \
    comp->break_continue_except_level = old_break_continue_except_level;

STATIC void micropy_compile_while_stmt(struct _mp_state_ctx_t *mp_state, compiler_t *comp, mp_parse_node_struct_t *pns) {
    START_BREAK_CONTINUE_BLOCK

    if (!micropy_node_is_const_false(mp_state, pns->nodes[0])) { // optimisation: don't emit anything for "while False"
        uint top_label = micropy_comp_next_label(mp_state, comp);
        if (!micropy_node_is_const_true(mp_state, pns->nodes[0])) { // optimisation: don't jump to cond for "while True"
            EMIT_ARG(jump, continue_label);
        }
        EMIT_ARG(label_assign, top_label);
        micropy_compile_node(mp_state, comp, pns->nodes[1]); // body
        EMIT_ARG(label_assign, continue_label);
        micropy_c_if_cond(mp_state, comp, pns->nodes[0], true, top_label); // condition
    }

    // break/continue apply to outer loop (if any) in the else block
    END_BREAK_CONTINUE_BLOCK

    micropy_compile_node(mp_state, comp, pns->nodes[2]); // else

    EMIT_ARG(label_assign, break_label);
}

// This function compiles an optimised for-loop of the form:
//      for <var> in range(<start>, <end>, <step>):
//          <body>
//      else:
//          <else>
// <var> must be an identifier and <step> must be a small-int.
//
// Semantics of for-loop require:
//  - final failing value should not be stored in the loop variable
//  - if the loop never runs, the loop variable should never be assigned
//  - assignments to <var>, <end> or <step> in the body do not alter the loop
//    (<step> is a constant for us, so no need to worry about it changing)
//
// If <end> is a small-int, then the stack during the for-loop contains just
// the current value of <var>.  Otherwise, the stack contains <end> then the
// current value of <var>.
STATIC void micropy_compile_for_stmt_optimised_range(struct _mp_state_ctx_t *mp_state, compiler_t *comp, mp_parse_node_t pn_var, mp_parse_node_t pn_start, mp_parse_node_t pn_end, mp_parse_node_t pn_step, mp_parse_node_t pn_body, mp_parse_node_t pn_else) {
    START_BREAK_CONTINUE_BLOCK

    uint top_label = micropy_comp_next_label(mp_state, comp);
    uint entry_label = micropy_comp_next_label(mp_state, comp);

    // put the end value on the stack if it's not a small-int constant
    bool end_on_stack = !MP_PARSE_NODE_IS_SMALL_INT(pn_end);
    if (end_on_stack) {
        micropy_compile_node(mp_state, comp, pn_end);
    }

    // compile: start
    micropy_compile_node(mp_state, comp, pn_start);

    EMIT_ARG(jump, entry_label);
    EMIT_ARG(label_assign, top_label);

    // duplicate next value and store it to var
    EMIT(dup_top);
    micropy_c_assign(mp_state, comp, pn_var, ASSIGN_STORE);

    // compile body
    micropy_compile_node(mp_state, comp, pn_body);

    EMIT_ARG(label_assign, continue_label);

    // compile: var + step
    micropy_compile_node(mp_state, comp, pn_step);
    EMIT_ARG(binary_op, MP_BINARY_OP_INPLACE_ADD);

    EMIT_ARG(label_assign, entry_label);

    // compile: if var <cond> end: goto top
    if (end_on_stack) {
        EMIT(dup_top_two);
        EMIT(rot_two);
    } else {
        EMIT(dup_top);
        micropy_compile_node(mp_state, comp, pn_end);
    }
    assert(MP_PARSE_NODE_IS_SMALL_INT(pn_step));
    if (MP_PARSE_NODE_LEAF_SMALL_INT(pn_step) >= 0) {
        EMIT_ARG(binary_op, MP_BINARY_OP_LESS);
    } else {
        EMIT_ARG(binary_op, MP_BINARY_OP_MORE);
    }
    EMIT_ARG(pop_jump_if, true, top_label);

    // break/continue apply to outer loop (if any) in the else block
    END_BREAK_CONTINUE_BLOCK

    micropy_compile_node(mp_state, comp, pn_else);

    EMIT_ARG(label_assign, break_label);

    // discard final value of var that failed the loop condition
    EMIT(pop_top);

    // discard <end> value if it's on the stack
    if (end_on_stack) {
        EMIT(pop_top);
    }
}

STATIC void micropy_compile_for_stmt(struct _mp_state_ctx_t *mp_state, compiler_t *comp, mp_parse_node_struct_t *pns) {
    // this bit optimises: for <x> in range(...), turning it into an explicitly incremented variable
    // this is actually slower, but uses no heap memory
    // for viper it will be much, much faster
    if (/*comp->scope_cur->emit_options == MP_EMIT_OPT_VIPER &&*/ MP_PARSE_NODE_IS_ID(pns->nodes[0]) && MP_PARSE_NODE_IS_STRUCT_KIND(pns->nodes[1], PN_atom_expr_normal)) {
        mp_parse_node_struct_t *pns_it = (mp_parse_node_struct_t*)pns->nodes[1];
        if (MP_PARSE_NODE_IS_ID(pns_it->nodes[0])
            && MP_PARSE_NODE_LEAF_ARG(pns_it->nodes[0]) == MP_QSTR_range
            && MP_PARSE_NODE_IS_STRUCT_KIND(pns_it->nodes[1], PN_trailer_paren)) {
            mp_parse_node_t pn_range_args = ((mp_parse_node_struct_t*)pns_it->nodes[1])->nodes[0];
            mp_parse_node_t *args;
            int n_args = micropy_parse_node_extract_list(mp_state, &pn_range_args, PN_arglist, &args);
            mp_parse_node_t pn_range_start;
            mp_parse_node_t pn_range_end;
            mp_parse_node_t pn_range_step;
            bool optimize = false;
            if (1 <= n_args && n_args <= 3) {
                optimize = true;
                if (n_args == 1) {
                    pn_range_start = micropy_parse_node_new_leaf(mp_state, MP_PARSE_NODE_SMALL_INT, 0);
                    pn_range_end = args[0];
                    pn_range_step = micropy_parse_node_new_leaf(mp_state, MP_PARSE_NODE_SMALL_INT, 1);
                } else if (n_args == 2) {
                    pn_range_start = args[0];
                    pn_range_end = args[1];
                    pn_range_step = micropy_parse_node_new_leaf(mp_state, MP_PARSE_NODE_SMALL_INT, 1);
                } else {
                    pn_range_start = args[0];
                    pn_range_end = args[1];
                    pn_range_step = args[2];
                    // We need to know sign of step. This is possible only if it's constant
                    if (!MP_PARSE_NODE_IS_SMALL_INT(pn_range_step)) {
                        optimize = false;
                    }
                }
                // arguments must be able to be compiled as standard expressions
                if (optimize && MP_PARSE_NODE_IS_STRUCT(pn_range_start)) {
                    int k = MP_PARSE_NODE_STRUCT_KIND((mp_parse_node_struct_t*)pn_range_start);
                    if (k == PN_arglist_star || k == PN_arglist_dbl_star || k == PN_argument) {
                        optimize = false;
                    }
                }
                if (optimize && MP_PARSE_NODE_IS_STRUCT(pn_range_end)) {
                    int k = MP_PARSE_NODE_STRUCT_KIND((mp_parse_node_struct_t*)pn_range_end);
                    if (k == PN_arglist_star || k == PN_arglist_dbl_star || k == PN_argument) {
                        optimize = false;
                    }
                }
            }
            if (optimize) {
                micropy_compile_for_stmt_optimised_range(mp_state, comp, pns->nodes[0], pn_range_start, pn_range_end, pn_range_step, pns->nodes[2], pns->nodes[3]);
                return;
            }
        }
    }

    START_BREAK_CONTINUE_BLOCK
    comp->break_label |= MP_EMIT_BREAK_FROM_FOR;

    uint pop_label = micropy_comp_next_label(mp_state, comp);

    micropy_compile_node(mp_state, comp, pns->nodes[1]); // iterator
    EMIT(get_iter);
    EMIT_ARG(label_assign, continue_label);
    EMIT_ARG(for_iter, pop_label);
    micropy_c_assign(mp_state, comp, pns->nodes[0], ASSIGN_STORE); // variable
    micropy_compile_node(mp_state, comp, pns->nodes[2]); // body
    if (!EMIT(last_emit_was_return_value)) {
        EMIT_ARG(jump, continue_label);
    }
    EMIT_ARG(label_assign, pop_label);
    EMIT(for_iter_end);

    // break/continue apply to outer loop (if any) in the else block
    END_BREAK_CONTINUE_BLOCK

    micropy_compile_node(mp_state, comp, pns->nodes[3]); // else (not tested)

    EMIT_ARG(label_assign, break_label);
}

STATIC void micropy_compile_try_except(struct _mp_state_ctx_t *mp_state, compiler_t *comp, mp_parse_node_t pn_body, int n_except, mp_parse_node_t *pn_excepts, mp_parse_node_t pn_else) {
    // setup code
    uint l1 = micropy_comp_next_label(mp_state, comp);
    uint success_label = micropy_comp_next_label(mp_state, comp);

    EMIT_ARG(setup_except, l1);
    micropy_compile_increase_except_level(mp_state, comp);

    micropy_compile_node(mp_state, comp, pn_body); // body
    EMIT(pop_block);
    EMIT_ARG(jump, success_label); // jump over exception handler

    EMIT_ARG(label_assign, l1); // start of exception handler
    EMIT(start_except_handler);

    uint l2 = micropy_comp_next_label(mp_state, comp);

    for (int i = 0; i < n_except; i++) {
        assert(MP_PARSE_NODE_IS_STRUCT_KIND(pn_excepts[i], PN_try_stmt_except)); // should be
        mp_parse_node_struct_t *pns_except = (mp_parse_node_struct_t*)pn_excepts[i];

        qstr qstr_exception_local = 0;
        uint end_finally_label = micropy_comp_next_label(mp_state, comp);

        if (MP_PARSE_NODE_IS_NULL(pns_except->nodes[0])) {
            // this is a catch all exception handler
            if (i + 1 != n_except) {
                micropy_compile_syntax_error(mp_state, comp, pn_excepts[i], "default 'except:' must be last");
                micropy_compile_decrease_except_level(mp_state, comp);
                return;
            }
        } else {
            // this exception handler requires a match to a certain type of exception
            mp_parse_node_t pns_exception_expr = pns_except->nodes[0];
            if (MP_PARSE_NODE_IS_STRUCT(pns_exception_expr)) {
                mp_parse_node_struct_t *pns3 = (mp_parse_node_struct_t*)pns_exception_expr;
                if (MP_PARSE_NODE_STRUCT_KIND(pns3) == PN_try_stmt_as_name) {
                    // handler binds the exception to a local
                    pns_exception_expr = pns3->nodes[0];
                    qstr_exception_local = MP_PARSE_NODE_LEAF_ARG(pns3->nodes[1]);
                }
            }
            EMIT(dup_top);
            micropy_compile_node(mp_state, comp, pns_exception_expr);
            EMIT_ARG(binary_op, MP_BINARY_OP_EXCEPTION_MATCH);
            EMIT_ARG(pop_jump_if, false, end_finally_label);
        }

        EMIT(pop_top);

        if (qstr_exception_local == 0) {
            EMIT(pop_top);
        } else {
            micropy_compile_store_id(mp_state, comp, qstr_exception_local);
        }

        EMIT(pop_top);

        uint l3 = 0;
        if (qstr_exception_local != 0) {
            l3 = micropy_comp_next_label(mp_state, comp);
            EMIT_ARG(setup_finally, l3);
            micropy_compile_increase_except_level(mp_state, comp);
        }
        micropy_compile_node(mp_state, comp, pns_except->nodes[1]);
        if (qstr_exception_local != 0) {
            EMIT(pop_block);
        }
        EMIT(pop_except);
        if (qstr_exception_local != 0) {
            EMIT_ARG(load_const_tok, MP_TOKEN_KW_NONE);
            EMIT_ARG(label_assign, l3);
            EMIT_ARG(load_const_tok, MP_TOKEN_KW_NONE);
            micropy_compile_store_id(mp_state, comp, qstr_exception_local);
            micropy_compile_delete_id(mp_state, comp, qstr_exception_local);

            micropy_compile_decrease_except_level(mp_state, comp);
            EMIT(end_finally);
        }
        EMIT_ARG(jump, l2);
        EMIT_ARG(label_assign, end_finally_label);
        EMIT_ARG(adjust_stack_size, 3); // stack adjust for the 3 exception items
    }

    micropy_compile_decrease_except_level(mp_state, comp);
    EMIT(end_finally);
    EMIT(end_except_handler);

    EMIT_ARG(label_assign, success_label);
    micropy_compile_node(mp_state, comp, pn_else); // else block, can be null
    EMIT_ARG(label_assign, l2);
}

STATIC void micropy_compile_try_finally(struct _mp_state_ctx_t *mp_state, compiler_t *comp, mp_parse_node_t pn_body, int n_except, mp_parse_node_t *pn_except, mp_parse_node_t pn_else, mp_parse_node_t pn_finally) {
    uint l_finally_block = micropy_comp_next_label(mp_state, comp);

    EMIT_ARG(setup_finally, l_finally_block);
    micropy_compile_increase_except_level(mp_state, comp);

    if (n_except == 0) {
        assert(MP_PARSE_NODE_IS_NULL(pn_else));
        EMIT_ARG(adjust_stack_size, 3); // stack adjust for possible UNWIND_JUMP state
        micropy_compile_node(mp_state, comp, pn_body);
        EMIT_ARG(adjust_stack_size, -3);
    } else {
        micropy_compile_try_except(mp_state, comp, pn_body, n_except, pn_except, pn_else);
    }
    EMIT(pop_block);
    EMIT_ARG(load_const_tok, MP_TOKEN_KW_NONE);
    EMIT_ARG(label_assign, l_finally_block);
    micropy_compile_node(mp_state, comp, pn_finally);

    micropy_compile_decrease_except_level(mp_state, comp);
    EMIT(end_finally);
}

STATIC void micropy_compile_try_stmt(struct _mp_state_ctx_t *mp_state, compiler_t *comp, mp_parse_node_struct_t *pns) {
    assert(MP_PARSE_NODE_IS_STRUCT(pns->nodes[1])); // should be
    {
        mp_parse_node_struct_t *pns2 = (mp_parse_node_struct_t*)pns->nodes[1];
        if (MP_PARSE_NODE_STRUCT_KIND(pns2) == PN_try_stmt_finally) {
            // just try-finally
            micropy_compile_try_finally(mp_state, comp, pns->nodes[0], 0, NULL, MP_PARSE_NODE_NULL, pns2->nodes[0]);
        } else if (MP_PARSE_NODE_STRUCT_KIND(pns2) == PN_try_stmt_except_and_more) {
            // try-except and possibly else and/or finally
            mp_parse_node_t *pn_excepts;
            int n_except = micropy_parse_node_extract_list(mp_state, &pns2->nodes[0], PN_try_stmt_except_list, &pn_excepts);
            if (MP_PARSE_NODE_IS_NULL(pns2->nodes[2])) {
                // no finally
                micropy_compile_try_except(mp_state, comp, pns->nodes[0], n_except, pn_excepts, pns2->nodes[1]);
            } else {
                // have finally
                micropy_compile_try_finally(mp_state, comp, pns->nodes[0], n_except, pn_excepts, pns2->nodes[1], ((mp_parse_node_struct_t*)pns2->nodes[2])->nodes[0]);
            }
        } else {
            // just try-except
            mp_parse_node_t *pn_excepts;
            int n_except = micropy_parse_node_extract_list(mp_state, &pns->nodes[1], PN_try_stmt_except_list, &pn_excepts);
            micropy_compile_try_except(mp_state, comp, pns->nodes[0], n_except, pn_excepts, MP_PARSE_NODE_NULL);
        }
    }
}

STATIC void micropy_compile_with_stmt_helper(struct _mp_state_ctx_t *mp_state, compiler_t *comp, int n, mp_parse_node_t *nodes, mp_parse_node_t body) {
    if (n == 0) {
        // no more pre-bits, compile the body of the with
        micropy_compile_node(mp_state, comp, body);
    } else {
        uint l_end = micropy_comp_next_label(mp_state, comp);
        if (MICROPY_EMIT_NATIVE && comp->scope_cur->emit_options != MP_EMIT_OPT_BYTECODE) {
            // we need to allocate an extra label for the native emitter
            // it will use l_end+1 as an auxiliary label
            micropy_comp_next_label(mp_state, comp);
        }
        if (MP_PARSE_NODE_IS_STRUCT_KIND(nodes[0], PN_with_item)) {
            // this pre-bit is of the form "a as b"
            mp_parse_node_struct_t *pns = (mp_parse_node_struct_t*)nodes[0];
            micropy_compile_node(mp_state, comp, pns->nodes[0]);
            EMIT_ARG(setup_with, l_end);
            micropy_c_assign(mp_state, comp, pns->nodes[1], ASSIGN_STORE);
        } else {
            // this pre-bit is just an expression
            micropy_compile_node(mp_state, comp, nodes[0]);
            EMIT_ARG(setup_with, l_end);
            EMIT(pop_top);
        }
        micropy_compile_increase_except_level(mp_state, comp);
        // compile additional pre-bits and the body
        micropy_compile_with_stmt_helper(mp_state, comp, n - 1, nodes + 1, body);
        // finish this with block
        EMIT_ARG(with_cleanup, l_end);
        micropy_compile_decrease_except_level(mp_state, comp);
        EMIT(end_finally);
    }
}

STATIC void micropy_compile_with_stmt(struct _mp_state_ctx_t *mp_state, compiler_t *comp, mp_parse_node_struct_t *pns) {
    // get the nodes for the pre-bit of the with (the a as b, c as d, ... bit)
    mp_parse_node_t *nodes;
    int n = micropy_parse_node_extract_list(mp_state, &pns->nodes[0], PN_with_stmt_list, &nodes);
    assert(n > 0);

    // compile in a nested fashion
    micropy_compile_with_stmt_helper(mp_state, comp, n, nodes, pns->nodes[1]);
}

STATIC void micropy_compile_yield_from(struct _mp_state_ctx_t *mp_state, compiler_t *comp) {
    EMIT(get_iter);
    EMIT_ARG(load_const_tok, MP_TOKEN_KW_NONE);
    EMIT(yield_from);
}

#if MICROPY_PY_ASYNC_AWAIT
STATIC void micropy_compile_await_object_method(struct _mp_state_ctx_t *mp_state, compiler_t *comp, qstr method) {
    EMIT_ARG(load_method, method);
    EMIT_ARG(call_method, 0, 0, 0);
    micropy_compile_yield_from(mp_state, comp);
}

STATIC void micropy_compile_async_for_stmt(struct _mp_state_ctx_t *mp_state, compiler_t *comp, mp_parse_node_struct_t *pns) {
    // comp->break_label |= MP_EMIT_BREAK_FROM_FOR;

    qstr context = MP_PARSE_NODE_LEAF_ARG(pns->nodes[1]);
    uint while_else_label = micropy_comp_next_label(mp_state, comp);
    uint try_exception_label = micropy_comp_next_label(mp_state, comp);
    uint try_else_label = micropy_comp_next_label(mp_state, comp);
    uint try_finally_label = micropy_comp_next_label(mp_state, comp);

    micropy_compile_node(mp_state, comp, pns->nodes[1]); // iterator
    micropy_compile_await_object_method(mp_state, comp, MP_QSTR___aiter__);
    micropy_compile_store_id(mp_state, comp, context);

    START_BREAK_CONTINUE_BLOCK

    EMIT_ARG(label_assign, continue_label);

    EMIT_ARG(setup_except, try_exception_label);
    micropy_compile_increase_except_level(mp_state, comp);

    micropy_compile_load_id(mp_state, comp, context);
    micropy_compile_await_object_method(mp_state, comp, MP_QSTR___anext__);
    micropy_c_assign(mp_state, comp, pns->nodes[0], ASSIGN_STORE); // variable
    EMIT(pop_block);
    EMIT_ARG(jump, try_else_label);

    EMIT_ARG(label_assign, try_exception_label);
    EMIT(start_except_handler);
    EMIT(dup_top);
    EMIT_LOAD_GLOBAL(MP_QSTR_StopAsyncIteration);
    EMIT_ARG(binary_op, MP_BINARY_OP_EXCEPTION_MATCH);
    EMIT_ARG(pop_jump_if, false, try_finally_label);
    EMIT(pop_top);
    EMIT(pop_top);
    EMIT(pop_top);
    EMIT(pop_except);
    EMIT_ARG(jump, while_else_label);

    EMIT_ARG(label_assign, try_finally_label);
    EMIT_ARG(adjust_stack_size, 3);
    micropy_compile_decrease_except_level(mp_state, comp);
    EMIT(end_finally);
    EMIT(end_except_handler);

    EMIT_ARG(label_assign, try_else_label);
    micropy_compile_node(mp_state, comp, pns->nodes[2]); // body

    EMIT_ARG(jump, continue_label);
    // break/continue apply to outer loop (if any) in the else block
    END_BREAK_CONTINUE_BLOCK

    EMIT_ARG(label_assign, while_else_label);
    micropy_compile_node(mp_state, comp, pns->nodes[3]); // else

    EMIT_ARG(label_assign, break_label);
}

STATIC void micropy_compile_async_with_stmt_helper(struct _mp_state_ctx_t *mp_state, compiler_t *comp, int n, mp_parse_node_t *nodes, mp_parse_node_t body) {
    if (n == 0) {
        // no more pre-bits, compile the body of the with
        micropy_compile_node(mp_state, comp, body);
    } else {
        uint try_exception_label = micropy_comp_next_label(mp_state, comp);
        uint no_reraise_label = micropy_comp_next_label(mp_state, comp);
        uint try_else_label = micropy_comp_next_label(mp_state, comp);
        uint end_label = micropy_comp_next_label(mp_state, comp);
        qstr context;

        if (MP_PARSE_NODE_IS_STRUCT_KIND(nodes[0], PN_with_item)) {
            // this pre-bit is of the form "a as b"
            mp_parse_node_struct_t *pns = (mp_parse_node_struct_t*)nodes[0];
            micropy_compile_node(mp_state, comp, pns->nodes[0]);
            context = MP_PARSE_NODE_LEAF_ARG(pns->nodes[0]);
            micropy_compile_store_id(mp_state, comp, context);
            micropy_compile_load_id(mp_state, comp, context);
            micropy_compile_await_object_method(mp_state, comp, MP_QSTR___aenter__);
            micropy_c_assign(mp_state, comp, pns->nodes[1], ASSIGN_STORE);
        } else {
            // this pre-bit is just an expression
            micropy_compile_node(mp_state, comp, nodes[0]);
            context = MP_PARSE_NODE_LEAF_ARG(nodes[0]);
            micropy_compile_store_id(mp_state, comp, context);
            micropy_compile_load_id(mp_state, comp, context);
            micropy_compile_await_object_method(mp_state, comp, MP_QSTR___aenter__);
            EMIT(pop_top);
        }

        micropy_compile_load_id(mp_state, comp, context);
        EMIT_ARG(load_method, MP_QSTR___aexit__);

        EMIT_ARG(setup_except, try_exception_label);
        micropy_compile_increase_except_level(mp_state, comp);
        // compile additional pre-bits and the body
        micropy_compile_async_with_stmt_helper(mp_state, comp, n - 1, nodes + 1, body);
        // finish this with block
        EMIT(pop_block);
        EMIT_ARG(jump, try_else_label); // jump over exception handler

        EMIT_ARG(label_assign, try_exception_label); // start of exception handler
        EMIT(start_except_handler);
        EMIT(rot_three);
        EMIT(rot_two);
        EMIT_ARG(call_method, 3, 0, 0);
        micropy_compile_yield_from(mp_state, comp);
        EMIT_ARG(pop_jump_if, true, no_reraise_label);
        EMIT_ARG(raise_varargs, 0);

        EMIT_ARG(label_assign, no_reraise_label);
        EMIT(pop_except);
        EMIT_ARG(jump, end_label);

        EMIT_ARG(adjust_stack_size, 5);
        micropy_compile_decrease_except_level(mp_state, comp);
        EMIT(end_finally);
        EMIT(end_except_handler);

        EMIT_ARG(label_assign, try_else_label); // start of try-else handler
        EMIT_ARG(load_const_tok, MP_TOKEN_KW_NONE);
        EMIT(dup_top);
        EMIT(dup_top);
        EMIT_ARG(call_method, 3, 0, 0);
        micropy_compile_yield_from(mp_state, comp);
        EMIT(pop_top);

        EMIT_ARG(label_assign, end_label);

    }
}

STATIC void micropy_compile_async_with_stmt(struct _mp_state_ctx_t *mp_state, compiler_t *comp, mp_parse_node_struct_t *pns) {
    // get the nodes for the pre-bit of the with (the a as b, c as d, ... bit)
    mp_parse_node_t *nodes;
    int n = micropy_parse_node_extract_list(mp_state, &pns->nodes[0], PN_with_stmt_list, &nodes);
    assert(n > 0);

    // compile in a nested fashion
    micropy_compile_async_with_stmt_helper(mp_state, comp, n, nodes, pns->nodes[1]);
}

STATIC void micropy_compile_async_stmt(struct _mp_state_ctx_t *mp_state, compiler_t *comp, mp_parse_node_struct_t *pns) {
    assert(MP_PARSE_NODE_IS_STRUCT(pns->nodes[0]));
    mp_parse_node_struct_t *pns0 = (mp_parse_node_struct_t*)pns->nodes[0];
    if (MP_PARSE_NODE_STRUCT_KIND(pns0) == PN_funcdef) {
        // async def
        micropy_compile_funcdef(mp_state, comp, pns0);
        scope_t *fscope = (scope_t*)pns0->nodes[4];
        fscope->scope_flags |= MP_SCOPE_FLAG_GENERATOR;
    } else if (MP_PARSE_NODE_STRUCT_KIND(pns0) == PN_for_stmt) {
        // async for
        micropy_compile_async_for_stmt(mp_state, comp, pns0);
    } else {
        // async with
        assert(MP_PARSE_NODE_STRUCT_KIND(pns0) == PN_with_stmt);
        micropy_compile_async_with_stmt(mp_state, comp, pns0);
    }
}
#endif

STATIC void micropy_compile_expr_stmt(struct _mp_state_ctx_t *mp_state, compiler_t *comp, mp_parse_node_struct_t *pns) {
    if (MP_PARSE_NODE_IS_NULL(pns->nodes[1])) {
        if (comp->is_repl && comp->scope_cur->kind == SCOPE_MODULE) {
            // for REPL, evaluate then print the expression
            micropy_compile_load_id(mp_state, comp, MP_QSTR___repl_print__);
            micropy_compile_node(mp_state, comp, pns->nodes[0]);
            EMIT_ARG(call_function, 1, 0, 0);
            EMIT(pop_top);

        } else {
            // for non-REPL, evaluate then discard the expression
            if ((MP_PARSE_NODE_IS_LEAF(pns->nodes[0]) && !MP_PARSE_NODE_IS_ID(pns->nodes[0]))
                || MP_PARSE_NODE_IS_STRUCT_KIND(pns->nodes[0], PN_string)
                || MP_PARSE_NODE_IS_STRUCT_KIND(pns->nodes[0], PN_bytes)
                || MP_PARSE_NODE_IS_STRUCT_KIND(pns->nodes[0], PN_const_object)) {
                // do nothing with a lonely constant
            } else {
                micropy_compile_node(mp_state, comp, pns->nodes[0]); // just an expression
                EMIT(pop_top); // discard last result since this is a statement and leaves nothing on the stack
            }
        }
    } else if (MP_PARSE_NODE_IS_STRUCT(pns->nodes[1])) {
        mp_parse_node_struct_t *pns1 = (mp_parse_node_struct_t*)pns->nodes[1];
        int kind = MP_PARSE_NODE_STRUCT_KIND(pns1);
        if (kind == PN_expr_stmt_augassign) {
            micropy_c_assign(mp_state, comp, pns->nodes[0], ASSIGN_AUG_LOAD); // lhs load for aug assign
            micropy_compile_node(mp_state, comp, pns1->nodes[1]); // rhs
            assert(MP_PARSE_NODE_IS_TOKEN(pns1->nodes[0]));
            mp_binary_op_t op;
            switch (MP_PARSE_NODE_LEAF_ARG(pns1->nodes[0])) {
                case MP_TOKEN_DEL_PIPE_EQUAL: op = MP_BINARY_OP_INPLACE_OR; break;
                case MP_TOKEN_DEL_CARET_EQUAL: op = MP_BINARY_OP_INPLACE_XOR; break;
                case MP_TOKEN_DEL_AMPERSAND_EQUAL: op = MP_BINARY_OP_INPLACE_AND; break;
                case MP_TOKEN_DEL_DBL_LESS_EQUAL: op = MP_BINARY_OP_INPLACE_LSHIFT; break;
                case MP_TOKEN_DEL_DBL_MORE_EQUAL: op = MP_BINARY_OP_INPLACE_RSHIFT; break;
                case MP_TOKEN_DEL_PLUS_EQUAL: op = MP_BINARY_OP_INPLACE_ADD; break;
                case MP_TOKEN_DEL_MINUS_EQUAL: op = MP_BINARY_OP_INPLACE_SUBTRACT; break;
                case MP_TOKEN_DEL_STAR_EQUAL: op = MP_BINARY_OP_INPLACE_MULTIPLY; break;
                case MP_TOKEN_DEL_DBL_SLASH_EQUAL: op = MP_BINARY_OP_INPLACE_FLOOR_DIVIDE; break;
                case MP_TOKEN_DEL_SLASH_EQUAL: op = MP_BINARY_OP_INPLACE_TRUE_DIVIDE; break;
                case MP_TOKEN_DEL_PERCENT_EQUAL: op = MP_BINARY_OP_INPLACE_MODULO; break;
                case MP_TOKEN_DEL_DBL_STAR_EQUAL: default: op = MP_BINARY_OP_INPLACE_POWER; break;
            }
            EMIT_ARG(binary_op, op);
            micropy_c_assign(mp_state, comp, pns->nodes[0], ASSIGN_AUG_STORE); // lhs store for aug assign
        } else if (kind == PN_expr_stmt_assign_list) {
            int rhs = MP_PARSE_NODE_STRUCT_NUM_NODES(pns1) - 1;
            micropy_compile_node(mp_state, comp, pns1->nodes[rhs]); // rhs
            // following CPython, we store left-most first
            if (rhs > 0) {
                EMIT(dup_top);
            }
            micropy_c_assign(mp_state, comp, pns->nodes[0], ASSIGN_STORE); // lhs store
            for (int i = 0; i < rhs; i++) {
                if (i + 1 < rhs) {
                    EMIT(dup_top);
                }
                micropy_c_assign(mp_state, comp, pns1->nodes[i], ASSIGN_STORE); // middle store
            }
        } else {
        plain_assign:
            if (MICROPY_COMP_DOUBLE_TUPLE_ASSIGN
                && MP_PARSE_NODE_IS_STRUCT_KIND(pns->nodes[1], PN_testlist_star_expr)
                && MP_PARSE_NODE_IS_STRUCT_KIND(pns->nodes[0], PN_testlist_star_expr)
                && MP_PARSE_NODE_STRUCT_NUM_NODES((mp_parse_node_struct_t*)pns->nodes[1]) == 2
                && MP_PARSE_NODE_STRUCT_NUM_NODES((mp_parse_node_struct_t*)pns->nodes[0]) == 2) {
                // optimisation for a, b = c, d
                mp_parse_node_struct_t *pns10 = (mp_parse_node_struct_t*)pns->nodes[1];
                mp_parse_node_struct_t *pns0 = (mp_parse_node_struct_t*)pns->nodes[0];
                if (MP_PARSE_NODE_IS_STRUCT_KIND(pns0->nodes[0], PN_star_expr)
                    || MP_PARSE_NODE_IS_STRUCT_KIND(pns0->nodes[1], PN_star_expr)) {
                    // can't optimise when it's a star expression on the lhs
                    goto no_optimisation;
                }
                micropy_compile_node(mp_state, comp, pns10->nodes[0]); // rhs
                micropy_compile_node(mp_state, comp, pns10->nodes[1]); // rhs
                EMIT(rot_two);
                micropy_c_assign(mp_state, comp, pns0->nodes[0], ASSIGN_STORE); // lhs store
                micropy_c_assign(mp_state, comp, pns0->nodes[1], ASSIGN_STORE); // lhs store
            } else if (MICROPY_COMP_TRIPLE_TUPLE_ASSIGN
                && MP_PARSE_NODE_IS_STRUCT_KIND(pns->nodes[1], PN_testlist_star_expr)
                && MP_PARSE_NODE_IS_STRUCT_KIND(pns->nodes[0], PN_testlist_star_expr)
                && MP_PARSE_NODE_STRUCT_NUM_NODES((mp_parse_node_struct_t*)pns->nodes[1]) == 3
                && MP_PARSE_NODE_STRUCT_NUM_NODES((mp_parse_node_struct_t*)pns->nodes[0]) == 3) {
                // optimisation for a, b, c = d, e, f
                mp_parse_node_struct_t *pns10 = (mp_parse_node_struct_t*)pns->nodes[1];
                mp_parse_node_struct_t *pns0 = (mp_parse_node_struct_t*)pns->nodes[0];
                if (MP_PARSE_NODE_IS_STRUCT_KIND(pns0->nodes[0], PN_star_expr)
                    || MP_PARSE_NODE_IS_STRUCT_KIND(pns0->nodes[1], PN_star_expr)
                    || MP_PARSE_NODE_IS_STRUCT_KIND(pns0->nodes[2], PN_star_expr)) {
                    // can't optimise when it's a star expression on the lhs
                    goto no_optimisation;
                }
                micropy_compile_node(mp_state, comp, pns10->nodes[0]); // rhs
                micropy_compile_node(mp_state, comp, pns10->nodes[1]); // rhs
                micropy_compile_node(mp_state, comp, pns10->nodes[2]); // rhs
                EMIT(rot_three);
                EMIT(rot_two);
                micropy_c_assign(mp_state, comp, pns0->nodes[0], ASSIGN_STORE); // lhs store
                micropy_c_assign(mp_state, comp, pns0->nodes[1], ASSIGN_STORE); // lhs store
                micropy_c_assign(mp_state, comp, pns0->nodes[2], ASSIGN_STORE); // lhs store
            } else {
                no_optimisation:
                micropy_compile_node(mp_state, comp, pns->nodes[1]); // rhs
                micropy_c_assign(mp_state, comp, pns->nodes[0], ASSIGN_STORE); // lhs store
            }
        }
    } else {
        goto plain_assign;
    }
}

STATIC void micropy_c_binary_op(struct _mp_state_ctx_t *mp_state, compiler_t *comp, mp_parse_node_struct_t *pns, mp_binary_op_t binary_op) {
    int num_nodes = MP_PARSE_NODE_STRUCT_NUM_NODES(pns);
    micropy_compile_node(mp_state, comp, pns->nodes[0]);
    for (int i = 1; i < num_nodes; i += 1) {
        micropy_compile_node(mp_state, comp, pns->nodes[i]);
        EMIT_ARG(binary_op, binary_op);
    }
}

STATIC void micropy_compile_test_if_expr(struct _mp_state_ctx_t *mp_state, compiler_t *comp, mp_parse_node_struct_t *pns) {
    assert(MP_PARSE_NODE_IS_STRUCT_KIND(pns->nodes[1], PN_test_if_else));
    mp_parse_node_struct_t *pns_test_if_else = (mp_parse_node_struct_t*)pns->nodes[1];

    uint l_fail = micropy_comp_next_label(mp_state, comp);
    uint l_end = micropy_comp_next_label(mp_state, comp);
    micropy_c_if_cond(mp_state, comp, pns_test_if_else->nodes[0], false, l_fail); // condition
    micropy_compile_node(mp_state, comp, pns->nodes[0]); // success value
    EMIT_ARG(jump, l_end);
    EMIT_ARG(label_assign, l_fail);
    EMIT_ARG(adjust_stack_size, -1); // adjust stack size
    micropy_compile_node(mp_state, comp, pns_test_if_else->nodes[1]); // failure value
    EMIT_ARG(label_assign, l_end);
}

STATIC void micropy_compile_lambdef(struct _mp_state_ctx_t *mp_state, compiler_t *comp, mp_parse_node_struct_t *pns) {
    if (comp->pass == MP_PASS_SCOPE) {
        // create a new scope for this lambda
        scope_t *s = micropy_scope_new_and_link(mp_state, comp, SCOPE_LAMBDA, (mp_parse_node_t)pns, comp->scope_cur->emit_options);
        // store the lambda scope so the compiling function (this one) can use it at each pass
        pns->nodes[2] = (mp_parse_node_t)s;
    }

    // get the scope for this lambda
    scope_t *this_scope = (scope_t*)pns->nodes[2];

    // compile the lambda definition
    micropy_compile_funcdef_lambdef(mp_state, comp, this_scope, pns->nodes[0], PN_varargslist);
}

STATIC void micropy_compile_or_and_test(struct _mp_state_ctx_t *mp_state, compiler_t *comp, mp_parse_node_struct_t *pns, bool cond) {
    uint l_end = micropy_comp_next_label(mp_state, comp);
    int n = MP_PARSE_NODE_STRUCT_NUM_NODES(pns);
    for (int i = 0; i < n; i += 1) {
        micropy_compile_node(mp_state, comp, pns->nodes[i]);
        if (i + 1 < n) {
            EMIT_ARG(jump_if_or_pop, cond, l_end);
        }
    }
    EMIT_ARG(label_assign, l_end);
}

STATIC void micropy_compile_or_test(struct _mp_state_ctx_t *mp_state, compiler_t *comp, mp_parse_node_struct_t *pns) {
    micropy_compile_or_and_test(mp_state, comp, pns, true);
}

STATIC void micropy_compile_and_test(struct _mp_state_ctx_t *mp_state, compiler_t *comp, mp_parse_node_struct_t *pns) {
    micropy_compile_or_and_test(mp_state, comp, pns, false);
}

STATIC void micropy_compile_not_test_2(struct _mp_state_ctx_t *mp_state, compiler_t *comp, mp_parse_node_struct_t *pns) {
    micropy_compile_node(mp_state, comp, pns->nodes[0]);
    EMIT_ARG(unary_op, MP_UNARY_OP_NOT);
}

STATIC void micropy_compile_comparison(struct _mp_state_ctx_t *mp_state, compiler_t *comp, mp_parse_node_struct_t *pns) {
    int num_nodes = MP_PARSE_NODE_STRUCT_NUM_NODES(pns);
    micropy_compile_node(mp_state, comp, pns->nodes[0]);
    bool multi = (num_nodes > 3);
    uint l_fail = 0;
    if (multi) {
        l_fail = micropy_comp_next_label(mp_state, comp);
    }
    for (int i = 1; i + 1 < num_nodes; i += 2) {
        micropy_compile_node(mp_state, comp, pns->nodes[i + 1]);
        if (i + 2 < num_nodes) {
            EMIT(dup_top);
            EMIT(rot_three);
        }
        if (MP_PARSE_NODE_IS_TOKEN(pns->nodes[i])) {
            mp_binary_op_t op;
            switch (MP_PARSE_NODE_LEAF_ARG(pns->nodes[i])) {
                case MP_TOKEN_OP_LESS: op = MP_BINARY_OP_LESS; break;
                case MP_TOKEN_OP_MORE: op = MP_BINARY_OP_MORE; break;
                case MP_TOKEN_OP_DBL_EQUAL: op = MP_BINARY_OP_EQUAL; break;
                case MP_TOKEN_OP_LESS_EQUAL: op = MP_BINARY_OP_LESS_EQUAL; break;
                case MP_TOKEN_OP_MORE_EQUAL: op = MP_BINARY_OP_MORE_EQUAL; break;
                case MP_TOKEN_OP_NOT_EQUAL: op = MP_BINARY_OP_NOT_EQUAL; break;
                case MP_TOKEN_KW_IN: default: op = MP_BINARY_OP_IN; break;
            }
            EMIT_ARG(binary_op, op);
        } else {
            assert(MP_PARSE_NODE_IS_STRUCT(pns->nodes[i])); // should be
            mp_parse_node_struct_t *pns2 = (mp_parse_node_struct_t*)pns->nodes[i];
            int kind = MP_PARSE_NODE_STRUCT_KIND(pns2);
            if (kind == PN_comp_op_not_in) {
                EMIT_ARG(binary_op, MP_BINARY_OP_NOT_IN);
            } else {
                assert(kind == PN_comp_op_is); // should be
                if (MP_PARSE_NODE_IS_NULL(pns2->nodes[0])) {
                    EMIT_ARG(binary_op, MP_BINARY_OP_IS);
                } else {
                    EMIT_ARG(binary_op, MP_BINARY_OP_IS_NOT);
                }
            }
        }
        if (i + 2 < num_nodes) {
            EMIT_ARG(jump_if_or_pop, false, l_fail);
        }
    }
    if (multi) {
        uint l_end = micropy_comp_next_label(mp_state, comp);
        EMIT_ARG(jump, l_end);
        EMIT_ARG(label_assign, l_fail);
        EMIT_ARG(adjust_stack_size, 1);
        EMIT(rot_two);
        EMIT(pop_top);
        EMIT_ARG(label_assign, l_end);
    }
}

STATIC void micropy_compile_star_expr(struct _mp_state_ctx_t *mp_state, compiler_t *comp, mp_parse_node_struct_t *pns) {
    micropy_compile_syntax_error(mp_state, comp, (mp_parse_node_t)pns, "*x must be assignment target");
}

STATIC void micropy_compile_expr(struct _mp_state_ctx_t *mp_state, compiler_t *comp, mp_parse_node_struct_t *pns) {
    micropy_c_binary_op(mp_state, comp, pns, MP_BINARY_OP_OR);
}

STATIC void micropy_compile_xor_expr(struct _mp_state_ctx_t *mp_state, compiler_t *comp, mp_parse_node_struct_t *pns) {
    micropy_c_binary_op(mp_state, comp, pns, MP_BINARY_OP_XOR);
}

STATIC void micropy_compile_and_expr(struct _mp_state_ctx_t *mp_state, compiler_t *comp, mp_parse_node_struct_t *pns) {
    micropy_c_binary_op(mp_state, comp, pns, MP_BINARY_OP_AND);
}

STATIC void micropy_compile_shift_expr(struct _mp_state_ctx_t *mp_state, compiler_t *comp, mp_parse_node_struct_t *pns) {
    int num_nodes = MP_PARSE_NODE_STRUCT_NUM_NODES(pns);
    micropy_compile_node(mp_state, comp, pns->nodes[0]);
    for (int i = 1; i + 1 < num_nodes; i += 2) {
        micropy_compile_node(mp_state, comp, pns->nodes[i + 1]);
        if (MP_PARSE_NODE_IS_TOKEN_KIND(pns->nodes[i], MP_TOKEN_OP_DBL_LESS)) {
            EMIT_ARG(binary_op, MP_BINARY_OP_LSHIFT);
        } else {
            assert(MP_PARSE_NODE_IS_TOKEN_KIND(pns->nodes[i], MP_TOKEN_OP_DBL_MORE)); // should be
            EMIT_ARG(binary_op, MP_BINARY_OP_RSHIFT);
        }
    }
}

STATIC void micropy_compile_arith_expr(struct _mp_state_ctx_t *mp_state, compiler_t *comp, mp_parse_node_struct_t *pns) {
    int num_nodes = MP_PARSE_NODE_STRUCT_NUM_NODES(pns);
    micropy_compile_node(mp_state, comp, pns->nodes[0]);
    for (int i = 1; i + 1 < num_nodes; i += 2) {
        micropy_compile_node(mp_state, comp, pns->nodes[i + 1]);
        if (MP_PARSE_NODE_IS_TOKEN_KIND(pns->nodes[i], MP_TOKEN_OP_PLUS)) {
            EMIT_ARG(binary_op, MP_BINARY_OP_ADD);
        } else {
            assert(MP_PARSE_NODE_IS_TOKEN_KIND(pns->nodes[i], MP_TOKEN_OP_MINUS)); // should be
            EMIT_ARG(binary_op, MP_BINARY_OP_SUBTRACT);
        }
    }
}

STATIC void micropy_compile_term(struct _mp_state_ctx_t *mp_state, compiler_t *comp, mp_parse_node_struct_t *pns) {
    int num_nodes = MP_PARSE_NODE_STRUCT_NUM_NODES(pns);
    micropy_compile_node(mp_state, comp, pns->nodes[0]);
    for (int i = 1; i + 1 < num_nodes; i += 2) {
        micropy_compile_node(mp_state, comp, pns->nodes[i + 1]);
        if (MP_PARSE_NODE_IS_TOKEN_KIND(pns->nodes[i], MP_TOKEN_OP_STAR)) {
            EMIT_ARG(binary_op, MP_BINARY_OP_MULTIPLY);
        } else if (MP_PARSE_NODE_IS_TOKEN_KIND(pns->nodes[i], MP_TOKEN_OP_DBL_SLASH)) {
            EMIT_ARG(binary_op, MP_BINARY_OP_FLOOR_DIVIDE);
        } else if (MP_PARSE_NODE_IS_TOKEN_KIND(pns->nodes[i], MP_TOKEN_OP_SLASH)) {
            EMIT_ARG(binary_op, MP_BINARY_OP_TRUE_DIVIDE);
        } else {
            assert(MP_PARSE_NODE_IS_TOKEN_KIND(pns->nodes[i], MP_TOKEN_OP_PERCENT)); // should be
            EMIT_ARG(binary_op, MP_BINARY_OP_MODULO);
        }
    }
}

STATIC void micropy_compile_factor_2(struct _mp_state_ctx_t *mp_state, compiler_t *comp, mp_parse_node_struct_t *pns) {
    micropy_compile_node(mp_state, comp, pns->nodes[1]);
    if (MP_PARSE_NODE_IS_TOKEN_KIND(pns->nodes[0], MP_TOKEN_OP_PLUS)) {
        EMIT_ARG(unary_op, MP_UNARY_OP_POSITIVE);
    } else if (MP_PARSE_NODE_IS_TOKEN_KIND(pns->nodes[0], MP_TOKEN_OP_MINUS)) {
        EMIT_ARG(unary_op, MP_UNARY_OP_NEGATIVE);
    } else {
        assert(MP_PARSE_NODE_IS_TOKEN_KIND(pns->nodes[0], MP_TOKEN_OP_TILDE)); // should be
        EMIT_ARG(unary_op, MP_UNARY_OP_INVERT);
    }
}

STATIC void micropy_compile_atom_expr_normal(struct _mp_state_ctx_t *mp_state, compiler_t *comp, mp_parse_node_struct_t *pns) {
    // this is to handle special super() call
    comp->func_arg_is_super = MP_PARSE_NODE_IS_ID(pns->nodes[0]) && MP_PARSE_NODE_LEAF_ARG(pns->nodes[0]) == MP_QSTR_super;

    micropy_compile_generic_all_nodes(mp_state, comp, pns);
}

STATIC void micropy_compile_power(struct _mp_state_ctx_t *mp_state, compiler_t *comp, mp_parse_node_struct_t *pns) {
    micropy_compile_generic_all_nodes(mp_state, comp, pns); // 2 nodes, arguments of power
    EMIT_ARG(binary_op, MP_BINARY_OP_POWER);
}

STATIC void micropy_compile_trailer_paren_helper(struct _mp_state_ctx_t *mp_state, compiler_t *comp, mp_parse_node_t pn_arglist, bool is_method_call, int n_positional_extra) {
    // function to call is on top of stack

    // this is to handle special super() call
    if (MP_PARSE_NODE_IS_NULL(pn_arglist) && comp->func_arg_is_super && comp->scope_cur->kind == SCOPE_FUNCTION) {
        micropy_compile_load_id(mp_state, comp, MP_QSTR___class__);
        // look for first argument to function (assumes it's "self")
        for (int i = 0; i < comp->scope_cur->id_info_len; i++) {
            if (comp->scope_cur->id_info[i].flags & ID_FLAG_IS_PARAM) {
                // first argument found; load it and call super
                EMIT_LOAD_FAST(MP_QSTR_, comp->scope_cur->id_info[i].local_num);
                EMIT_ARG(call_function, 2, 0, 0);
                return;
            }
        }
        micropy_compile_syntax_error(mp_state, comp, MP_PARSE_NODE_NULL, "super() call cannot find self"); // really a TypeError
        return;
    }

    // get the list of arguments
    mp_parse_node_t *args;
    int n_args = micropy_parse_node_extract_list(mp_state, &pn_arglist, PN_arglist, &args);

    // compile the arguments
    // Rather than calling compile_node on the list, we go through the list of args
    // explicitly here so that we can count the number of arguments and give sensible
    // error messages.
    int n_positional = n_positional_extra;
    uint n_keyword = 0;
    uint star_flags = 0;
    mp_parse_node_struct_t *star_args_node = NULL, *dblstar_args_node = NULL;
    for (int i = 0; i < n_args; i++) {
        if (MP_PARSE_NODE_IS_STRUCT(args[i])) {
            mp_parse_node_struct_t *pns_arg = (mp_parse_node_struct_t*)args[i];
            if (MP_PARSE_NODE_STRUCT_KIND(pns_arg) == PN_arglist_star) {
                if (star_flags & MP_EMIT_STAR_FLAG_SINGLE) {
                    micropy_compile_syntax_error(mp_state, comp, (mp_parse_node_t)pns_arg, "can't have multiple *x");
                    return;
                }
                star_flags |= MP_EMIT_STAR_FLAG_SINGLE;
                star_args_node = pns_arg;
            } else if (MP_PARSE_NODE_STRUCT_KIND(pns_arg) == PN_arglist_dbl_star) {
                if (star_flags & MP_EMIT_STAR_FLAG_DOUBLE) {
                    micropy_compile_syntax_error(mp_state, comp, (mp_parse_node_t)pns_arg, "can't have multiple **x");
                    return;
                }
                star_flags |= MP_EMIT_STAR_FLAG_DOUBLE;
                dblstar_args_node = pns_arg;
            } else if (MP_PARSE_NODE_STRUCT_KIND(pns_arg) == PN_argument) {
                if (!MP_PARSE_NODE_IS_STRUCT_KIND(pns_arg->nodes[1], PN_comp_for)) {
                    if (!MP_PARSE_NODE_IS_ID(pns_arg->nodes[0])) {
                        micropy_compile_syntax_error(mp_state, comp, (mp_parse_node_t)pns_arg, "LHS of keyword arg must be an id");
                        return;
                    }
                    EMIT_ARG(load_const_str, MP_PARSE_NODE_LEAF_ARG(pns_arg->nodes[0]));
                    micropy_compile_node(mp_state, comp, pns_arg->nodes[1]);
                    n_keyword += 1;
                } else {
                    micropy_compile_comprehension(mp_state, comp, pns_arg, SCOPE_GEN_EXPR);
                    n_positional++;
                }
            } else {
                goto normal_argument;
            }
        } else {
            normal_argument:
            if (n_keyword > 0) {
                micropy_compile_syntax_error(mp_state, comp, args[i], "non-keyword arg after keyword arg");
                return;
            }
            micropy_compile_node(mp_state, comp, args[i]);
            n_positional++;
        }
    }

    // compile the star/double-star arguments if we had them
    // if we had one but not the other then we load "null" as a place holder
    if (star_flags != 0) {
        if (star_args_node == NULL) {
            EMIT(load_null);
        } else {
            micropy_compile_node(mp_state, comp, star_args_node->nodes[0]);
        }
        if (dblstar_args_node == NULL) {
            EMIT(load_null);
        } else {
            micropy_compile_node(mp_state, comp, dblstar_args_node->nodes[0]);
        }
    }

    // emit the function/method call
    if (is_method_call) {
        EMIT_ARG(call_method, n_positional, n_keyword, star_flags);
    } else {
        EMIT_ARG(call_function, n_positional, n_keyword, star_flags);
    }
}

STATIC void micropy_compile_atom_expr_trailers(struct _mp_state_ctx_t *mp_state, compiler_t *comp, mp_parse_node_struct_t *pns) {
    int num_nodes = MP_PARSE_NODE_STRUCT_NUM_NODES(pns);
    for (int i = 0; i < num_nodes; i++) {
        if (i + 1 < num_nodes && MP_PARSE_NODE_IS_STRUCT_KIND(pns->nodes[i], PN_trailer_period) && MP_PARSE_NODE_IS_STRUCT_KIND(pns->nodes[i + 1], PN_trailer_paren)) {
            // optimisation for method calls a.f(...), following PyPy
            mp_parse_node_struct_t *pns_period = (mp_parse_node_struct_t*)pns->nodes[i];
            mp_parse_node_struct_t *pns_paren = (mp_parse_node_struct_t*)pns->nodes[i + 1];
            EMIT_ARG(load_method, MP_PARSE_NODE_LEAF_ARG(pns_period->nodes[0])); // get the method
            micropy_compile_trailer_paren_helper(mp_state, comp, pns_paren->nodes[0], true, 0);
            i += 1;
        } else {
            micropy_compile_node(mp_state, comp, pns->nodes[i]);
        }
        comp->func_arg_is_super = false;
    }
}

STATIC void micropy_compile_atom_string(struct _mp_state_ctx_t *mp_state, compiler_t *comp, mp_parse_node_struct_t *pns) {
    // a list of strings

    // check type of list (string or bytes) and count total number of bytes
    int n = MP_PARSE_NODE_STRUCT_NUM_NODES(pns);
    size_t n_bytes = 0;
    int string_kind = MP_PARSE_NODE_NULL;
    for (int i = 0; i < n; i++) {
        int pn_kind;
        if (MP_PARSE_NODE_IS_LEAF(pns->nodes[i])) {
            pn_kind = MP_PARSE_NODE_LEAF_KIND(pns->nodes[i]);
            assert(pn_kind == MP_PARSE_NODE_STRING || pn_kind == MP_PARSE_NODE_BYTES);
            n_bytes += micropy_qstr_len(mp_state, MP_PARSE_NODE_LEAF_ARG(pns->nodes[i]));
        } else {
            assert(MP_PARSE_NODE_IS_STRUCT(pns->nodes[i]));
            mp_parse_node_struct_t *pns_string = (mp_parse_node_struct_t*)pns->nodes[i];
            if (MP_PARSE_NODE_STRUCT_KIND(pns_string) == PN_string) {
                pn_kind = MP_PARSE_NODE_STRING;
            } else {
                assert(MP_PARSE_NODE_STRUCT_KIND(pns_string) == PN_bytes);
                pn_kind = MP_PARSE_NODE_BYTES;
            }
            n_bytes += pns_string->nodes[1];
        }
        if (i == 0) {
            string_kind = pn_kind;
        } else if (pn_kind != string_kind) {
            micropy_compile_syntax_error(mp_state, comp, (mp_parse_node_t)pns, "cannot mix bytes and nonbytes literals");
            return;
        }
    }

    // if we are not in the last pass, just load a dummy object
    if (comp->pass != MP_PASS_EMIT) {
        EMIT_ARG(load_const_obj, mp_const_none);
        return;
    }

    // concatenate string/bytes
    vstr_t vstr;
    micropy_vstr_init_len(mp_state, &vstr, n_bytes);
    byte *s_dest = (byte*)vstr.buf;
    for (int i = 0; i < n; i++) {
        if (MP_PARSE_NODE_IS_LEAF(pns->nodes[i])) {
            size_t s_len;
            const byte *s = micropy_qstr_data(mp_state, MP_PARSE_NODE_LEAF_ARG(pns->nodes[i]), &s_len);
            memcpy(s_dest, s, s_len);
            s_dest += s_len;
        } else {
            mp_parse_node_struct_t *pns_string = (mp_parse_node_struct_t*)pns->nodes[i];
            memcpy(s_dest, (const char*)pns_string->nodes[0], pns_string->nodes[1]);
            s_dest += pns_string->nodes[1];
        }
    }

    // load the object
    EMIT_ARG(load_const_obj, micropy_obj_new_str_from_vstr(mp_state, string_kind == MP_PARSE_NODE_STRING ? &mp_type_str : &mp_type_bytes, &vstr));
}

// pns needs to have 2 nodes, first is lhs of comprehension, second is PN_comp_for node
STATIC void micropy_compile_comprehension(struct _mp_state_ctx_t *mp_state, compiler_t *comp, mp_parse_node_struct_t *pns, scope_kind_t kind) {
    assert(MP_PARSE_NODE_STRUCT_NUM_NODES(pns) == 2);
    assert(MP_PARSE_NODE_IS_STRUCT_KIND(pns->nodes[1], PN_comp_for));
    mp_parse_node_struct_t *pns_comp_for = (mp_parse_node_struct_t*)pns->nodes[1];

    if (comp->pass == MP_PASS_SCOPE) {
        // create a new scope for this comprehension
        scope_t *s = micropy_scope_new_and_link(mp_state, comp, kind, (mp_parse_node_t)pns, comp->scope_cur->emit_options);
        // store the comprehension scope so the compiling function (this one) can use it at each pass
        pns_comp_for->nodes[3] = (mp_parse_node_t)s;
    }

    // get the scope for this comprehension
    scope_t *this_scope = (scope_t*)pns_comp_for->nodes[3];

    // compile the comprehension
    micropy_close_over_variables_etc(mp_state, comp, this_scope, 0, 0);

    micropy_compile_node(mp_state, comp, pns_comp_for->nodes[1]); // source of the iterator
    EMIT(get_iter);
    EMIT_ARG(call_function, 1, 0, 0);
}

STATIC void micropy_compile_atom_paren(struct _mp_state_ctx_t *mp_state, compiler_t *comp, mp_parse_node_struct_t *pns) {
    if (MP_PARSE_NODE_IS_NULL(pns->nodes[0])) {
        // an empty tuple
        micropy_c_tuple(mp_state, comp, MP_PARSE_NODE_NULL, NULL);
    } else {
        assert(MP_PARSE_NODE_IS_STRUCT_KIND(pns->nodes[0], PN_testlist_comp));
        pns = (mp_parse_node_struct_t*)pns->nodes[0];
        assert(!MP_PARSE_NODE_IS_NULL(pns->nodes[1]));
        if (MP_PARSE_NODE_IS_STRUCT(pns->nodes[1])) {
            mp_parse_node_struct_t *pns2 = (mp_parse_node_struct_t*)pns->nodes[1];
            if (MP_PARSE_NODE_STRUCT_KIND(pns2) == PN_testlist_comp_3b) {
                // tuple of one item, with trailing comma
                assert(MP_PARSE_NODE_IS_NULL(pns2->nodes[0]));
                micropy_c_tuple(mp_state, comp, pns->nodes[0], NULL);
            } else if (MP_PARSE_NODE_STRUCT_KIND(pns2) == PN_testlist_comp_3c) {
                // tuple of many items
                micropy_c_tuple(mp_state, comp, pns->nodes[0], pns2);
            } else if (MP_PARSE_NODE_STRUCT_KIND(pns2) == PN_comp_for) {
                // generator expression
                micropy_compile_comprehension(mp_state, comp, pns, SCOPE_GEN_EXPR);
            } else {
                // tuple with 2 items
                goto tuple_with_2_items;
            }
        } else {
            // tuple with 2 items
            tuple_with_2_items:
            micropy_c_tuple(mp_state, comp, MP_PARSE_NODE_NULL, pns);
        }
    }
}

STATIC void micropy_compile_atom_bracket(struct _mp_state_ctx_t *mp_state, compiler_t *comp, mp_parse_node_struct_t *pns) {
    if (MP_PARSE_NODE_IS_NULL(pns->nodes[0])) {
        // empty list
        EMIT_ARG(build_list, 0);
    } else if (MP_PARSE_NODE_IS_STRUCT_KIND(pns->nodes[0], PN_testlist_comp)) {
        mp_parse_node_struct_t *pns2 = (mp_parse_node_struct_t*)pns->nodes[0];
        if (MP_PARSE_NODE_IS_STRUCT(pns2->nodes[1])) {
            mp_parse_node_struct_t *pns3 = (mp_parse_node_struct_t*)pns2->nodes[1];
            if (MP_PARSE_NODE_STRUCT_KIND(pns3) == PN_testlist_comp_3b) {
                // list of one item, with trailing comma
                assert(MP_PARSE_NODE_IS_NULL(pns3->nodes[0]));
                micropy_compile_node(mp_state, comp, pns2->nodes[0]);
                EMIT_ARG(build_list, 1);
            } else if (MP_PARSE_NODE_STRUCT_KIND(pns3) == PN_testlist_comp_3c) {
                // list of many items
                micropy_compile_node(mp_state, comp, pns2->nodes[0]);
                micropy_compile_generic_all_nodes(mp_state, comp, pns3);
                EMIT_ARG(build_list, 1 + MP_PARSE_NODE_STRUCT_NUM_NODES(pns3));
            } else if (MP_PARSE_NODE_STRUCT_KIND(pns3) == PN_comp_for) {
                // list comprehension
                micropy_compile_comprehension(mp_state, comp, pns2, SCOPE_LIST_COMP);
            } else {
                // list with 2 items
                goto list_with_2_items;
            }
        } else {
            // list with 2 items
            list_with_2_items:
            micropy_compile_node(mp_state, comp, pns2->nodes[0]);
            micropy_compile_node(mp_state, comp, pns2->nodes[1]);
            EMIT_ARG(build_list, 2);
        }
    } else {
        // list with 1 item
        micropy_compile_node(mp_state, comp, pns->nodes[0]);
        EMIT_ARG(build_list, 1);
    }
}

STATIC void micropy_compile_atom_brace(struct _mp_state_ctx_t *mp_state, compiler_t *comp, mp_parse_node_struct_t *pns) {
    mp_parse_node_t pn = pns->nodes[0];
    if (MP_PARSE_NODE_IS_NULL(pn)) {
        // empty dict
        EMIT_ARG(build_map, 0);
    } else if (MP_PARSE_NODE_IS_STRUCT(pn)) {
        pns = (mp_parse_node_struct_t*)pn;
        if (MP_PARSE_NODE_STRUCT_KIND(pns) == PN_dictorsetmaker_item) {
            // dict with one element
            EMIT_ARG(build_map, 1);
            micropy_compile_node(mp_state, comp, pn);
            EMIT(store_map);
        } else if (MP_PARSE_NODE_STRUCT_KIND(pns) == PN_dictorsetmaker) {
            assert(MP_PARSE_NODE_IS_STRUCT(pns->nodes[1])); // should succeed
            mp_parse_node_struct_t *pns1 = (mp_parse_node_struct_t*)pns->nodes[1];
            if (MP_PARSE_NODE_STRUCT_KIND(pns1) == PN_dictorsetmaker_list) {
                // dict/set with multiple elements

                // get tail elements (2nd, 3rd, ...)
                mp_parse_node_t *nodes;
                int n = micropy_parse_node_extract_list(mp_state, &pns1->nodes[0], PN_dictorsetmaker_list2, &nodes);

                // first element sets whether it's a dict or set
                bool is_dict;
                if (!MICROPY_PY_BUILTINS_SET || MP_PARSE_NODE_IS_STRUCT_KIND(pns->nodes[0], PN_dictorsetmaker_item)) {
                    // a dictionary
                    EMIT_ARG(build_map, 1 + n);
                    micropy_compile_node(mp_state, comp, pns->nodes[0]);
                    EMIT(store_map);
                    is_dict = true;
                } else {
                    // a set
                    micropy_compile_node(mp_state, comp, pns->nodes[0]); // 1st value of set
                    is_dict = false;
                }

                // process rest of elements
                for (int i = 0; i < n; i++) {
                    mp_parse_node_t pn_i = nodes[i];
                    bool is_key_value = MP_PARSE_NODE_IS_STRUCT_KIND(pn_i, PN_dictorsetmaker_item);
                    micropy_compile_node(mp_state, comp, pn_i);
                    if (is_dict) {
                        if (!is_key_value) {
                            micropy_compile_syntax_error(mp_state, comp, (mp_parse_node_t)pns, "expecting key:value for dictionary");
                            return;
                        }
                        EMIT(store_map);
                    } else {
                        if (is_key_value) {
                            micropy_compile_syntax_error(mp_state, comp, (mp_parse_node_t)pns, "expecting just a value for set");
                            return;
                        }
                    }
                }

                #if MICROPY_PY_BUILTINS_SET
                // if it's a set, build it
                if (!is_dict) {
                    EMIT_ARG(build_set, 1 + n);
                }
                #endif
            } else {
                assert(MP_PARSE_NODE_STRUCT_KIND(pns1) == PN_comp_for); // should be
                // dict/set comprehension
                if (!MICROPY_PY_BUILTINS_SET || MP_PARSE_NODE_IS_STRUCT_KIND(pns->nodes[0], PN_dictorsetmaker_item)) {
                    // a dictionary comprehension
                    micropy_compile_comprehension(mp_state, comp, pns, SCOPE_DICT_COMP);
                } else {
                    // a set comprehension
                    micropy_compile_comprehension(mp_state, comp, pns, SCOPE_SET_COMP);
                }
            }
        } else {
            // set with one element
            goto set_with_one_element;
        }
    } else {
        // set with one element
        set_with_one_element:
        #if MICROPY_PY_BUILTINS_SET
        micropy_compile_node(mp_state, comp, pn);
        EMIT_ARG(build_set, 1);
        #else
        assert(0);
        #endif
    }
}

STATIC void micropy_compile_trailer_paren(struct _mp_state_ctx_t *mp_state, compiler_t *comp, mp_parse_node_struct_t *pns) {
    micropy_compile_trailer_paren_helper(mp_state, comp, pns->nodes[0], false, 0);
}

STATIC void micropy_compile_trailer_bracket(struct _mp_state_ctx_t *mp_state, compiler_t *comp, mp_parse_node_struct_t *pns) {
    // object who's index we want is on top of stack
    micropy_compile_node(mp_state, comp, pns->nodes[0]); // the index
    EMIT(load_subscr);
}

STATIC void micropy_compile_trailer_period(struct _mp_state_ctx_t *mp_state, compiler_t *comp, mp_parse_node_struct_t *pns) {
    // object who's attribute we want is on top of stack
    EMIT_ARG(load_attr, MP_PARSE_NODE_LEAF_ARG(pns->nodes[0])); // attribute to get
}

#if MICROPY_PY_BUILTINS_SLICE
STATIC void micropy_compile_subscript_3_helper(struct _mp_state_ctx_t *mp_state, compiler_t *comp, mp_parse_node_struct_t *pns) {
    assert(MP_PARSE_NODE_STRUCT_KIND(pns) == PN_subscript_3); // should always be
    mp_parse_node_t pn = pns->nodes[0];
    if (MP_PARSE_NODE_IS_NULL(pn)) {
        // [?:]
        EMIT_ARG(load_const_tok, MP_TOKEN_KW_NONE);
        EMIT_ARG(build_slice, 2);
    } else if (MP_PARSE_NODE_IS_STRUCT(pn)) {
        pns = (mp_parse_node_struct_t*)pn;
        if (MP_PARSE_NODE_STRUCT_KIND(pns) == PN_subscript_3c) {
            EMIT_ARG(load_const_tok, MP_TOKEN_KW_NONE);
            pn = pns->nodes[0];
            if (MP_PARSE_NODE_IS_NULL(pn)) {
                // [?::]
                EMIT_ARG(build_slice, 2);
            } else {
                // [?::x]
                micropy_compile_node(mp_state, comp, pn);
                EMIT_ARG(build_slice, 3);
            }
        } else if (MP_PARSE_NODE_STRUCT_KIND(pns) == PN_subscript_3d) {
            micropy_compile_node(mp_state, comp, pns->nodes[0]);
            assert(MP_PARSE_NODE_IS_STRUCT(pns->nodes[1])); // should always be
            pns = (mp_parse_node_struct_t*)pns->nodes[1];
            assert(MP_PARSE_NODE_STRUCT_KIND(pns) == PN_sliceop); // should always be
            if (MP_PARSE_NODE_IS_NULL(pns->nodes[0])) {
                // [?:x:]
                EMIT_ARG(build_slice, 2);
            } else {
                // [?:x:x]
                micropy_compile_node(mp_state, comp, pns->nodes[0]);
                EMIT_ARG(build_slice, 3);
            }
        } else {
            // [?:x]
            micropy_compile_node(mp_state, comp, pn);
            EMIT_ARG(build_slice, 2);
        }
    } else {
        // [?:x]
        micropy_compile_node(mp_state, comp, pn);
        EMIT_ARG(build_slice, 2);
    }
}

STATIC void micropy_compile_subscript_2(struct _mp_state_ctx_t *mp_state, compiler_t *comp, mp_parse_node_struct_t *pns) {
    micropy_compile_node(mp_state, comp, pns->nodes[0]); // start of slice
    assert(MP_PARSE_NODE_IS_STRUCT(pns->nodes[1])); // should always be
    micropy_compile_subscript_3_helper(mp_state, comp, (mp_parse_node_struct_t*)pns->nodes[1]);
}

STATIC void micropy_compile_subscript_3(struct _mp_state_ctx_t *mp_state, compiler_t *comp, mp_parse_node_struct_t *pns) {
    EMIT_ARG(load_const_tok, MP_TOKEN_KW_NONE);
    micropy_compile_subscript_3_helper(mp_state, comp, pns);
}
#endif // MICROPY_PY_BUILTINS_SLICE

STATIC void micropy_compile_dictorsetmaker_item(struct _mp_state_ctx_t *mp_state, compiler_t *comp, mp_parse_node_struct_t *pns) {
    // if this is called then we are compiling a dict key:value pair
    micropy_compile_node(mp_state, comp, pns->nodes[1]); // value
    micropy_compile_node(mp_state, comp, pns->nodes[0]); // key
}

STATIC void micropy_compile_classdef(struct _mp_state_ctx_t *mp_state, compiler_t *comp, mp_parse_node_struct_t *pns) {
    qstr cname = micropy_compile_classdef_helper(mp_state, comp, pns, comp->scope_cur->emit_options);
    // store class object into class name
    micropy_compile_store_id(mp_state, comp, cname);
}

STATIC void micropy_compile_yield_expr(struct _mp_state_ctx_t *mp_state, compiler_t *comp, mp_parse_node_struct_t *pns) {
    if (comp->scope_cur->kind != SCOPE_FUNCTION && comp->scope_cur->kind != SCOPE_LAMBDA) {
        micropy_compile_syntax_error(mp_state, comp, (mp_parse_node_t)pns, "'yield' outside function");
        return;
    }
    if (MP_PARSE_NODE_IS_NULL(pns->nodes[0])) {
        EMIT_ARG(load_const_tok, MP_TOKEN_KW_NONE);
        EMIT(yield_value);
    } else if (MP_PARSE_NODE_IS_STRUCT_KIND(pns->nodes[0], PN_yield_arg_from)) {
        pns = (mp_parse_node_struct_t*)pns->nodes[0];
        micropy_compile_node(mp_state, comp, pns->nodes[0]);
        micropy_compile_yield_from(mp_state, comp);
    } else {
        micropy_compile_node(mp_state, comp, pns->nodes[0]);
        EMIT(yield_value);
    }
}

#if MICROPY_PY_ASYNC_AWAIT
STATIC void micropy_compile_atom_expr_await(struct _mp_state_ctx_t *mp_state, compiler_t *comp, mp_parse_node_struct_t *pns) {
    if (comp->scope_cur->kind != SCOPE_FUNCTION && comp->scope_cur->kind != SCOPE_LAMBDA) {
        micropy_compile_syntax_error(mp_state, comp, (mp_parse_node_t)pns, "'await' outside function");
        return;
    }
    micropy_compile_atom_expr_normal(mp_state, comp, pns);
    micropy_compile_yield_from(mp_state, comp);
}
#endif

STATIC void micropy_compile_string(struct _mp_state_ctx_t *mp_state, compiler_t *comp, mp_parse_node_struct_t *pns) {
    // only create and load the actual str object on the last pass
    if (comp->pass != MP_PASS_EMIT) {
        EMIT_ARG(load_const_obj, mp_const_none);
    } else {
        EMIT_ARG(load_const_obj, micropy_obj_new_str(mp_state, (const char*)pns->nodes[0], pns->nodes[1], false));
    }
}

STATIC void micropy_compile_bytes(struct _mp_state_ctx_t *mp_state, compiler_t *comp, mp_parse_node_struct_t *pns) {
    // only create and load the actual bytes object on the last pass
    if (comp->pass != MP_PASS_EMIT) {
        EMIT_ARG(load_const_obj, mp_const_none);
    } else {
        EMIT_ARG(load_const_obj, micropy_obj_new_bytes(mp_state, (const byte*)pns->nodes[0], pns->nodes[1]));
    }
}

STATIC void micropy_compile_const_object(struct _mp_state_ctx_t *mp_state, compiler_t *comp, mp_parse_node_struct_t *pns) {
    #if MICROPY_OBJ_REPR == MICROPY_OBJ_REPR_D
    // nodes are 32-bit pointers, but need to extract 64-bit object
    EMIT_ARG(load_const_obj, (uint64_t)pns->nodes[0] | ((uint64_t)pns->nodes[1] << 32));
    #else
    EMIT_ARG(load_const_obj, (mp_obj_t)pns->nodes[0]);
    #endif
}

typedef void (*compile_function_t)(struct _mp_state_ctx_t *mp_state, compiler_t*, mp_parse_node_struct_t*);
STATIC const compile_function_t compile_function[] = {
#define nc NULL
#define c(f) micropy_compile_##f
#define DEF_RULE(rule, comp, kind, ...) comp,
/*
 * This file is part of the Micro Python project, http://micropython.org/
 *
 * The MIT License (MIT)
 *
 * Copyright (c) 2013-2015 Damien P. George
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

// rules for writing rules:
// - zero_or_more is implemented using opt_rule around a one_or_more rule
// - don't put opt_rule in arguments of or rule; instead, wrap the call to this or rule in opt_rule

// # Start symbols for the grammar:
// #       single_input is a single interactive statement;
// #       file_input is a module or sequence of commands read from an input file;
// #       eval_input is the input for the eval() functions.
// # NB: compound_stmt in single_input is followed by extra NEWLINE! --> not in Micro Python
// single_input: NEWLINE | simple_stmt | compound_stmt
// file_input: (NEWLINE | stmt)* ENDMARKER
// eval_input: testlist NEWLINE* ENDMARKER

DEF_RULE(single_input, nc, or(3), tok(NEWLINE), rule(simple_stmt), rule(compound_stmt))
DEF_RULE(file_input, c(generic_all_nodes), and_ident(1), opt_rule(file_input_2))
DEF_RULE(file_input_2, c(generic_all_nodes), one_or_more, rule(file_input_3))
DEF_RULE(file_input_3, nc, or(2), tok(NEWLINE), rule(stmt))
DEF_RULE(eval_input, nc, and_ident(2), rule(testlist), opt_rule(eval_input_2))
DEF_RULE(eval_input_2, nc, and(1), tok(NEWLINE))

// decorator: '@' dotted_name [ '(' [arglist] ')' ] NEWLINE
// decorators: decorator+
// decorated: decorators (classdef | funcdef | async_funcdef)
// funcdef: 'def' NAME parameters ['->' test] ':' suite
// async_funcdef: 'async' funcdef
// parameters: '(' [typedargslist] ')'
// typedargslist: tfpdef ['=' test] (',' tfpdef ['=' test])* [',' ['*' [tfpdef] (',' tfpdef ['=' test])* [',' '**' tfpdef] | '**' tfpdef]] | '*' [tfpdef] (',' tfpdef ['=' test])* [',' '**' tfpdef] | '**' tfpdef
// tfpdef: NAME [':' test]
// varargslist: vfpdef ['=' test] (',' vfpdef ['=' test])* [',' ['*' [vfpdef] (',' vfpdef ['=' test])* [',' '**' vfpdef] | '**' vfpdef]] |  '*' [vfpdef] (',' vfpdef ['=' test])* [',' '**' vfpdef] | '**' vfpdef
// vfpdef: NAME

DEF_RULE(decorator, nc, and(4), tok(DEL_AT), rule(dotted_name), opt_rule(trailer_paren), tok(NEWLINE))
DEF_RULE(decorators, nc, one_or_more, rule(decorator))
DEF_RULE(decorated, c(decorated), and_ident(2), rule(decorators), rule(decorated_body))
#if MICROPY_PY_ASYNC_AWAIT
DEF_RULE(decorated_body, nc, or(3), rule(classdef), rule(funcdef), rule(async_funcdef))
DEF_RULE(async_funcdef, nc, and(2), tok(KW_ASYNC), rule(funcdef))
#else
DEF_RULE(decorated_body, nc, or(2), rule(classdef), rule(funcdef))
#endif
DEF_RULE(funcdef, c(funcdef), and_blank(8), tok(KW_DEF), tok(NAME), tok(DEL_PAREN_OPEN), opt_rule(typedargslist), tok(DEL_PAREN_CLOSE), opt_rule(funcdefrettype), tok(DEL_COLON), rule(suite))
DEF_RULE(funcdefrettype, nc, and_ident(2), tok(DEL_MINUS_MORE), rule(test))
// note: typedargslist lets through more than is allowed, compiler does further checks
DEF_RULE(typedargslist, nc, list_with_end, rule(typedargslist_item), tok(DEL_COMMA))
DEF_RULE(typedargslist_item, nc, or(3), rule(typedargslist_name), rule(typedargslist_star), rule(typedargslist_dbl_star))
DEF_RULE(typedargslist_name, nc, and_ident(3), tok(NAME), opt_rule(typedargslist_colon), opt_rule(typedargslist_equal))
DEF_RULE(typedargslist_star, nc, and(2), tok(OP_STAR), opt_rule(tfpdef))
DEF_RULE(typedargslist_dbl_star, nc, and(3), tok(OP_DBL_STAR), tok(NAME), opt_rule(typedargslist_colon))
DEF_RULE(typedargslist_colon, nc, and_ident(2), tok(DEL_COLON), rule(test))
DEF_RULE(typedargslist_equal, nc, and_ident(2), tok(DEL_EQUAL), rule(test))
DEF_RULE(tfpdef, nc, and(2), tok(NAME), opt_rule(typedargslist_colon))
// note: varargslist lets through more than is allowed, compiler does further checks
DEF_RULE(varargslist, nc, list_with_end, rule(varargslist_item), tok(DEL_COMMA))
DEF_RULE(varargslist_item, nc, or(3), rule(varargslist_name), rule(varargslist_star), rule(varargslist_dbl_star))
DEF_RULE(varargslist_name, nc, and_ident(2), tok(NAME), opt_rule(varargslist_equal))
DEF_RULE(varargslist_star, nc, and(2), tok(OP_STAR), opt_rule(vfpdef))
DEF_RULE(varargslist_dbl_star, nc, and(2), tok(OP_DBL_STAR), tok(NAME))
DEF_RULE(varargslist_equal, nc, and_ident(2), tok(DEL_EQUAL), rule(test))
DEF_RULE(vfpdef, nc, and_ident(1), tok(NAME))

// stmt: compound_stmt | simple_stmt

DEF_RULE(stmt, nc, or(2), rule(compound_stmt), rule(simple_stmt))

// simple_stmt: small_stmt (';' small_stmt)* [';'] NEWLINE

DEF_RULE(simple_stmt, nc, and_ident(2), rule(simple_stmt_2), tok(NEWLINE))
DEF_RULE(simple_stmt_2, c(generic_all_nodes), list_with_end, rule(small_stmt), tok(DEL_SEMICOLON))

// small_stmt: expr_stmt | del_stmt | pass_stmt | flow_stmt | import_stmt | global_stmt | nonlocal_stmt | assert_stmt
// expr_stmt: testlist_star_expr (augassign (yield_expr|testlist) | ('=' (yield_expr|testlist_star_expr))*)
// testlist_star_expr: (test|star_expr) (',' (test|star_expr))* [',']
// augassign: '+=' | '-=' | '*=' | '/=' | '%=' | '&=' | '|=' | '^=' | '<<=' | '>>=' | '**=' | '//='
// # For normal assignments, additional restrictions enforced by the interpreter

DEF_RULE(small_stmt, nc, or(8), rule(del_stmt), rule(pass_stmt), rule(flow_stmt), rule(import_stmt), rule(global_stmt), rule(nonlocal_stmt), rule(assert_stmt), rule(expr_stmt))
DEF_RULE(expr_stmt, c(expr_stmt), and(2), rule(testlist_star_expr), opt_rule(expr_stmt_2))
DEF_RULE(expr_stmt_2, nc, or(2), rule(expr_stmt_augassign), rule(expr_stmt_assign_list))
DEF_RULE(expr_stmt_augassign, nc, and_ident(2), rule(augassign), rule(expr_stmt_6))
DEF_RULE(expr_stmt_assign_list, nc, one_or_more, rule(expr_stmt_assign))
DEF_RULE(expr_stmt_assign, nc, and_ident(2), tok(DEL_EQUAL), rule(expr_stmt_6))
DEF_RULE(expr_stmt_6, nc, or(2), rule(yield_expr), rule(testlist_star_expr))
DEF_RULE(testlist_star_expr, c(generic_tuple), list_with_end, rule(testlist_star_expr_2), tok(DEL_COMMA))
DEF_RULE(testlist_star_expr_2, nc, or(2), rule(star_expr), rule(test))
DEF_RULE(augassign, nc, or(12), tok(DEL_PLUS_EQUAL), tok(DEL_MINUS_EQUAL), tok(DEL_STAR_EQUAL), tok(DEL_SLASH_EQUAL), tok(DEL_PERCENT_EQUAL), tok(DEL_AMPERSAND_EQUAL), tok(DEL_PIPE_EQUAL), tok(DEL_CARET_EQUAL), tok(DEL_DBL_LESS_EQUAL), tok(DEL_DBL_MORE_EQUAL), tok(DEL_DBL_STAR_EQUAL), tok(DEL_DBL_SLASH_EQUAL))

// del_stmt: 'del' exprlist
// pass_stmt: 'pass'
// flow_stmt: break_stmt | continue_stmt | return_stmt | raise_stmt | yield_stmt
// break_stmt: 'break'
// continue_stmt: 'continue'
// return_stmt: 'return' [testlist]
// yield_stmt: yield_expr
// raise_stmt: 'raise' [test ['from' test]]

DEF_RULE(del_stmt, c(del_stmt), and(2), tok(KW_DEL), rule(exprlist))
DEF_RULE(pass_stmt, c(generic_all_nodes), and(1), tok(KW_PASS))
DEF_RULE(flow_stmt, nc, or(5), rule(break_stmt), rule(continue_stmt), rule(return_stmt), rule(raise_stmt), rule(yield_stmt))
DEF_RULE(break_stmt, c(break_stmt), and(1), tok(KW_BREAK))
DEF_RULE(continue_stmt, c(continue_stmt), and(1), tok(KW_CONTINUE))
DEF_RULE(return_stmt, c(return_stmt), and(2), tok(KW_RETURN), opt_rule(testlist))
DEF_RULE(yield_stmt, c(yield_stmt), and(1), rule(yield_expr))
DEF_RULE(raise_stmt, c(raise_stmt), and(2), tok(KW_RAISE), opt_rule(raise_stmt_arg))
DEF_RULE(raise_stmt_arg, nc, and_ident(2), rule(test), opt_rule(raise_stmt_from))
DEF_RULE(raise_stmt_from, nc, and_ident(2), tok(KW_FROM), rule(test))

// import_stmt: import_name | import_from
// import_name: 'import' dotted_as_names
// import_from: 'from' (('.' | '...')* dotted_name | ('.' | '...')+) 'import' ('*' | '(' import_as_names ')' | import_as_names)
// import_as_name: NAME ['as' NAME]
// dotted_as_name: dotted_name ['as' NAME]
// import_as_names: import_as_name (',' import_as_name)* [',']
// dotted_as_names: dotted_as_name (',' dotted_as_name)*
// dotted_name: NAME ('.' NAME)*
// global_stmt: 'global' NAME (',' NAME)*
// nonlocal_stmt: 'nonlocal' NAME (',' NAME)*
// assert_stmt: 'assert' test [',' test]

DEF_RULE(import_stmt, nc, or(2), rule(import_name), rule(import_from))
DEF_RULE(import_name, c(import_name), and(2), tok(KW_IMPORT), rule(dotted_as_names))
DEF_RULE(import_from, c(import_from), and(4), tok(KW_FROM), rule(import_from_2), tok(KW_IMPORT), rule(import_from_3))
DEF_RULE(import_from_2, nc, or(2), rule(dotted_name), rule(import_from_2b))
DEF_RULE(import_from_2b, nc, and_ident(2), rule(one_or_more_period_or_ellipsis), opt_rule(dotted_name))
DEF_RULE(import_from_3, nc, or(3), tok(OP_STAR), rule(import_as_names_paren), rule(import_as_names))
DEF_RULE(import_as_names_paren, nc, and_ident(3), tok(DEL_PAREN_OPEN), rule(import_as_names), tok(DEL_PAREN_CLOSE))
DEF_RULE(one_or_more_period_or_ellipsis, nc, one_or_more, rule(period_or_ellipsis))
DEF_RULE(period_or_ellipsis, nc, or(2), tok(DEL_PERIOD), tok(ELLIPSIS))
DEF_RULE(import_as_name, nc, and(2), tok(NAME), opt_rule(as_name))
DEF_RULE(dotted_as_name, nc, and_ident(2), rule(dotted_name), opt_rule(as_name))
DEF_RULE(as_name, nc, and_ident(2), tok(KW_AS), tok(NAME))
DEF_RULE(import_as_names, nc, list_with_end, rule(import_as_name), tok(DEL_COMMA))
DEF_RULE(dotted_as_names, nc, list, rule(dotted_as_name), tok(DEL_COMMA))
DEF_RULE(dotted_name, nc, list, tok(NAME), tok(DEL_PERIOD))
DEF_RULE(global_stmt, c(global_stmt), and(2), tok(KW_GLOBAL), rule(name_list))
DEF_RULE(nonlocal_stmt, c(nonlocal_stmt), and(2), tok(KW_NONLOCAL), rule(name_list))
DEF_RULE(name_list, nc, list, tok(NAME), tok(DEL_COMMA))
DEF_RULE(assert_stmt, c(assert_stmt), and(3), tok(KW_ASSERT), rule(test), opt_rule(assert_stmt_extra))
DEF_RULE(assert_stmt_extra, nc, and_ident(2), tok(DEL_COMMA), rule(test))

// compound_stmt: if_stmt | while_stmt | for_stmt | try_stmt | with_stmt | funcdef | classdef | decorated | async_stmt
// if_stmt: 'if' test ':' suite ('elif' test ':' suite)* ['else' ':' suite]
// while_stmt: 'while' test ':' suite ['else' ':' suite]
// for_stmt: 'for' exprlist 'in' testlist ':' suite ['else' ':' suite]
// try_stmt: 'try' ':' suite ((except_clause ':' suite)+ ['else' ':' suite] ['finally' ':' suite] | 'finally' ':' suite)
// # NB compile.c makes sure that the default except clause is last
// except_clause: 'except' [test ['as' NAME]]
// with_stmt: 'with' with_item (',' with_item)* ':' suite
// with_item: test ['as' expr]
// suite: simple_stmt | NEWLINE INDENT stmt+ DEDENT
// async_stmt: 'async' (funcdef | with_stmt | for_stmt)

#if MICROPY_PY_ASYNC_AWAIT
DEF_RULE(compound_stmt, nc, or(9), rule(if_stmt), rule(while_stmt), rule(for_stmt), rule(try_stmt), rule(with_stmt), rule(funcdef), rule(classdef), rule(decorated), rule(async_stmt))
DEF_RULE(async_stmt, c(async_stmt), and(2), tok(KW_ASYNC), rule(async_stmt_2))
DEF_RULE(async_stmt_2, nc, or(3), rule(funcdef), rule(with_stmt), rule(for_stmt))
#else
DEF_RULE(compound_stmt, nc, or(8), rule(if_stmt), rule(while_stmt), rule(for_stmt), rule(try_stmt), rule(with_stmt), rule(funcdef), rule(classdef), rule(decorated))
#endif
DEF_RULE(if_stmt, c(if_stmt), and(6), tok(KW_IF), rule(test), tok(DEL_COLON), rule(suite), opt_rule(if_stmt_elif_list), opt_rule(else_stmt))
DEF_RULE(if_stmt_elif_list, nc, one_or_more, rule(if_stmt_elif))
DEF_RULE(if_stmt_elif, nc, and(4), tok(KW_ELIF), rule(test), tok(DEL_COLON), rule(suite))
DEF_RULE(while_stmt, c(while_stmt), and(5), tok(KW_WHILE), rule(test), tok(DEL_COLON), rule(suite), opt_rule(else_stmt))
DEF_RULE(for_stmt, c(for_stmt), and(7), tok(KW_FOR), rule(exprlist), tok(KW_IN), rule(testlist), tok(DEL_COLON), rule(suite), opt_rule(else_stmt))
DEF_RULE(try_stmt, c(try_stmt), and(4), tok(KW_TRY), tok(DEL_COLON), rule(suite), rule(try_stmt_2))
DEF_RULE(try_stmt_2, nc, or(2), rule(try_stmt_except_and_more), rule(try_stmt_finally))
DEF_RULE(try_stmt_except_and_more, nc, and_ident(3), rule(try_stmt_except_list), opt_rule(else_stmt), opt_rule(try_stmt_finally))
DEF_RULE(try_stmt_except, nc, and(4), tok(KW_EXCEPT), opt_rule(try_stmt_as_name), tok(DEL_COLON), rule(suite))
DEF_RULE(try_stmt_as_name, nc, and_ident(2), rule(test), opt_rule(as_name))
DEF_RULE(try_stmt_except_list, nc, one_or_more, rule(try_stmt_except))
DEF_RULE(try_stmt_finally, nc, and(3), tok(KW_FINALLY), tok(DEL_COLON), rule(suite))
DEF_RULE(else_stmt, nc, and_ident(3), tok(KW_ELSE), tok(DEL_COLON), rule(suite))
DEF_RULE(with_stmt, c(with_stmt), and(4), tok(KW_WITH), rule(with_stmt_list), tok(DEL_COLON), rule(suite))
DEF_RULE(with_stmt_list, nc, list, rule(with_item), tok(DEL_COMMA))
DEF_RULE(with_item, nc, and_ident(2), rule(test), opt_rule(with_item_as))
DEF_RULE(with_item_as, nc, and_ident(2), tok(KW_AS), rule(expr))
DEF_RULE(suite, nc, or(2), rule(suite_block), rule(simple_stmt))
DEF_RULE(suite_block, nc, and_ident(4), tok(NEWLINE), tok(INDENT), rule(suite_block_stmts), tok(DEDENT))
DEF_RULE(suite_block_stmts, c(generic_all_nodes), one_or_more, rule(stmt))

// test: or_test ['if' or_test 'else' test] | lambdef
// test_nocond: or_test | lambdef_nocond
// lambdef: 'lambda' [varargslist] ':' test
// lambdef_nocond: 'lambda' [varargslist] ':' test_nocond

DEF_RULE(test, nc, or(2), rule(lambdef), rule(test_if_expr))
DEF_RULE(test_if_expr, c(test_if_expr), and_ident(2), rule(or_test), opt_rule(test_if_else))
DEF_RULE(test_if_else, nc, and(4), tok(KW_IF), rule(or_test), tok(KW_ELSE), rule(test))
DEF_RULE(test_nocond, nc, or(2), rule(lambdef_nocond), rule(or_test))
DEF_RULE(lambdef, c(lambdef), and_blank(4), tok(KW_LAMBDA), opt_rule(varargslist), tok(DEL_COLON), rule(test))
DEF_RULE(lambdef_nocond, c(lambdef), and_blank(4), tok(KW_LAMBDA), opt_rule(varargslist), tok(DEL_COLON), rule(test_nocond))

// or_test: and_test ('or' and_test)*
// and_test: not_test ('and' not_test)*
// not_test: 'not' not_test | comparison
// comparison: expr (comp_op expr)*
// comp_op: '<'|'>'|'=='|'>='|'<='|'!='|'in'|'not' 'in'|'is'|'is' 'not'
// star_expr: '*' expr
// expr: xor_expr ('|' xor_expr)*
// xor_expr: and_expr ('^' and_expr)*
// and_expr: shift_expr ('&' shift_expr)*
// shift_expr: arith_expr (('<<'|'>>') arith_expr)*
// arith_expr: term (('+'|'-') term)*
// term: factor (('*'|'/'|'%'|'//') factor)*
// factor: ('+'|'-'|'~') factor | power
// power: atom_expr ['**' factor]
// atom_expr: 'await' atom trailer* | atom trailer*

DEF_RULE(or_test, c(or_test), list, rule(and_test), tok(KW_OR))
DEF_RULE(and_test, c(and_test), list, rule(not_test), tok(KW_AND))
DEF_RULE(not_test, nc, or(2), rule(not_test_2), rule(comparison))
DEF_RULE(not_test_2, c(not_test_2), and(2), tok(KW_NOT), rule(not_test))
DEF_RULE(comparison, c(comparison), list, rule(expr), rule(comp_op))
DEF_RULE(comp_op, nc, or(9), tok(OP_LESS), tok(OP_MORE), tok(OP_DBL_EQUAL), tok(OP_LESS_EQUAL), tok(OP_MORE_EQUAL), tok(OP_NOT_EQUAL), tok(KW_IN), rule(comp_op_not_in), rule(comp_op_is))
DEF_RULE(comp_op_not_in, nc, and(2), tok(KW_NOT), tok(KW_IN))
DEF_RULE(comp_op_is, nc, and(2), tok(KW_IS), opt_rule(comp_op_is_not))
DEF_RULE(comp_op_is_not, nc, and(1), tok(KW_NOT))
DEF_RULE(star_expr, c(star_expr), and(2), tok(OP_STAR), rule(expr))
DEF_RULE(expr, c(expr), list, rule(xor_expr), tok(OP_PIPE))
DEF_RULE(xor_expr, c(xor_expr), list, rule(and_expr), tok(OP_CARET))
DEF_RULE(and_expr, c(and_expr), list, rule(shift_expr), tok(OP_AMPERSAND))
DEF_RULE(shift_expr, c(shift_expr), list, rule(arith_expr), rule(shift_op))
DEF_RULE(shift_op, nc, or(2), tok(OP_DBL_LESS), tok(OP_DBL_MORE))
DEF_RULE(arith_expr, c(arith_expr), list, rule(term), rule(arith_op))
DEF_RULE(arith_op, nc, or(2), tok(OP_PLUS), tok(OP_MINUS))
DEF_RULE(term, c(term), list, rule(factor), rule(term_op))
DEF_RULE(term_op, nc, or(4), tok(OP_STAR), tok(OP_SLASH), tok(OP_PERCENT), tok(OP_DBL_SLASH))
DEF_RULE(factor, nc, or(2), rule(factor_2), rule(power))
DEF_RULE(factor_2, c(factor_2), and_ident(2), rule(factor_op), rule(factor))
DEF_RULE(factor_op, nc, or(3), tok(OP_PLUS), tok(OP_MINUS), tok(OP_TILDE))
DEF_RULE(power, c(power), and_ident(2), rule(atom_expr), opt_rule(power_dbl_star))
#if MICROPY_PY_ASYNC_AWAIT
DEF_RULE(atom_expr, nc, or(2), rule(atom_expr_await), rule(atom_expr_normal))
DEF_RULE(atom_expr_await, c(atom_expr_await), and(3), tok(KW_AWAIT), rule(atom), opt_rule(atom_expr_trailers))
#else
DEF_RULE(atom_expr, nc, or(1), rule(atom_expr_normal))
#endif
DEF_RULE(atom_expr_normal, c(atom_expr_normal), and_ident(2), rule(atom), opt_rule(atom_expr_trailers))
DEF_RULE(atom_expr_trailers, c(atom_expr_trailers), one_or_more, rule(trailer))
DEF_RULE(power_dbl_star, nc, and_ident(2), tok(OP_DBL_STAR), rule(factor))

// atom: '(' [yield_expr|testlist_comp] ')' | '[' [testlist_comp] ']' | '{' [dictorsetmaker] '}' | NAME | NUMBER | STRING+ | '...' | 'None' | 'True' | 'False'
// testlist_comp: (test|star_expr) ( comp_for | (',' (test|star_expr))* [','] )
// trailer: '(' [arglist] ')' | '[' subscriptlist ']' | '.' NAME

DEF_RULE(atom, nc, or(11), tok(NAME), tok(INTEGER), tok(FLOAT_OR_IMAG), rule(atom_string), tok(ELLIPSIS), tok(KW_NONE), tok(KW_TRUE), tok(KW_FALSE), rule(atom_paren), rule(atom_bracket), rule(atom_brace))
DEF_RULE(atom_string, c(atom_string), one_or_more, rule(string_or_bytes))
DEF_RULE(string_or_bytes, nc, or(2), tok(STRING), tok(BYTES))
DEF_RULE(atom_paren, c(atom_paren), and(3), tok(DEL_PAREN_OPEN), opt_rule(atom_2b), tok(DEL_PAREN_CLOSE))
DEF_RULE(atom_2b, nc, or(2), rule(yield_expr), rule(testlist_comp))
DEF_RULE(atom_bracket, c(atom_bracket), and(3), tok(DEL_BRACKET_OPEN), opt_rule(testlist_comp), tok(DEL_BRACKET_CLOSE))
DEF_RULE(atom_brace, c(atom_brace), and(3), tok(DEL_BRACE_OPEN), opt_rule(dictorsetmaker), tok(DEL_BRACE_CLOSE))
DEF_RULE(testlist_comp, nc, and_ident(2), rule(testlist_comp_2), opt_rule(testlist_comp_3))
DEF_RULE(testlist_comp_2, nc, or(2), rule(star_expr), rule(test))
DEF_RULE(testlist_comp_3, nc, or(2), rule(comp_for), rule(testlist_comp_3b))
DEF_RULE(testlist_comp_3b, nc, and_ident(2), tok(DEL_COMMA), opt_rule(testlist_comp_3c))
DEF_RULE(testlist_comp_3c, nc, list_with_end, rule(testlist_comp_2), tok(DEL_COMMA))
DEF_RULE(trailer, nc, or(3), rule(trailer_paren), rule(trailer_bracket), rule(trailer_period))
DEF_RULE(trailer_paren, c(trailer_paren), and(3), tok(DEL_PAREN_OPEN), opt_rule(arglist), tok(DEL_PAREN_CLOSE))
DEF_RULE(trailer_bracket, c(trailer_bracket), and(3), tok(DEL_BRACKET_OPEN), rule(subscriptlist), tok(DEL_BRACKET_CLOSE))
DEF_RULE(trailer_period, c(trailer_period), and(2), tok(DEL_PERIOD), tok(NAME))

// subscriptlist: subscript (',' subscript)* [',']
// subscript: test | [test] ':' [test] [sliceop]
// sliceop: ':' [test]

#if MICROPY_PY_BUILTINS_SLICE
DEF_RULE(subscriptlist, c(generic_tuple), list_with_end, rule(subscript), tok(DEL_COMMA))
DEF_RULE(subscript, nc, or(2), rule(subscript_3), rule(subscript_2))
DEF_RULE(subscript_2, c(subscript_2), and_ident(2), rule(test), opt_rule(subscript_3))
DEF_RULE(subscript_3, c(subscript_3), and(2), tok(DEL_COLON), opt_rule(subscript_3b))
DEF_RULE(subscript_3b, nc, or(2), rule(subscript_3c), rule(subscript_3d))
DEF_RULE(subscript_3c, nc, and(2), tok(DEL_COLON), opt_rule(test))
DEF_RULE(subscript_3d, nc, and_ident(2), rule(test), opt_rule(sliceop))
DEF_RULE(sliceop, nc, and(2), tok(DEL_COLON), opt_rule(test))
#else
DEF_RULE(subscriptlist, c(generic_tuple), list_with_end, rule(test), tok(DEL_COMMA))
#endif

// exprlist: (expr|star_expr) (',' (expr|star_expr))* [',']
// testlist: test (',' test)* [',']
// dictorsetmaker: (test ':' test (comp_for | (',' test ':' test)* [','])) | (test (comp_for | (',' test)* [',']))

DEF_RULE(exprlist, nc, list_with_end, rule(exprlist_2), tok(DEL_COMMA))
DEF_RULE(exprlist_2, nc, or(2), rule(star_expr), rule(expr))
DEF_RULE(testlist, c(generic_tuple), list_with_end, rule(test), tok(DEL_COMMA))
// TODO dictorsetmaker lets through more than is allowed
DEF_RULE(dictorsetmaker, nc, and_ident(2), rule(dictorsetmaker_item), opt_rule(dictorsetmaker_tail))
#if MICROPY_PY_BUILTINS_SET
DEF_RULE(dictorsetmaker_item, c(dictorsetmaker_item), and_ident(2), rule(test), opt_rule(dictorsetmaker_colon))
DEF_RULE(dictorsetmaker_colon, nc, and_ident(2), tok(DEL_COLON), rule(test))
#else
DEF_RULE(dictorsetmaker_item, c(dictorsetmaker_item), and(3), rule(test), tok(DEL_COLON), rule(test))
#endif
DEF_RULE(dictorsetmaker_tail, nc, or(2), rule(comp_for), rule(dictorsetmaker_list))
DEF_RULE(dictorsetmaker_list, nc, and(2), tok(DEL_COMMA), opt_rule(dictorsetmaker_list2))
DEF_RULE(dictorsetmaker_list2, nc, list_with_end, rule(dictorsetmaker_item), tok(DEL_COMMA))

// classdef: 'class' NAME ['(' [arglist] ')'] ':' suite

DEF_RULE(classdef, c(classdef), and_blank(5), tok(KW_CLASS), tok(NAME), opt_rule(classdef_2), tok(DEL_COLON), rule(suite))
DEF_RULE(classdef_2, nc, and_ident(3), tok(DEL_PAREN_OPEN), opt_rule(arglist), tok(DEL_PAREN_CLOSE))

// arglist: (argument ',')* (argument [','] | '*' test (',' argument)* [',' '**' test] | '**' test)

// TODO arglist lets through more than is allowed, compiler needs to do further verification
DEF_RULE(arglist, nc, list_with_end, rule(arglist_2), tok(DEL_COMMA))
DEF_RULE(arglist_2, nc, or(3), rule(arglist_star), rule(arglist_dbl_star), rule(argument))
DEF_RULE(arglist_star, nc, and(2), tok(OP_STAR), rule(test))
DEF_RULE(arglist_dbl_star, nc, and(2), tok(OP_DBL_STAR), rule(test))

// # The reason that keywords are test nodes instead of NAME is that using NAME
// # results in an ambiguity. ast.c makes sure it's a NAME.
// argument: test [comp_for] | test '=' test  # Really [keyword '='] test
// comp_iter: comp_for | comp_if
// comp_for: 'for' exprlist 'in' or_test [comp_iter]
// comp_if: 'if' test_nocond [comp_iter]

DEF_RULE(argument, nc, and_ident(2), rule(test), opt_rule(argument_2))
DEF_RULE(argument_2, nc, or(2), rule(comp_for), rule(argument_3))
DEF_RULE(argument_3, nc, and_ident(2), tok(DEL_EQUAL), rule(test))
DEF_RULE(comp_iter, nc, or(2), rule(comp_for), rule(comp_if))
DEF_RULE(comp_for, nc, and_blank(5), tok(KW_FOR), rule(exprlist), tok(KW_IN), rule(or_test), opt_rule(comp_iter))
DEF_RULE(comp_if, nc, and(3), tok(KW_IF), rule(test_nocond), opt_rule(comp_iter))

// # not used in grammar, but may appear in "node" passed from Parser to Compiler
// encoding_decl: NAME

// yield_expr: 'yield' [yield_arg]
// yield_arg: 'from' test | testlist

DEF_RULE(yield_expr, c(yield_expr), and(2), tok(KW_YIELD), opt_rule(yield_arg))
DEF_RULE(yield_arg, nc, or(2), rule(yield_arg_from), rule(testlist))
DEF_RULE(yield_arg_from, nc, and(2), tok(KW_FROM), rule(test))
#undef nc
#undef c
#undef DEF_RULE
    NULL,
    micropy_compile_string,
    micropy_compile_bytes,
    micropy_compile_const_object,
};

STATIC void micropy_compile_node(struct _mp_state_ctx_t *mp_state, compiler_t *comp, mp_parse_node_t pn) {
    if (MP_PARSE_NODE_IS_NULL(pn)) {
        // pass
    } else if (MP_PARSE_NODE_IS_SMALL_INT(pn)) {
        mp_int_t arg = MP_PARSE_NODE_LEAF_SMALL_INT(pn);
        #if MICROPY_DYNAMIC_COMPILER
        mp_uint_t sign_mask = -(1 << (mp_dynamic_compiler.small_int_bits - 1));
        if ((arg & sign_mask) == 0 || (arg & sign_mask) == sign_mask) {
            // integer fits in target runtime's small-int
            EMIT_ARG(load_const_small_int, arg);
        } else {
            // integer doesn't fit, so create a multi-precision int object
            // (but only create the actual object on the last pass)
            if (comp->pass != MP_PASS_EMIT) {
                EMIT_ARG(load_const_obj, mp_const_none);
            } else {
                EMIT_ARG(load_const_obj, micropy_obj_new_int_from_ll(mp_state, arg));
            }
        }
        #else
        EMIT_ARG(load_const_small_int, arg);
        #endif
    } else if (MP_PARSE_NODE_IS_LEAF(pn)) {
        uintptr_t arg = MP_PARSE_NODE_LEAF_ARG(pn);
        switch (MP_PARSE_NODE_LEAF_KIND(pn)) {
            case MP_PARSE_NODE_ID: micropy_compile_load_id(mp_state, comp, arg); break;
            case MP_PARSE_NODE_STRING: EMIT_ARG(load_const_str, arg); break;
            case MP_PARSE_NODE_BYTES:
                // only create and load the actual bytes object on the last pass
                if (comp->pass != MP_PASS_EMIT) {
                    EMIT_ARG(load_const_obj, mp_const_none);
                } else {
                    size_t len;
                    const byte *data = micropy_qstr_data(mp_state, arg, &len);
                    EMIT_ARG(load_const_obj, micropy_obj_new_bytes(mp_state, data, len));
                }
                break;
            case MP_PARSE_NODE_TOKEN: default:
                if (arg == MP_TOKEN_NEWLINE) {
                    // this can occur when file_input lets through a NEWLINE (eg if file starts with a newline)
                    // or when single_input lets through a NEWLINE (user enters a blank line)
                    // do nothing
                } else {
                  EMIT_ARG(load_const_tok, arg);
                }
                break;
        }
    } else {
        mp_parse_node_struct_t *pns = (mp_parse_node_struct_t*)pn;
        EMIT_ARG(set_source_line, pns->source_line);
        compile_function_t f = compile_function[MP_PARSE_NODE_STRUCT_KIND(pns)];
        if (f == NULL) {
#if MICROPY_DEBUG_PRINTERS
            printf("node %u cannot be compiled\n", (uint)MP_PARSE_NODE_STRUCT_KIND(pns));
            micropy_parse_node_print(mp_state, pn, 0);
#endif
            micropy_compile_syntax_error(mp_state, comp, pn, "internal compiler error");
        } else {
            f(mp_state, comp, pns);
        }
    }
}

STATIC void micropy_compile_scope_func_lambda_param(struct _mp_state_ctx_t *mp_state, compiler_t *comp, mp_parse_node_t pn, pn_kind_t pn_name, pn_kind_t pn_star, pn_kind_t pn_dbl_star) {
    // check that **kw is last
    if ((comp->scope_cur->scope_flags & MP_SCOPE_FLAG_VARKEYWORDS) != 0) {
        micropy_compile_syntax_error(mp_state, comp, pn, "invalid syntax");
        return;
    }

    qstr param_name = MP_QSTR_NULL;
    uint param_flag = ID_FLAG_IS_PARAM;
    if (MP_PARSE_NODE_IS_ID(pn)) {
        param_name = MP_PARSE_NODE_LEAF_ARG(pn);
        if (comp->have_star) {
            // comes after a star, so counts as a keyword-only parameter
            comp->scope_cur->num_kwonly_args += 1;
        } else {
            // comes before a star, so counts as a positional parameter
            comp->scope_cur->num_pos_args += 1;
        }
    } else {
        assert(MP_PARSE_NODE_IS_STRUCT(pn));
        mp_parse_node_struct_t *pns = (mp_parse_node_struct_t*)pn;
        if (MP_PARSE_NODE_STRUCT_KIND(pns) == pn_name) {
            param_name = MP_PARSE_NODE_LEAF_ARG(pns->nodes[0]);
            if (comp->have_star) {
                // comes after a star, so counts as a keyword-only parameter
                comp->scope_cur->num_kwonly_args += 1;
            } else {
                // comes before a star, so counts as a positional parameter
                comp->scope_cur->num_pos_args += 1;
            }
        } else if (MP_PARSE_NODE_STRUCT_KIND(pns) == pn_star) {
            if (comp->have_star) {
                // more than one star
                micropy_compile_syntax_error(mp_state, comp, pn, "invalid syntax");
                return;
            }
            comp->have_star = true;
            param_flag = ID_FLAG_IS_PARAM | ID_FLAG_IS_STAR_PARAM;
            if (MP_PARSE_NODE_IS_NULL(pns->nodes[0])) {
                // bare star
                // TODO see http://www.python.org/dev/peps/pep-3102/
                //assert(comp->scope_cur->num_dict_params == 0);
            } else if (MP_PARSE_NODE_IS_ID(pns->nodes[0])) {
                // named star
                comp->scope_cur->scope_flags |= MP_SCOPE_FLAG_VARARGS;
                param_name = MP_PARSE_NODE_LEAF_ARG(pns->nodes[0]);
            } else {
                assert(MP_PARSE_NODE_IS_STRUCT_KIND(pns->nodes[0], PN_tfpdef)); // should be
                // named star with possible annotation
                comp->scope_cur->scope_flags |= MP_SCOPE_FLAG_VARARGS;
                pns = (mp_parse_node_struct_t*)pns->nodes[0];
                param_name = MP_PARSE_NODE_LEAF_ARG(pns->nodes[0]);
            }
        } else {
            assert(MP_PARSE_NODE_STRUCT_KIND(pns) == pn_dbl_star); // should be
            param_name = MP_PARSE_NODE_LEAF_ARG(pns->nodes[0]);
            param_flag = ID_FLAG_IS_PARAM | ID_FLAG_IS_DBL_STAR_PARAM;
            comp->scope_cur->scope_flags |= MP_SCOPE_FLAG_VARKEYWORDS;
        }
    }

    if (param_name != MP_QSTR_NULL) {
        bool added;
        id_info_t *id_info = micropy_scope_find_or_add_id(mp_state, comp->scope_cur, param_name, &added);
        if (!added) {
            micropy_compile_syntax_error(mp_state, comp, pn, "name reused for argument");
            return;
        }
        id_info->kind = ID_INFO_KIND_LOCAL;
        id_info->flags = param_flag;
    }
}

STATIC void micropy_compile_scope_func_param(struct _mp_state_ctx_t *mp_state, compiler_t *comp, mp_parse_node_t pn) {
    micropy_compile_scope_func_lambda_param(mp_state, comp, pn, PN_typedargslist_name, PN_typedargslist_star, PN_typedargslist_dbl_star);
}

STATIC void micropy_compile_scope_lambda_param(struct _mp_state_ctx_t *mp_state, compiler_t *comp, mp_parse_node_t pn) {
    micropy_compile_scope_func_lambda_param(mp_state, comp, pn, PN_varargslist_name, PN_varargslist_star, PN_varargslist_dbl_star);
}

#if MICROPY_EMIT_NATIVE
STATIC void micropy_compile_scope_func_annotations(struct _mp_state_ctx_t *mp_state, compiler_t *comp, mp_parse_node_t pn) {
    if (!MP_PARSE_NODE_IS_STRUCT(pn)) {
        // no annotation
        return;
    }

    mp_parse_node_struct_t *pns = (mp_parse_node_struct_t*)pn;
    if (MP_PARSE_NODE_STRUCT_KIND(pns) == PN_typedargslist_name) {
        // named parameter with possible annotation
        // fallthrough
    } else if (MP_PARSE_NODE_STRUCT_KIND(pns) == PN_typedargslist_star) {
        if (MP_PARSE_NODE_IS_STRUCT_KIND(pns->nodes[0], PN_tfpdef)) {
            // named star with possible annotation
            pns = (mp_parse_node_struct_t*)pns->nodes[0];
            // fallthrough
        } else {
            // no annotation
            return;
        }
    } else if (MP_PARSE_NODE_STRUCT_KIND(pns) == PN_typedargslist_dbl_star) {
        // double star with possible annotation
        // fallthrough
    } else {
        // no annotation
        return;
    }

    mp_parse_node_t pn_annotation = pns->nodes[1];

    if (!MP_PARSE_NODE_IS_NULL(pn_annotation)) {
        qstr param_name = MP_PARSE_NODE_LEAF_ARG(pns->nodes[0]);
        id_info_t *id_info = micropy_scope_find(mp_state, comp->scope_cur, param_name);
        assert(id_info != NULL);

        if (MP_PARSE_NODE_IS_ID(pn_annotation)) {
            qstr arg_type = MP_PARSE_NODE_LEAF_ARG(pn_annotation);
            EMIT_ARG(set_native_type, MP_EMIT_NATIVE_TYPE_ARG, id_info->local_num, arg_type);
        } else {
            micropy_compile_syntax_error(mp_state, comp, pn_annotation, "parameter annotation must be an identifier");
        }
    }
}
#endif // MICROPY_EMIT_NATIVE

STATIC void micropy_compile_scope_comp_iter(struct _mp_state_ctx_t *mp_state, compiler_t *comp, mp_parse_node_struct_t *pns_comp_for, mp_parse_node_t pn_inner_expr, int for_depth) {
    uint l_top = micropy_comp_next_label(mp_state, comp);
    uint l_end = micropy_comp_next_label(mp_state, comp);
    EMIT_ARG(label_assign, l_top);
    EMIT_ARG(for_iter, l_end);
    micropy_c_assign(mp_state, comp, pns_comp_for->nodes[0], ASSIGN_STORE);
    mp_parse_node_t pn_iter = pns_comp_for->nodes[2];

    tail_recursion:
    if (MP_PARSE_NODE_IS_NULL(pn_iter)) {
        // no more nested if/for; compile inner expression
        micropy_compile_node(mp_state, comp, pn_inner_expr);
        if (comp->scope_cur->kind == SCOPE_LIST_COMP) {
            EMIT_ARG(list_append, for_depth + 2);
        } else if (comp->scope_cur->kind == SCOPE_DICT_COMP) {
            EMIT_ARG(map_add, for_depth + 2);
        #if MICROPY_PY_BUILTINS_SET
        } else if (comp->scope_cur->kind == SCOPE_SET_COMP) {
            EMIT_ARG(set_add, for_depth + 2);
        #endif
        } else {
            EMIT(yield_value);
            EMIT(pop_top);
        }
    } else if (MP_PARSE_NODE_IS_STRUCT_KIND(pn_iter, PN_comp_if)) {
        // if condition
        mp_parse_node_struct_t *pns_comp_if = (mp_parse_node_struct_t*)pn_iter;
        micropy_c_if_cond(mp_state, comp, pns_comp_if->nodes[0], false, l_top);
        pn_iter = pns_comp_if->nodes[1];
        goto tail_recursion;
    } else {
        assert(MP_PARSE_NODE_IS_STRUCT_KIND(pn_iter, PN_comp_for)); // should be
        // for loop
        mp_parse_node_struct_t *pns_comp_for2 = (mp_parse_node_struct_t*)pn_iter;
        micropy_compile_node(mp_state, comp, pns_comp_for2->nodes[1]);
        EMIT(get_iter);
        micropy_compile_scope_comp_iter(mp_state, comp, pns_comp_for2, pn_inner_expr, for_depth + 1);
    }

    EMIT_ARG(jump, l_top);
    EMIT_ARG(label_assign, l_end);
    EMIT(for_iter_end);
}

STATIC void micropy_check_for_doc_string(struct _mp_state_ctx_t *mp_state, compiler_t *comp, mp_parse_node_t pn) {
#if MICROPY_ENABLE_DOC_STRING
    // see http://www.python.org/dev/peps/pep-0257/

    // look for the first statement
    if (MP_PARSE_NODE_IS_STRUCT_KIND(pn, PN_expr_stmt)) {
        // a statement; fall through
    } else if (MP_PARSE_NODE_IS_STRUCT_KIND(pn, PN_file_input_2)) {
        // file input; find the first non-newline node
        mp_parse_node_struct_t *pns = (mp_parse_node_struct_t*)pn;
        int num_nodes = MP_PARSE_NODE_STRUCT_NUM_NODES(pns);
        for (int i = 0; i < num_nodes; i++) {
            pn = pns->nodes[i];
            if (!(MP_PARSE_NODE_IS_LEAF(pn) && MP_PARSE_NODE_LEAF_KIND(pn) == MP_PARSE_NODE_TOKEN && MP_PARSE_NODE_LEAF_ARG(pn) == MP_TOKEN_NEWLINE)) {
                // not a newline, so this is the first statement; finish search
                break;
            }
        }
        // if we didn't find a non-newline then it's okay to fall through; pn will be a newline and so doc-string test below will fail gracefully
    } else if (MP_PARSE_NODE_IS_STRUCT_KIND(pn, PN_suite_block_stmts)) {
        // a list of statements; get the first one
        pn = ((mp_parse_node_struct_t*)pn)->nodes[0];
    } else {
        return;
    }

    // check the first statement for a doc string
    if (MP_PARSE_NODE_IS_STRUCT_KIND(pn, PN_expr_stmt)) {
        mp_parse_node_struct_t *pns = (mp_parse_node_struct_t*)pn;
        if ((MP_PARSE_NODE_IS_LEAF(pns->nodes[0])
                && MP_PARSE_NODE_LEAF_KIND(pns->nodes[0]) == MP_PARSE_NODE_STRING)
            || MP_PARSE_NODE_IS_STRUCT_KIND(pns->nodes[0], PN_string)) {
                // compile the doc string
                micropy_compile_node(mp_state, comp, pns->nodes[0]);
                // store the doc string
                micropy_compile_store_id(mp_state, comp, MP_QSTR___doc__);
        }
    }
#else
    (void)comp;
    (void)pn;
#endif
}

STATIC void micropy_compile_scope(struct _mp_state_ctx_t *mp_state, compiler_t *comp, scope_t *scope, pass_kind_t pass) {
    comp->pass = pass;
    comp->scope_cur = scope;
    comp->next_label = 1;
    EMIT_ARG(start_pass, pass, scope);

    if (comp->pass == MP_PASS_SCOPE) {
        // reset maximum stack sizes in scope
        // they will be computed in this first pass
        scope->stack_size = 0;
        scope->exc_stack_size = 0;
    }

    // compile
    if (MP_PARSE_NODE_IS_STRUCT_KIND(scope->pn, PN_eval_input)) {
        assert(scope->kind == SCOPE_MODULE);
        mp_parse_node_struct_t *pns = (mp_parse_node_struct_t*)scope->pn;
        micropy_compile_node(mp_state, comp, pns->nodes[0]); // compile the expression
        EMIT(return_value);
    } else if (scope->kind == SCOPE_MODULE) {
        if (!comp->is_repl) {
            micropy_check_for_doc_string(mp_state, comp, scope->pn);
        }
        micropy_compile_node(mp_state, comp, scope->pn);
        EMIT_ARG(load_const_tok, MP_TOKEN_KW_NONE);
        EMIT(return_value);
    } else if (scope->kind == SCOPE_FUNCTION) {
        assert(MP_PARSE_NODE_IS_STRUCT(scope->pn));
        mp_parse_node_struct_t *pns = (mp_parse_node_struct_t*)scope->pn;
        assert(MP_PARSE_NODE_STRUCT_KIND(pns) == PN_funcdef);

        // work out number of parameters, keywords and default parameters, and add them to the id_info array
        // must be done before compiling the body so that arguments are numbered first (for LOAD_FAST etc)
        if (comp->pass == MP_PASS_SCOPE) {
            comp->have_star = false;
            micropy_apply_to_single_or_list(mp_state, comp, pns->nodes[1], PN_typedargslist, micropy_compile_scope_func_param);
        }
        #if MICROPY_EMIT_NATIVE
        else if (scope->emit_options == MP_EMIT_OPT_VIPER) {
            // compile annotations; only needed on latter compiler passes
            // only needed for viper emitter

            // argument annotations
            micropy_apply_to_single_or_list(mp_state, comp, pns->nodes[1], PN_typedargslist, micropy_compile_scope_func_annotations);

            // pns->nodes[2] is return/whole function annotation
            mp_parse_node_t pn_annotation = pns->nodes[2];
            if (!MP_PARSE_NODE_IS_NULL(pn_annotation)) {
                // nodes[2] can be null or a test-expr
                if (MP_PARSE_NODE_IS_ID(pn_annotation)) {
                    qstr ret_type = MP_PARSE_NODE_LEAF_ARG(pn_annotation);
                    EMIT_ARG(set_native_type, MP_EMIT_NATIVE_TYPE_RETURN, 0, ret_type);
                } else {
                    micropy_compile_syntax_error(mp_state, comp, pn_annotation, "return annotation must be an identifier");
                }
            }
        }
        #endif // MICROPY_EMIT_NATIVE

        micropy_compile_node(mp_state, comp, pns->nodes[3]); // 3 is function body
        // emit return if it wasn't the last opcode
        if (!EMIT(last_emit_was_return_value)) {
            EMIT_ARG(load_const_tok, MP_TOKEN_KW_NONE);
            EMIT(return_value);
        }
    } else if (scope->kind == SCOPE_LAMBDA) {
        assert(MP_PARSE_NODE_IS_STRUCT(scope->pn));
        mp_parse_node_struct_t *pns = (mp_parse_node_struct_t*)scope->pn;
        assert(MP_PARSE_NODE_STRUCT_NUM_NODES(pns) == 3);

        // work out number of parameters, keywords and default parameters, and add them to the id_info array
        // must be done before compiling the body so that arguments are numbered first (for LOAD_FAST etc)
        if (comp->pass == MP_PASS_SCOPE) {
            comp->have_star = false;
            micropy_apply_to_single_or_list(mp_state, comp, pns->nodes[0], PN_varargslist, micropy_compile_scope_lambda_param);
        }

        micropy_compile_node(mp_state, comp, pns->nodes[1]); // 1 is lambda body

        // if the lambda is a generator, then we return None, not the result of the expression of the lambda
        if (scope->scope_flags & MP_SCOPE_FLAG_GENERATOR) {
            EMIT(pop_top);
            EMIT_ARG(load_const_tok, MP_TOKEN_KW_NONE);
        }
        EMIT(return_value);
    } else if (scope->kind == SCOPE_LIST_COMP || scope->kind == SCOPE_DICT_COMP || scope->kind == SCOPE_SET_COMP || scope->kind == SCOPE_GEN_EXPR) {
        // a bit of a hack at the moment

        assert(MP_PARSE_NODE_IS_STRUCT(scope->pn));
        mp_parse_node_struct_t *pns = (mp_parse_node_struct_t*)scope->pn;
        assert(MP_PARSE_NODE_STRUCT_NUM_NODES(pns) == 2);
        assert(MP_PARSE_NODE_IS_STRUCT_KIND(pns->nodes[1], PN_comp_for));
        mp_parse_node_struct_t *pns_comp_for = (mp_parse_node_struct_t*)pns->nodes[1];

        // We need a unique name for the comprehension argument (the iterator).
        // CPython uses .0, but we should be able to use anything that won't
        // clash with a user defined variable.  Best to use an existing qstr,
        // so we use the blank qstr.
        qstr qstr_arg = MP_QSTR_;
        if (comp->pass == MP_PASS_SCOPE) {
            bool added;
            id_info_t *id_info = micropy_scope_find_or_add_id(mp_state, comp->scope_cur, qstr_arg, &added);
            assert(added);
            id_info->kind = ID_INFO_KIND_LOCAL;
            scope->num_pos_args = 1;
        }

        if (scope->kind == SCOPE_LIST_COMP) {
            EMIT_ARG(build_list, 0);
        } else if (scope->kind == SCOPE_DICT_COMP) {
            EMIT_ARG(build_map, 0);
        #if MICROPY_PY_BUILTINS_SET
        } else if (scope->kind == SCOPE_SET_COMP) {
            EMIT_ARG(build_set, 0);
        #endif
        }

        micropy_compile_load_id(mp_state, comp, qstr_arg);
        micropy_compile_scope_comp_iter(mp_state, comp, pns_comp_for, pns->nodes[0], 0);

        if (scope->kind == SCOPE_GEN_EXPR) {
            EMIT_ARG(load_const_tok, MP_TOKEN_KW_NONE);
        }
        EMIT(return_value);
    } else {
        assert(scope->kind == SCOPE_CLASS);
        assert(MP_PARSE_NODE_IS_STRUCT(scope->pn));
        mp_parse_node_struct_t *pns = (mp_parse_node_struct_t*)scope->pn;
        assert(MP_PARSE_NODE_STRUCT_KIND(pns) == PN_classdef);

        if (comp->pass == MP_PASS_SCOPE) {
            bool added;
            id_info_t *id_info = micropy_scope_find_or_add_id(mp_state, scope, MP_QSTR___class__, &added);
            assert(added);
            id_info->kind = ID_INFO_KIND_LOCAL;
        }

        micropy_compile_load_id(mp_state, comp, MP_QSTR___name__);
        micropy_compile_store_id(mp_state, comp, MP_QSTR___module__);
        EMIT_ARG(load_const_str, MP_PARSE_NODE_LEAF_ARG(pns->nodes[0])); // 0 is class name
        micropy_compile_store_id(mp_state, comp, MP_QSTR___qualname__);

        micropy_check_for_doc_string(mp_state, comp, pns->nodes[2]);
        micropy_compile_node(mp_state, comp, pns->nodes[2]); // 2 is class body

        id_info_t *id = micropy_scope_find(mp_state, scope, MP_QSTR___class__);
        assert(id != NULL);
        if (id->kind == ID_INFO_KIND_LOCAL) {
            EMIT_ARG(load_const_tok, MP_TOKEN_KW_NONE);
        } else {
            EMIT_LOAD_FAST(MP_QSTR___class__, id->local_num);
        }
        EMIT(return_value);
    }

    EMIT(end_pass);

    // make sure we match all the exception levels
    assert(comp->cur_except_level == 0);
}

#if MICROPY_EMIT_INLINE_THUMB
// requires 3 passes: SCOPE, CODE_SIZE, EMIT
STATIC void micropy_compile_scope_inline_asm(struct _mp_state_ctx_t *mp_state, compiler_t *comp, scope_t *scope, pass_kind_t pass) {
    comp->pass = pass;
    comp->scope_cur = scope;
    comp->next_label = 1;

    if (scope->kind != SCOPE_FUNCTION) {
        micropy_compile_syntax_error(mp_state, comp, MP_PARSE_NODE_NULL, "inline assembler must be a function");
        return;
    }

    if (comp->pass > MP_PASS_SCOPE) {
        EMIT_INLINE_ASM_ARG(start_pass, comp->pass, comp->scope_cur, &comp->compile_error);
    }

    // get the function definition parse node
    assert(MP_PARSE_NODE_IS_STRUCT(scope->pn));
    mp_parse_node_struct_t *pns = (mp_parse_node_struct_t*)scope->pn;
    assert(MP_PARSE_NODE_STRUCT_KIND(pns) == PN_funcdef);

    //qstr f_id = MP_PARSE_NODE_LEAF_ARG(pns->nodes[0]); // function name

    // parameters are in pns->nodes[1]
    if (comp->pass == MP_PASS_CODE_SIZE) {
        mp_parse_node_t *pn_params;
        int n_params = micropy_parse_node_extract_list(mp_state, &pns->nodes[1], PN_typedargslist, &pn_params);
        scope->num_pos_args = EMIT_INLINE_ASM_ARG(count_params, n_params, pn_params);
        if (comp->compile_error != MP_OBJ_NULL) {
            goto inline_asm_error;
        }
    }

    // pns->nodes[2] is function return annotation
    mp_uint_t type_sig = MP_NATIVE_TYPE_INT;
    mp_parse_node_t pn_annotation = pns->nodes[2];
    if (!MP_PARSE_NODE_IS_NULL(pn_annotation)) {
        // nodes[2] can be null or a test-expr
        if (MP_PARSE_NODE_IS_ID(pn_annotation)) {
            qstr ret_type = MP_PARSE_NODE_LEAF_ARG(pn_annotation);
            switch (ret_type) {
                case MP_QSTR_object: type_sig = MP_NATIVE_TYPE_OBJ; break;
                case MP_QSTR_bool: type_sig = MP_NATIVE_TYPE_BOOL; break;
                case MP_QSTR_int: type_sig = MP_NATIVE_TYPE_INT; break;
                case MP_QSTR_uint: type_sig = MP_NATIVE_TYPE_UINT; break;
                default: micropy_compile_syntax_error(mp_state, comp, pn_annotation, "unknown type"); return;
            }
        } else {
            micropy_compile_syntax_error(mp_state, comp, pn_annotation, "return annotation must be an identifier");
        }
    }

    mp_parse_node_t pn_body = pns->nodes[3]; // body
    mp_parse_node_t *nodes;
    int num = micropy_parse_node_extract_list(mp_state, &pn_body, PN_suite_block_stmts, &nodes);

    for (int i = 0; i < num; i++) {
        assert(MP_PARSE_NODE_IS_STRUCT(nodes[i]));
        mp_parse_node_struct_t *pns2 = (mp_parse_node_struct_t*)nodes[i];
        if (MP_PARSE_NODE_STRUCT_KIND(pns2) == PN_pass_stmt) {
            // no instructions
            continue;
        } else if (MP_PARSE_NODE_STRUCT_KIND(pns2) != PN_expr_stmt) {
            // not an instruction; error
        not_an_instruction:
            micropy_compile_syntax_error(mp_state, comp, nodes[i], "expecting an assembler instruction");
            return;
        }

        // check structure of parse node
        assert(MP_PARSE_NODE_IS_STRUCT(pns2->nodes[0]));
        if (!MP_PARSE_NODE_IS_NULL(pns2->nodes[1])) {
            goto not_an_instruction;
        }
        pns2 = (mp_parse_node_struct_t*)pns2->nodes[0];
        if (MP_PARSE_NODE_STRUCT_KIND(pns2) != PN_atom_expr_normal) {
            goto not_an_instruction;
        }
        if (!MP_PARSE_NODE_IS_ID(pns2->nodes[0])) {
            goto not_an_instruction;
        }
        if (!MP_PARSE_NODE_IS_STRUCT_KIND(pns2->nodes[1], PN_trailer_paren)) {
            goto not_an_instruction;
        }

        // parse node looks like an instruction
        // get instruction name and args
        qstr op = MP_PARSE_NODE_LEAF_ARG(pns2->nodes[0]);
        pns2 = (mp_parse_node_struct_t*)pns2->nodes[1]; // PN_trailer_paren
        mp_parse_node_t *pn_arg;
        int n_args = micropy_parse_node_extract_list(mp_state, &pns2->nodes[0], PN_arglist, &pn_arg);

        // emit instructions
        if (op == MP_QSTR_label) {
            if (!(n_args == 1 && MP_PARSE_NODE_IS_ID(pn_arg[0]))) {
                micropy_compile_syntax_error(mp_state, comp, nodes[i], "'label' requires 1 argument");
                return;
            }
            uint lab = micropy_comp_next_label(mp_state, comp);
            if (pass > MP_PASS_SCOPE) {
                if (!EMIT_INLINE_ASM_ARG(label, lab, MP_PARSE_NODE_LEAF_ARG(pn_arg[0]))) {
                    micropy_compile_syntax_error(mp_state, comp, nodes[i], "label redefined");
                    return;
                }
            }
        } else if (op == MP_QSTR_align) {
            if (!(n_args == 1 && MP_PARSE_NODE_IS_SMALL_INT(pn_arg[0]))) {
                micropy_compile_syntax_error(mp_state, comp, nodes[i], "'align' requires 1 argument");
                return;
            }
            if (pass > MP_PASS_SCOPE) {
                EMIT_INLINE_ASM_ARG(align, MP_PARSE_NODE_LEAF_SMALL_INT(pn_arg[0]));
            }
        } else if (op == MP_QSTR_data) {
            if (!(n_args >= 2 && MP_PARSE_NODE_IS_SMALL_INT(pn_arg[0]))) {
                micropy_compile_syntax_error(mp_state, comp, nodes[i], "'data' requires at least 2 arguments");
                return;
            }
            if (pass > MP_PASS_SCOPE) {
                mp_int_t bytesize = MP_PARSE_NODE_LEAF_SMALL_INT(pn_arg[0]);
                for (uint j = 1; j < n_args; j++) {
                    if (!MP_PARSE_NODE_IS_SMALL_INT(pn_arg[j])) {
                        micropy_compile_syntax_error(mp_state, comp, nodes[i], "'data' requires integer arguments");
                        return;
                    }
                    EMIT_INLINE_ASM_ARG(data, bytesize, MP_PARSE_NODE_LEAF_SMALL_INT(pn_arg[j]));
                }
            }
        } else {
            if (pass > MP_PASS_SCOPE) {
                EMIT_INLINE_ASM_ARG(op, op, n_args, pn_arg);
            }
        }

        if (comp->compile_error != MP_OBJ_NULL) {
            pns = pns2; // this is the parse node that had the error
            goto inline_asm_error;
        }
    }

    if (comp->pass > MP_PASS_SCOPE) {
        EMIT_INLINE_ASM_ARG(end_pass, type_sig);
    }

    if (comp->compile_error != MP_OBJ_NULL) {
        // inline assembler had an error; set line for its exception
    inline_asm_error:
        comp->compile_error_line = pns->source_line;
    }
}
#endif

STATIC void micropy_scope_compute_things(struct _mp_state_ctx_t *mp_state, scope_t *scope) {
    // in Micro Python we put the *x parameter after all other parameters (except **y)
    if (scope->scope_flags & MP_SCOPE_FLAG_VARARGS) {
        id_info_t *id_param = NULL;
        for (int i = scope->id_info_len - 1; i >= 0; i--) {
            id_info_t *id = &scope->id_info[i];
            if (id->flags & ID_FLAG_IS_STAR_PARAM) {
                if (id_param != NULL) {
                    // swap star param with last param
                    id_info_t temp = *id_param; *id_param = *id; *id = temp;
                }
                break;
            } else if (id_param == NULL && id->flags == ID_FLAG_IS_PARAM) {
                id_param = id;
            }
        }
    }

    // in functions, turn implicit globals into explicit globals
    // compute the index of each local
    scope->num_locals = 0;
    for (int i = 0; i < scope->id_info_len; i++) {
        id_info_t *id = &scope->id_info[i];
        if (scope->kind == SCOPE_CLASS && id->qst == MP_QSTR___class__) {
            // __class__ is not counted as a local; if it's used then it becomes a ID_INFO_KIND_CELL
            continue;
        }
        if (scope->kind >= SCOPE_FUNCTION && scope->kind <= SCOPE_GEN_EXPR && id->kind == ID_INFO_KIND_GLOBAL_IMPLICIT) {
            id->kind = ID_INFO_KIND_GLOBAL_EXPLICIT;
        }
        // params always count for 1 local, even if they are a cell
        if (id->kind == ID_INFO_KIND_LOCAL || (id->flags & ID_FLAG_IS_PARAM)) {
            id->local_num = scope->num_locals++;
        }
    }

    // compute the index of cell vars
    for (int i = 0; i < scope->id_info_len; i++) {
        id_info_t *id = &scope->id_info[i];
        // in Micro Python the cells come right after the fast locals
        // parameters are not counted here, since they remain at the start
        // of the locals, even if they are cell vars
        if (id->kind == ID_INFO_KIND_CELL && !(id->flags & ID_FLAG_IS_PARAM)) {
            id->local_num = scope->num_locals;
            scope->num_locals += 1;
        }
    }

    // compute the index of free vars
    // make sure they are in the order of the parent scope
    if (scope->parent != NULL) {
        int num_free = 0;
        for (int i = 0; i < scope->parent->id_info_len; i++) {
            id_info_t *id = &scope->parent->id_info[i];
            if (id->kind == ID_INFO_KIND_CELL || id->kind == ID_INFO_KIND_FREE) {
                for (int j = 0; j < scope->id_info_len; j++) {
                    id_info_t *id2 = &scope->id_info[j];
                    if (id2->kind == ID_INFO_KIND_FREE && id->qst == id2->qst) {
                        assert(!(id2->flags & ID_FLAG_IS_PARAM)); // free vars should not be params
                        // in Micro Python the frees come first, before the params
                        id2->local_num = num_free;
                        num_free += 1;
                    }
                }
            }
        }
        // in Micro Python shift all other locals after the free locals
        if (num_free > 0) {
            for (int i = 0; i < scope->id_info_len; i++) {
                id_info_t *id = &scope->id_info[i];
                if (id->kind != ID_INFO_KIND_FREE || (id->flags & ID_FLAG_IS_PARAM)) {
                    id->local_num += num_free;
                }
            }
            scope->num_pos_args += num_free; // free vars are counted as params for passing them into the function
            scope->num_locals += num_free;
        }
    }
}

#if !MICROPY_PERSISTENT_CODE_SAVE
STATIC
#endif
mp_raw_code_t *micropy_compile_to_raw_code(struct _mp_state_ctx_t *mp_state, mp_parse_tree_t *parse_tree, qstr source_file, uint emit_opt, bool is_repl) {
    // put compiler state on the stack, it's relatively small
    compiler_t comp_state = {0};
    compiler_t *comp = &comp_state;

    comp->source_file = source_file;
    comp->is_repl = is_repl;

    // create the module scope
    scope_t *module_scope = micropy_scope_new_and_link(mp_state, comp, SCOPE_MODULE, parse_tree->root, emit_opt);

    // create standard emitter; it's used at least for MP_PASS_SCOPE
    emit_t *emit_bc = micropy_emit_bc_new(mp_state);

    // compile pass 1
    comp->emit = emit_bc;
    #if MICROPY_EMIT_NATIVE
    comp->emit_method_table = &emit_bc_method_table;
    #endif
    uint max_num_labels = 0;
    for (scope_t *s = comp->scope_head; s != NULL && comp->compile_error == MP_OBJ_NULL; s = s->next) {
        if (false) {
#if MICROPY_EMIT_INLINE_THUMB
        } else if (s->emit_options == MP_EMIT_OPT_ASM_THUMB) {
            micropy_compile_scope_inline_asm(mp_state, comp, s, MP_PASS_SCOPE);
#endif
        } else {
            micropy_compile_scope(mp_state, comp, s, MP_PASS_SCOPE);
        }

        // update maximim number of labels needed
        if (comp->next_label > max_num_labels) {
            max_num_labels = comp->next_label;
        }
    }

    // compute some things related to scope and identifiers
    for (scope_t *s = comp->scope_head; s != NULL && comp->compile_error == MP_OBJ_NULL; s = s->next) {
        micropy_scope_compute_things(mp_state, s);
    }

    // set max number of labels now that it's calculated
    micropy_emit_bc_set_max_num_labels(mp_state, emit_bc, max_num_labels);

    // compile pass 2 and 3
#if MICROPY_EMIT_NATIVE
    emit_t *emit_native = NULL;
#endif
#if MICROPY_EMIT_INLINE_THUMB
    emit_inline_asm_t *emit_inline_thumb = NULL;
#endif
    for (scope_t *s = comp->scope_head; s != NULL && comp->compile_error == MP_OBJ_NULL; s = s->next) {
        if (false) {
            // dummy

#if MICROPY_EMIT_INLINE_THUMB
        } else if (s->emit_options == MP_EMIT_OPT_ASM_THUMB) {
            // inline assembly for thumb
            if (emit_inline_thumb == NULL) {
                emit_inline_thumb = micropy_emit_inline_thumb_new(mp_state, max_num_labels);
            }
            comp->emit = NULL;
            comp->emit_inline_asm = emit_inline_thumb;
            comp->emit_inline_asm_method_table = &emit_inline_thumb_method_table;
            micropy_compile_scope_inline_asm(mp_state, comp, s, MP_PASS_CODE_SIZE);
            if (comp->compile_error == MP_OBJ_NULL) {
                micropy_compile_scope_inline_asm(mp_state, comp, s, MP_PASS_EMIT);
            }
#endif

        } else {

            // choose the emit type

            switch (s->emit_options) {

#if MICROPY_EMIT_NATIVE
                case MP_EMIT_OPT_NATIVE_PYTHON:
                case MP_EMIT_OPT_VIPER:
#if MICROPY_EMIT_X64
                    if (emit_native == NULL) {
                        emit_native = micropy_emit_native_x64_new(mp_state, &comp->compile_error, max_num_labels);
                    }
                    comp->emit_method_table = &emit_native_x64_method_table;
#elif MICROPY_EMIT_X86
                    if (emit_native == NULL) {
                        emit_native = micropy_emit_native_x86_new(mp_state, &comp->compile_error, max_num_labels);
                    }
                    comp->emit_method_table = &emit_native_x86_method_table;
#elif MICROPY_EMIT_THUMB
                    if (emit_native == NULL) {
                        emit_native = micropy_emit_native_thumb_new(mp_state, &comp->compile_error, max_num_labels);
                    }
                    comp->emit_method_table = &emit_native_thumb_method_table;
#elif MICROPY_EMIT_ARM
                    if (emit_native == NULL) {
                        emit_native = micropy_emit_native_arm_new(mp_state, &comp->compile_error, max_num_labels);
                    }
                    comp->emit_method_table = &emit_native_arm_method_table;
#endif
                    comp->emit = emit_native;
                    EMIT_ARG(set_native_type, MP_EMIT_NATIVE_TYPE_ENABLE, s->emit_options == MP_EMIT_OPT_VIPER, 0);
                    break;
#endif // MICROPY_EMIT_NATIVE

                default:
                    comp->emit = emit_bc;
                    #if MICROPY_EMIT_NATIVE
                    comp->emit_method_table = &emit_bc_method_table;
                    #endif
                    break;
            }

            // need a pass to compute stack size
            micropy_compile_scope(mp_state, comp, s, MP_PASS_STACK_SIZE);

            // second last pass: compute code size
            if (comp->compile_error == MP_OBJ_NULL) {
                micropy_compile_scope(mp_state, comp, s, MP_PASS_CODE_SIZE);
            }

            // final pass: emit code
            if (comp->compile_error == MP_OBJ_NULL) {
                micropy_compile_scope(mp_state, comp, s, MP_PASS_EMIT);
            }
        }
    }

    if (comp->compile_error != MP_OBJ_NULL) {
        // if there is no line number for the error then use the line
        // number for the start of this scope
        micropy_compile_error_set_line(mp_state, comp, comp->scope_cur->pn);
        // add a traceback to the exception using relevant source info
        micropy_obj_exception_add_traceback(mp_state, comp->compile_error, comp->source_file,
            comp->compile_error_line, comp->scope_cur->simple_name);
    }

    // free the emitters

    micropy_emit_bc_free(mp_state, emit_bc);
#if MICROPY_EMIT_NATIVE
    if (emit_native != NULL) {
#if MICROPY_EMIT_X64
        micropy_emit_native_x64_free(mp_state, emit_native);
#elif MICROPY_EMIT_X86
        micropy_emit_native_x86_free(mp_state, emit_native);
#elif MICROPY_EMIT_THUMB
        micropy_emit_native_thumb_free(mp_state, emit_native);
#elif MICROPY_EMIT_ARM
        micropy_emit_native_arm_free(mp_state, emit_native);
#endif
    }
#endif
#if MICROPY_EMIT_INLINE_THUMB
    if (emit_inline_thumb != NULL) {
        micropy_emit_inline_thumb_free(mp_state, emit_inline_thumb);
    }
#endif

    // free the parse tree
    micropy_parse_tree_clear(mp_state, parse_tree);

    // free the scopes
    mp_raw_code_t *outer_raw_code = module_scope->raw_code;
    for (scope_t *s = module_scope; s;) {
        scope_t *next = s->next;
        micropy_scope_free(mp_state, s);
        s = next;
    }

    if (comp->compile_error != MP_OBJ_NULL) {
        micropy_nlr_raise(mp_state, comp->compile_error);
    } else {
        return outer_raw_code;
    }
}

mp_obj_t micropy_compile(struct _mp_state_ctx_t *mp_state, mp_parse_tree_t *parse_tree, qstr source_file, uint emit_opt, bool is_repl) {
    mp_raw_code_t *rc = micropy_compile_to_raw_code(mp_state, parse_tree, source_file, emit_opt, is_repl);
    // return function that executes the outer module
    return micropy_make_function_from_raw_code(mp_state, rc, MP_OBJ_NULL, MP_OBJ_NULL);
}

#endif // MICROPY_ENABLE_COMPILER
/*
 * This file is part of the Micro Python project, http://micropython.org/
 *
 * The MIT License (MIT)
 *
 * Copyright (c) 2013, 2014 Damien P. George
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

//#include "py/mpconfig.h"
#if MICROPY_FLOAT_IMPL != MICROPY_FLOAT_IMPL_NONE

#include <assert.h>
struct _mp_state_ctx_t;
#include <stdlib.h>
#include <stdint.h>
//#include "py/formatfloat.h"

/***********************************************************************

  Routine for converting a arbitrary floating
  point number into a string.

  The code in this funcion was inspired from Fred Bayer's pdouble.c.
  Since pdouble.c was released as Public Domain, I'm releasing this
  code as public domain as well.

  The original code can be found in https://github.com/dhylands/format-float

  Dave Hylands

***********************************************************************/

#if MICROPY_FLOAT_IMPL == MICROPY_FLOAT_IMPL_FLOAT
// 1 sign bit, 8 exponent bits, and 23 mantissa bits.
// exponent values 0 and 255 are reserved, exponent can be 1 to 254.
// exponent is stored with a bias of 127.
// The min and max floats are on the order of 1x10^37 and 1x10^-37

#define FPTYPE float
#define FPCONST(x) x##F
#define FPROUND_TO_ONE 0.9999995F
#define FPDECEXP 32
#define FPMIN_BUF_SIZE 6 // +9e+99

#define FLT_SIGN_MASK   0x80000000
#define FLT_EXP_MASK    0x7F800000
#define FLT_MAN_MASK    0x007FFFFF

union floatbits {
    float f;
    uint32_t u;
};
static inline int micropy_fp_signbit(struct _mp_state_ctx_t *mp_state, float x) { union floatbits fb = {x}; return fb.u & FLT_SIGN_MASK; }
static inline int micropy_fp_isspecial(struct _mp_state_ctx_t *mp_state, float x) { union floatbits fb = {x}; return (fb.u & FLT_EXP_MASK) == FLT_EXP_MASK; }
static inline int micropy_fp_isinf(struct _mp_state_ctx_t *mp_state, float x) { union floatbits fb = {x}; return (fb.u & FLT_MAN_MASK) == 0; }
static inline int micropy_fp_iszero(struct _mp_state_ctx_t *mp_state, float x) { union floatbits fb = {x}; return fb.u == 0; }
static inline int micropy_fp_isless1(struct _mp_state_ctx_t *mp_state, float x) { union floatbits fb = {x}; return fb.u < 0x3f800000; }
// Assumes both fp_isspecial() and fp_isinf() were applied before
#define micropy_fp_isnan(mp_state, x) 1

#elif MICROPY_FLOAT_IMPL == MICROPY_FLOAT_IMPL_DOUBLE

#define FPTYPE double
#define FPCONST(x) x
#define FPROUND_TO_ONE 0.999999999995
#define FPDECEXP 256
#define FPMIN_BUF_SIZE 7 // +9e+199
#include <math.h>
#define micropy_fp_signbit(mp_state, x) signbit(x)
#define micropy_fp_isspecial(mp_state, x) 1
#define micropy_fp_isnan(mp_state, x) isnan(x)
#define micropy_fp_isinf(mp_state, x) isinf(x)
#define micropy_fp_iszero(mp_state, x) (x == 0)
#define micropy_fp_isless1(mp_state, x) (x < 1.0)

#endif

static const FPTYPE g_pos_pow[] = {
    #if FPDECEXP > 32
    1e256, 1e128, 1e64,
    #endif
    1e32, 1e16, 1e8, 1e4, 1e2, 1e1
};
static const FPTYPE g_neg_pow[] = {
    #if FPDECEXP > 32
    1e-256, 1e-128, 1e-64,
    #endif
    1e-32, 1e-16, 1e-8, 1e-4, 1e-2, 1e-1
};

int micropy_format_float(struct _mp_state_ctx_t *mp_state, FPTYPE f, char *buf, size_t buf_size, char fmt, int prec, char sign) {

    char *s = buf;

    if (buf_size <= FPMIN_BUF_SIZE) {
        // FPMIN_BUF_SIZE is the minimum size needed to store any FP number.
        // If the buffer does not have enough room for this (plus null terminator)
        // then don't try to format the float.

        if (buf_size >= 2) {
            *s++ = '?';
        }
        if (buf_size >= 1) {
            *s++ = '\0';
        }
        return buf_size >= 2;
    }
    if (micropy_fp_signbit(mp_state, f)) {
        *s++ = '-';
        f = -f;
    } else {
        if (sign) {
            *s++ = sign;
        }
    }

    // buf_remaining contains bytes available for digits and exponent.
    // It is buf_size minus room for the sign and null byte.
    int buf_remaining = buf_size - 1 - (s - buf);

    if (micropy_fp_isspecial(mp_state, f)) {
        char uc = fmt & 0x20;
        if (micropy_fp_isinf(mp_state, f)) {
            *s++ = 'I' ^ uc;
            *s++ = 'N' ^ uc;
            *s++ = 'F' ^ uc;
            goto ret;
        } else if (micropy_fp_isnan(mp_state, f)) {
            *s++ = 'N' ^ uc;
            *s++ = 'A' ^ uc;
            *s++ = 'N' ^ uc;
        ret:
            *s = '\0';
            return s - buf;
        }
    }

    if (prec < 0) {
        prec = 6;
    }
    char e_char = 'E' | (fmt & 0x20);   // e_char will match case of fmt
    fmt |= 0x20; // Force fmt to be lowercase
    char org_fmt = fmt;
    if (fmt == 'g' && prec == 0) {
        prec = 1;
    }
    int e, e1; 
    int dec = 0;
    char e_sign = '\0';
    int num_digits = 0;
    const FPTYPE *pos_pow = g_pos_pow;
    const FPTYPE *neg_pow = g_neg_pow;

    if (micropy_fp_iszero(mp_state, f)) {
        e = 0;
        if (fmt == 'f') {
            // Truncate precision to prevent buffer overflow
            if (prec + 2 > buf_remaining) {
                prec = buf_remaining - 2;
            }
            num_digits = prec + 1;
        } else {
            // Truncate precision to prevent buffer overflow
            if (prec + 6 > buf_remaining) {
                prec = buf_remaining - 6;
            }
            if (fmt == 'e') {
                e_sign = '+';
            }
        }
    } else if (micropy_fp_isless1(mp_state, f)) {
        // We need to figure out what an integer digit will be used
        // in case 'f' is used (or we revert other format to it below).
        // As we just tested number to be <1, this is obviously 0,
        // but we can round it up to 1 below.
        char first_dig = '0';
        if (f >= FPROUND_TO_ONE) {
            first_dig = '1';
        }

        // Build negative exponent
        for (e = 0, e1 = FPDECEXP; e1; e1 >>= 1, pos_pow++, neg_pow++) {
            if (*neg_pow > f) {
                e += e1;
                f *= *pos_pow;
            }
        }
        char e_sign_char = '-';
        if (micropy_fp_isless1(mp_state, f) && f >= FPROUND_TO_ONE) {
            f = FPCONST(1.0);
            if (e == 0) {
                e_sign_char = '+';
            }
        } else if (micropy_fp_isless1(mp_state, f)) {
            e++; 
            f *= FPCONST(10.0);
        }

        // If the user specified 'g' format, and e is <= 4, then we'll switch
        // to the fixed format ('f')

        if (fmt == 'f' || (fmt == 'g' && e <= 4)) {
            fmt = 'f';
            dec = -1;
            *s++ = first_dig;

            if (org_fmt == 'g') {
                prec += (e - 1);
            }

            // truncate precision to prevent buffer overflow
            if (prec + 2 > buf_remaining) {
                prec = buf_remaining - 2;
            }

            num_digits = prec;
            if (num_digits) {
                *s++ = '.'; 
                while (--e && num_digits) {
                    *s++ = '0';
                    num_digits--;
                }
            }
        } else {
            // For e & g formats, we'll be printing the exponent, so set the
            // sign.
            e_sign = e_sign_char;
            dec = 0;

            if (prec > (buf_remaining - FPMIN_BUF_SIZE)) {
                prec = buf_remaining - FPMIN_BUF_SIZE;
                if (fmt == 'g') {
                    prec++;
                }
            }
        }
    } else {
        // Build positive exponent
        for (e = 0, e1 = FPDECEXP; e1; e1 >>= 1, pos_pow++, neg_pow++) {
            if (*pos_pow <= f) {
                e += e1;
                f *= *neg_pow;
            }
        }

        // It can be that f was right on the edge of an entry in pos_pow needs to be reduced
        if (f >= FPCONST(10.0)) {
            e += 1;
            f *= FPCONST(0.1);
        }

        // If the user specified fixed format (fmt == 'f') and e makes the 
        // number too big to fit into the available buffer, then we'll
        // switch to the 'e' format.

        if (fmt == 'f') {
            if (e >= buf_remaining) {
                fmt = 'e';
            } else if ((e + prec + 2) > buf_remaining) {
                prec = buf_remaining - e - 2;
                if (prec < 0) {
                    // This means no decimal point, so we can add one back
                    // for the decimal.
                    prec++;
                }
            }
        }
        if (fmt == 'e' && prec > (buf_remaining - FPMIN_BUF_SIZE)) {
            prec = buf_remaining - FPMIN_BUF_SIZE;
        }
        if (fmt == 'g'){
            // Truncate precision to prevent buffer overflow
            if (prec + (FPMIN_BUF_SIZE - 1) > buf_remaining) {
                prec = buf_remaining - (FPMIN_BUF_SIZE - 1);
            }
        }
        // If the user specified 'g' format, and e is < prec, then we'll switch
        // to the fixed format.

        if (fmt == 'g' && e < prec) {
            fmt = 'f';
            prec -= (e + 1);
        }
        if (fmt == 'f') {
            dec = e;
            num_digits = prec + e + 1;
        } else {
            e_sign = '+';
        }
    }
    if (prec < 0) {
        // This can happen when the prec is trimmed to prevent buffer overflow
        prec = 0;
    }

    // We now have num.f as a floating point number between >= 1 and < 10
    // (or equal to zero), and e contains the absolute value of the power of
    // 10 exponent. and (dec + 1) == the number of dgits before the decimal.

    // For e, prec is # digits after the decimal
    // For f, prec is # digits after the decimal
    // For g, prec is the max number of significant digits
    //
    // For e & g there will be a single digit before the decimal
    // for f there will be e digits before the decimal

    if (fmt == 'e') {
        num_digits = prec + 1;
    } else if (fmt == 'g') {
        if (prec == 0) {
            prec = 1;
        }
        num_digits = prec; 
    }

    // Print the digits of the mantissa
    for (int i = 0; i < num_digits; ++i, --dec) {
        int32_t d = f;
        *s++ = '0' + d;
        if (dec == 0 && prec > 0) {
            *s++ = '.';
        }
        f -= (FPTYPE)d;
        f *= FPCONST(10.0);
    }

    // Round
    // If we print non-exponential format (i.e. 'f'), but a digit we're going
    // to round by (e) is too far away, then there's nothing to round.
    if ((org_fmt != 'f' || e <= 1) && f >= FPCONST(5.0)) {
        char *rs = s;
        rs--;
        while (1) {
            if (*rs == '.') {
                rs--;
                continue;
            }
            if (*rs < '0' || *rs > '9') {
                // + or -
                rs++; // So we sit on the digit to the right of the sign
                break;
            }
            if (*rs < '9') {
                (*rs)++;
                break;
            }
            *rs = '0';
            if (rs == buf) {
                break;
            }
            rs--; 
        }
        if (*rs == '0') {
            // We need to insert a 1
            if (rs[1] == '.' && fmt != 'f') {
                // We're going to round 9.99 to 10.00
                // Move the decimal point
                rs[0] = '.';
                rs[1] = '0';
                if (e_sign == '-') {
                    e--;
                } else {
                    e++; 
                }
            }
            s++;
            char *ss = s; 
            while (ss > rs) {
                *ss = ss[-1];
                ss--;
            }
            *rs = '1';
        }
        if (micropy_fp_isless1(mp_state, f) && fmt == 'f') {
            // We rounded up to 1.0
            prec--;
        }
    }

    // verify that we did not overrun the input buffer so far
    assert((size_t)(s + 1 - buf) <= buf_size);

    if (org_fmt == 'g' && prec > 0) {
        // Remove trailing zeros and a trailing decimal point
        while (s[-1] == '0') {
            s--;
        }
        if (s[-1] == '.') {
            s--;
        }
    }
    // Append the exponent
    if (e_sign) {
        *s++ = e_char;
        *s++ = e_sign;
        if (FPMIN_BUF_SIZE == 7 && e >= 100) {
            *s++ = '0' + (e / 100);
        }
        *s++ = '0' + ((e / 10) % 10);
        *s++ = '0' + (e % 10);
    }
    *s = '\0';

    // verify that we did not overrun the input buffer
    assert((size_t)(s + 1 - buf) <= buf_size);

    return s - buf;
}

#endif // MICROPY_FLOAT_IMPL != MICROPY_FLOAT_IMPL_NONE
/*
 * This file is part of the Micro Python project, http://micropython.org/
 *
 * The MIT License (MIT)
 *
 * Copyright (c) 2013, 2014 Damien P. George
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

//#include "py/mpconfig.h"
//#include "py/misc.h"
//#include "py/parsenumbase.h"

// find real radix base, and strip preceding '0x', '0o' and '0b'
// puts base in *base, and returns number of bytes to skip the prefix
size_t micropy_parse_num_base(struct _mp_state_ctx_t *mp_state, const char *str, size_t len, int *base) {
    const byte *p = (const byte*)str;
    if (len <= 1) {
        goto no_prefix;
    }
    unichar c = *(p++);
    if ((*base == 0 || *base == 16) && c == '0') {
        c = *(p++);
        if ((c | 32) == 'x') {
            *base = 16;
        } else if (*base == 0 && (c | 32) == 'o') {
            *base = 8;
        } else if (*base == 0 && (c | 32) == 'b') {
            *base = 2;
        } else {
            if (*base == 0) {
                *base = 10;
            }
            p -= 2;
        }
    } else if (*base == 8 && c == '0') {
        c = *(p++);
        if ((c | 32) != 'o') {
            p -= 2;
        }
    } else if (*base == 2 && c == '0') {
        c = *(p++);
        if ((c | 32) != 'b') {
            p -= 2;
        }
    } else {
        p--;
    no_prefix:
        if (*base == 0) {
            *base = 10;
        }
    }
    return p - (const byte*)str;
}
/*
 * This file is part of the Micro Python project, http://micropython.org/
 *
 * The MIT License (MIT)
 *
 * Copyright (c) 2013, 2014 Damien P. George
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

#include <stdbool.h>
#include <stdlib.h>

//#include "py/nlr.h"
//#include "py/parsenumbase.h"
//#include "py/parsenum.h"
//#include "py/smallint.h"

#if MICROPY_PY_BUILTINS_FLOAT
#include <math.h>
#endif

STATIC NORETURN void micropy_raise_exc(struct _mp_state_ctx_t *mp_state, mp_obj_t exc, mp_lexer_t *lex) {
    // if lex!=NULL then the parser called us and we need to convert the
    // exception's type from ValueError to SyntaxError and add traceback info
    if (lex != NULL) {
        ((mp_obj_base_t*)MP_OBJ_TO_PTR(exc))->type = &mp_type_SyntaxError;
        micropy_obj_exception_add_traceback(mp_state, exc, lex->source_name, lex->tok_line, MP_QSTR_NULL);
    }
    micropy_nlr_raise(mp_state, exc);
}

mp_obj_t micropy_parse_num_integer(struct _mp_state_ctx_t *mp_state, const char *restrict str_, size_t len, int base, mp_lexer_t *lex) {
    const byte *restrict str = (const byte *)str_;
    const byte *restrict top = str + len;
    bool neg = false;
    mp_obj_t ret_val;

    // check radix base
    if ((base != 0 && base < 2) || base > 36) {
        // this won't be reached if lex!=NULL
        micropy_nlr_raise(mp_state, micropy_obj_new_exception_msg(mp_state, &mp_type_ValueError, "int() arg 2 must be >= 2 and <= 36"));
    }

    // skip leading space
    for (; str < top && unichar_isspace(*str); str++) {
    }

    // parse optional sign
    if (str < top) {
        if (*str == '+') {
            str++;
        } else if (*str == '-') {
            str++;
            neg = true;
        }
    }

    // parse optional base prefix
    str += micropy_parse_num_base(mp_state, (const char*)str, top - str, &base);

    // string should be an integer number
    mp_int_t int_val = 0;
    const byte *restrict str_val_start = str;
    for (; str < top; str++) {
        // get next digit as a value
        mp_uint_t dig = *str;
        if (unichar_isdigit(dig) && (int)dig - '0' < base) {
            // 0-9 digit
            dig = dig - '0';
        } else if (base == 16) {
            dig |= 0x20;
            if ('a' <= dig && dig <= 'f') {
                // a-f hex digit
                dig = dig - 'a' + 10;
            } else {
                // unknown character
                break;
            }
        } else {
            // unknown character
            break;
        }

        // add next digi and check for overflow
        if (micropy_small_int_mul_overflow(mp_state, int_val, base)) {
            goto overflow;
        }
        int_val = int_val * base + dig;
        if (!MP_SMALL_INT_FITS(int_val)) {
            goto overflow;
        }
    }

    // negate value if needed
    if (neg) {
        int_val = -int_val;
    }

    // create the small int
    ret_val = MP_OBJ_NEW_SMALL_INT(int_val);

have_ret_val:
    // check we parsed something
    if (str == str_val_start) {
        goto value_error;
    }

    // skip trailing space
    for (; str < top && unichar_isspace(*str); str++) {
    }

    // check we reached the end of the string
    if (str != top) {
        goto value_error;
    }

    // return the object
    return ret_val;

overflow:
    // reparse using long int
    {
        const char *s2 = (const char*)str_val_start;
        ret_val = micropy_obj_new_int_from_str_len(mp_state, &s2, top - str_val_start, neg, base);
        str = (const byte*)s2;
        goto have_ret_val;
    }

value_error:
    if (MICROPY_ERROR_REPORTING == MICROPY_ERROR_REPORTING_TERSE) {
        mp_obj_t exc = micropy_obj_new_exception_msg(mp_state, &mp_type_ValueError,
            "invalid syntax for integer");
        micropy_raise_exc(mp_state, exc, lex);
    } else if (MICROPY_ERROR_REPORTING == MICROPY_ERROR_REPORTING_NORMAL) {
        mp_obj_t exc = micropy_obj_new_exception_msg_varg(mp_state, &mp_type_ValueError,
            "invalid syntax for integer with base %d", base);
        micropy_raise_exc(mp_state, exc, lex);
    } else {
        vstr_t vstr;
        mp_print_t print;
        micropy_vstr_init_print(mp_state, &vstr, 50, &print);
        micropy_printf(mp_state, &print, "invalid syntax for integer with base %d: ", base);
        micropy_str_print_quoted(mp_state, &print, str_val_start, top - str_val_start, true);
        mp_obj_t exc = micropy_obj_new_exception_arg1(mp_state, &mp_type_ValueError,
            micropy_obj_new_str_from_vstr(mp_state, &mp_type_str, &vstr));
        micropy_raise_exc(mp_state, exc, lex);
    }
}

typedef enum {
    PARSE_DEC_IN_INTG,
    PARSE_DEC_IN_FRAC,
    PARSE_DEC_IN_EXP,
} parse_dec_in_t;

mp_obj_t micropy_parse_num_decimal(struct _mp_state_ctx_t *mp_state, const char *str, size_t len, bool allow_imag, bool force_complex, mp_lexer_t *lex) {
#if MICROPY_PY_BUILTINS_FLOAT
    const char *top = str + len;
    mp_float_t dec_val = 0;
    bool dec_neg = false;
    bool imag = false;

    // skip leading space
    for (; str < top && unichar_isspace(*str); str++) {
    }

    // parse optional sign
    if (str < top) {
        if (*str == '+') {
            str++;
        } else if (*str == '-') {
            str++;
            dec_neg = true;
        }
    }

    const char *str_val_start = str;

    // determine what the string is
    if (str < top && (str[0] | 0x20) == 'i') {
        // string starts with 'i', should be 'inf' or 'infinity' (case insensitive)
        if (str + 2 < top && (str[1] | 0x20) == 'n' && (str[2] | 0x20) == 'f') {
            // inf
            str += 3;
            dec_val = INFINITY;
            if (str + 4 < top && (str[0] | 0x20) == 'i' && (str[1] | 0x20) == 'n' && (str[2] | 0x20) == 'i' && (str[3] | 0x20) == 't' && (str[4] | 0x20) == 'y') {
                // infinity
                str += 5;
            }
        }
    } else if (str < top && (str[0] | 0x20) == 'n') {
        // string starts with 'n', should be 'nan' (case insensitive)
        if (str + 2 < top && (str[1] | 0x20) == 'a' && (str[2] | 0x20) == 'n') {
            // NaN
            str += 3;
            dec_val = MICROPY_FLOAT_C_FUN(nan)("");
        }
    } else {
        // string should be a decimal number
        parse_dec_in_t in = PARSE_DEC_IN_INTG;
        bool exp_neg = false;
        mp_float_t frac_mult = 0.1;
        mp_int_t exp_val = 0;
        while (str < top) {
            mp_uint_t dig = *str++;
            if ('0' <= dig && dig <= '9') {
                dig -= '0';
                if (in == PARSE_DEC_IN_EXP) {
                    exp_val = 10 * exp_val + dig;
                } else {
                    if (in == PARSE_DEC_IN_FRAC) {
                        dec_val += dig * frac_mult;
                        frac_mult *= 0.1;
                    } else {
                        dec_val = 10 * dec_val + dig;
                    }
                }
            } else if (in == PARSE_DEC_IN_INTG && dig == '.') {
                in = PARSE_DEC_IN_FRAC;
            } else if (in != PARSE_DEC_IN_EXP && ((dig | 0x20) == 'e')) {
                in = PARSE_DEC_IN_EXP;
                if (str < top) {
                    if (str[0] == '+') {
                        str++;
                    } else if (str[0] == '-') {
                        str++;
                        exp_neg = true;
                    }
                }
                if (str == top) {
                    goto value_error;
                }
            } else if (allow_imag && (dig | 0x20) == 'j') {
                imag = true;
                break;
            } else {
                // unknown character
                str--;
                break;
            }
        }

        // work out the exponent
        if (exp_neg) {
            exp_val = -exp_val;
        }

        // apply the exponent
        dec_val *= MICROPY_FLOAT_C_FUN(pow)(10, exp_val);
    }

    // negate value if needed
    if (dec_neg) {
        dec_val = -dec_val;
    }

    // check we parsed something
    if (str == str_val_start) {
        goto value_error;
    }

    // skip trailing space
    for (; str < top && unichar_isspace(*str); str++) {
    }

    // check we reached the end of the string
    if (str != top) {
        goto value_error;
    }

    // return the object
#if MICROPY_PY_BUILTINS_COMPLEX
    if (imag) {
        return micropy_obj_new_complex(mp_state, 0, dec_val);
    } else if (force_complex) {
        return micropy_obj_new_complex(mp_state, dec_val, 0);
#else
    if (imag || force_complex) {
        micropy_raise_exc(mp_state, micropy_obj_new_exception_msg(mp_state, &mp_type_ValueError, "complex values not supported"), lex);
#endif
    } else {
        return micropy_obj_new_float(mp_state, dec_val);
    }

value_error:
    micropy_raise_exc(mp_state, micropy_obj_new_exception_msg(mp_state, &mp_type_ValueError, "invalid syntax for number"), lex);

#else
    micropy_raise_exc(mp_state, micropy_obj_new_exception_msg(mp_state, &mp_type_ValueError, "decimal numbers not supported"), lex);
#endif
}
/*
 * This file is part of the Micro Python project, http://micropython.org/
 *
 * The MIT License (MIT)
 *
 * Copyright (c) 2013, 2014 Damien P. George
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

// This code glues the code emitters to the runtime.

#include <stdint.h>
#include <stdio.h>
#include <string.h>
#include <assert.h>

//#include "py/emitglue.h"
//#include "py/runtime0.h"
//#include "py/bc.h"

#if 0 // print debugging info
#define DEBUG_PRINT (1)
#define WRITE_CODE (1)
#define DEBUG_printf DEBUG_printf
#define DEBUG_OP_printf(...) DEBUG_printf(__VA_ARGS__)
#else // don't print debugging info
#define DEBUG_printf(...) (void)0
#define DEBUG_OP_printf(...) (void)0
#endif

#if MICROPY_DEBUG_PRINTERS
mp_uint_t mp_verbose_flag = 0;
#endif

mp_raw_code_t *micropy_emit_glue_new_raw_code(struct _mp_state_ctx_t *mp_state) {
    mp_raw_code_t *rc = micropy_m_new0(mp_state, mp_raw_code_t, 1);
    rc->kind = MP_CODE_RESERVED;
    return rc;
}

void micropy_emit_glue_assign_bytecode(struct _mp_state_ctx_t *mp_state, mp_raw_code_t *rc, const byte *code, mp_uint_t len,
    const mp_uint_t *const_table,
    #if MICROPY_PERSISTENT_CODE_SAVE
    uint16_t n_obj, uint16_t n_raw_code,
    #endif
    mp_uint_t scope_flags) {

    rc->kind = MP_CODE_BYTECODE;
    rc->scope_flags = scope_flags;
    rc->data.u_byte.bytecode = code;
    rc->data.u_byte.const_table = const_table;
    #if MICROPY_PERSISTENT_CODE_SAVE
    rc->data.u_byte.bc_len = len;
    rc->data.u_byte.n_obj = n_obj;
    rc->data.u_byte.n_raw_code = n_raw_code;
    #endif

#ifdef DEBUG_PRINT
    DEBUG_printf("assign byte code: code=%p len=" UINT_FMT " flags=%x\n", code, len, (uint)scope_flags);
#endif
#if MICROPY_DEBUG_PRINTERS
    if (mp_verbose_flag >= 2) {
        micropy_bytecode_print(mp_state, rc, code, len, const_table);
    }
#endif
}

#if MICROPY_EMIT_NATIVE || MICROPY_EMIT_INLINE_THUMB
void micropy_emit_glue_assign_native(struct _mp_state_ctx_t *mp_state, mp_raw_code_t *rc, mp_raw_code_kind_t kind, void *fun_data, mp_uint_t fun_len, const mp_uint_t *const_table, mp_uint_t n_pos_args, mp_uint_t scope_flags, mp_uint_t type_sig) {
    assert(kind == MP_CODE_NATIVE_PY || kind == MP_CODE_NATIVE_VIPER || kind == MP_CODE_NATIVE_ASM);
    rc->kind = kind;
    rc->scope_flags = scope_flags;
    rc->n_pos_args = n_pos_args;
    rc->data.u_native.fun_data = fun_data;
    rc->data.u_native.const_table = const_table;
    rc->data.u_native.type_sig = type_sig;

#ifdef DEBUG_PRINT
    DEBUG_printf("assign native: kind=%d fun=%p len=" UINT_FMT " n_pos_args=" UINT_FMT " flags=%x\n", kind, fun_data, fun_len, n_pos_args, (uint)scope_flags);
    for (mp_uint_t i = 0; i < fun_len; i++) {
        if (i > 0 && i % 16 == 0) {
            DEBUG_printf("\n");
        }
        DEBUG_printf(" %02x", ((byte*)fun_data)[i]);
    }
    DEBUG_printf("\n");

#ifdef WRITE_CODE
    FILE *fp_write_code = micropy_fopen(mp_state, "out-code", "wb");
    micropy_fwrite(mp_state, fun_data, fun_len, 1, fp_write_code);
    micropy_fclose(mp_state, fp_write_code);
#endif
#else
    (void)fun_len;
#endif
}
#endif

mp_obj_t micropy_make_function_from_raw_code(struct _mp_state_ctx_t *mp_state, const mp_raw_code_t *rc, mp_obj_t def_args, mp_obj_t def_kw_args) {
    DEBUG_OP_printf("make_function_from_raw_code %p\n", rc);
    assert(rc != NULL);

    // def_args must be MP_OBJ_NULL or a tuple
    assert(def_args == MP_OBJ_NULL || MP_OBJ_IS_TYPE(def_args, &mp_type_tuple));

    // def_kw_args must be MP_OBJ_NULL or a dict
    assert(def_kw_args == MP_OBJ_NULL || MP_OBJ_IS_TYPE(def_kw_args, &mp_type_dict));

    // make the function, depending on the raw code kind
    mp_obj_t fun;
    switch (rc->kind) {
        case MP_CODE_BYTECODE:
        no_other_choice:
            fun = micropy_obj_new_fun_bc(mp_state, def_args, def_kw_args, rc->data.u_byte.bytecode, rc->data.u_byte.const_table);
            break;
        #if MICROPY_EMIT_NATIVE
        case MP_CODE_NATIVE_PY:
            fun = micropy_obj_new_fun_native(mp_state, def_args, def_kw_args, rc->data.u_native.fun_data, rc->data.u_native.const_table);
            break;
        case MP_CODE_NATIVE_VIPER:
            fun = micropy_obj_new_fun_viper(mp_state, rc->n_pos_args, rc->data.u_native.fun_data, rc->data.u_native.type_sig);
            break;
        #endif
        #if MICROPY_EMIT_INLINE_THUMB
        case MP_CODE_NATIVE_ASM:
            fun = micropy_obj_new_fun_asm(mp_state, rc->n_pos_args, rc->data.u_native.fun_data, rc->data.u_native.type_sig);
            break;
        #endif
        default:
            // raw code was never set (this should not happen)
            assert(0);
            goto no_other_choice; // to help flow control analysis
    }

    // check for generator functions and if so wrap in generator object
    if ((rc->scope_flags & MP_SCOPE_FLAG_GENERATOR) != 0) {
        fun = micropy_obj_new_gen_wrap(mp_state, fun);
    }

    return fun;
}

mp_obj_t micropy_make_closure_from_raw_code(struct _mp_state_ctx_t *mp_state, const mp_raw_code_t *rc, mp_uint_t n_closed_over, const mp_obj_t *args) {
    DEBUG_OP_printf("make_closure_from_raw_code %p " UINT_FMT " %p\n", rc, n_closed_over, args);
    // make function object
    mp_obj_t ffun;
    if (n_closed_over & 0x100) {
        // default positional and keyword args given
        ffun = micropy_make_function_from_raw_code(mp_state, rc, args[0], args[1]);
    } else {
        // default positional and keyword args not given
        ffun = micropy_make_function_from_raw_code(mp_state, rc, MP_OBJ_NULL, MP_OBJ_NULL);
    }
    // wrap function in closure object
    return micropy_obj_new_closure(mp_state, ffun, n_closed_over & 0xff, args + ((n_closed_over >> 7) & 2));
}

#if MICROPY_PERSISTENT_CODE_LOAD || MICROPY_PERSISTENT_CODE_SAVE

//#include "py/smallint.h"

// The feature flags byte encodes the compile-time config options that
// affect the generate bytecode.
#define MPY_FEATURE_FLAGS ( \
    ((MICROPY_OPT_CACHE_MAP_LOOKUP_IN_BYTECODE) << 0) \
    | ((MICROPY_PY_BUILTINS_STR_UNICODE) << 1) \
    )
// This is a version of the flags that can be configured at runtime.
#define MPY_FEATURE_FLAGS_DYNAMIC ( \
    ((MICROPY_OPT_CACHE_MAP_LOOKUP_IN_BYTECODE_DYNAMIC) << 0) \
    | ((MICROPY_PY_BUILTINS_STR_UNICODE_DYNAMIC) << 1) \
    )

#if MICROPY_PERSISTENT_CODE_LOAD || (MICROPY_PERSISTENT_CODE_SAVE && !MICROPY_DYNAMIC_COMPILER)
// The bytecode will depend on the number of bits in a small-int, and
// this function computes that (could make it a fixed constant, but it
// would need to be defined in mpconfigport.h).
STATIC int micropy_small_int_bits(struct _mp_state_ctx_t *mp_state) {
    mp_int_t i = MP_SMALL_INT_MAX;
    int n = 1;
    while (i != 0) {
        i >>= 1;
        ++n;
    }
    return n;
}
#endif

typedef struct _bytecode_prelude_t {
    uint n_state;
    uint n_exc_stack;
    uint scope_flags;
    uint n_pos_args;
    uint n_kwonly_args;
    uint n_def_pos_args;
    uint code_info_size;
} bytecode_prelude_t;

// ip will point to start of opcodes
// ip2 will point to simple_name, source_file qstrs
STATIC void micropy_extract_prelude(struct _mp_state_ctx_t *mp_state, const byte **ip, const byte **ip2, bytecode_prelude_t *prelude) {
    prelude->n_state = micropy_decode_uint(mp_state, ip);
    prelude->n_exc_stack = micropy_decode_uint(mp_state, ip);
    prelude->scope_flags = *(*ip)++;
    prelude->n_pos_args = *(*ip)++;
    prelude->n_kwonly_args = *(*ip)++;
    prelude->n_def_pos_args = *(*ip)++;
    *ip2 = *ip;
    prelude->code_info_size = micropy_decode_uint(mp_state, ip2);
    *ip += prelude->code_info_size;
    while (*(*ip)++ != 255) {
    }
}

#endif // MICROPY_PERSISTENT_CODE_LOAD || MICROPY_PERSISTENT_CODE_SAVE

#if MICROPY_PERSISTENT_CODE_LOAD

//#include "py/parsenum.h"
//#include "py/bc0.h"

STATIC int micropy_read_byte(struct _mp_state_ctx_t *mp_state, mp_reader_t *reader) {
    return reader->read_byte(reader->data);
}

STATIC void micropy_read_bytes(struct _mp_state_ctx_t *mp_state, mp_reader_t *reader, byte *buf, size_t len) {
    while (len-- > 0) {
        *buf++ = reader->read_byte(reader->data);
    }
}

STATIC mp_uint_t micropy_read_uint(struct _mp_state_ctx_t *mp_state, mp_reader_t *reader) {
    mp_uint_t unum = 0;
    for (;;) {
        byte b = reader->read_byte(reader->data);
        unum = (unum << 7) | (b & 0x7f);
        if ((b & 0x80) == 0) {
            break;
        }
    }
    return unum;
}

STATIC qstr micropy_load_qstr(struct _mp_state_ctx_t *mp_state, mp_reader_t *reader) {
    mp_uint_t len = micropy_read_uint(mp_state, reader);
    char *str = micropy_m_new(mp_state, char, len);
    micropy_read_bytes(mp_state, reader, (byte*)str, len);
    qstr qst = micropy_qstr_from_strn(mp_state, str, len);
    micropy_m_del(mp_state, char, str, len);
    return qst;
}

STATIC mp_obj_t micropy_load_obj(struct _mp_state_ctx_t *mp_state, mp_reader_t *reader) {
    byte obj_type = micropy_read_byte(mp_state, reader);
    if (obj_type == 'e') {
        return MP_OBJ_FROM_PTR(&mp_const_ellipsis_obj);
    } else {
        size_t len = micropy_read_uint(mp_state, reader);
        vstr_t vstr;
        micropy_vstr_init_len(mp_state, &vstr, len);
        micropy_read_bytes(mp_state, reader, (byte*)vstr.buf, len);
        if (obj_type == 's' || obj_type == 'b') {
            return micropy_obj_new_str_from_vstr(mp_state, obj_type == 's' ? &mp_type_str : &mp_type_bytes, &vstr);
        } else if (obj_type == 'i') {
            return micropy_parse_num_integer(mp_state, vstr.buf, vstr.len, 10, NULL);
        } else {
            assert(obj_type == 'f' || obj_type == 'c');
            return micropy_parse_num_decimal(mp_state, vstr.buf, vstr.len, obj_type == 'c', false, NULL);
        }
    }
}

STATIC void micropy_load_bytecode_qstrs(struct _mp_state_ctx_t *mp_state, mp_reader_t *reader, byte *ip, byte *ip_top) {
    while (ip < ip_top) {
        size_t sz;
        uint f = micropy_opcode_format(mp_state, ip, &sz);
        if (f == MP_OPCODE_QSTR) {
            qstr qst = micropy_load_qstr(mp_state, reader);
            ip[1] = qst;
            ip[2] = qst >> 8;
        }
        ip += sz;
    }
}

STATIC mp_raw_code_t *micropy_load_raw_code(struct _mp_state_ctx_t *mp_state, mp_reader_t *reader) {
    // load bytecode
    mp_uint_t bc_len = micropy_read_uint(mp_state, reader);
    byte *bytecode = micropy_m_new(mp_state, byte, bc_len);
    micropy_read_bytes(mp_state, reader, bytecode, bc_len);

    // extract prelude
    const byte *ip = bytecode;
    const byte *ip2;
    bytecode_prelude_t prelude;
    micropy_extract_prelude(mp_state, &ip, &ip2, &prelude);

    // load qstrs and link global qstr ids into bytecode
    qstr simple_name = micropy_load_qstr(mp_state, reader);
    qstr source_file = micropy_load_qstr(mp_state, reader);
    ((byte*)ip2)[0] = simple_name; ((byte*)ip2)[1] = simple_name >> 8;
    ((byte*)ip2)[2] = source_file; ((byte*)ip2)[3] = source_file >> 8;
    micropy_load_bytecode_qstrs(mp_state, reader, (byte*)ip, bytecode + bc_len);

    // load constant table
    mp_uint_t n_obj = micropy_read_uint(mp_state, reader);
    mp_uint_t n_raw_code = micropy_read_uint(mp_state, reader);
    mp_uint_t *const_table = micropy_m_new(mp_state, mp_uint_t, prelude.n_pos_args + prelude.n_kwonly_args + n_obj + n_raw_code);
    mp_uint_t *ct = const_table;
    for (mp_uint_t i = 0; i < prelude.n_pos_args + prelude.n_kwonly_args; ++i) {
        *ct++ = (mp_uint_t)MP_OBJ_NEW_QSTR(micropy_load_qstr(mp_state, reader));
    }
    for (mp_uint_t i = 0; i < n_obj; ++i) {
        *ct++ = (mp_uint_t)micropy_load_obj(mp_state, reader);
    }
    for (mp_uint_t i = 0; i < n_raw_code; ++i) {
        *ct++ = (mp_uint_t)(uintptr_t)micropy_load_raw_code(mp_state, reader);
    }

    // create raw_code and return it
    mp_raw_code_t *rc = micropy_emit_glue_new_raw_code(mp_state);
    micropy_emit_glue_assign_bytecode(mp_state, rc, bytecode, bc_len, const_table,
        #if MICROPY_PERSISTENT_CODE_SAVE
        n_obj, n_raw_code,
        #endif
        prelude.scope_flags);
    return rc;
}

mp_raw_code_t *micropy_raw_code_load(struct _mp_state_ctx_t *mp_state, mp_reader_t *reader) {
    byte header[4];
    micropy_read_bytes(mp_state, reader, header, sizeof(header));
    if (strncmp((char*)header, "M\x00", 2) != 0) {
        micropy_nlr_raise(mp_state, micropy_obj_new_exception_msg(mp_state, &mp_type_ValueError,
            "invalid .mpy file"));
    }
    if (header[2] != MPY_FEATURE_FLAGS || header[3] > micropy_small_int_bits(mp_state)) {
        micropy_nlr_raise(mp_state, micropy_obj_new_exception_msg(mp_state, &mp_type_ValueError,
            "incompatible .mpy file"));
    }
    return micropy_load_raw_code(mp_state, reader);
}

typedef struct _mp_mem_reader_t {
    const byte *cur;
    const byte *end;
} mp_mem_reader_t;

STATIC mp_uint_t micropy_mem_reader_next_byte(struct _mp_state_ctx_t *mp_state, void *br_in) {
    mp_mem_reader_t *br = br_in;
    if (br->cur < br->end) {
        return *br->cur++;
    } else {
        return (mp_uint_t)-1;
    }
}

mp_raw_code_t *micropy_raw_code_load_mem(struct _mp_state_ctx_t *mp_state, const byte *buf, size_t len) {
    mp_mem_reader_t mr = {buf, buf + len};
    mp_reader_t reader = {&mr, mp_mem_reader_next_byte};
    return micropy_raw_code_load(mp_state, &reader);
}

// here we define mp_raw_code_load_file depending on the port
// TODO abstract this away properly

#if defined(__i386__) || defined(__x86_64__) || defined(__aarch64__) || (defined(__arm__) && (defined(__unix__)))
// unix file reader

#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>

typedef struct _mp_lexer_file_buf_t {
    int fd;
    byte buf[20];
    mp_uint_t len;
    mp_uint_t pos;
} mp_lexer_file_buf_t;

STATIC mp_uint_t micropy_file_buf_next_byte(struct _mp_state_ctx_t *mp_state, void *fb_in) {
    mp_lexer_file_buf_t *fb = fb_in;
    if (fb->pos >= fb->len) {
        if (fb->len == 0) {
            return (mp_uint_t)-1;
        } else {
            int n = read(fb->fd, fb->buf, sizeof(fb->buf));
            if (n <= 0) {
                fb->len = 0;
                return (mp_uint_t)-1;
            }
            fb->len = n;
            fb->pos = 0;
        }
    }
    return fb->buf[fb->pos++];
}

mp_raw_code_t *micropy_raw_code_load_file(struct _mp_state_ctx_t *mp_state, const char *filename) {
    mp_lexer_file_buf_t fb;
    fb.fd = open(filename, O_RDONLY, 0644);
    int n = read(fb.fd, fb.buf, sizeof(fb.buf));
    fb.len = n;
    fb.pos = 0;
    mp_reader_t reader;
    reader.data = &fb;
    reader.read_byte = micropy_file_buf_next_byte;
    mp_raw_code_t *rc = micropy_raw_code_load(mp_state, &reader);
    close(fb.fd);
    return rc;
}

#elif defined(__thumb2__)
// fatfs file reader (assume thumb2 arch uses fatfs...)

#include "lib/fatfs/ff.h"

typedef struct _mp_lexer_file_buf_t {
    FIL fp;
    byte buf[20];
    uint16_t len;
    uint16_t pos;
} mp_lexer_file_buf_t;

STATIC mp_uint_t micropy_file_buf_next_byte(struct _mp_state_ctx_t *mp_state, void *fb_in) {
    mp_lexer_file_buf_t *fb = fb_in;
    if (fb->pos >= fb->len) {
        if (fb->len < sizeof(fb->buf)) {
            return (mp_uint_t)-1;
        } else {
            UINT n;
            micropy_f_read(mp_state, &fb->fp, fb->buf, sizeof(fb->buf), &n);
            if (n == 0) {
                return (mp_uint_t)-1;
            }
            fb->len = n;
            fb->pos = 0;
        }
    }
    return fb->buf[fb->pos++];
}

mp_raw_code_t *micropy_raw_code_load_file(struct _mp_state_ctx_t *mp_state, const char *filename) {
    mp_lexer_file_buf_t fb;
    /*FRESULT res =*/ micropy_f_open(mp_state, &fb.fp, filename, FA_READ);
    UINT n;
    micropy_f_read(mp_state, &fb.fp, fb.buf, sizeof(fb.buf), &n);
    fb.len = n;
    fb.pos = 0;

    mp_reader_t reader;
    reader.data = &fb;
    reader.read_byte = micropy_file_buf_next_byte;
    mp_raw_code_t *rc = micropy_raw_code_load(mp_state, &reader);

    micropy_f_close(mp_state, &fb.fp);

    return rc;
}

#endif

#endif // MICROPY_PERSISTENT_CODE_LOAD

#if MICROPY_PERSISTENT_CODE_SAVE

//#include "py/objstr.h"

STATIC void micropy_print_bytes(struct _mp_state_ctx_t *mp_state, mp_print_t *print, const byte *data, size_t len) {
    print->print_strn(mp_state, print->data, (const char*)data, len);
}

#define BYTES_FOR_INT ((BYTES_PER_WORD * 8 + 6) / 7)
STATIC void micropy_print_uint(struct _mp_state_ctx_t *mp_state, mp_print_t *print, mp_uint_t n) {
    byte buf[BYTES_FOR_INT];
    byte *p = buf + sizeof(buf);
    *--p = n & 0x7f;
    n >>= 7;
    for (; n != 0; n >>= 7) {
        *--p = 0x80 | (n & 0x7f);
    }
    print->print_strn(mp_state, print->data, (char*)p, buf + sizeof(buf) - p);
}

STATIC void micropy_save_qstr(struct _mp_state_ctx_t *mp_state, mp_print_t *print, qstr qst) {
    size_t len;
    const byte *str = micropy_qstr_data(mp_state, qst, &len);
    micropy_print_uint(mp_state, print, len);
    micropy_print_bytes(mp_state, print, str, len);
}

STATIC void micropy_save_obj(struct _mp_state_ctx_t *mp_state, mp_print_t *print, mp_obj_t o) {
    if (MP_OBJ_IS_STR_OR_BYTES(o)) {
        byte obj_type;
        if (MP_OBJ_IS_STR(o)) {
            obj_type = 's';
        } else {
            obj_type = 'b';
        }
        mp_uint_t len;
        const char *str = micropy_obj_str_get_data(mp_state, o, &len);
        micropy_print_bytes(mp_state, print, &obj_type, 1);
        micropy_print_uint(mp_state, print, len);
        micropy_print_bytes(mp_state, print, (const byte*)str, len);
    } else if (MP_OBJ_TO_PTR(o) == &mp_const_ellipsis_obj) {
        byte obj_type = 'e';
        micropy_print_bytes(mp_state, print, &obj_type, 1);
    } else {
        // we save numbers using a simplistic text representation
        // TODO could be improved
        byte obj_type;
        if (MP_OBJ_IS_TYPE(o, &mp_type_int)) {
            obj_type = 'i';
        } else if (micropy_obj_is_float(mp_state, o)) {
            obj_type = 'f';
        } else {
            assert(MP_OBJ_IS_TYPE(o, &mp_type_complex));
            obj_type = 'c';
        }
        vstr_t vstr;
        mp_print_t pr;
        micropy_vstr_init_print(mp_state, &vstr, 10, &pr);
        micropy_obj_print_helper(mp_state, &pr, o, PRINT_REPR);
        micropy_print_bytes(mp_state, print, &obj_type, 1);
        micropy_print_uint(mp_state, print, vstr.len);
        micropy_print_bytes(mp_state, print, (const byte*)vstr.buf, vstr.len);
        micropy_vstr_clear(mp_state, &vstr);
    }
}

STATIC void micropy_save_bytecode_qstrs(struct _mp_state_ctx_t *mp_state, mp_print_t *print, const byte *ip, const byte *ip_top) {
    while (ip < ip_top) {
        size_t sz;
        uint f = micropy_opcode_format(mp_state, ip, &sz);
        if (f == MP_OPCODE_QSTR) {
            qstr qst = ip[1] | (ip[2] << 8);
            micropy_save_qstr(mp_state, print, qst);
        }
        ip += sz;
    }
}

STATIC void micropy_save_raw_code(struct _mp_state_ctx_t *mp_state, mp_print_t *print, mp_raw_code_t *rc) {
    if (rc->kind != MP_CODE_BYTECODE) {
        micropy_nlr_raise(mp_state, micropy_obj_new_exception_msg(mp_state, &mp_type_ValueError,
            "can only save bytecode"));
    }

    // save bytecode
    micropy_print_uint(mp_state, print, rc->data.u_byte.bc_len);
    micropy_print_bytes(mp_state, print, rc->data.u_byte.bytecode, rc->data.u_byte.bc_len);

    // extract prelude
    const byte *ip = rc->data.u_byte.bytecode;
    const byte *ip2;
    bytecode_prelude_t prelude;
    micropy_extract_prelude(mp_state, &ip, &ip2, &prelude);

    // save qstrs
    micropy_save_qstr(mp_state, print, ip2[0] | (ip2[1] << 8)); // simple_name
    micropy_save_qstr(mp_state, print, ip2[2] | (ip2[3] << 8)); // source_file
    micropy_save_bytecode_qstrs(mp_state, print, ip, rc->data.u_byte.bytecode + rc->data.u_byte.bc_len);

    // save constant table
    micropy_print_uint(mp_state, print, rc->data.u_byte.n_obj);
    micropy_print_uint(mp_state, print, rc->data.u_byte.n_raw_code);
    const mp_uint_t *const_table = rc->data.u_byte.const_table;
    for (uint i = 0; i < prelude.n_pos_args + prelude.n_kwonly_args; ++i) {
        mp_obj_t o = (mp_obj_t)*const_table++;
        micropy_save_qstr(mp_state, print, MP_OBJ_QSTR_VALUE(o));
    }
    for (uint i = 0; i < rc->data.u_byte.n_obj; ++i) {
        micropy_save_obj(mp_state, print, (mp_obj_t)*const_table++);
    }
    for (uint i = 0; i < rc->data.u_byte.n_raw_code; ++i) {
        micropy_save_raw_code(mp_state, print, (mp_raw_code_t*)(uintptr_t)*const_table++);
    }
}

void micropy_raw_code_save(struct _mp_state_ctx_t *mp_state, mp_raw_code_t *rc, mp_print_t *print) {
    // header contains:
    //  byte  'M'
    //  byte  version
    //  byte  feature flags
    //  byte  number of bits in a small int
    byte header[4] = {'M', 0, MPY_FEATURE_FLAGS_DYNAMIC,
        #if MICROPY_DYNAMIC_COMPILER
        mp_dynamic_compiler.small_int_bits,
        #else
        micropy_small_int_bits(mp_state),
        #endif
    };
    micropy_print_bytes(mp_state, print, header, sizeof(header));

    micropy_save_raw_code(mp_state, print, rc);
}

// here we define mp_raw_code_save_file depending on the port
// TODO abstract this away properly

#if defined(__i386__) || defined(__x86_64__) || (defined(__arm__) && (defined(__unix__)))

#include <unistd.h>
#include <sys/stat.h>
#include <fcntl.h>

STATIC void micropy_fd_print_strn(struct _mp_state_ctx_t *mp_state, void *env, const char *str, size_t len) {
    int fd = (intptr_t)env;
    ssize_t ret = write(fd, str, len);
    (void)ret;
}

void micropy_raw_code_save_file(struct _mp_state_ctx_t *mp_state, mp_raw_code_t *rc, const char *filename) {
    int fd = open(filename, O_WRONLY | O_CREAT | O_TRUNC, 0644);
    mp_print_t fd_print = {(void*)(intptr_t)fd, fd_print_strn};
    micropy_raw_code_save(mp_state, rc, &fd_print);
    close(fd);
}

#else
#error mp_raw_code_save_file not implemented for this platform
#endif

#endif // MICROPY_PERSISTENT_CODE_SAVE
/*
 * This file is part of the Micro Python project, http://micropython.org/
 *
 * The MIT License (MIT)
 *
 * Copyright (c) 2013, 2014 Damien P. George
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

#include <stdio.h>
#include <string.h>
#include <assert.h>

//#include "py/mpstate.h"
//#include "py/nlr.h"
//#include "py/parsenum.h"
//#include "py/compile.h"
//#include "py/objstr.h"
//#include "py/objtuple.h"
//#include "py/objlist.h"
//#include "py/objmodule.h"
//#include "py/objgenerator.h"
//#include "py/smallint.h"
//#include "py/runtime0.h"
//#include "py/runtime.h"
//#include "py/builtin.h"
//#include "py/stackctrl.h"
//#include "py/gc.h"

#if 0 // print debugging info
#define DEBUG_PRINT (1)
#define DEBUG_printf DEBUG_printf
#define DEBUG_OP_printf(...) DEBUG_printf(__VA_ARGS__)
#else // don't print debugging info
#define DEBUG_printf(...) (void)0
#define DEBUG_OP_printf(...) (void)0
#endif

const mp_obj_module_t mp_module___main__ = {
    .base = { &mp_type_module },
    .name = MP_QSTR___main__,

};

void micropy_init(struct _mp_state_ctx_t *mp_state) {
    micropy_qstr_init(mp_state);

    // no pending exceptions to start with
    (mp_state)->vm.mp_pending_exception = MP_OBJ_NULL;

#if MICROPY_ENABLE_EMERGENCY_EXCEPTION_BUF
    micropy_init_emergency_exception_buf(mp_state);
#endif

    // call port specific initialization if any
#ifdef MICROPY_PORT_INIT_FUNC
    MICROPY_PORT_INIT_FUNC;
#endif

    // optimization disabled by default
    (mp_state)->vm.mp_optimise_value = 0;

    // init global module stuff
    micropy_module_init(mp_state);

    // initialise the __main__ module
    micropy_obj_dict_init(mp_state, &(mp_state)->vm.dict_main, 1);
    micropy_obj_dict_store(mp_state, MP_OBJ_FROM_PTR(&(mp_state)->vm.dict_main), MP_OBJ_NEW_QSTR(MP_QSTR___name__), MP_OBJ_NEW_QSTR(MP_QSTR___main__));

    // locals = globals for outer module (see Objects/frameobject.c/PyFrame_New())
    (mp_state)->dict_locals = (mp_state)->dict_globals = &(mp_state)->vm.dict_main;

    #if MICROPY_CAN_OVERRIDE_BUILTINS
    // start with no extensions to builtins
    (mp_state)->vm.mp_module_builtins_override_dict = NULL;
    #endif
}

void micropy_deinit(struct _mp_state_ctx_t *mp_state) {
    //mp_obj_dict_free(&dict_main);
    micropy_module_deinit(mp_state);

    // call port specific deinitialization if any 
#ifdef MICROPY_PORT_INIT_FUNC
    MICROPY_PORT_DEINIT_FUNC;
#endif
}

mp_obj_t micropy_load_name(struct _mp_state_ctx_t *mp_state, qstr qst) {
    // logic: search locals, globals, builtins
    DEBUG_OP_printf("load name %s\n", micropy_qstr_str(mp_state, qst));
    // If we're at the outer scope (locals == globals), dispatch to load_global right away
    if ((mp_state)->dict_locals != (mp_state)->dict_globals) {
        mp_map_elem_t *elem = micropy_map_lookup(mp_state, &(mp_state)->dict_locals->map, MP_OBJ_NEW_QSTR(qst), MP_MAP_LOOKUP);
        if (elem != NULL) {
            return elem->value;
        }
    }
    return micropy_load_global(mp_state, qst);
}

mp_obj_t micropy_load_global(struct _mp_state_ctx_t *mp_state, qstr qst) {
    // logic: search globals, builtins
    DEBUG_OP_printf("load global %s\n", micropy_qstr_str(mp_state, qst));
    mp_map_elem_t *elem = micropy_map_lookup(mp_state, &(mp_state)->dict_globals->map, MP_OBJ_NEW_QSTR(qst), MP_MAP_LOOKUP);
    if (elem == NULL) {
        #if MICROPY_CAN_OVERRIDE_BUILTINS
        if ((mp_state)->vm.mp_module_builtins_override_dict != NULL) {
            // lookup in additional dynamic table of builtins first
            elem = micropy_map_lookup(mp_state, &(mp_state)->vm.mp_module_builtins_override_dict->map, MP_OBJ_NEW_QSTR(qst), MP_MAP_LOOKUP);
            if (elem != NULL) {
                return elem->value;
            }
        }
        #endif
        elem = micropy_map_lookup(mp_state, (mp_map_t*)&mp_module_builtins_globals.map, MP_OBJ_NEW_QSTR(qst), MP_MAP_LOOKUP);
        if (elem == NULL) {
            if (MICROPY_ERROR_REPORTING == MICROPY_ERROR_REPORTING_TERSE) {
                micropy_nlr_raise(mp_state, micropy_obj_new_exception_msg(mp_state, &mp_type_NameError,
                    "name not defined"));
            } else {
                micropy_nlr_raise(mp_state, micropy_obj_new_exception_msg_varg(mp_state, &mp_type_NameError,
                    "name '%q' is not defined", qst));
            }
        }
    }
    return elem->value;
}

mp_obj_t micropy_load_build_class(struct _mp_state_ctx_t *mp_state) {
    DEBUG_OP_printf("load_build_class\n");
    #if MICROPY_CAN_OVERRIDE_BUILTINS
    if ((mp_state)->vm.mp_module_builtins_override_dict != NULL) {
        // lookup in additional dynamic table of builtins first
        mp_map_elem_t *elem = micropy_map_lookup(mp_state, &(mp_state)->vm.mp_module_builtins_override_dict->map, MP_OBJ_NEW_QSTR(MP_QSTR___build_class__), MP_MAP_LOOKUP);
        if (elem != NULL) {
            return elem->value;
        }
    }
    #endif
    return MP_OBJ_FROM_PTR(&mp_builtin___build_class___obj);
}

void micropy_store_name(struct _mp_state_ctx_t *mp_state, qstr qst, mp_obj_t obj) {
    DEBUG_OP_printf("store name %s <- %p\n", micropy_qstr_str(mp_state, qst), obj);
    micropy_obj_dict_store(mp_state, MP_OBJ_FROM_PTR((mp_state)->dict_locals), MP_OBJ_NEW_QSTR(qst), obj);
}

void micropy_delete_name(struct _mp_state_ctx_t *mp_state, qstr qst) {
    DEBUG_OP_printf("delete name %s\n", micropy_qstr_str(mp_state, qst));
    // TODO convert KeyError to NameError if qst not found
    micropy_obj_dict_delete(mp_state, MP_OBJ_FROM_PTR((mp_state)->dict_locals), MP_OBJ_NEW_QSTR(qst));
}

void micropy_store_global(struct _mp_state_ctx_t *mp_state, qstr qst, mp_obj_t obj) {
    DEBUG_OP_printf("store global %s <- %p\n", micropy_qstr_str(mp_state, qst), obj);
    micropy_obj_dict_store(mp_state, MP_OBJ_FROM_PTR((mp_state)->dict_globals), MP_OBJ_NEW_QSTR(qst), obj);
}

void micropy_delete_global(struct _mp_state_ctx_t *mp_state, qstr qst) {
    DEBUG_OP_printf("delete global %s\n", micropy_qstr_str(mp_state, qst));
    // TODO convert KeyError to NameError if qst not found
    micropy_obj_dict_delete(mp_state, MP_OBJ_FROM_PTR((mp_state)->dict_globals), MP_OBJ_NEW_QSTR(qst));
}

mp_obj_t micropy_unary_op(struct _mp_state_ctx_t *mp_state, mp_uint_t op, mp_obj_t arg) {
    DEBUG_OP_printf("unary " UINT_FMT " %p\n", op, arg);

    if (op == MP_UNARY_OP_NOT) {
        // "not x" is the negative of whether "x" is true per Python semantics
        return micropy_obj_new_bool(mp_state, micropy_obj_is_true(mp_state, arg) == 0);
    } else if (MP_OBJ_IS_SMALL_INT(arg)) {
        mp_int_t val = MP_OBJ_SMALL_INT_VALUE(arg);
        switch (op) {
            case MP_UNARY_OP_BOOL:
                return micropy_obj_new_bool(mp_state, val != 0);
            case MP_UNARY_OP_HASH:
                return arg;
            case MP_UNARY_OP_POSITIVE:
                return arg;
            case MP_UNARY_OP_NEGATIVE:
                // check for overflow
                if (val == MP_SMALL_INT_MIN) {
                    return micropy_obj_new_int(mp_state, -val);
                } else {
                    return MP_OBJ_NEW_SMALL_INT(-val);
                }
            case MP_UNARY_OP_INVERT:
                return MP_OBJ_NEW_SMALL_INT(~val);
            default:
                assert(0);
                return arg;
        }
    } else if (op == MP_UNARY_OP_HASH && MP_OBJ_IS_STR_OR_BYTES(arg)) {
        // fast path for hashing str/bytes
        GET_STR_HASH(arg, h);
        return MP_OBJ_NEW_SMALL_INT(h);
    } else {
        mp_obj_type_t *type = micropy_obj_get_type(mp_state, arg);
        if (type->unary_op != NULL) {
            mp_obj_t result = type->unary_op(mp_state, op, arg);
            if (result != MP_OBJ_NULL) {
                return result;
            }
        }
        if (MICROPY_ERROR_REPORTING == MICROPY_ERROR_REPORTING_TERSE) {
            micropy_nlr_raise(mp_state, micropy_obj_new_exception_msg(mp_state, &mp_type_TypeError,
                "unsupported type for operator"));
        } else {
            micropy_nlr_raise(mp_state, micropy_obj_new_exception_msg_varg(mp_state, &mp_type_TypeError,
                "unsupported type for %q: '%s'",
                mp_unary_op_method_name[op], micropy_obj_get_type_str(mp_state, arg)));
        }
    }
}

mp_obj_t micropy_binary_op(struct _mp_state_ctx_t *mp_state, mp_uint_t op, mp_obj_t lhs, mp_obj_t rhs) {
    DEBUG_OP_printf("binary " UINT_FMT " %p %p\n", op, lhs, rhs);

    // TODO correctly distinguish inplace operators for mutable objects
    // lookup logic that CPython uses for +=:
    //   check for implemented +=
    //   then check for implemented +
    //   then check for implemented seq.inplace_concat
    //   then check for implemented seq.concat
    //   then fail
    // note that list does not implement + or +=, so that inplace_concat is reached first for +=

    // deal with is
    if (op == MP_BINARY_OP_IS) {
        return micropy_obj_new_bool(mp_state, lhs == rhs);
    }

    // deal with == and != for all types
    if (op == MP_BINARY_OP_EQUAL || op == MP_BINARY_OP_NOT_EQUAL) {
        if (micropy_obj_equal(mp_state, lhs, rhs)) {
            if (op == MP_BINARY_OP_EQUAL) {
                return mp_const_true;
            } else {
                return mp_const_false;
            }
        } else {
            if (op == MP_BINARY_OP_EQUAL) {
                return mp_const_false;
            } else {
                return mp_const_true;
            }
        }
    }

    // deal with exception_match for all types
    if (op == MP_BINARY_OP_EXCEPTION_MATCH) {
        // rhs must be issubclass(rhs, BaseException)
        if (micropy_obj_is_exception_type(mp_state, rhs)) {
            if (micropy_obj_exception_match(mp_state, lhs, rhs)) {
                return mp_const_true;
            } else {
                return mp_const_false;
            }
        } else if (MP_OBJ_IS_TYPE(rhs, &mp_type_tuple)) {
            mp_obj_tuple_t *tuple = MP_OBJ_TO_PTR(rhs);
            for (mp_uint_t i = 0; i < tuple->len; i++) {
                rhs = tuple->items[i];
                if (!micropy_obj_is_exception_type(mp_state, rhs)) {
                    goto unsupported_op;
                }
                if (micropy_obj_exception_match(mp_state, lhs, rhs)) {
                    return mp_const_true;
                }
            }
            return mp_const_false;
        }
        goto unsupported_op;
    }

    if (MP_OBJ_IS_SMALL_INT(lhs)) {
        mp_int_t lhs_val = MP_OBJ_SMALL_INT_VALUE(lhs);
        if (MP_OBJ_IS_SMALL_INT(rhs)) {
            mp_int_t rhs_val = MP_OBJ_SMALL_INT_VALUE(rhs);
            // This is a binary operation: lhs_val op rhs_val
            // We need to be careful to handle overflow; see CERT INT32-C
            // Operations that can overflow:
            //      +       result always fits in mp_int_t, then handled by SMALL_INT check
            //      -       result always fits in mp_int_t, then handled by SMALL_INT check
            //      *       checked explicitly
            //      /       if lhs=MIN and rhs=-1; result always fits in mp_int_t, then handled by SMALL_INT check
            //      %       if lhs=MIN and rhs=-1; result always fits in mp_int_t, then handled by SMALL_INT check
            //      <<      checked explicitly
            switch (op) {
                case MP_BINARY_OP_OR:
                case MP_BINARY_OP_INPLACE_OR: lhs_val |= rhs_val; break;
                case MP_BINARY_OP_XOR:
                case MP_BINARY_OP_INPLACE_XOR: lhs_val ^= rhs_val; break;
                case MP_BINARY_OP_AND:
                case MP_BINARY_OP_INPLACE_AND: lhs_val &= rhs_val; break;
                case MP_BINARY_OP_LSHIFT:
                case MP_BINARY_OP_INPLACE_LSHIFT: {
                    if (rhs_val < 0) {
                        // negative shift not allowed
                        micropy_nlr_raise(mp_state, micropy_obj_new_exception_msg(mp_state, &mp_type_ValueError, "negative shift count"));
                    } else if (rhs_val >= (mp_int_t)BITS_PER_WORD || lhs_val > (MP_SMALL_INT_MAX >> rhs_val) || lhs_val < (MP_SMALL_INT_MIN >> rhs_val)) {
                        // left-shift will overflow, so use higher precision integer
                        lhs = micropy_obj_new_int_from_ll(mp_state, lhs_val);
                        goto generic_binary_op;
                    } else {
                        // use standard precision
                        lhs_val <<= rhs_val;
                    }
                    break;
                }
                case MP_BINARY_OP_RSHIFT:
                case MP_BINARY_OP_INPLACE_RSHIFT:
                    if (rhs_val < 0) {
                        // negative shift not allowed
                        micropy_nlr_raise(mp_state, micropy_obj_new_exception_msg(mp_state, &mp_type_ValueError, "negative shift count"));
                    } else {
                        // standard precision is enough for right-shift
                        if (rhs_val >= (mp_int_t)BITS_PER_WORD) {
                            // Shifting to big amounts is underfined behavior
                            // in C and is CPU-dependent; propagate sign bit.
                            rhs_val = BITS_PER_WORD - 1;
                        }
                        lhs_val >>= rhs_val;
                    }
                    break;
                case MP_BINARY_OP_ADD:
                case MP_BINARY_OP_INPLACE_ADD: lhs_val += rhs_val; break;
                case MP_BINARY_OP_SUBTRACT:
                case MP_BINARY_OP_INPLACE_SUBTRACT: lhs_val -= rhs_val; break;
                case MP_BINARY_OP_MULTIPLY:
                case MP_BINARY_OP_INPLACE_MULTIPLY: {

                    // If long long type exists and is larger than mp_int_t, then
                    // we can use the following code to perform overflow-checked multiplication.
                    // Otherwise (eg in x64 case) we must use mp_small_int_mul_overflow.
                    #if 0
                    // compute result using long long precision
                    long long res = (long long)lhs_val * (long long)rhs_val;
                    if (res > MP_SMALL_INT_MAX || res < MP_SMALL_INT_MIN) {
                        // result overflowed SMALL_INT, so return higher precision integer
                        return micropy_obj_new_int_from_ll(mp_state, res);
                    } else {
                        // use standard precision
                        lhs_val = (mp_int_t)res;
                    }
                    #endif

                    if (micropy_small_int_mul_overflow(mp_state, lhs_val, rhs_val)) {
                        // use higher precision
                        lhs = micropy_obj_new_int_from_ll(mp_state, lhs_val);
                        goto generic_binary_op;
                    } else {
                        // use standard precision
                        return MP_OBJ_NEW_SMALL_INT(lhs_val * rhs_val);
                    }
                    break;
                }
                case MP_BINARY_OP_FLOOR_DIVIDE:
                case MP_BINARY_OP_INPLACE_FLOOR_DIVIDE:
                    if (rhs_val == 0) {
                        goto zero_division;
                    }
                    lhs_val = micropy_small_int_floor_divide(mp_state, lhs_val, rhs_val);
                    break;

                #if MICROPY_PY_BUILTINS_FLOAT
                case MP_BINARY_OP_TRUE_DIVIDE:
                case MP_BINARY_OP_INPLACE_TRUE_DIVIDE:
                    if (rhs_val == 0) {
                        goto zero_division;
                    }
                    return micropy_obj_new_float(mp_state, (mp_float_t)lhs_val / (mp_float_t)rhs_val);
                #endif

                case MP_BINARY_OP_MODULO:
                case MP_BINARY_OP_INPLACE_MODULO: {
                    if (rhs_val == 0) {
                        goto zero_division;
                    }
                    lhs_val = micropy_small_int_modulo(mp_state, lhs_val, rhs_val);
                    break;
                }

                case MP_BINARY_OP_POWER:
                case MP_BINARY_OP_INPLACE_POWER:
                    if (rhs_val < 0) {
                        #if MICROPY_PY_BUILTINS_FLOAT
                        lhs = micropy_obj_new_float(mp_state, lhs_val);
                        goto generic_binary_op;
                        #else
                        micropy_nlr_raise(mp_state, micropy_obj_new_exception_msg(mp_state, &mp_type_ValueError, "negative power with no float support"));
                        #endif
                    } else {
                        mp_int_t ans = 1;
                        while (rhs_val > 0) {
                            if (rhs_val & 1) {
                                if (micropy_small_int_mul_overflow(mp_state, ans, lhs_val)) {
                                    goto power_overflow;
                                }
                                ans *= lhs_val;
                            }
                            if (rhs_val == 1) {
                                break;
                            }
                            rhs_val /= 2;
                            if (micropy_small_int_mul_overflow(mp_state, lhs_val, lhs_val)) {
                                goto power_overflow;
                            }
                            lhs_val *= lhs_val;
                        }
                        lhs_val = ans;
                    }
                    break;

                power_overflow:
                    // use higher precision
                    lhs = micropy_obj_new_int_from_ll(mp_state, MP_OBJ_SMALL_INT_VALUE(lhs));
                    goto generic_binary_op;

                case MP_BINARY_OP_DIVMOD: {
                    if (rhs_val == 0) {
                        goto zero_division;
                    }
                    // to reduce stack usage we don't pass a temp array of the 2 items
                    mp_obj_tuple_t *tuple = MP_OBJ_TO_PTR(micropy_obj_new_tuple(mp_state, 2, NULL));
                    tuple->items[0] = MP_OBJ_NEW_SMALL_INT(micropy_small_int_floor_divide(mp_state, lhs_val, rhs_val));
                    tuple->items[1] = MP_OBJ_NEW_SMALL_INT(micropy_small_int_modulo(mp_state, lhs_val, rhs_val));
                    return MP_OBJ_FROM_PTR(tuple);
                }

                case MP_BINARY_OP_LESS: return micropy_obj_new_bool(mp_state, lhs_val < rhs_val); break;
                case MP_BINARY_OP_MORE: return micropy_obj_new_bool(mp_state, lhs_val > rhs_val); break;
                case MP_BINARY_OP_LESS_EQUAL: return micropy_obj_new_bool(mp_state, lhs_val <= rhs_val); break;
                case MP_BINARY_OP_MORE_EQUAL: return micropy_obj_new_bool(mp_state, lhs_val >= rhs_val); break;

                default:
                    goto unsupported_op;
            }
            // TODO: We just should make mp_obj_new_int() inline and use that
            if (MP_SMALL_INT_FITS(lhs_val)) {
                return MP_OBJ_NEW_SMALL_INT(lhs_val);
            } else {
                return micropy_obj_new_int(mp_state, lhs_val);
            }
#if MICROPY_PY_BUILTINS_FLOAT
        } else if (micropy_obj_is_float(mp_state, rhs)) {
            mp_obj_t res = micropy_obj_float_binary_op(mp_state, op, lhs_val, rhs);
            if (res == MP_OBJ_NULL) {
                goto unsupported_op;
            } else {
                return res;
            }
#if MICROPY_PY_BUILTINS_COMPLEX
        } else if (MP_OBJ_IS_TYPE(rhs, &mp_type_complex)) {
            mp_obj_t res = micropy_obj_complex_binary_op(mp_state, op, lhs_val, 0, rhs);
            if (res == MP_OBJ_NULL) {
                goto unsupported_op;
            } else {
                return res;
            }
#endif
#endif
        }
    }

    /* deal with `in`
     *
     * NOTE `a in b` is `b.__contains__(a)`, hence why the generic dispatch
     * needs to go below with swapped arguments
     */
    if (op == MP_BINARY_OP_IN) {
        mp_obj_type_t *type = micropy_obj_get_type(mp_state, rhs);
        if (type->binary_op != NULL) {
            mp_obj_t res = type->binary_op(mp_state, op, rhs, lhs);
            if (res != MP_OBJ_NULL) {
                return res;
            }
        }
        if (type->getiter != NULL) {
            /* second attempt, walk the iterator */
            mp_obj_t iter = micropy_getiter(mp_state, rhs);
            mp_obj_t next;
            while ((next = micropy_iternext(mp_state, iter)) != MP_OBJ_STOP_ITERATION) {
                if (micropy_obj_equal(mp_state, next, lhs)) {
                    return mp_const_true;
                }
            }
            return mp_const_false;
        }

        if (MICROPY_ERROR_REPORTING == MICROPY_ERROR_REPORTING_TERSE) {
            micropy_nlr_raise(mp_state, micropy_obj_new_exception_msg(mp_state, &mp_type_TypeError,
                "object not iterable"));
        } else {
            micropy_nlr_raise(mp_state, micropy_obj_new_exception_msg_varg(mp_state, &mp_type_TypeError,
                "'%s' object is not iterable", micropy_obj_get_type_str(mp_state, rhs)));
        }
    }

    // generic binary_op supplied by type
    mp_obj_type_t *type;
generic_binary_op:
    type = micropy_obj_get_type(mp_state, lhs);
    if (type->binary_op != NULL) {
        mp_obj_t result = type->binary_op(mp_state, op, lhs, rhs);
        if (result != MP_OBJ_NULL) {
            return result;
        }
    }

    // TODO implement dispatch for reverse binary ops

unsupported_op:
    if (MICROPY_ERROR_REPORTING == MICROPY_ERROR_REPORTING_TERSE) {
        micropy_nlr_raise(mp_state, micropy_obj_new_exception_msg(mp_state, &mp_type_TypeError,
            "unsupported type for operator"));
    } else {
        micropy_nlr_raise(mp_state, micropy_obj_new_exception_msg_varg(mp_state, &mp_type_TypeError,
            "unsupported types for %q: '%s', '%s'",
            mp_binary_op_method_name[op], micropy_obj_get_type_str(mp_state, lhs), micropy_obj_get_type_str(mp_state, rhs)));
    }

zero_division:
    micropy_nlr_raise(mp_state, micropy_obj_new_exception_msg(mp_state, &mp_type_ZeroDivisionError, "division by zero"));
}

mp_obj_t micropy_call_function_0(struct _mp_state_ctx_t *mp_state, mp_obj_t fun) {
    return micropy_call_function_n_kw(mp_state, fun, 0, 0, NULL);
}

mp_obj_t micropy_call_function_1(struct _mp_state_ctx_t *mp_state, mp_obj_t fun, mp_obj_t arg) {
    return micropy_call_function_n_kw(mp_state, fun, 1, 0, &arg);
}

mp_obj_t micropy_call_function_2(struct _mp_state_ctx_t *mp_state, mp_obj_t fun, mp_obj_t arg1, mp_obj_t arg2) {
    mp_obj_t args[2];
    args[0] = arg1;
    args[1] = arg2;
    return micropy_call_function_n_kw(mp_state, fun, 2, 0, args);
}

// args contains, eg: arg0  arg1  key0  value0  key1  value1
mp_obj_t micropy_call_function_n_kw(struct _mp_state_ctx_t *mp_state, mp_obj_t fun_in, mp_uint_t n_args, mp_uint_t n_kw, const mp_obj_t *args) {
    // TODO improve this: fun object can specify its type and we parse here the arguments,
    // passing to the function arrays of fixed and keyword arguments

    DEBUG_OP_printf("calling function %p(n_args=" UINT_FMT ", n_kw=" UINT_FMT ", args=%p)\n", fun_in, n_args, n_kw, args);

    // get the type
    mp_obj_type_t *type = micropy_obj_get_type(mp_state, fun_in);

    // do the call
    if (type->call != NULL) {
        return type->call(mp_state, fun_in, n_args, n_kw, args);
    }

    if (MICROPY_ERROR_REPORTING == MICROPY_ERROR_REPORTING_TERSE) {
        micropy_nlr_raise(mp_state, micropy_obj_new_exception_msg(mp_state, &mp_type_TypeError,
            "object not callable"));
    } else {
        micropy_nlr_raise(mp_state, micropy_obj_new_exception_msg_varg(mp_state, &mp_type_TypeError,
            "'%s' object is not callable", micropy_obj_get_type_str(mp_state, fun_in)));
    }
}

// args contains: fun  self/NULL  arg(0)  ...  arg(n_args-2)  arg(n_args-1)  kw_key(0)  kw_val(0)  ... kw_key(n_kw-1)  kw_val(n_kw-1)
// if n_args==0 and n_kw==0 then there are only fun and self/NULL
mp_obj_t micropy_call_method_n_kw(struct _mp_state_ctx_t *mp_state, mp_uint_t n_args, mp_uint_t n_kw, const mp_obj_t *args) {
    DEBUG_OP_printf("call method (fun=%p, self=%p, n_args=" UINT_FMT ", n_kw=" UINT_FMT ", args=%p)\n", args[0], args[1], n_args, n_kw, args);
    int adjust = (args[1] == MP_OBJ_NULL) ? 0 : 1;
    return micropy_call_function_n_kw(mp_state, args[0], n_args + adjust, n_kw, args + 2 - adjust);
}

// This function only needs to be exposed externally when in stackless mode.
#if !MICROPY_STACKLESS
STATIC
#endif
void micropy_call_prepare_args_n_kw_var(struct _mp_state_ctx_t *mp_state, bool have_self, mp_uint_t n_args_n_kw, const mp_obj_t *args, mp_call_args_t *out_args) {
    mp_obj_t fun = *args++;
    mp_obj_t self = MP_OBJ_NULL;
    if (have_self) {
        self = *args++; // may be MP_OBJ_NULL
    }
    uint n_args = n_args_n_kw & 0xff;
    uint n_kw = (n_args_n_kw >> 8) & 0xff;
    mp_obj_t pos_seq = args[n_args + 2 * n_kw]; // may be MP_OBJ_NULL
    mp_obj_t kw_dict = args[n_args + 2 * n_kw + 1]; // may be MP_OBJ_NULL

    DEBUG_OP_printf("call method var (fun=%p, self=%p, n_args=%u, n_kw=%u, args=%p, seq=%p, dict=%p)\n", fun, self, n_args, n_kw, args, pos_seq, kw_dict);

    // We need to create the following array of objects:
    //     args[0 .. n_args]  unpacked(pos_seq)  args[n_args .. n_args + 2 * n_kw]  unpacked(kw_dict)
    // TODO: optimize one day to avoid constructing new arg array? Will be hard.

    // The new args array
    mp_obj_t *args2;
    uint args2_alloc;
    uint args2_len = 0;

    // Try to get a hint for the size of the kw_dict
    uint kw_dict_len = 0;
    if (kw_dict != MP_OBJ_NULL && MP_OBJ_IS_TYPE(kw_dict, &mp_type_dict)) {
        kw_dict_len = micropy_obj_dict_len(mp_state, kw_dict);
    }

    // Extract the pos_seq sequence to the new args array.
    // Note that it can be arbitrary iterator.
    if (pos_seq == MP_OBJ_NULL) {
        // no sequence

        // allocate memory for the new array of args
        args2_alloc = 1 + n_args + 2 * (n_kw + kw_dict_len);
        args2 = micropy_m_new(mp_state, mp_obj_t, args2_alloc);

        // copy the self
        if (self != MP_OBJ_NULL) {
            args2[args2_len++] = self;
        }

        // copy the fixed pos args
        micropy_seq_copy(mp_state, args2 + args2_len, args, n_args, mp_obj_t);
        args2_len += n_args;

    } else if (MP_OBJ_IS_TYPE(pos_seq, &mp_type_tuple) || MP_OBJ_IS_TYPE(pos_seq, &mp_type_list)) {
        // optimise the case of a tuple and list

        // get the items
        mp_uint_t len;
        mp_obj_t *items;
        micropy_obj_get_array(mp_state, pos_seq, &len, &items);

        // allocate memory for the new array of args
        args2_alloc = 1 + n_args + len + 2 * (n_kw + kw_dict_len);
        args2 = micropy_m_new(mp_state, mp_obj_t, args2_alloc);

        // copy the self
        if (self != MP_OBJ_NULL) {
            args2[args2_len++] = self;
        }

        // copy the fixed and variable position args
        micropy_seq_cat(mp_state, args2 + args2_len, args, n_args, items, len, mp_obj_t);
        args2_len += n_args + len;

    } else {
        // generic iterator

        // allocate memory for the new array of args
        args2_alloc = 1 + n_args + 2 * (n_kw + kw_dict_len) + 3;
        args2 = micropy_m_new(mp_state, mp_obj_t, args2_alloc);

        // copy the self
        if (self != MP_OBJ_NULL) {
            args2[args2_len++] = self;
        }

        // copy the fixed position args
        micropy_seq_copy(mp_state, args2 + args2_len, args, n_args, mp_obj_t);
        args2_len += n_args;

        // extract the variable position args from the iterator
        mp_obj_t iterable = micropy_getiter(mp_state, pos_seq);
        mp_obj_t item;
        while ((item = micropy_iternext(mp_state, iterable)) != MP_OBJ_STOP_ITERATION) {
            if (args2_len >= args2_alloc) {
                args2 = micropy_m_renew(mp_state, mp_obj_t, args2, args2_alloc, args2_alloc * 2);
                args2_alloc *= 2;
            }
            args2[args2_len++] = item;
        }
    }

    // The size of the args2 array now is the number of positional args.
    uint pos_args_len = args2_len;

    // Copy the fixed kw args.
    micropy_seq_copy(mp_state, args2 + args2_len, args + n_args, 2 * n_kw, mp_obj_t);
    args2_len += 2 * n_kw;

    // Extract (key,value) pairs from kw_dict dictionary and append to args2.
    // Note that it can be arbitrary iterator.
    if (kw_dict == MP_OBJ_NULL) {
        // pass
    } else if (MP_OBJ_IS_TYPE(kw_dict, &mp_type_dict)) {
        // dictionary
        mp_map_t *map = micropy_obj_dict_get_map(mp_state, kw_dict);
        assert(args2_len + 2 * map->used <= args2_alloc); // should have enough, since kw_dict_len is in this case hinted correctly above
        for (mp_uint_t i = 0; i < map->alloc; i++) {
            if (MP_MAP_SLOT_IS_FILLED(map, i)) {
                // the key must be a qstr, so intern it if it's a string
                mp_obj_t key = map->table[i].key;
                if (MP_OBJ_IS_TYPE(key, &mp_type_str)) {
                    key = micropy_obj_str_intern(mp_state, key);
                }
                args2[args2_len++] = key;
                args2[args2_len++] = map->table[i].value;
            }
        }
    } else {
        // generic mapping:
        // - call keys() to get an iterable of all keys in the mapping
        // - call __getitem__ for each key to get the corresponding value

        // get the keys iterable
        mp_obj_t dest[3];
        micropy_load_method(mp_state, kw_dict, MP_QSTR_keys, dest);
        mp_obj_t iterable = micropy_getiter(mp_state, micropy_call_method_n_kw(mp_state, 0, 0, dest));

        mp_obj_t key;
        while ((key = micropy_iternext(mp_state, iterable)) != MP_OBJ_STOP_ITERATION) {
            // expand size of args array if needed
            if (args2_len + 1 >= args2_alloc) {
                uint new_alloc = args2_alloc * 2;
                if (new_alloc < 4) {
                    new_alloc = 4;
                }
                args2 = micropy_m_renew(mp_state, mp_obj_t, args2, args2_alloc, new_alloc);
                args2_alloc = new_alloc;
            }

            // the key must be a qstr, so intern it if it's a string
            if (MP_OBJ_IS_TYPE(key, &mp_type_str)) {
                key = micropy_obj_str_intern(mp_state, key);
            }

            // get the value corresponding to the key
            micropy_load_method(mp_state, kw_dict, MP_QSTR___getitem__, dest);
            dest[2] = key;
            mp_obj_t value = micropy_call_method_n_kw(mp_state, 1, 0, dest);

            // store the key/value pair in the argument array
            args2[args2_len++] = key;
            args2[args2_len++] = value;
        }
    }

    out_args->fun = fun;
    out_args->args = args2;
    out_args->n_args = pos_args_len;
    out_args->n_kw = (args2_len - pos_args_len) / 2;
    out_args->n_alloc = args2_alloc;
}

mp_obj_t micropy_call_method_n_kw_var(struct _mp_state_ctx_t *mp_state, bool have_self, mp_uint_t n_args_n_kw, const mp_obj_t *args) {
    mp_call_args_t out_args;
    micropy_call_prepare_args_n_kw_var(mp_state, have_self, n_args_n_kw, args, &out_args);

    mp_obj_t res = micropy_call_function_n_kw(mp_state, out_args.fun, out_args.n_args, out_args.n_kw, out_args.args);
    micropy_m_del(mp_state, mp_obj_t, out_args.args, out_args.n_alloc);

    return res;
}

// unpacked items are stored in reverse order into the array pointed to by items
void micropy_unpack_sequence(struct _mp_state_ctx_t *mp_state, mp_obj_t seq_in, mp_uint_t num, mp_obj_t *items) {
    mp_uint_t seq_len;
    if (MP_OBJ_IS_TYPE(seq_in, &mp_type_tuple) || MP_OBJ_IS_TYPE(seq_in, &mp_type_list)) {
        mp_obj_t *seq_items;
        if (MP_OBJ_IS_TYPE(seq_in, &mp_type_tuple)) {
            micropy_obj_tuple_get(mp_state, seq_in, &seq_len, &seq_items);
        } else {
            micropy_obj_list_get(mp_state, seq_in, &seq_len, &seq_items);
        }
        if (seq_len < num) {
            goto too_short;
        } else if (seq_len > num) {
            goto too_long;
        }
        for (mp_uint_t i = 0; i < num; i++) {
            items[i] = seq_items[num - 1 - i];
        }
    } else {
        mp_obj_t iterable = micropy_getiter(mp_state, seq_in);

        for (seq_len = 0; seq_len < num; seq_len++) {
            mp_obj_t el = micropy_iternext(mp_state, iterable);
            if (el == MP_OBJ_STOP_ITERATION) {
                goto too_short;
            }
            items[num - 1 - seq_len] = el;
        }
        if (micropy_iternext(mp_state, iterable) != MP_OBJ_STOP_ITERATION) {
            goto too_long;
        }
    }
    return;

too_short:
    if (MICROPY_ERROR_REPORTING == MICROPY_ERROR_REPORTING_TERSE) {
        micropy_nlr_raise(mp_state, micropy_obj_new_exception_msg(mp_state, &mp_type_ValueError,
            "wrong number of values to unpack"));
    } else {
        micropy_nlr_raise(mp_state, micropy_obj_new_exception_msg_varg(mp_state, &mp_type_ValueError,
            "need more than %d values to unpack", (int)seq_len));
    }
too_long:
    if (MICROPY_ERROR_REPORTING == MICROPY_ERROR_REPORTING_TERSE) {
        micropy_nlr_raise(mp_state, micropy_obj_new_exception_msg(mp_state, &mp_type_ValueError,
            "wrong number of values to unpack"));
    } else {
        micropy_nlr_raise(mp_state, micropy_obj_new_exception_msg_varg(mp_state, &mp_type_ValueError,
            "too many values to unpack (expected %d)", (int)num));
    }
}

// unpacked items are stored in reverse order into the array pointed to by items
void micropy_unpack_ex(struct _mp_state_ctx_t *mp_state, mp_obj_t seq_in, mp_uint_t num_in, mp_obj_t *items) {
    mp_uint_t num_left = num_in & 0xff;
    mp_uint_t num_right = (num_in >> 8) & 0xff;
    DEBUG_OP_printf("unpack ex " UINT_FMT " " UINT_FMT "\n", num_left, num_right);
    mp_uint_t seq_len;
    if (MP_OBJ_IS_TYPE(seq_in, &mp_type_tuple) || MP_OBJ_IS_TYPE(seq_in, &mp_type_list)) {
        mp_obj_t *seq_items;
        if (MP_OBJ_IS_TYPE(seq_in, &mp_type_tuple)) {
            micropy_obj_tuple_get(mp_state, seq_in, &seq_len, &seq_items);
        } else {
            if (num_left == 0 && num_right == 0) {
                // *a, = b # sets a to b if b is a list
                items[0] = seq_in;
                return;
            }
            micropy_obj_list_get(mp_state, seq_in, &seq_len, &seq_items);
        }
        if (seq_len < num_left + num_right) {
            goto too_short;
        }
        for (mp_uint_t i = 0; i < num_right; i++) {
            items[i] = seq_items[seq_len - 1 - i];
        }
        items[num_right] = micropy_obj_new_list(mp_state, seq_len - num_left - num_right, seq_items + num_left);
        for (mp_uint_t i = 0; i < num_left; i++) {
            items[num_right + 1 + i] = seq_items[num_left - 1 - i];
        }
    } else {
        // Generic iterable; this gets a bit messy: we unpack known left length to the
        // items destination array, then the rest to a dynamically created list.  Once the
        // iterable is exhausted, we take from this list for the right part of the items.
        // TODO Improve to waste less memory in the dynamically created list.
        mp_obj_t iterable = micropy_getiter(mp_state, seq_in);
        mp_obj_t item;
        for (seq_len = 0; seq_len < num_left; seq_len++) {
            item = micropy_iternext(mp_state, iterable);
            if (item == MP_OBJ_STOP_ITERATION) {
                goto too_short;
            }
            items[num_left + num_right + 1 - 1 - seq_len] = item;
        }
        mp_obj_list_t *rest = MP_OBJ_TO_PTR(micropy_obj_new_list(mp_state, 0, NULL));
        while ((item = micropy_iternext(mp_state, iterable)) != MP_OBJ_STOP_ITERATION) {
            micropy_obj_list_append(mp_state, MP_OBJ_FROM_PTR(rest), item);
        }
        if (rest->len < num_right) {
            goto too_short;
        }
        items[num_right] = MP_OBJ_FROM_PTR(rest);
        for (mp_uint_t i = 0; i < num_right; i++) {
            items[num_right - 1 - i] = rest->items[rest->len - num_right + i];
        }
        micropy_obj_list_set_len(mp_state, MP_OBJ_FROM_PTR(rest), rest->len - num_right);
    }
    return;

too_short:
    if (MICROPY_ERROR_REPORTING == MICROPY_ERROR_REPORTING_TERSE) {
        micropy_nlr_raise(mp_state, micropy_obj_new_exception_msg(mp_state, &mp_type_ValueError,
            "wrong number of values to unpack"));
    } else {
        micropy_nlr_raise(mp_state, micropy_obj_new_exception_msg_varg(mp_state, &mp_type_ValueError,
            "need more than %d values to unpack", (int)seq_len));
    }
}

mp_obj_t micropy_load_attr(struct _mp_state_ctx_t *mp_state, mp_obj_t base, qstr attr) {
    DEBUG_OP_printf("load attr %p.%s\n", base, micropy_qstr_str(mp_state, attr));
    // use load_method
    mp_obj_t dest[2];
    micropy_load_method(mp_state, base, attr, dest);
    if (dest[1] == MP_OBJ_NULL) {
        // load_method returned just a normal attribute
        return dest[0];
    } else {
        // load_method returned a method, so build a bound method object
        return micropy_obj_new_bound_meth(mp_state, dest[0], dest[1]);
    }
}

#if MICROPY_BUILTIN_METHOD_CHECK_SELF_ARG

// The following "checked fun" type is local to the mp_convert_member_lookup
// function, and serves to check that the first argument to a builtin function
// has the correct type.

typedef struct _mp_obj_checked_fun_t {
    mp_obj_base_t base;
    const mp_obj_type_t *type;
    mp_obj_t fun;
} mp_obj_checked_fun_t;

STATIC mp_obj_t micropy_checked_fun_call(struct _mp_state_ctx_t *mp_state, mp_obj_t self_in, size_t n_args, size_t n_kw, const mp_obj_t *args) {
    mp_obj_checked_fun_t *self = MP_OBJ_TO_PTR(self_in);
    if (n_args > 0) {
        const mp_obj_type_t *arg0_type = micropy_obj_get_type(mp_state, args[0]);
        if (arg0_type != self->type) {
            if (MICROPY_ERROR_REPORTING != MICROPY_ERROR_REPORTING_DETAILED) {
                micropy_nlr_raise(mp_state, micropy_obj_new_exception_msg(mp_state, &mp_type_TypeError,
                    "argument has wrong type"));
            } else {
                micropy_nlr_raise(mp_state, micropy_obj_new_exception_msg_varg(mp_state, &mp_type_TypeError,
                    "argument should be a '%q' not a '%q'", self->type->name, arg0_type->name));
            }
        }
    }
    return micropy_call_function_n_kw(mp_state, self->fun, n_args, n_kw, args);
}

STATIC const mp_obj_type_t mp_type_checked_fun = {
    { &mp_type_type },
    .name = MP_QSTR_function,
    .call = micropy_checked_fun_call,
};

STATIC mp_obj_t micropy_obj_new_checked_fun(struct _mp_state_ctx_t *mp_state, const mp_obj_type_t *type, mp_obj_t fun) {
    mp_obj_checked_fun_t *o = micropy_m_new_obj(mp_state, mp_obj_checked_fun_t);
    o->base.type = &mp_type_checked_fun;
    o->type = type;
    o->fun = fun;
    return MP_OBJ_FROM_PTR(o);
}

#endif // MICROPY_BUILTIN_METHOD_CHECK_SELF_ARG

// Given a member that was extracted from an instance, convert it correctly
// and put the result in the dest[] array for a possible method call.
// Conversion means dealing with static/class methods, callables, and values.
// see http://docs.python.org/3/howto/descriptor.html
void micropy_convert_member_lookup(struct _mp_state_ctx_t *mp_state, mp_obj_t self, const mp_obj_type_t *type, mp_obj_t member, mp_obj_t *dest) {
    if (MP_OBJ_IS_TYPE(member, &mp_type_staticmethod)) {
        // return just the function
        dest[0] = ((mp_obj_static_class_method_t*)MP_OBJ_TO_PTR(member))->fun;
    } else if (MP_OBJ_IS_TYPE(member, &mp_type_classmethod)) {
        // return a bound method, with self being the type of this object
        // this type should be the type of the original instance, not the base
        // type (which is what is passed in the 'type' argument to this function)
        if (self != MP_OBJ_NULL) {
            type = micropy_obj_get_type(mp_state, self);
        }
        dest[0] = ((mp_obj_static_class_method_t*)MP_OBJ_TO_PTR(member))->fun;
        dest[1] = MP_OBJ_FROM_PTR(type);
    } else if (MP_OBJ_IS_TYPE(member, &mp_type_type)) {
        // Don't try to bind types (even though they're callable)
        dest[0] = member;
    } else if (MP_OBJ_IS_FUN(member)
        || (MP_OBJ_IS_OBJ(member)
            && (((mp_obj_base_t*)MP_OBJ_TO_PTR(member))->type->name == MP_QSTR_closure
                || ((mp_obj_base_t*)MP_OBJ_TO_PTR(member))->type->name == MP_QSTR_generator))) {
        // only functions, closures and generators objects can be bound to self
        #if MICROPY_BUILTIN_METHOD_CHECK_SELF_ARG
        if (self == MP_OBJ_NULL && micropy_obj_get_type(mp_state, member) == &mp_type_fun_builtin) {
            // we extracted a builtin method without a first argument, so we must
            // wrap this function in a type checker
            dest[0] = micropy_obj_new_checked_fun(mp_state, type, member);
        } else
        #endif
        {
            // return a bound method, with self being this object
            dest[0] = member;
            dest[1] = self;
        }
    } else {
        // class member is a value, so just return that value
        dest[0] = member;
    }
}

// no attribute found, returns:     dest[0] == MP_OBJ_NULL, dest[1] == MP_OBJ_NULL
// normal attribute found, returns: dest[0] == <attribute>, dest[1] == MP_OBJ_NULL
// method attribute found, returns: dest[0] == <method>,    dest[1] == <self>
void micropy_load_method_maybe(struct _mp_state_ctx_t *mp_state, mp_obj_t obj, qstr attr, mp_obj_t *dest) {
    // clear output to indicate no attribute/method found yet
    dest[0] = MP_OBJ_NULL;
    dest[1] = MP_OBJ_NULL;

    // get the type
    mp_obj_type_t *type = micropy_obj_get_type(mp_state, obj);

    // look for built-in names
    if (0) {
#if MICROPY_CPYTHON_COMPAT
    } else if (attr == MP_QSTR___class__) {
        // a.__class__ is equivalent to type(a)
        dest[0] = MP_OBJ_FROM_PTR(type);
#endif

    } else if (attr == MP_QSTR___next__ && type->iternext != NULL) {
        dest[0] = MP_OBJ_FROM_PTR(&mp_builtin_next_obj);
        dest[1] = obj;

    } else if (type->attr != NULL) {
        // this type can do its own load, so call it
        type->attr(mp_state, obj, attr, dest);

    } else if (type->locals_dict != NULL) {
        // generic method lookup
        // this is a lookup in the object (ie not class or type)
        assert(type->locals_dict->base.type == &mp_type_dict); // Micro Python restriction, for now
        mp_map_t *locals_map = &type->locals_dict->map;
        mp_map_elem_t *elem = micropy_map_lookup(mp_state, locals_map, MP_OBJ_NEW_QSTR(attr), MP_MAP_LOOKUP);
        if (elem != NULL) {
            micropy_convert_member_lookup(mp_state, obj, type, elem->value, dest);
        }
    }
}

void micropy_load_method(struct _mp_state_ctx_t *mp_state, mp_obj_t base, qstr attr, mp_obj_t *dest) {
    DEBUG_OP_printf("load method %p.%s\n", base, micropy_qstr_str(mp_state, attr));

    micropy_load_method_maybe(mp_state, base, attr, dest);

    if (dest[0] == MP_OBJ_NULL) {
        // no attribute/method called attr
        if (MICROPY_ERROR_REPORTING == MICROPY_ERROR_REPORTING_TERSE) {
            micropy_nlr_raise(mp_state, micropy_obj_new_exception_msg(mp_state, &mp_type_AttributeError,
                "no such attribute"));
        } else {
            // following CPython, we give a more detailed error message for type objects
            if (MP_OBJ_IS_TYPE(base, &mp_type_type)) {
                micropy_nlr_raise(mp_state, micropy_obj_new_exception_msg_varg(mp_state, &mp_type_AttributeError,
                    "type object '%q' has no attribute '%q'",
                    ((mp_obj_type_t*)MP_OBJ_TO_PTR(base))->name, attr));
            } else {
                micropy_nlr_raise(mp_state, micropy_obj_new_exception_msg_varg(mp_state, &mp_type_AttributeError,
                    "'%s' object has no attribute '%q'",
                    micropy_obj_get_type_str(mp_state, base), attr));
            }
        }
    }
}

void micropy_store_attr(struct _mp_state_ctx_t *mp_state, mp_obj_t base, qstr attr, mp_obj_t value) {
    DEBUG_OP_printf("store attr %p.%s <- %p\n", base, micropy_qstr_str(mp_state, attr), value);
    mp_obj_type_t *type = micropy_obj_get_type(mp_state, base);
    if (type->attr != NULL) {
        mp_obj_t dest[2] = {MP_OBJ_SENTINEL, value};
        type->attr(mp_state, base, attr, dest);
        if (dest[0] == MP_OBJ_NULL) {
            // success
            return;
        }
    }
    if (MICROPY_ERROR_REPORTING == MICROPY_ERROR_REPORTING_TERSE) {
        micropy_nlr_raise(mp_state, micropy_obj_new_exception_msg(mp_state, &mp_type_AttributeError,
            "no such attribute"));
    } else {
        micropy_nlr_raise(mp_state, micropy_obj_new_exception_msg_varg(mp_state, &mp_type_AttributeError,
            "'%s' object has no attribute '%q'",
            micropy_obj_get_type_str(mp_state, base), attr));
    }
}

mp_obj_t micropy_getiter(struct _mp_state_ctx_t *mp_state, mp_obj_t o_in) {
    assert(o_in);

    // check for native getiter (corresponds to __iter__)
    mp_obj_type_t *type = micropy_obj_get_type(mp_state, o_in);
    if (type->getiter != NULL) {
        mp_obj_t iter = type->getiter(mp_state, o_in);
        if (iter != MP_OBJ_NULL) {
            return iter;
        }
    }

    // check for __getitem__
    mp_obj_t dest[2];
    micropy_load_method_maybe(mp_state, o_in, MP_QSTR___getitem__, dest);
    if (dest[0] != MP_OBJ_NULL) {
        // __getitem__ exists, create and return an iterator
        return micropy_obj_new_getitem_iter(mp_state, dest);
    }

    // object not iterable
    if (MICROPY_ERROR_REPORTING == MICROPY_ERROR_REPORTING_TERSE) {
        micropy_nlr_raise(mp_state, micropy_obj_new_exception_msg(mp_state, &mp_type_TypeError,
            "object not iterable"));
    } else {
        micropy_nlr_raise(mp_state, micropy_obj_new_exception_msg_varg(mp_state, &mp_type_TypeError,
            "'%s' object is not iterable", micropy_obj_get_type_str(mp_state, o_in)));
    }
}

// may return MP_OBJ_STOP_ITERATION as an optimisation instead of raise StopIteration()
// may also raise StopIteration()
mp_obj_t micropy_iternext_allow_raise(struct _mp_state_ctx_t *mp_state, mp_obj_t o_in) {
    mp_obj_type_t *type = micropy_obj_get_type(mp_state, o_in);
    if (type->iternext != NULL) {
        return type->iternext(mp_state, o_in);
    } else {
        // check for __next__ method
        mp_obj_t dest[2];
        micropy_load_method_maybe(mp_state, o_in, MP_QSTR___next__, dest);
        if (dest[0] != MP_OBJ_NULL) {
            // __next__ exists, call it and return its result
            return micropy_call_method_n_kw(mp_state, 0, 0, dest);
        } else {
            if (MICROPY_ERROR_REPORTING == MICROPY_ERROR_REPORTING_TERSE) {
                micropy_nlr_raise(mp_state, micropy_obj_new_exception_msg(mp_state, &mp_type_TypeError,
                    "object not an iterator"));
            } else {
                micropy_nlr_raise(mp_state, micropy_obj_new_exception_msg_varg(mp_state, &mp_type_TypeError,
                    "'%s' object is not an iterator", micropy_obj_get_type_str(mp_state, o_in)));
            }
        }
    }
}

// will always return MP_OBJ_STOP_ITERATION instead of raising StopIteration() (or any subclass thereof)
// may raise other exceptions
mp_obj_t micropy_iternext(struct _mp_state_ctx_t *mp_state, mp_obj_t o_in) {
    MP_STACK_CHECK(); // enumerate, filter, map and zip can recursively call mp_iternext
    mp_obj_type_t *type = micropy_obj_get_type(mp_state, o_in);
    if (type->iternext != NULL) {
        return type->iternext(mp_state, o_in);
    } else {
        // check for __next__ method
        mp_obj_t dest[2];
        micropy_load_method_maybe(mp_state, o_in, MP_QSTR___next__, dest);
        if (dest[0] != MP_OBJ_NULL) {
            // __next__ exists, call it and return its result
            nlr_buf_t nlr;
            if (micropy_nlr_push(mp_state, &nlr) == 0) {
                mp_obj_t ret = micropy_call_method_n_kw(mp_state, 0, 0, dest);
                micropy_nlr_pop(mp_state);
                return ret;
            } else {
                if (micropy_obj_is_subclass_fast(mp_state, MP_OBJ_FROM_PTR(((mp_obj_base_t*)nlr.ret_val)->type), MP_OBJ_FROM_PTR(&mp_type_StopIteration))) {
                    return MP_OBJ_STOP_ITERATION;
                } else {
                    micropy_nlr_jump(mp_state, nlr.ret_val);
                }
            }
        } else {
            if (MICROPY_ERROR_REPORTING == MICROPY_ERROR_REPORTING_TERSE) {
                micropy_nlr_raise(mp_state, micropy_obj_new_exception_msg(mp_state, &mp_type_TypeError,
                    "object not an iterator"));
            } else {
                micropy_nlr_raise(mp_state, micropy_obj_new_exception_msg_varg(mp_state, &mp_type_TypeError,
                    "'%s' object is not an iterator", micropy_obj_get_type_str(mp_state, o_in)));
            }
        }
    }
}

// TODO: Unclear what to do with StopIterarion exception here.
mp_vm_return_kind_t micropy_resume(struct _mp_state_ctx_t *mp_state, mp_obj_t self_in, mp_obj_t send_value, mp_obj_t throw_value, mp_obj_t *ret_val) {
    assert((send_value != MP_OBJ_NULL) ^ (throw_value != MP_OBJ_NULL));
    mp_obj_type_t *type = micropy_obj_get_type(mp_state, self_in);

    if (type == &mp_type_gen_instance) {
        return micropy_obj_gen_resume(mp_state, self_in, send_value, throw_value, ret_val);
    }

    if (type->iternext != NULL && send_value == mp_const_none) {
        mp_obj_t ret = type->iternext(mp_state, self_in);
        if (ret != MP_OBJ_STOP_ITERATION) {
            *ret_val = ret;
            return MP_VM_RETURN_YIELD;
        } else {
            // Emulate raise StopIteration()
            // Special case, handled in vm.c
            *ret_val = MP_OBJ_NULL;
            return MP_VM_RETURN_NORMAL;
        }
    }

    mp_obj_t dest[3]; // Reserve slot for send() arg

    if (send_value == mp_const_none) {
        micropy_load_method_maybe(mp_state, self_in, MP_QSTR___next__, dest);
        if (dest[0] != MP_OBJ_NULL) {
            *ret_val = micropy_call_method_n_kw(mp_state, 0, 0, dest);
            return MP_VM_RETURN_YIELD;
        }
    }

    if (send_value != MP_OBJ_NULL) {
        micropy_load_method(mp_state, self_in, MP_QSTR_send, dest);
        dest[2] = send_value;
        *ret_val = micropy_call_method_n_kw(mp_state, 1, 0, dest);
        return MP_VM_RETURN_YIELD;
    }

    if (throw_value != MP_OBJ_NULL) {
        if (micropy_obj_is_subclass_fast(mp_state, MP_OBJ_FROM_PTR(micropy_obj_get_type(mp_state, throw_value)), MP_OBJ_FROM_PTR(&mp_type_GeneratorExit))) {
            micropy_load_method_maybe(mp_state, self_in, MP_QSTR_close, dest);
            if (dest[0] != MP_OBJ_NULL) {
                // TODO: Exceptions raised in close() are not propagated,
                // printed to sys.stderr
                *ret_val = micropy_call_method_n_kw(mp_state, 0, 0, dest);
                // We assume one can't "yield" from close()
                return MP_VM_RETURN_NORMAL;
            }
        }
        micropy_load_method_maybe(mp_state, self_in, MP_QSTR_throw, dest);
        if (dest[0] != MP_OBJ_NULL) {
            *ret_val = micropy_call_method_n_kw(mp_state, 1, 0, &throw_value);
            // If .throw() method returned, we assume it's value to yield
            // - any exception would be thrown with nlr_raise().
            return MP_VM_RETURN_YIELD;
        }
        // If there's nowhere to throw exception into, then we assume that object
        // is just incapable to handle it, so any exception thrown into it
        // will be propagated up. This behavior is approved by test_pep380.py
        // test_delegation_of_close_to_non_generator(),
        //  test_delegating_throw_to_non_generator()
        *ret_val = throw_value;
        return MP_VM_RETURN_EXCEPTION;
    }

    assert(0);
    return MP_VM_RETURN_NORMAL; // Should be unreachable
}

mp_obj_t micropy_make_raise_obj(struct _mp_state_ctx_t *mp_state, mp_obj_t o) {
    DEBUG_printf("raise %p\n", o);
    if (micropy_obj_is_exception_type(mp_state, o)) {
        // o is an exception type (it is derived from BaseException (or is BaseException))
        // create and return a new exception instance by calling o
        // TODO could have an option to disable traceback, then builtin exceptions (eg TypeError)
        // could have const instances in ROM which we return here instead
        return micropy_call_function_n_kw(mp_state, o, 0, 0, NULL);
    } else if (micropy_obj_is_exception_instance(mp_state, o)) {
        // o is an instance of an exception, so use it as the exception
        return o;
    } else {
        // o cannot be used as an exception, so return a type error (which will be raised by the caller)
        return micropy_obj_new_exception_msg(mp_state, &mp_type_TypeError, "exceptions must derive from BaseException");
    }
}

mp_obj_t micropy_import_name(struct _mp_state_ctx_t *mp_state, qstr name, mp_obj_t fromlist, mp_obj_t level) {
    DEBUG_printf("import name '%s' level=%d\n", micropy_qstr_str(mp_state, name), MP_OBJ_SMALL_INT_VALUE(level));

    // build args array
    mp_obj_t args[5];
    args[0] = MP_OBJ_NEW_QSTR(name);
    args[1] = mp_const_none; // TODO should be globals
    args[2] = mp_const_none; // TODO should be locals
    args[3] = fromlist;
    args[4] = level; // must be 0; we don't yet support other values

    // TODO lookup __import__ and call that instead of going straight to builtin implementation
    return micropy_builtin___import__(mp_state, 5, args);
}

mp_obj_t micropy_import_from(struct _mp_state_ctx_t *mp_state, mp_obj_t module, qstr name) {
    DEBUG_printf("import from %p %s\n", module, micropy_qstr_str(mp_state, name));

    mp_obj_t dest[2];

    micropy_load_method_maybe(mp_state, module, name, dest);

    if (dest[1] != MP_OBJ_NULL) {
        // Hopefully we can't import bound method from an object
import_error:
        micropy_nlr_raise(mp_state, micropy_obj_new_exception_msg_varg(mp_state, &mp_type_ImportError, "cannot import name %q", name));
    }

    if (dest[0] != MP_OBJ_NULL) {
        return dest[0];
    }

    // See if it's a package, then can try FS import
    if (!micropy_obj_is_package(mp_state, module)) {
        goto import_error;
    }

    micropy_load_method_maybe(mp_state, module, MP_QSTR___name__, dest);
    mp_uint_t pkg_name_len;
    const char *pkg_name = micropy_obj_str_get_data(mp_state, dest[0], &pkg_name_len);

    const uint dot_name_len = pkg_name_len + 1 + micropy_qstr_len(mp_state, name);
    char *dot_name = alloca(dot_name_len);
    memcpy(dot_name, pkg_name, pkg_name_len);
    dot_name[pkg_name_len] = '.';
    memcpy(dot_name + pkg_name_len + 1, micropy_qstr_str(mp_state, name), micropy_qstr_len(mp_state, name));
    qstr dot_name_q = micropy_qstr_from_strn(mp_state, dot_name, dot_name_len);

    mp_obj_t args[5];
    args[0] = MP_OBJ_NEW_QSTR(dot_name_q);
    args[1] = mp_const_none; // TODO should be globals
    args[2] = mp_const_none; // TODO should be locals
    args[3] = mp_const_true; // Pass sentinel "non empty" value to force returning of leaf module
    args[4] = MP_OBJ_NEW_SMALL_INT(0);

    // TODO lookup __import__ and call that instead of going straight to builtin implementation
    return micropy_builtin___import__(mp_state, 5, args);
}

void micropy_import_all(struct _mp_state_ctx_t *mp_state, mp_obj_t module) {
    DEBUG_printf("import all %p\n", module);

    // TODO: Support __all__
    mp_map_t *map = micropy_obj_dict_get_map(mp_state, MP_OBJ_FROM_PTR(micropy_obj_module_get_globals(mp_state, module)));
    for (mp_uint_t i = 0; i < map->alloc; i++) {
        if (MP_MAP_SLOT_IS_FILLED(map, i)) {
            qstr name = MP_OBJ_QSTR_VALUE(map->table[i].key);
            if (*micropy_qstr_str(mp_state, name) != '_') {
                micropy_store_name(mp_state, name, map->table[i].value);
            }
        }
    }
}

#if MICROPY_ENABLE_COMPILER

// this is implemented in this file so it can optimise access to locals/globals
mp_obj_t micropy_parse_compile_execute(struct _mp_state_ctx_t *mp_state, mp_lexer_t *lex, mp_parse_input_kind_t parse_input_kind, mp_obj_dict_t *globals, mp_obj_dict_t *locals) {
    // save context
    mp_obj_dict_t *volatile old_globals = mp_state->dict_globals;
    mp_obj_dict_t *volatile old_locals = mp_state->dict_locals;

    // set new context
    mp_state->dict_globals = globals;
    mp_state->dict_locals = locals;

    nlr_buf_t nlr;
    if (micropy_nlr_push(mp_state, &nlr) == 0) {
        qstr source_name = lex->source_name;
        mp_parse_tree_t parse_tree = micropy_parse(mp_state, lex, parse_input_kind);
        mp_obj_t module_fun = micropy_compile(mp_state, &parse_tree, source_name, MP_EMIT_OPT_NONE, false);

        mp_obj_t ret;
        if (MICROPY_PY_BUILTINS_COMPILE && globals == NULL) {
            // for compile only, return value is the module function
            ret = module_fun;
        } else {
            // execute module function and get return value
            ret = micropy_call_function_0(mp_state, module_fun);
        }

        // finish nlr block, restore context and return value
        micropy_nlr_pop(mp_state);
        mp_state->dict_globals = old_globals;
        mp_state->dict_locals = old_locals;
        return ret;
    } else {
        // exception; restore context and re-raise same exception
        mp_state->dict_globals = old_globals;
        mp_state->dict_locals = old_locals;
        micropy_nlr_jump(mp_state, nlr.ret_val);
    }
}

#endif // MICROPY_ENABLE_COMPILER

void *micropy_m_malloc_fail(struct _mp_state_ctx_t *mp_state, size_t num_bytes) {
    DEBUG_printf("memory allocation failed, allocating %u bytes\n", (uint)num_bytes);
    if (0) {
        // dummy
    #if MICROPY_ENABLE_GC
    } else if (micropy_gc_is_locked(mp_state)) {
        micropy_nlr_raise(mp_state, micropy_obj_new_exception_msg(mp_state, &mp_type_MemoryError,
                                           "memory allocation failed, heap is locked"));
    #endif
    } else {
        micropy_nlr_raise(mp_state, micropy_obj_new_exception_msg_varg(mp_state, &mp_type_MemoryError,
            "memory allocation failed, allocating %u bytes", (uint)num_bytes));
    }
}

NORETURN void micropy_not_implemented(struct _mp_state_ctx_t *mp_state, const char *msg) {
    micropy_nlr_raise(mp_state, micropy_obj_new_exception_msg(mp_state, &mp_type_NotImplementedError, msg));
}
/*
 * This file is part of the Micro Python project, http://micropython.org/
 *
 * The MIT License (MIT)
 *
 * Copyright (c) 2014 Damien P. George
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

#include <stdio.h>
#include <string.h>
#include <assert.h>

//#include "py/nlr.h"
//#include "py/runtime0.h"
//#include "py/runtime.h"
//#include "py/emitglue.h"
//#include "py/bc.h"

#if 0 // print debugging info
#define DEBUG_printf DEBUG_printf
#else // don't print debugging info
#define DEBUG_printf(...) (void)0
#endif

#if MICROPY_EMIT_NATIVE

// convert a Micro Python object to a valid native value based on type
mp_uint_t micropy_convert_obj_to_native(struct _mp_state_ctx_t *mp_state, mp_obj_t obj, mp_uint_t type) {
    DEBUG_printf("mp_convert_obj_to_native(%p, " UINT_FMT ")\n", obj, type);
    switch (type & 0xf) {
        case MP_NATIVE_TYPE_OBJ: return (mp_uint_t)obj;
        case MP_NATIVE_TYPE_BOOL:
        case MP_NATIVE_TYPE_INT:
        case MP_NATIVE_TYPE_UINT: return micropy_obj_get_int_truncated(mp_state, obj);
        default: { // cast obj to a pointer
            mp_buffer_info_t bufinfo;
            if (micropy_get_buffer(mp_state, obj, &bufinfo, MP_BUFFER_RW)) {
                return (mp_uint_t)bufinfo.buf;
            } else {
                // assume obj is an integer that represents an address
                return micropy_obj_get_int_truncated(mp_state, obj);
            }
        }
    }
}

#endif

#if MICROPY_EMIT_NATIVE || MICROPY_EMIT_INLINE_THUMB

// convert a native value to a Micro Python object based on type
mp_obj_t micropy_convert_native_to_obj(struct _mp_state_ctx_t *mp_state, mp_uint_t val, mp_uint_t type) {
    DEBUG_printf("mp_convert_native_to_obj(" UINT_FMT ", " UINT_FMT ")\n", val, type);
    switch (type & 0xf) {
        case MP_NATIVE_TYPE_OBJ: return (mp_obj_t)val;
        case MP_NATIVE_TYPE_BOOL: return micropy_obj_new_bool(mp_state, val);
        case MP_NATIVE_TYPE_INT: return micropy_obj_new_int(mp_state, val);
        case MP_NATIVE_TYPE_UINT: return micropy_obj_new_int_from_uint(mp_state, val);
        default: // a pointer
            // we return just the value of the pointer as an integer
            return micropy_obj_new_int_from_uint(mp_state, val);
    }
}

#endif

#if MICROPY_EMIT_NATIVE

// wrapper that accepts n_args and n_kw in one argument
// (native emitter can only pass at most 3 arguments to a function)
mp_obj_t micropy_native_call_function_n_kw(struct _mp_state_ctx_t *mp_state, mp_obj_t fun_in, mp_uint_t n_args_kw, const mp_obj_t *args) {
    return micropy_call_function_n_kw(mp_state, fun_in, n_args_kw & 0xff, (n_args_kw >> 8) & 0xff, args);
}

// wrapper that makes raise obj and raises it
// END_FINALLY opcode requires that we don't raise if o==None
void micropy_native_raise(struct _mp_state_ctx_t *mp_state, mp_obj_t o) {
    if (o != mp_const_none) {
        micropy_nlr_raise(mp_state, micropy_make_raise_obj(mp_state, o));
    }
}

// these must correspond to the respective enum in runtime0.h
void *const mp_fun_table[MP_F_NUMBER_OF] = {
    mp_convert_obj_to_native,
    mp_convert_native_to_obj,
    mp_load_name,
    mp_load_global,
    mp_load_build_class,
    mp_load_attr,
    mp_load_method,
    mp_store_name,
    mp_store_global,
    mp_store_attr,
    mp_obj_subscr,
    mp_obj_is_true,
    mp_unary_op,
    mp_binary_op,
    mp_obj_new_tuple,
    mp_obj_new_list,
    mp_obj_list_append,
    mp_obj_new_dict,
    mp_obj_dict_store,
#if MICROPY_PY_BUILTINS_SET
    mp_obj_new_set,
    mp_obj_set_store,
#endif
    mp_make_function_from_raw_code,
    mp_native_call_function_n_kw,
    mp_call_method_n_kw,
    mp_call_method_n_kw_var,
    mp_getiter,
    mp_iternext,
    nlr_push,
    nlr_pop,
    mp_native_raise,
    mp_import_name,
    mp_import_from,
    mp_import_all,
#if MICROPY_PY_BUILTINS_SLICE
    mp_obj_new_slice,
#endif
    mp_unpack_sequence,
    mp_unpack_ex,
    mp_delete_name,
    mp_delete_global,
    mp_obj_new_cell,
    mp_make_closure_from_raw_code,
    mp_setup_code_state,
};

/*
void micropy_f_vector(struct _mp_state_ctx_t *mp_state, mp_fun_kind_t fun_kind) {
    (mp_f_table[fun_kind])();
}
*/

#endif // MICROPY_EMIT_NATIVE
/*
 * This file is part of the Micro Python project, http://micropython.org/
 *
 * The MIT License (MIT)
 *
 * Copyright (c) 2014 Paul Sokolovsky
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

//#include "py/mpstate.h"
//#include "py/nlr.h"
//#include "py/obj.h"
//#include "py/runtime.h"
//#include "py/stackctrl.h"

void micropy_stack_ctrl_init(struct _mp_state_ctx_t *mp_state) {
    volatile int stack_dummy;
    (mp_state)->vm.stack_top = (char*)&stack_dummy;
}

void micropy_stack_set_top(struct _mp_state_ctx_t *mp_state, void *top) {
    (mp_state)->vm.stack_top = top;
}

mp_uint_t micropy_stack_usage(struct _mp_state_ctx_t *mp_state) {
    // Assumes descending stack
    volatile int stack_dummy;
    return (mp_state)->vm.stack_top - (char*)&stack_dummy;
}

#if MICROPY_STACK_CHECK

void micropy_stack_set_limit(struct _mp_state_ctx_t *mp_state, mp_uint_t limit) {
    (mp_state)->vm.stack_limit = limit;
}

void micropy_exc_recursion_depth(struct _mp_state_ctx_t *mp_state) {
    micropy_nlr_raise(mp_state, micropy_obj_new_exception_arg1(mp_state, &mp_type_RuntimeError,
        MP_OBJ_NEW_QSTR(MP_QSTR_maximum_space_recursion_space_depth_space_exceeded)));
}

void micropy_stack_check(struct _mp_state_ctx_t *mp_state) {
    if (micropy_stack_usage(mp_state) >= (mp_state)->vm.stack_limit) {
        micropy_exc_recursion_depth(mp_state);
    }
}

#endif // MICROPY_STACK_CHECK
/*
 * This file is part of the Micro Python project, http://micropython.org/
 *
 * The MIT License (MIT)
 *
 * Copyright (c) 2013, 2014 Damien P. George
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

#include <stdlib.h>
#include <assert.h>

//#include "py/nlr.h"
//#include "py/runtime.h"

void micropy_arg_check_num(struct _mp_state_ctx_t *mp_state, size_t n_args, size_t n_kw, size_t n_args_min, size_t n_args_max, bool takes_kw) {
    // TODO maybe take the function name as an argument so we can print nicer error messages

    if (n_kw && !takes_kw) {
        if (MICROPY_ERROR_REPORTING == MICROPY_ERROR_REPORTING_TERSE) {
            micropy_arg_error_terse_mismatch(mp_state);
        } else {
            micropy_nlr_raise(mp_state, micropy_obj_new_exception_msg(mp_state, &mp_type_TypeError,
                "function does not take keyword arguments"));
        }
    }

    if (n_args_min == n_args_max) {
        if (n_args != n_args_min) {
            if (MICROPY_ERROR_REPORTING == MICROPY_ERROR_REPORTING_TERSE) {
                micropy_arg_error_terse_mismatch(mp_state);
            } else {
                micropy_nlr_raise(mp_state, micropy_obj_new_exception_msg_varg(mp_state, &mp_type_TypeError,
                    "function takes %d positional arguments but %d were given",
                    n_args_min, n_args));
            }
        }
    } else {
        if (n_args < n_args_min) {
            if (MICROPY_ERROR_REPORTING == MICROPY_ERROR_REPORTING_TERSE) {
                micropy_arg_error_terse_mismatch(mp_state);
            } else {
                micropy_nlr_raise(mp_state, micropy_obj_new_exception_msg_varg(mp_state, &mp_type_TypeError,
                    "function missing %d required positional arguments",
                    n_args_min - n_args));
            }
        } else if (n_args > n_args_max) {
            if (MICROPY_ERROR_REPORTING == MICROPY_ERROR_REPORTING_TERSE) {
                micropy_arg_error_terse_mismatch(mp_state);
            } else {
                micropy_nlr_raise(mp_state, micropy_obj_new_exception_msg_varg(mp_state, &mp_type_TypeError,
                    "function expected at most %d arguments, got %d",
                    n_args_max, n_args));
            }
        }
    }
}

void micropy_arg_parse_all(struct _mp_state_ctx_t *mp_state, size_t n_pos, const mp_obj_t *pos, mp_map_t *kws, size_t n_allowed, const mp_arg_t *allowed, mp_arg_val_t *out_vals) {
    size_t pos_found = 0, kws_found = 0;
    for (size_t i = 0; i < n_allowed; i++) {
        mp_obj_t given_arg;
        if (i < n_pos) {
            if (allowed[i].flags & MP_ARG_KW_ONLY) {
                goto extra_positional;
            }
            pos_found++;
            given_arg = pos[i];
        } else {
            mp_map_elem_t *kw = micropy_map_lookup(mp_state, kws, MP_OBJ_NEW_QSTR(allowed[i].qst), MP_MAP_LOOKUP);
            if (kw == NULL) {
                if (allowed[i].flags & MP_ARG_REQUIRED) {
                    if (MICROPY_ERROR_REPORTING == MICROPY_ERROR_REPORTING_TERSE) {
                        micropy_arg_error_terse_mismatch(mp_state);
                    } else {
                        micropy_nlr_raise(mp_state, micropy_obj_new_exception_msg_varg(mp_state, &mp_type_TypeError,
                            "'%q' argument required", allowed[i].qst));
                    }
                }
                out_vals[i] = allowed[i].defval;
                continue;
            } else {
                kws_found++;
                given_arg = kw->value;
            }
        }
        if ((allowed[i].flags & MP_ARG_KIND_MASK) == MP_ARG_BOOL) {
            out_vals[i].u_bool = micropy_obj_is_true(mp_state, given_arg);
        } else if ((allowed[i].flags & MP_ARG_KIND_MASK) == MP_ARG_INT) {
            out_vals[i].u_int = micropy_obj_get_int(mp_state, given_arg);
        } else if ((allowed[i].flags & MP_ARG_KIND_MASK) == MP_ARG_OBJ) {
            out_vals[i].u_obj = given_arg;
        } else {
            assert(0);
        }
    }
    if (pos_found < n_pos) {
        extra_positional:
        if (MICROPY_ERROR_REPORTING == MICROPY_ERROR_REPORTING_TERSE) {
            micropy_arg_error_terse_mismatch(mp_state);
        } else {
            // TODO better error message
            micropy_nlr_raise(mp_state, micropy_obj_new_exception_msg(mp_state, &mp_type_TypeError,
                "extra positional arguments given"));
        }
    }
    if (kws_found < kws->used) {
        if (MICROPY_ERROR_REPORTING == MICROPY_ERROR_REPORTING_TERSE) {
            micropy_arg_error_terse_mismatch(mp_state);
        } else {
            // TODO better error message
            micropy_nlr_raise(mp_state, micropy_obj_new_exception_msg(mp_state, &mp_type_TypeError,
                "extra keyword arguments given"));
        }
    }
}

void micropy_arg_parse_all_kw_array(struct _mp_state_ctx_t *mp_state, size_t n_pos, size_t n_kw, const mp_obj_t *args, size_t n_allowed, const mp_arg_t *allowed, mp_arg_val_t *out_vals) {
    mp_map_t kw_args;
    micropy_map_init_fixed_table(mp_state, &kw_args, n_kw, args + n_pos);
    micropy_arg_parse_all(mp_state, n_pos, args, &kw_args, n_allowed, allowed, out_vals);
}

#if MICROPY_ERROR_REPORTING == MICROPY_ERROR_REPORTING_TERSE || _MSC_VER
NORETURN void micropy_arg_error_terse_mismatch(struct _mp_state_ctx_t *mp_state) {
    micropy_nlr_raise(mp_state, micropy_obj_new_exception_msg(mp_state, &mp_type_TypeError, "argument num/types mismatch"));
}
#endif

#if MICROPY_CPYTHON_COMPAT
NORETURN void micropy_arg_error_unimpl_kw(struct _mp_state_ctx_t *mp_state) {
    micropy_not_implemented(mp_state, "keyword micropy_argument(mp_state, s) not yet implemented - use normal args instead");
}
#endif
/*
 * This file is part of the Micro Python project, http://micropython.org/
 *
 * The MIT License (MIT)
 *
 * Copyright (c) 2014 Damien P. George
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

#include <stdarg.h>
#include <stdio.h>

//#include "py/emit.h"
//#include "py/runtime.h"

#if MICROPY_WARNINGS

void micropy_warning(struct _mp_state_ctx_t *mp_state, const char *msg, ...) {
    va_list args;
    va_start(args, msg);
    micropy_print_str(mp_state, &mp_plat_print, "Warning: ");
    micropy_vprintf(mp_state, &mp_plat_print, msg, args);
    micropy_print_str(mp_state, &mp_plat_print, "\n");
}

void micropy_emitter_warning(struct _mp_state_ctx_t *mp_state, pass_kind_t pass, const char *msg) {
    if (pass == MP_PASS_CODE_SIZE) {
        micropy_warning(mp_state, msg, NULL);
    }
}

#endif // MICROPY_WARNINGS
/*
 * This file is part of the Micro Python project, http://micropython.org/
 *
 * The MIT License (MIT)
 *
 * Copyright (c) 2013, 2014 Damien P. George
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>

//#include "py/mpconfig.h"
//#include "py/misc.h"
//#include "py/runtime0.h"
//#include "py/runtime.h"

// Fixed empty map. Useful when need to call kw-receiving functions
// without any keywords from C, etc.
const mp_map_t mp_const_empty_map = {
    .all_keys_are_qstrs = 0,
    .is_fixed = 1,
    .is_ordered = 1,
    .used = 0,
    .alloc = 0,
    .table = NULL,
};

// This table of sizes is used to control the growth of hash tables.
// The first set of sizes are chosen so the allocation fits exactly in a
// 4-word GC block, and it's not so important for these small values to be
// prime.  The latter sizes are prime and increase at an increasing rate.
STATIC const uint16_t hash_allocation_sizes[] = {
    0, 2, 4, 6, 8, 10, 12, // +2
    17, 23, 29, 37, 47, 59, 73, // *1.25
    97, 127, 167, 223, 293, 389, 521, 691, 919, 1223, 1627, 2161, // *1.33
    3229, 4831, 7243, 10861, 16273, 24407, 36607, 54907, // *1.5
};

STATIC mp_uint_t micropy_get_hash_alloc_greater_or_equal_to(struct _mp_state_ctx_t *mp_state, mp_uint_t x) {
    for (size_t i = 0; i < MP_ARRAY_SIZE(hash_allocation_sizes); i++) {
        if (hash_allocation_sizes[i] >= x) {
            return hash_allocation_sizes[i];
        }
    }
    // ran out of primes in the table!
    // return something sensible, at least make it odd
    return (x + x / 2) | 1;
}

/******************************************************************************/
/* map                                                                        */

void micropy_map_init(struct _mp_state_ctx_t *mp_state, mp_map_t *map, mp_uint_t n) {
    if (n == 0) {
        map->alloc = 0;
        map->table = NULL;
    } else {
        map->alloc = n;
        map->table = micropy_m_new0(mp_state, mp_map_elem_t, map->alloc);
    }
    map->used = 0;
    map->all_keys_are_qstrs = 1;
    map->is_fixed = 0;
    map->is_ordered = 0;
}

void micropy_map_init_fixed_table(struct _mp_state_ctx_t *mp_state, mp_map_t *map, mp_uint_t n, const mp_obj_t *table) {
    map->alloc = n;
    map->used = n;
    map->all_keys_are_qstrs = 1;
    map->is_fixed = 1;
    map->is_ordered = 1;
    map->table = (mp_map_elem_t*)table;
}

mp_map_t *micropy_map_new(struct _mp_state_ctx_t *mp_state, mp_uint_t n) {
    mp_map_t *map = micropy_m_new(mp_state, mp_map_t, 1);
    micropy_map_init(mp_state, map, n);
    return map;
}

// Differentiate from mp_map_clear() - semantics is different
void micropy_map_deinit(struct _mp_state_ctx_t *mp_state, mp_map_t *map) {
    if (!map->is_fixed) {
        micropy_m_del(mp_state, mp_map_elem_t, map->table, map->alloc);
    }
    map->used = map->alloc = 0;
}

void micropy_map_free(struct _mp_state_ctx_t *mp_state, mp_map_t *map) {
    micropy_map_deinit(mp_state, map);
    micropy_m_del_obj(mp_state, mp_map_t, map);
}

void micropy_map_clear(struct _mp_state_ctx_t *mp_state, mp_map_t *map) {
    if (!map->is_fixed) {
        micropy_m_del(mp_state, mp_map_elem_t, map->table, map->alloc);
    }
    map->alloc = 0;
    map->used = 0;
    map->all_keys_are_qstrs = 1;
    map->is_fixed = 0;
    map->table = NULL;
}

STATIC void micropy_map_rehash(struct _mp_state_ctx_t *mp_state, mp_map_t *map) {
    mp_uint_t old_alloc = map->alloc;
    mp_uint_t new_alloc = micropy_get_hash_alloc_greater_or_equal_to(mp_state, map->alloc + 1);
    mp_map_elem_t *old_table = map->table;
    mp_map_elem_t *new_table = micropy_m_new0(mp_state, mp_map_elem_t, new_alloc);
    // If we reach this point, table resizing succeeded, now we can edit the old map.
    map->alloc = new_alloc;
    map->used = 0;
    map->all_keys_are_qstrs = 1;
    map->table = new_table;
    for (mp_uint_t i = 0; i < old_alloc; i++) {
        if (old_table[i].key != MP_OBJ_NULL && old_table[i].key != MP_OBJ_SENTINEL) {
            micropy_map_lookup(mp_state, map, old_table[i].key, MP_MAP_LOOKUP_ADD_IF_NOT_FOUND)->value = old_table[i].value;
        }
    }
    micropy_m_del(mp_state, mp_map_elem_t, old_table, old_alloc);
}

// MP_MAP_LOOKUP behaviour:
//  - returns NULL if not found, else the slot it was found in with key,value non-null
// MP_MAP_LOOKUP_ADD_IF_NOT_FOUND behaviour:
//  - returns slot, with key non-null and value=MP_OBJ_NULL if it was added
// MP_MAP_LOOKUP_REMOVE_IF_FOUND behaviour:
//  - returns NULL if not found, else the slot if was found in with key null and value non-null
mp_map_elem_t *micropy_map_lookup(struct _mp_state_ctx_t *mp_state, mp_map_t *map, mp_obj_t index, mp_map_lookup_kind_t lookup_kind) {

    if (map->is_fixed && lookup_kind != MP_MAP_LOOKUP) {
        // can't add/remove from a fixed array
        return NULL;
    }

    // Work out if we can compare just pointers
    bool compare_only_ptrs = map->all_keys_are_qstrs;
    if (compare_only_ptrs) {
        if (MP_OBJ_IS_QSTR(index)) {
            // Index is a qstr, so can just do ptr comparison.
        } else if (MP_OBJ_IS_TYPE(index, &mp_type_str)) {
            // Index is a non-interned string.
            // We can either intern the string, or force a full equality comparison.
            // We chose the latter, since interning costs time and potentially RAM,
            // and it won't necessarily benefit subsequent calls because these calls
            // most likely won't pass the newly-interned string.
            compare_only_ptrs = false;
        } else if (lookup_kind != MP_MAP_LOOKUP_ADD_IF_NOT_FOUND) {
            // If we are not adding, then we can return straight away a failed
            // lookup because we know that the index will never be found.
            return NULL;
        }
    }

    // if the map is an ordered array then we must do a brute force linear search
    if (map->is_ordered) {
        for (mp_map_elem_t *elem = &map->table[0], *top = &map->table[map->used]; elem < top; elem++) {
            if (elem->key == index || (!compare_only_ptrs && micropy_obj_equal(mp_state, elem->key, index))) {
                if (MP_UNLIKELY(lookup_kind == MP_MAP_LOOKUP_REMOVE_IF_FOUND)) {
                    elem->key = MP_OBJ_SENTINEL;
                    // keep elem->value so that caller can access it if needed
                }
                return elem;
            }
        }
        if (MP_LIKELY(lookup_kind != MP_MAP_LOOKUP_ADD_IF_NOT_FOUND)) {
            return NULL;
        }
        // TODO shrink array down over any previously-freed slots
        if (map->used == map->alloc) {
            // TODO: Alloc policy
            map->alloc += 4;
            map->table = micropy_m_renew(mp_state, mp_map_elem_t, map->table, map->used, map->alloc);
            micropy_seq_clear(mp_state, map->table, map->used, map->alloc, sizeof(*map->table));
        }
        mp_map_elem_t *elem = map->table + map->used++;
        elem->key = index;
        if (!MP_OBJ_IS_QSTR(index)) {
            map->all_keys_are_qstrs = 0;
        }
        return elem;
    }

    // map is a hash table (not an ordered array), so do a hash lookup

    if (map->alloc == 0) {
        if (lookup_kind == MP_MAP_LOOKUP_ADD_IF_NOT_FOUND) {
            micropy_map_rehash(mp_state, map);
        } else {
            return NULL;
        }
    }

    // get hash of index, with fast path for common case of qstr
    mp_uint_t hash;
    if (MP_OBJ_IS_QSTR(index)) {
        hash = micropy_qstr_hash(mp_state, MP_OBJ_QSTR_VALUE(index));
    } else {
        hash = MP_OBJ_SMALL_INT_VALUE(micropy_unary_op(mp_state, MP_UNARY_OP_HASH, index));
    }

    mp_uint_t pos = hash % map->alloc;
    mp_uint_t start_pos = pos;
    mp_map_elem_t *avail_slot = NULL;
    for (;;) {
        mp_map_elem_t *slot = &map->table[pos];
        if (slot->key == MP_OBJ_NULL) {
            // found NULL slot, so index is not in table
            if (lookup_kind == MP_MAP_LOOKUP_ADD_IF_NOT_FOUND) {
                map->used += 1;
                if (avail_slot == NULL) {
                    avail_slot = slot;
                }
                avail_slot->key = index;
                avail_slot->value = MP_OBJ_NULL;
                if (!MP_OBJ_IS_QSTR(index)) {
                    map->all_keys_are_qstrs = 0;
                }
                return avail_slot;
            } else {
                return NULL;
            }
        } else if (slot->key == MP_OBJ_SENTINEL) {
            // found deleted slot, remember for later
            if (avail_slot == NULL) {
                avail_slot = slot;
            }
        } else if (slot->key == index || (!compare_only_ptrs && micropy_obj_equal(mp_state, slot->key, index))) {
            // found index
            // Note: CPython does not replace the index; try x={True:'true'};x[1]='one';x
            if (lookup_kind == MP_MAP_LOOKUP_REMOVE_IF_FOUND) {
                // delete element in this slot
                map->used--;
                if (map->table[(pos + 1) % map->alloc].key == MP_OBJ_NULL) {
                    // optimisation if next slot is empty
                    slot->key = MP_OBJ_NULL;
                } else {
                    slot->key = MP_OBJ_SENTINEL;
                }
                // keep slot->value so that caller can access it if needed
            }
            return slot;
        }

        // not yet found, keep searching in this table
        pos = (pos + 1) % map->alloc;

        if (pos == start_pos) {
            // search got back to starting position, so index is not in table
            if (lookup_kind == MP_MAP_LOOKUP_ADD_IF_NOT_FOUND) {
                if (avail_slot != NULL) {
                    // there was an available slot, so use that
                    map->used++;
                    avail_slot->key = index;
                    avail_slot->value = MP_OBJ_NULL;
                    if (!MP_OBJ_IS_QSTR(index)) {
                        map->all_keys_are_qstrs = 0;
                    }
                    return avail_slot;
                } else {
                    // not enough room in table, rehash it
                    micropy_map_rehash(mp_state, map);
                    // restart the search for the new element
                    start_pos = pos = hash % map->alloc;
                }
            } else {
                return NULL;
            }
        }
    }
}

/******************************************************************************/
/* set                                                                        */

#if MICROPY_PY_BUILTINS_SET

void micropy_set_init(struct _mp_state_ctx_t *mp_state, mp_set_t *set, mp_uint_t n) {
    set->alloc = n;
    set->used = 0;
    set->table = micropy_m_new0(mp_state, mp_obj_t, set->alloc);
}

STATIC void micropy_set_rehash(struct _mp_state_ctx_t *mp_state, mp_set_t *set) {
    mp_uint_t old_alloc = set->alloc;
    mp_obj_t *old_table = set->table;
    set->alloc = micropy_get_hash_alloc_greater_or_equal_to(mp_state, set->alloc + 1);
    set->used = 0;
    set->table = micropy_m_new0(mp_state, mp_obj_t, set->alloc);
    for (mp_uint_t i = 0; i < old_alloc; i++) {
        if (old_table[i] != MP_OBJ_NULL && old_table[i] != MP_OBJ_SENTINEL) {
            micropy_set_lookup(mp_state, set, old_table[i], MP_MAP_LOOKUP_ADD_IF_NOT_FOUND);
        }
    }
    micropy_m_del(mp_state, mp_obj_t, old_table, old_alloc);
}

mp_obj_t micropy_set_lookup(struct _mp_state_ctx_t *mp_state, mp_set_t *set, mp_obj_t index, mp_map_lookup_kind_t lookup_kind) {
    // Note: lookup_kind can be MP_MAP_LOOKUP_ADD_IF_NOT_FOUND_OR_REMOVE_IF_FOUND which
    // is handled by using bitwise operations.

    if (set->alloc == 0) {
        if (lookup_kind & MP_MAP_LOOKUP_ADD_IF_NOT_FOUND) {
            micropy_set_rehash(mp_state, set);
        } else {
            return MP_OBJ_NULL;
        }
    }
    mp_uint_t hash = MP_OBJ_SMALL_INT_VALUE(micropy_unary_op(mp_state, MP_UNARY_OP_HASH, index));
    mp_uint_t pos = hash % set->alloc;
    mp_uint_t start_pos = pos;
    mp_obj_t *avail_slot = NULL;
    for (;;) {
        mp_obj_t elem = set->table[pos];
        if (elem == MP_OBJ_NULL) {
            // found NULL slot, so index is not in table
            if (lookup_kind & MP_MAP_LOOKUP_ADD_IF_NOT_FOUND) {
                if (avail_slot == NULL) {
                    avail_slot = &set->table[pos];
                }
                set->used++;
                *avail_slot = index;
                return index;
            } else {
                return MP_OBJ_NULL;
            }
        } else if (elem == MP_OBJ_SENTINEL) {
            // found deleted slot, remember for later
            if (avail_slot == NULL) {
                avail_slot = &set->table[pos];
            }
        } else if (micropy_obj_equal(mp_state, elem, index)) {
            // found index
            if (lookup_kind & MP_MAP_LOOKUP_REMOVE_IF_FOUND) {
                // delete element
                set->used--;
                if (set->table[(pos + 1) % set->alloc] == MP_OBJ_NULL) {
                    // optimisation if next slot is empty
                    set->table[pos] = MP_OBJ_NULL;
                } else {
                    set->table[pos] = MP_OBJ_SENTINEL;
                }
            }
            return elem;
        }

        // not yet found, keep searching in this table
        pos = (pos + 1) % set->alloc;

        if (pos == start_pos) {
            // search got back to starting position, so index is not in table
            if (lookup_kind & MP_MAP_LOOKUP_ADD_IF_NOT_FOUND) {
                if (avail_slot != NULL) {
                    // there was an available slot, so use that
                    set->used++;
                    *avail_slot = index;
                    return index;
                } else {
                    // not enough room in table, rehash it
                    micropy_set_rehash(mp_state, set);
                    // restart the search for the new element
                    start_pos = pos = hash % set->alloc;
                }
            } else {
                return MP_OBJ_NULL;
            }
        }
    }
}

mp_obj_t micropy_set_remove_first(struct _mp_state_ctx_t *mp_state, mp_set_t *set) {
    for (mp_uint_t pos = 0; pos < set->alloc; pos++) {
        if (MP_SET_SLOT_IS_FILLED(set, pos)) {
            mp_obj_t elem = set->table[pos];
            // delete element
            set->used--;
            if (set->table[(pos + 1) % set->alloc] == MP_OBJ_NULL) {
                // optimisation if next slot is empty
                set->table[pos] = MP_OBJ_NULL;
            } else {
                set->table[pos] = MP_OBJ_SENTINEL;
            }
            return elem;
        }
    }
    return MP_OBJ_NULL;
}

void micropy_set_clear(struct _mp_state_ctx_t *mp_state, mp_set_t *set) {
    micropy_m_del(mp_state, mp_obj_t, set->table, set->alloc);
    set->alloc = 0;
    set->used = 0;
    set->table = NULL;
}

#endif // MICROPY_PY_BUILTINS_SET

#if defined(DEBUG_PRINT) && DEBUG_PRINT
void micropy_map_dump(struct _mp_state_ctx_t *mp_state, mp_map_t *map) {
    for (mp_uint_t i = 0; i < map->alloc; i++) {
        if (map->table[i].key != NULL) {
            micropy_obj_print(mp_state, map->table[i].key, PRINT_REPR);
        } else {
            printf("(nil)");
        }
        printf(": %p\n", map->table[i].value);
    }
    printf("---\n");
}
#endif
/*
 * This file is part of the Micro Python project, http://micropython.org/
 *
 * The MIT License (MIT)
 *
 * Copyright (c) 2013, 2014 Damien P. George
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

//#include "py/runtime0.h"
//#include "py/builtin.h"

STATIC mp_obj_t micropy_op_getitem(struct _mp_state_ctx_t *mp_state, mp_obj_t self_in, mp_obj_t key_in) {
    mp_obj_type_t *type = micropy_obj_get_type(mp_state, self_in);
    return type->subscr(mp_state, self_in, key_in, MP_OBJ_SENTINEL);
}
MP_DEFINE_CONST_FUN_OBJ_2(mp_op_getitem_obj, micropy_op_getitem);

STATIC mp_obj_t micropy_op_setitem(struct _mp_state_ctx_t *mp_state, mp_obj_t self_in, mp_obj_t key_in, mp_obj_t value_in) {
    mp_obj_type_t *type = micropy_obj_get_type(mp_state, self_in);
    return type->subscr(mp_state, self_in, key_in, value_in);
}
MP_DEFINE_CONST_FUN_OBJ_3(mp_op_setitem_obj, micropy_op_setitem);

STATIC mp_obj_t micropy_op_delitem(struct _mp_state_ctx_t *mp_state, mp_obj_t self_in, mp_obj_t key_in) {
    mp_obj_type_t *type = micropy_obj_get_type(mp_state, self_in);
    return type->subscr(mp_state, self_in, key_in, MP_OBJ_NULL);
}
MP_DEFINE_CONST_FUN_OBJ_2(mp_op_delitem_obj, micropy_op_delitem);

STATIC mp_obj_t micropy_op_contains(struct _mp_state_ctx_t *mp_state, mp_obj_t lhs_in, mp_obj_t rhs_in) {
    mp_obj_type_t *type = micropy_obj_get_type(mp_state, lhs_in);
    return type->binary_op(mp_state, MP_BINARY_OP_IN, lhs_in, rhs_in);
}
MP_DEFINE_CONST_FUN_OBJ_2(mp_op_contains_obj, micropy_op_contains);
/*
 * This file is part of the Micro Python project, http://micropython.org/
 *
 * The MIT License (MIT)
 *
 * Copyright (c) 2013, 2014 Damien P. George
 * Copyright (c) 2014 Paul Sokolovsky
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

#include <string.h>

//#include "py/nlr.h"
//#include "py/obj.h"
//#include "py/runtime0.h"
//#include "py/runtime.h"

// Helpers for sequence types

#define SWAP(type, var1, var2) { type t = var2; var2 = var1; var1 = t; }

// Implements backend of sequence * integer operation. Assumes elements are
// memory-adjacent in sequence.
void micropy_seq_multiply(struct _mp_state_ctx_t *mp_state, const void *items, mp_uint_t item_sz, mp_uint_t len, mp_uint_t times, void *dest) {
    for (mp_uint_t i = 0; i < times; i++) {
        uint copy_sz = item_sz * len;
        memcpy(dest, items, copy_sz);
        dest = (char*)dest + copy_sz;
    }
}

#if MICROPY_PY_BUILTINS_SLICE

bool micropy_seq_get_fast_slice_indexes(struct _mp_state_ctx_t *mp_state, mp_uint_t len, mp_obj_t slice, mp_bound_slice_t *indexes) {
    mp_obj_t ostart, ostop, ostep;
    mp_int_t start, stop;
    micropy_obj_slice_get(mp_state, slice, &ostart, &ostop, &ostep);

    if (ostart == mp_const_none) {
        start = 0;
    } else {
        start = MP_OBJ_SMALL_INT_VALUE(ostart);
    }
    if (ostop == mp_const_none) {
        stop = len;
    } else {
        stop = MP_OBJ_SMALL_INT_VALUE(ostop);
    }

    // Unlike subscription, out-of-bounds slice indexes are never error
    if (start < 0) {
        start = len + start;
        if (start < 0) {
            start = 0;
        }
    } else if ((mp_uint_t)start > len) {
        start = len;
    }
    if (stop < 0) {
        stop = len + stop;
    } else if ((mp_uint_t)stop > len) {
        stop = len;
    }

    // CPython returns empty sequence in such case, or point for assignment is at start
    if (start > stop) {
        stop = start;
    }

    indexes->start = start;
    indexes->stop = stop;

    if (ostep != mp_const_none && ostep != MP_OBJ_NEW_SMALL_INT(1)) {
        indexes->step = MP_OBJ_SMALL_INT_VALUE(ostep);
        return false;
    }
    indexes->step = 1;
    return true;
}

#endif

mp_obj_t micropy_seq_extract_slice(struct _mp_state_ctx_t *mp_state, mp_uint_t len, const mp_obj_t *seq, mp_bound_slice_t *indexes) {
    (void)len; // TODO can we remove len from the arg list?

    mp_int_t start = indexes->start, stop = indexes->stop;
    mp_int_t step = indexes->step;

    mp_obj_t res = micropy_obj_new_list(mp_state, 0, NULL);

    if (step < 0) {
        stop--;
        while (start <= stop) {
            micropy_obj_list_append(mp_state, res, seq[stop]);
            stop += step;
        }
    } else {
        while (start < stop) {
            micropy_obj_list_append(mp_state, res, seq[start]);
            start += step;
        }
    }
    return res;
}

// Special-case comparison function for sequences of bytes
// Don't pass MP_BINARY_OP_NOT_EQUAL here
bool micropy_seq_cmp_bytes(struct _mp_state_ctx_t *mp_state, mp_uint_t op, const byte *data1, mp_uint_t len1, const byte *data2, mp_uint_t len2) {
    if (op == MP_BINARY_OP_EQUAL && len1 != len2) {
        return false;
    }

    // Let's deal only with > & >=
    if (op == MP_BINARY_OP_LESS || op == MP_BINARY_OP_LESS_EQUAL) {
        SWAP(const byte*, data1, data2);
        SWAP(uint, len1, len2);
        if (op == MP_BINARY_OP_LESS) {
            op = MP_BINARY_OP_MORE;
        } else {
            op = MP_BINARY_OP_MORE_EQUAL;
        }
    }
    uint min_len = len1 < len2 ? len1 : len2;
    int res = memcmp(data1, data2, min_len);
    if (op == MP_BINARY_OP_EQUAL) {
        // If we are checking for equality, here're the answer
        return res == 0;
    }
    if (res < 0) {
        return false;
    }
    if (res > 0) {
        return true;
    }

    // If we had tie in the last element...
    // ... and we have lists of different lengths...
    if (len1 != len2) {
        if (len1 < len2) {
            // ... then longer list length wins (we deal only with >)
            return false;
        }
    } else if (op == MP_BINARY_OP_MORE) {
        // Otherwise, if we have strict relation, equality means failure
        return false;
    }
    return true;
}

// Special-case comparison function for sequences of mp_obj_t
// Don't pass MP_BINARY_OP_NOT_EQUAL here
bool micropy_seq_cmp_objs(struct _mp_state_ctx_t *mp_state, mp_uint_t op, const mp_obj_t *items1, mp_uint_t len1, const mp_obj_t *items2, mp_uint_t len2) {
    if (op == MP_BINARY_OP_EQUAL && len1 != len2) {
        return false;
    }

    // Let's deal only with > & >=
    if (op == MP_BINARY_OP_LESS || op == MP_BINARY_OP_LESS_EQUAL) {
        SWAP(const mp_obj_t *, items1, items2);
        SWAP(uint, len1, len2);
        if (op == MP_BINARY_OP_LESS) {
            op = MP_BINARY_OP_MORE;
        } else {
            op = MP_BINARY_OP_MORE_EQUAL;
        }
    }

    mp_uint_t len = len1 < len2 ? len1 : len2;
    for (mp_uint_t i = 0; i < len; i++) {
        // If current elements equal, can't decide anything - go on
        if (micropy_obj_equal(mp_state, items1[i], items2[i])) {
            continue;
        }

        // Othewise, if they are not equal, we can have final decision based on them
        if (op == MP_BINARY_OP_EQUAL) {
            // In particular, if we are checking for equality, here're the answer
            return false;
        }

        // Otherwise, application of relation op gives the answer
        return (micropy_binary_op(mp_state, op, items1[i], items2[i]) == mp_const_true);
    }

    // If we had tie in the last element...
    // ... and we have lists of different lengths...
    if (len1 != len2) {
        if (len1 < len2) {
            // ... then longer list length wins (we deal only with >)
            return false;
        }
    } else if (op == MP_BINARY_OP_MORE) {
        // Otherwise, if we have strict relation, sequence equality means failure
        return false;
    }

    return true;
}

// Special-case of index() which searches for mp_obj_t
mp_obj_t micropy_seq_index_obj(struct _mp_state_ctx_t *mp_state, const mp_obj_t *items, mp_uint_t len, mp_uint_t n_args, const mp_obj_t *args) {
    mp_obj_type_t *type = micropy_obj_get_type(mp_state, args[0]);
    mp_obj_t value = args[1];
    uint start = 0;
    uint stop = len;

    if (n_args >= 3) {
        start = micropy_get_index(mp_state, type, len, args[2], true);
        if (n_args >= 4) {
            stop = micropy_get_index(mp_state, type, len, args[3], true);
        }
    }

    for (mp_uint_t i = start; i < stop; i++) {
        if (micropy_obj_equal(mp_state, items[i], value)) {
            // Common sense says this cannot overflow small int
            return MP_OBJ_NEW_SMALL_INT(i);
        }
    }

    micropy_nlr_raise(mp_state, micropy_obj_new_exception_msg(mp_state, &mp_type_ValueError, "object not in sequence"));
}

mp_obj_t micropy_seq_count_obj(struct _mp_state_ctx_t *mp_state, const mp_obj_t *items, mp_uint_t len, mp_obj_t value) {
    mp_uint_t count = 0;
    for (uint i = 0; i < len; i++) {
         if (micropy_obj_equal(mp_state, items[i], value)) {
              count++;
         }
    }

    // Common sense says this cannot overflow small int
    return MP_OBJ_NEW_SMALL_INT(count);
}
/*
 * This file is part of the Micro Python project, http://micropython.org/
 *
 * The MIT License (MIT)
 *
 * Copyright (c) 2013, 2014 Damien P. George
 * Copyright (c) 2014 Paul Sokolovsky
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

#include <string.h>
#include <unistd.h>

//#include "py/nlr.h"
//#include "py/objstr.h"
//#include "py/stream.h"
//#include "py/runtime.h"

#if MICROPY_STREAMS_NON_BLOCK
#include <errno.h>
#if defined(__MINGW32__) && !defined(__MINGW64_VERSION_MAJOR)
#define EWOULDBLOCK 140
#endif
#endif

// This file defines generic Python stream read/write methods which
// dispatch to the underlying stream interface of an object.

// TODO: should be in mpconfig.h
#define DEFAULT_BUFFER_SIZE 256

STATIC mp_obj_t micropy_stream_readall(struct _mp_state_ctx_t *mp_state, mp_obj_t self_in);

#define STREAM_CONTENT_TYPE(stream) (((stream)->is_text) ? &mp_type_str : &mp_type_bytes)

// Returns error condition in *errcode, if non-zero, return value is number of bytes written
// before error condition occured. If *errcode == 0, returns total bytes written (which will
// be equal to input size).
mp_uint_t micropy_stream_rw(struct _mp_state_ctx_t *mp_state, mp_obj_t stream, void *buf_, mp_uint_t size, int *errcode, byte flags) {
    byte *buf = buf_;
    mp_obj_base_t* s = (mp_obj_base_t*)MP_OBJ_TO_PTR(stream);
    typedef mp_uint_t (*io_func_t)(struct _mp_state_ctx_t *mp_state, mp_obj_t obj, void *buf, mp_uint_t size, int *errcode);
    io_func_t io_func;
    if (flags & MP_STREAM_RW_WRITE) {
        io_func = (io_func_t)s->type->stream_p->write;
    } else {
        io_func = s->type->stream_p->read;
    }

    *errcode = 0;
    mp_uint_t done = 0;
    while (size > 0) {
        mp_uint_t out_sz = io_func(mp_state, stream, buf, size, errcode);
        // For read, out_sz == 0 means EOF. For write, it's unspecified
        // what it means, but we don't make any progress, so returning
        // is still the best option.
        if (out_sz == 0) {
            return done;
        }
        if (out_sz == MP_STREAM_ERROR) {
            // If we read something before getting EAGAIN, don't leak it
            if (micropy_is_nonblocking_error(mp_state, *errcode) && done != 0) {
                *errcode = 0;
            }
            return done;
        }
        if (flags & MP_STREAM_RW_ONCE) {
            return out_sz;
        }

        buf += out_sz;
        size -= out_sz;
        done += out_sz;
    }
    return done;
}

const mp_stream_p_t *micropy_get_stream_raise(struct _mp_state_ctx_t *mp_state, mp_obj_t self_in, int flags) {
    mp_obj_base_t *o = (mp_obj_base_t*)MP_OBJ_TO_PTR(self_in);
    const mp_stream_p_t *stream_p = o->type->stream_p;
    if (stream_p == NULL
        || ((flags & MP_STREAM_OP_READ) && stream_p->read == NULL)
        || ((flags & MP_STREAM_OP_WRITE) && stream_p->write == NULL)
        || ((flags & MP_STREAM_OP_IOCTL) && stream_p->ioctl == NULL)) {
        // CPython: io.UnsupportedOperation, OSError subclass
        micropy_nlr_raise(mp_state, micropy_obj_new_exception_msg(mp_state, &mp_type_OSError, "stream operation not supported"));
    }
    return stream_p;
}

mp_obj_t micropy_stream_close(struct _mp_state_ctx_t *mp_state, mp_obj_t stream) {
    // TODO: Still consider using ioctl for close
    mp_obj_t dest[2];
    micropy_load_method(mp_state, stream, MP_QSTR_close, dest);
    return micropy_call_method_n_kw(mp_state, 0, 0, dest);
}

STATIC mp_obj_t micropy_stream_read_generic(struct _mp_state_ctx_t *mp_state, size_t n_args, const mp_obj_t *args, byte flags) {
    const mp_stream_p_t *stream_p = micropy_get_stream_raise(mp_state, args[0], MP_STREAM_OP_READ);

    // What to do if sz < -1?  Python docs don't specify this case.
    // CPython does a readall, but here we silently let negatives through,
    // and they will cause a MemoryError.
    mp_int_t sz;
    if (n_args == 1 || ((sz = micropy_obj_get_int(mp_state, args[1])) == -1)) {
        return micropy_stream_readall(mp_state, args[0]);
    }

    #if MICROPY_PY_BUILTINS_STR_UNICODE
    if (stream_p->is_text) {
        // We need to read sz number of unicode characters.  Because we don't have any
        // buffering, and because the stream API can only read bytes, we must read here
        // in units of bytes and must never over read.  If we want sz chars, then reading
        // sz bytes will never over-read, so we follow this approach, in a loop to keep
        // reading until we have exactly enough chars.  This will be 1 read for text
        // with ASCII-only chars, and about 2 reads for text with a couple of non-ASCII
        // chars.  For text with lots of non-ASCII chars, it'll be pretty inefficient
        // in time and memory.

        vstr_t vstr;
        micropy_vstr_init(mp_state, &vstr, sz);
        mp_uint_t more_bytes = sz;
        mp_uint_t last_buf_offset = 0;
        while (more_bytes > 0) {
            char *p = micropy_vstr_add_len(mp_state, &vstr, more_bytes);
            if (p == NULL) {
                micropy_nlr_raise(mp_state, micropy_obj_new_exception_msg_varg(mp_state, &mp_type_MemoryError, "out of memory"));
            }
            int error;
            mp_uint_t out_sz = micropy_stream_read_exactly(mp_state, args[0], p, more_bytes, &error);
            if (error != 0) {
                micropy_vstr_cut_tail_bytes(mp_state, &vstr, more_bytes);
                if (micropy_is_nonblocking_error(mp_state, error)) {
                    // With non-blocking streams, we read as much as we can.
                    // If we read nothing, return None, just like read().
                    // Otherwise, return data read so far.
                    // TODO what if we have read only half a non-ASCII char?
                    if (vstr.len == 0) {
                        micropy_vstr_clear(mp_state, &vstr);
                        return mp_const_none;
                    }
                    break;
                }
                micropy_nlr_raise(mp_state, micropy_obj_new_exception_arg1(mp_state, &mp_type_OSError, MP_OBJ_NEW_SMALL_INT(error)));
            }

            if (out_sz < more_bytes) {
                // Finish reading.
                // TODO what if we have read only half a non-ASCII char?
                micropy_vstr_cut_tail_bytes(mp_state, &vstr, more_bytes - out_sz);
                if (out_sz == 0) {
                    break; 
                }
            }

            // count chars from bytes just read
            for (mp_uint_t off = last_buf_offset;;) {
                byte b = vstr.buf[off];
                int n;
                if (!UTF8_IS_NONASCII(b)) {
                    // 1-byte ASCII char
                    n = 1;
                } else if ((b & 0xe0) == 0xc0) {
                    // 2-byte char
                    n = 2;
                } else if ((b & 0xf0) == 0xe0) {
                    // 3-byte char
                    n = 3;
                } else if ((b & 0xf8) == 0xf0) {
                    // 4-byte char
                    n = 4;
                } else {
                    // TODO
                    n = 5;
                }
                if (off + n <= vstr.len) {
                    // got a whole char in n bytes
                    off += n;
                    sz -= 1;
                    last_buf_offset = off;
                    if (off >= vstr.len) {
                        more_bytes = sz;
                        break;
                    }
                } else {
                    // didn't get a whole char, so work out how many extra bytes are needed for
                    // this partial char, plus bytes for additional chars that we want
                    more_bytes = (off + n - vstr.len) + (sz - 1);
                    break;
                }
            }
        }

        return micropy_obj_new_str_from_vstr(mp_state, &mp_type_str, &vstr);
    }
    #endif

    vstr_t vstr;
    micropy_vstr_init_len(mp_state, &vstr, sz);
    int error;
    mp_uint_t out_sz = micropy_stream_rw(mp_state, args[0], vstr.buf, sz, &error, flags);
    if (error != 0) {
        micropy_vstr_clear(mp_state, &vstr);
        if (micropy_is_nonblocking_error(mp_state, error)) {
            // https://docs.python.org/3.4/library/io.html#io.RawIOBase.read
            // "If the object is in non-blocking mode and no bytes are available,
            // None is returned."
            // This is actually very weird, as naive truth check will treat
            // this as EOF.
            return mp_const_none;
        }
        micropy_nlr_raise(mp_state, micropy_obj_new_exception_arg1(mp_state, &mp_type_OSError, MP_OBJ_NEW_SMALL_INT(error)));
    } else {
        vstr.len = out_sz;
        return micropy_obj_new_str_from_vstr(mp_state, STREAM_CONTENT_TYPE(stream_p), &vstr);
    }
}

STATIC mp_obj_t micropy_stream_read(struct _mp_state_ctx_t *mp_state, size_t n_args, const mp_obj_t *args) {
    return micropy_stream_read_generic(mp_state, n_args, args, MP_STREAM_RW_READ);
}
MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(mp_stream_read_obj, 1, 2, micropy_stream_read);

STATIC mp_obj_t micropy_stream_read1(struct _mp_state_ctx_t *mp_state, size_t n_args, const mp_obj_t *args) {
    return micropy_stream_read_generic(mp_state, n_args, args, MP_STREAM_RW_READ | MP_STREAM_RW_ONCE);
}
MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(mp_stream_read1_obj, 1, 2, micropy_stream_read1);

mp_obj_t micropy_stream_write(struct _mp_state_ctx_t *mp_state, mp_obj_t self_in, const void *buf, size_t len, byte flags) {
    micropy_get_stream_raise(mp_state, self_in, MP_STREAM_OP_WRITE);

    int error;
    mp_uint_t out_sz = micropy_stream_rw(mp_state, self_in, (void*)buf, len, &error, flags);
    if (error != 0) {
        if (micropy_is_nonblocking_error(mp_state, error)) {
            // http://docs.python.org/3/library/io.html#io.RawIOBase.write
            // "None is returned if the raw stream is set not to block and
            // no single byte could be readily written to it."
            return mp_const_none;
        }
        micropy_nlr_raise(mp_state, micropy_obj_new_exception_arg1(mp_state, &mp_type_OSError, MP_OBJ_NEW_SMALL_INT(error)));
    } else {
        return MP_OBJ_NEW_SMALL_INT(out_sz);
    }
}

// XXX hack
void micropy_stream_write_adaptor(struct _mp_state_ctx_t *mp_state, void *self, const char *buf, size_t len) {
    micropy_stream_write(mp_state, MP_OBJ_FROM_PTR(self), buf, len, MP_STREAM_RW_WRITE);
}

STATIC mp_obj_t micropy_stream_write_method(struct _mp_state_ctx_t *mp_state, mp_obj_t self_in, mp_obj_t arg) {
    mp_buffer_info_t bufinfo;
    micropy_get_buffer_raise(mp_state, arg, &bufinfo, MP_BUFFER_READ);
    return micropy_stream_write(mp_state, self_in, bufinfo.buf, bufinfo.len, MP_STREAM_RW_WRITE);
}
MP_DEFINE_CONST_FUN_OBJ_2(mp_stream_write_obj, micropy_stream_write_method);

STATIC mp_obj_t micropy_stream_write1_method(struct _mp_state_ctx_t *mp_state, mp_obj_t self_in, mp_obj_t arg) {
    mp_buffer_info_t bufinfo;
    micropy_get_buffer_raise(mp_state, arg, &bufinfo, MP_BUFFER_READ);
    return micropy_stream_write(mp_state, self_in, bufinfo.buf, bufinfo.len, MP_STREAM_RW_WRITE | MP_STREAM_RW_ONCE);
}
MP_DEFINE_CONST_FUN_OBJ_2(mp_stream_write1_obj, micropy_stream_write1_method);

STATIC mp_obj_t micropy_stream_readinto(struct _mp_state_ctx_t *mp_state, size_t n_args, const mp_obj_t *args) {
    micropy_get_stream_raise(mp_state, args[0], MP_STREAM_OP_READ);
    mp_buffer_info_t bufinfo;
    micropy_get_buffer_raise(mp_state, args[1], &bufinfo, MP_BUFFER_WRITE);

    // CPython extension: if 2nd arg is provided, that's max len to read,
    // instead of full buffer. Similar to
    // https://docs.python.org/3/library/socket.html#socket.socket.recv_into
    mp_uint_t len = bufinfo.len;
    if (n_args > 2) {
        len = micropy_obj_get_int(mp_state, args[2]);
        if (len > bufinfo.len) {
            len = bufinfo.len;
        }
    }

    int error;
    mp_uint_t out_sz = micropy_stream_read_exactly(mp_state, args[0], bufinfo.buf, len, &error);
    if (error != 0) {
        if (micropy_is_nonblocking_error(mp_state, error)) {
            return mp_const_none;
        }
        micropy_nlr_raise(mp_state, micropy_obj_new_exception_arg1(mp_state, &mp_type_OSError, MP_OBJ_NEW_SMALL_INT(error)));
    } else {
        return MP_OBJ_NEW_SMALL_INT(out_sz);
    }
}
MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(mp_stream_readinto_obj, 2, 3, micropy_stream_readinto);

STATIC mp_obj_t micropy_stream_readall(struct _mp_state_ctx_t *mp_state, mp_obj_t self_in) {
    const mp_stream_p_t *stream_p = micropy_get_stream_raise(mp_state, self_in, MP_STREAM_OP_READ);

    mp_uint_t total_size = 0;
    vstr_t vstr;
    micropy_vstr_init(mp_state, &vstr, DEFAULT_BUFFER_SIZE);
    char *p = vstr.buf;
    mp_uint_t current_read = DEFAULT_BUFFER_SIZE;
    while (true) {
        int error;
        mp_uint_t out_sz = stream_p->read(mp_state, self_in, p, current_read, &error);
        if (out_sz == MP_STREAM_ERROR) {
            if (micropy_is_nonblocking_error(mp_state, error)) {
                // With non-blocking streams, we read as much as we can.
                // If we read nothing, return None, just like read().
                // Otherwise, return data read so far.
                if (total_size == 0) {
                    return mp_const_none;
                }
                break;
            }
            micropy_nlr_raise(mp_state, micropy_obj_new_exception_arg1(mp_state, &mp_type_OSError, MP_OBJ_NEW_SMALL_INT(error)));
        }
        if (out_sz == 0) {
            break;
        }
        total_size += out_sz;
        if (out_sz < current_read) {
            current_read -= out_sz;
            p += out_sz;
        } else {
            p = micropy_vstr_extend(mp_state, &vstr, DEFAULT_BUFFER_SIZE);
            current_read = DEFAULT_BUFFER_SIZE;
            if (p == NULL) {
                // TODO
                micropy_nlr_raise(mp_state, micropy_obj_new_exception_msg_varg(mp_state, &mp_type_OSError/*&mp_type_RuntimeError*/, "Out of memory"));
            }
        }
    }

    vstr.len = total_size;
    return micropy_obj_new_str_from_vstr(mp_state, STREAM_CONTENT_TYPE(stream_p), &vstr);
}
MP_DEFINE_CONST_FUN_OBJ_1(mp_stream_readall_obj, micropy_stream_readall);

// Unbuffered, inefficient implementation of readline() for raw I/O files.
STATIC mp_obj_t micropy_stream_unbuffered_readline(struct _mp_state_ctx_t *mp_state, size_t n_args, const mp_obj_t *args) {
    const mp_stream_p_t *stream_p = micropy_get_stream_raise(mp_state, args[0], MP_STREAM_OP_READ);

    mp_int_t max_size = -1;
    if (n_args > 1) {
        max_size = MP_OBJ_SMALL_INT_VALUE(args[1]);
    }

    vstr_t vstr;
    if (max_size != -1) {
        micropy_vstr_init(mp_state, &vstr, max_size);
    } else {
        micropy_vstr_init(mp_state, &vstr, 16);
    }

    while (max_size == -1 || max_size-- != 0) {
        char *p = micropy_vstr_add_len(mp_state, &vstr, 1);
        if (p == NULL) {
            micropy_nlr_raise(mp_state, micropy_obj_new_exception_msg_varg(mp_state, &mp_type_MemoryError, "out of memory"));
        }

        int error;
        mp_uint_t out_sz = stream_p->read(mp_state, args[0], p, 1, &error);
        if (out_sz == MP_STREAM_ERROR) {
            if (micropy_is_nonblocking_error(mp_state, error)) {
                if (vstr.len == 1) {
                    // We just incremented it, but otherwise we read nothing
                    // and immediately got EAGAIN. This is case is not well
                    // specified in
                    // https://docs.python.org/3/library/io.html#io.IOBase.readline
                    // unlike similar case for read(). But we follow the latter's
                    // behavior - return None.
                    micropy_vstr_clear(mp_state, &vstr);
                    return mp_const_none;
                } else {
                    goto done;
                }
            }
            micropy_nlr_raise(mp_state, micropy_obj_new_exception_arg1(mp_state, &mp_type_OSError, MP_OBJ_NEW_SMALL_INT(error)));
        }
        if (out_sz == 0) {
done:
            // Back out previously added byte
            // Consider, what's better - read a char and get OutOfMemory (so read
            // char is lost), or allocate first as we do.
            micropy_vstr_cut_tail_bytes(mp_state, &vstr, 1);
            break;
        }
        if (*p == '\n') {
            break;
        }
    }

    return micropy_obj_new_str_from_vstr(mp_state, STREAM_CONTENT_TYPE(stream_p), &vstr);
}
MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(mp_stream_unbuffered_readline_obj, 1, 2, micropy_stream_unbuffered_readline);

// TODO take an optional extra argument (what does it do exactly?)
STATIC mp_obj_t micropy_stream_unbuffered_readlines(struct _mp_state_ctx_t *mp_state, mp_obj_t self) {
    mp_obj_t lines = micropy_obj_new_list(mp_state, 0, NULL);
    for (;;) {
        mp_obj_t line = micropy_stream_unbuffered_readline(mp_state, 1, &self);
        if (!micropy_obj_is_true(mp_state, line)) {
            break;
        }
        micropy_obj_list_append(mp_state, lines, line);
    }
    return lines;
}
MP_DEFINE_CONST_FUN_OBJ_1(mp_stream_unbuffered_readlines_obj, micropy_stream_unbuffered_readlines);

mp_obj_t micropy_stream_unbuffered_iter(struct _mp_state_ctx_t *mp_state, mp_obj_t self) {
    mp_obj_t l_in = micropy_stream_unbuffered_readline(mp_state, 1, &self);
    if (micropy_obj_is_true(mp_state, l_in)) {
        return l_in;
    }
    return MP_OBJ_STOP_ITERATION;
}

STATIC mp_obj_t micropy_stream_seek(struct _mp_state_ctx_t *mp_state, size_t n_args, const mp_obj_t *args) {
    const mp_stream_p_t *stream_p = micropy_get_stream_raise(mp_state, args[0], MP_STREAM_OP_IOCTL);

    struct mp_stream_seek_t seek_s;
    // TODO: Could be uint64
    seek_s.offset = micropy_obj_get_int(mp_state, args[1]);
    seek_s.whence = 0;
    if (n_args == 3) {
        seek_s.whence = micropy_obj_get_int(mp_state, args[2]);
    }

    int error;
    mp_uint_t res = stream_p->ioctl(mp_state, args[0], MP_STREAM_SEEK, (mp_uint_t)(uintptr_t)&seek_s, &error);
    if (res == MP_STREAM_ERROR) {
        micropy_nlr_raise(mp_state, micropy_obj_new_exception_arg1(mp_state, &mp_type_OSError, MP_OBJ_NEW_SMALL_INT(error)));
    }

    // TODO: Could be uint64
    return micropy_obj_new_int_from_uint(mp_state, seek_s.offset);
}
MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(mp_stream_seek_obj, 2, 3, micropy_stream_seek);

STATIC mp_obj_t micropy_stream_tell(struct _mp_state_ctx_t *mp_state, mp_obj_t self) {
    mp_obj_t offset = MP_OBJ_NEW_SMALL_INT(0);
    mp_obj_t whence = MP_OBJ_NEW_SMALL_INT(SEEK_CUR);
    const mp_obj_t args[3] = {self, offset, whence};
    return micropy_stream_seek(mp_state, 3, args);
}
MP_DEFINE_CONST_FUN_OBJ_1(mp_stream_tell_obj, micropy_stream_tell);

STATIC mp_obj_t micropy_stream_ioctl(struct _mp_state_ctx_t *mp_state, size_t n_args, const mp_obj_t *args) {
    const mp_stream_p_t *stream_p = micropy_get_stream_raise(mp_state, args[0], MP_STREAM_OP_IOCTL);

    mp_buffer_info_t bufinfo;
    uintptr_t val = 0;
    if (n_args > 2) {
        if (micropy_get_buffer(mp_state, args[2], &bufinfo, MP_BUFFER_WRITE)) {
            val = (uintptr_t)bufinfo.buf;
        } else {
            val = micropy_obj_get_int_truncated(mp_state, args[2]);
        }
    }

    int error;
    mp_uint_t res = stream_p->ioctl(mp_state, args[0], micropy_obj_get_int(mp_state, args[1]), val, &error);
    if (res == MP_STREAM_ERROR) {
        micropy_nlr_raise(mp_state, micropy_obj_new_exception_arg1(mp_state, &mp_type_OSError, MP_OBJ_NEW_SMALL_INT(error)));
    }

    return micropy_obj_new_int(mp_state, res);
}
MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(mp_stream_ioctl_obj, 2, 3, micropy_stream_ioctl);
/*
 * This file is part of the Micro Python project, http://micropython.org/
 *
 * The MIT License (MIT)
 *
 * Copyright (c) 2013, 2014 Damien P. George
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

#include <stdint.h>
#include <stdlib.h>
#include <stddef.h>
#include <string.h>
#include <assert.h>

//#include "py/binary.h"
//#include "py/smallint.h"
//#include "py/objint.h"

// Helpers to work with binary-encoded data

#ifndef alignof
#define micropy_alignof(mp_state, type) offsetof(struct { char c; type t; }, t)
#endif

size_t micropy_binary_get_size(struct _mp_state_ctx_t *mp_state, char struct_type, char val_type, mp_uint_t *palign) {
    size_t size = 0;
    int align = 1;
    switch (struct_type) {
        case '<': case '>':
            switch (val_type) {
                case 'b': case 'B':
                    size = 1; break;
                case 'h': case 'H':
                    size = 2; break;
                case 'i': case 'I':
                    size = 4; break;
                case 'l': case 'L':
                    size = 4; break;
                case 'q': case 'Q':
                    size = 8; break;
                case 'P': case 'O': case 'S':
                    size = sizeof(void*); break;
                case 'f':
                    size = sizeof(float); break;
                case 'd':
                    size = sizeof(double); break;
            }
            break;
        case '@': {
            // TODO:
            // The simplest heuristic for alignment is to align by value
            // size, but that doesn't work for "bigger than int" types,
            // for example, long long may very well have long alignment
            // So, we introduce separate alignment handling, but having
            // formal support for that is different from actually supporting
            // particular (or any) ABI.
            switch (val_type) {
                case BYTEARRAY_TYPECODE:
                case 'b': case 'B':
                    align = size = 1; break;
                case 'h': case 'H':
                    align = micropy_alignof(mp_state, short);
                    size = sizeof(short); break;
                case 'i': case 'I':
                    align = micropy_alignof(mp_state, int);
                    size = sizeof(int); break;
                case 'l': case 'L':
                    align = micropy_alignof(mp_state, long);
                    size = sizeof(long); break;
                case 'q': case 'Q':
                    align = micropy_alignof(mp_state, long long);
                    size = sizeof(long long); break;
                case 'P': case 'O': case 'S':
                    align = micropy_alignof(mp_state, void*);
                    size = sizeof(void*); break;
                case 'f':
                    align = micropy_alignof(mp_state, float);
                    size = sizeof(float); break;
                case 'd':
                    align = micropy_alignof(mp_state, double);
                    size = sizeof(double); break;
            }
        }
    }
    if (palign != NULL) {
        *palign = align;
    }
    return size;
}

mp_obj_t micropy_binary_get_val_array(struct _mp_state_ctx_t *mp_state, char typecode, void *p, mp_uint_t index) {
    mp_int_t val = 0;
    switch (typecode) {
        case 'b':
            val = ((signed char*)p)[index];
            break;
        case BYTEARRAY_TYPECODE:
        case 'B':
            val = ((unsigned char*)p)[index];
            break;
        case 'h':
            val = ((short*)p)[index];
            break;
        case 'H':
            val = ((unsigned short*)p)[index];
            break;
        case 'i':
            return micropy_obj_new_int(mp_state, ((int*)p)[index]);
        case 'I':
            return micropy_obj_new_int_from_uint(mp_state, ((unsigned int*)p)[index]);
        case 'l':
            return micropy_obj_new_int(mp_state, ((long*)p)[index]);
        case 'L':
            return micropy_obj_new_int_from_uint(mp_state, ((unsigned long*)p)[index]);
        #if MICROPY_LONGINT_IMPL != MICROPY_LONGINT_IMPL_NONE
        case 'q':
            return micropy_obj_new_int_from_ll(mp_state, ((long long*)p)[index]);
        case 'Q':
            return micropy_obj_new_int_from_ull(mp_state, ((unsigned long long*)p)[index]);
        #endif
#if MICROPY_PY_BUILTINS_FLOAT
        case 'f':
            return micropy_obj_new_float(mp_state, ((float*)p)[index]);
        case 'd':
            return micropy_obj_new_float(mp_state, ((double*)p)[index]);
#endif
        // Extension to CPython: array of objects
        case 'O':
            return ((mp_obj_t*)p)[index];
        // Extension to CPython: array of pointers
        case 'P':
            return micropy_obj_new_int(mp_state, (mp_int_t)(uintptr_t)((void**)p)[index]);
    }
    return MP_OBJ_NEW_SMALL_INT(val);
}

// The long long type is guaranteed to hold at least 64 bits, and size is at
// most 8 (for q and Q), so we will always be able to parse the given data
// and fit it into a long long.
long long micropy_binary_get_int(struct _mp_state_ctx_t *mp_state, mp_uint_t size, bool is_signed, bool big_endian, const byte *src) {
    int delta;
    if (!big_endian) {
        delta = -1;
        src += size - 1;
    } else {
        delta = 1;
    }

    long long val = 0;
    if (is_signed && *src & 0x80) {
        val = -1;
    }
    for (uint i = 0; i < size; i++) {
        val <<= 8;
        val |= *src;
        src += delta;
    }

    return val;
}

#define micropy_is_signed(mp_state, typecode) (typecode > 'Z')
mp_obj_t micropy_binary_get_val(struct _mp_state_ctx_t *mp_state, char struct_type, char val_type, byte **ptr) {
    byte *p = *ptr;
    mp_uint_t align;

    size_t size = micropy_binary_get_size(mp_state, struct_type, val_type, &align);
    if (struct_type == '@') {
        // Make pointer aligned
        p = (byte*)MP_ALIGN(p, (size_t)align);
        #if MP_ENDIANNESS_LITTLE
        struct_type = '<';
        #else
        struct_type = '>';
        #endif
    }
    *ptr = p + size;

    long long val = micropy_binary_get_int(mp_state, size, micropy_is_signed(mp_state, val_type), (struct_type == '>'), p);

    if (val_type == 'O') {
        return (mp_obj_t)(mp_uint_t)val;
    } else if (val_type == 'S') {
        const char *s_val = (const char*)(uintptr_t)(mp_uint_t)val;
        return micropy_obj_new_str(mp_state, s_val, strlen(s_val), false);
#if MICROPY_PY_BUILTINS_FLOAT
    } else if (val_type == 'f') {
        union { uint32_t i; float f; } fpu = {val};
        return micropy_obj_new_float(mp_state, fpu.f);
    } else if (val_type == 'd') {
        union { uint64_t i; double f; } fpu = {val};
        return micropy_obj_new_float(mp_state, fpu.f);
#endif
    } else if (micropy_is_signed(mp_state, val_type)) {
        if ((long long)MP_SMALL_INT_MIN <= val && val <= (long long)MP_SMALL_INT_MAX) {
            return micropy_obj_new_int(mp_state, (mp_int_t)val);
        } else {
            return micropy_obj_new_int_from_ll(mp_state, val);
        }
    } else {
        if ((unsigned long long)val <= (unsigned long long)MP_SMALL_INT_MAX) {
            return micropy_obj_new_int_from_uint(mp_state, (mp_uint_t)val);
        } else {
            return micropy_obj_new_int_from_ull(mp_state, val);
        }
    }
}

void micropy_binary_set_int(struct _mp_state_ctx_t *mp_state, mp_uint_t val_sz, bool big_endian, byte *dest, mp_uint_t val) {
    if (MP_ENDIANNESS_LITTLE && !big_endian) {
        memcpy(dest, &val, val_sz);
    } else if (MP_ENDIANNESS_BIG && big_endian) {
        // only copy the least-significant val_sz bytes
        memcpy(dest, (byte*)&val + sizeof(mp_uint_t) - val_sz, val_sz);
    } else {
        const byte *src;
        if (MP_ENDIANNESS_LITTLE) {
            src = (const byte*)&val + val_sz;
        } else {
            src = (const byte*)&val + sizeof(mp_uint_t);
        }
        while (val_sz--) {
            *dest++ = *--src;
        }
    }
}

void micropy_binary_set_val(struct _mp_state_ctx_t *mp_state, char struct_type, char val_type, mp_obj_t val_in, byte **ptr) {
    byte *p = *ptr;
    mp_uint_t align;

    size_t size = micropy_binary_get_size(mp_state, struct_type, val_type, &align);
    if (struct_type == '@') {
        // Make pointer aligned
        p = (byte*)MP_ALIGN(p, (size_t)align);
        if (MP_ENDIANNESS_LITTLE) {
            struct_type = '<';
        } else {
            struct_type = '>';
        }
    }
    *ptr = p + size;

    mp_uint_t val;
    switch (val_type) {
        case 'O':
            val = (mp_uint_t)val_in;
            break;
#if MICROPY_PY_BUILTINS_FLOAT
        case 'f': {
            union { uint32_t i; float f; } fp_sp;
            fp_sp.f = micropy_obj_get_float(mp_state, val_in);
            val = fp_sp.i;
            break;
        }
        case 'd': {
            union { uint64_t i64; uint32_t i32[2]; double f; } fp_dp;
            fp_dp.f = micropy_obj_get_float(mp_state, val_in);
            if (BYTES_PER_WORD == 8) {
                val = fp_dp.i64;
            } else {
                int be = struct_type == '>';
                micropy_binary_set_int(mp_state, sizeof(uint32_t), be, p, fp_dp.i32[MP_ENDIANNESS_BIG ^ be]);
                p += sizeof(uint32_t);
                val = fp_dp.i32[MP_ENDIANNESS_LITTLE ^ be];
            }
            break;
        }
#endif
        default:
            #if MICROPY_LONGINT_IMPL != MICROPY_LONGINT_IMPL_NONE
            if (MP_OBJ_IS_TYPE(val_in, &mp_type_int)) {
                micropy_obj_int_to_bytes_impl(mp_state, val_in, struct_type == '>', size, p);
                return;
            } else
            #endif
            {
                val = micropy_obj_get_int(mp_state, val_in);
                // sign extend if needed
                if (BYTES_PER_WORD < 8 && size > sizeof(val) && micropy_is_signed(mp_state, val_type) && (mp_int_t)val < 0) {
                    memset(p + sizeof(val), 0xff, size - sizeof(val));
                }
            }
    }

    micropy_binary_set_int(mp_state, MIN((size_t)size, sizeof(val)), struct_type == '>', p, val);
}

void micropy_binary_set_val_array(struct _mp_state_ctx_t *mp_state, char typecode, void *p, mp_uint_t index, mp_obj_t val_in) {
    switch (typecode) {
#if MICROPY_PY_BUILTINS_FLOAT
        case 'f':
            ((float*)p)[index] = micropy_obj_get_float(mp_state, val_in);
            break;
        case 'd':
            ((double*)p)[index] = micropy_obj_get_float(mp_state, val_in);
            break;
#endif
        // Extension to CPython: array of objects
        case 'O':
            ((mp_obj_t*)p)[index] = val_in;
            break;
        default:
            #if MICROPY_LONGINT_IMPL != MICROPY_LONGINT_IMPL_NONE
            if ((typecode | 0x20) == 'q' && MP_OBJ_IS_TYPE(val_in, &mp_type_int)) {
                micropy_obj_int_to_bytes_impl(mp_state, val_in, MP_ENDIANNESS_BIG,
                    sizeof(long long), (byte*)&((long long*)p)[index]);
                return;
            }
            #endif
            micropy_binary_set_val_array_from_int(mp_state, typecode, p, index, micropy_obj_get_int(mp_state, val_in));
    }
}

void micropy_binary_set_val_array_from_int(struct _mp_state_ctx_t *mp_state, char typecode, void *p, mp_uint_t index, mp_int_t val) {
    switch (typecode) {
        case 'b':
            ((signed char*)p)[index] = val;
            break;
        case BYTEARRAY_TYPECODE:
        case 'B':
            ((unsigned char*)p)[index] = val;
            break;
        case 'h':
            ((short*)p)[index] = val;
            break;
        case 'H':
            ((unsigned short*)p)[index] = val;
            break;
        case 'i':
            ((int*)p)[index] = val;
            break;
        case 'I':
            ((unsigned int*)p)[index] = val;
            break;
        case 'l':
            ((long*)p)[index] = val;
            break;
        case 'L':
            ((unsigned long*)p)[index] = val;
            break;
        #if MICROPY_LONGINT_IMPL != MICROPY_LONGINT_IMPL_NONE
        case 'q':
            ((long long*)p)[index] = val;
        case 'Q':
            ((unsigned long long*)p)[index] = val;
            break;
        #endif
#if MICROPY_PY_BUILTINS_FLOAT
        case 'f':
            ((float*)p)[index] = val;
            break;
        case 'd':
            ((double*)p)[index] = val;
            break;
#endif
        // Extension to CPython: array of pointers
        case 'P':
            ((void**)p)[index] = (void*)(uintptr_t)val;
    }
}
/*
 * This file is part of the Micro Python project, http://micropython.org/
 *
 * The MIT License (MIT)
 *
 * Copyright (c) 2013, 2014 Damien P. George
 * Copyright (c) 2014 Paul Sokolovsky
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

#include <stdio.h>
#include <string.h>
#include <assert.h>

//#include "py/nlr.h"
//#include "py/compile.h"
//#include "py/objmodule.h"
//#include "py/runtime.h"
//#include "py/builtin.h"
//#include "py/frozenmod.h"

#if 0 // print debugging info
#define DEBUG_PRINT (1)
#define DEBUG_printf DEBUG_printf
#else // don't print debugging info
#define DEBUG_PRINT (0)
#define DEBUG_printf(...) (void)0
#endif

#define PATH_SEP_CHAR '/'

#if MICROPY_MODULE_WEAK_LINKS
STATIC const mp_rom_map_elem_t mp_builtin_module_weak_links_table[] = {
    MICROPY_PORT_BUILTIN_MODULE_WEAK_LINKS
};

STATIC MP_DEFINE_CONST_MAP(mp_builtin_module_weak_links_map, mp_builtin_module_weak_links_table);
#endif

bool micropy_obj_is_package(struct _mp_state_ctx_t *mp_state, mp_obj_t module) {
    mp_obj_t dest[2];
    micropy_load_method_maybe(mp_state, module, MP_QSTR___path__, dest);
    return dest[0] != MP_OBJ_NULL;
}

// Stat either frozen or normal module by a given path
// (whatever is available, if at all).
STATIC mp_import_stat_t micropy_import_stat_any(struct _mp_state_ctx_t *mp_state, const char *path) {
    #if MICROPY_MODULE_FROZEN
    mp_import_stat_t st = micropy_frozen_stat(mp_state, path);
    if (st != MP_IMPORT_STAT_NO_EXIST) {
        return st;
    }
    #endif
    return micropy_import_stat(mp_state, path);
}

STATIC mp_import_stat_t micropy_stat_dir_or_file(struct _mp_state_ctx_t *mp_state, vstr_t *path) {
    mp_import_stat_t stat = micropy_import_stat_any(mp_state, micropy_vstr_null_terminated_str(mp_state, path));
    DEBUG_printf("stat %s: %d\n", micropy_vstr_str(mp_state, path), stat);
    if (stat == MP_IMPORT_STAT_DIR) {
        return stat;
    }

    micropy_vstr_add_str(mp_state, path, ".py");
    stat = micropy_import_stat_any(mp_state, micropy_vstr_null_terminated_str(mp_state, path));
    if (stat == MP_IMPORT_STAT_FILE) {
        return stat;
    }

    #if MICROPY_PERSISTENT_CODE_LOAD
    micropy_vstr_ins_byte(mp_state, path, path->len - 2, 'm');
    stat = micropy_import_stat_any(mp_state, micropy_vstr_null_terminated_str(mp_state, path));
    if (stat == MP_IMPORT_STAT_FILE) {
        return stat;
    }
    #endif

    return MP_IMPORT_STAT_NO_EXIST;
}

STATIC mp_import_stat_t micropy_find_file(struct _mp_state_ctx_t *mp_state, const char *file_str, uint file_len, vstr_t *dest) {
#if MICROPY_PY_SYS
    // extract the list of paths
    mp_uint_t path_num;
    mp_obj_t *path_items;
    micropy_obj_list_get(mp_state, mp_sys_path, &path_num, &path_items);

    if (path_num == 0) {
#endif
        // mp_sys_path is empty, so just use the given file name
        micropy_vstr_add_strn(mp_state, dest, file_str, file_len);
        return micropy_stat_dir_or_file(mp_state, dest);
#if MICROPY_PY_SYS
    } else {
        // go through each path looking for a directory or file
        for (mp_uint_t i = 0; i < path_num; i++) {
            micropy_vstr_reset(mp_state, dest);
            mp_uint_t p_len;
            const char *p = micropy_obj_str_get_data(mp_state, path_items[i], &p_len);
            if (p_len > 0) {
                micropy_vstr_add_strn(mp_state, dest, p, p_len);
                micropy_vstr_add_char(mp_state, dest, PATH_SEP_CHAR);
            }
            micropy_vstr_add_strn(mp_state, dest, file_str, file_len);
            mp_import_stat_t stat = micropy_stat_dir_or_file(mp_state, dest);
            if (stat != MP_IMPORT_STAT_NO_EXIST) {
                return stat;
            }
        }

        // could not find a directory or file
        return MP_IMPORT_STAT_NO_EXIST;
    }
#endif
}

#if MICROPY_ENABLE_COMPILER
STATIC void micropy_do_load_from_lexer(struct _mp_state_ctx_t *mp_state, mp_obj_t module_obj, mp_lexer_t *lex, const char *fname) {

    if (lex == NULL) {
        // we verified the file exists using stat, but lexer could still fail
        if (MICROPY_ERROR_REPORTING == MICROPY_ERROR_REPORTING_TERSE) {
            micropy_nlr_raise(mp_state, micropy_obj_new_exception_msg(mp_state, &mp_type_ImportError, "module not found"));
        } else {
            micropy_nlr_raise(mp_state, micropy_obj_new_exception_msg_varg(mp_state, &mp_type_ImportError,
                "no module named '%s'", fname));
        }
    }

    #if MICROPY_PY___FILE__
    qstr source_name = lex->source_name;
    micropy_store_attr(mp_state, module_obj, MP_QSTR___file__, MP_OBJ_NEW_QSTR(source_name));
    #endif

    // parse, compile and execute the module in its context
    mp_obj_dict_t *mod_globals = micropy_obj_module_get_globals(mp_state, module_obj);
    micropy_parse_compile_execute(mp_state, lex, MP_PARSE_FILE_INPUT, mod_globals, mod_globals);
}
#endif

#if MICROPY_PERSISTENT_CODE_LOAD || MICROPY_MODULE_FROZEN_MPY
STATIC void micropy_do_execute_raw_code(struct _mp_state_ctx_t *mp_state, mp_obj_t module_obj, mp_raw_code_t *raw_code) {
    #if MICROPY_PY___FILE__
    // TODO
    //qstr source_name = lex->source_name;
    //mp_store_attr(module_obj, MP_QSTR___file__, MP_OBJ_NEW_QSTR(source_name));
    #endif

    // execute the module in its context
    mp_obj_dict_t *mod_globals = micropy_obj_module_get_globals(mp_state, module_obj);

    // save context
    mp_obj_dict_t *volatile old_globals = mp_state->dict_globals;
    mp_obj_dict_t *volatile old_locals = mp_state->dict_locals;

    // set new context
    mp_state->dict_globals = mod_globals;
    mp_state->dict_locals = mod_globals;

    nlr_buf_t nlr;
    if (micropy_nlr_push(mp_state, &nlr) == 0) {
        mp_obj_t module_fun = micropy_make_function_from_raw_code(mp_state, raw_code, MP_OBJ_NULL, MP_OBJ_NULL);
        micropy_call_function_0(mp_state, module_fun);

        // finish nlr block, restore context
        micropy_nlr_pop(mp_state);
        mp_state->dict_globals = old_globals;
        mp_state->dict_locals = old_locals;
    } else {
        // exception; restore context and re-raise same exception
        mp_state->dict_globals = old_globals;
        mp_state->dict_locals = old_locals;
        micropy_nlr_jump(mp_state, nlr.ret_val);
    }
}
#endif

STATIC void micropy_do_load(struct _mp_state_ctx_t *mp_state, mp_obj_t module_obj, vstr_t *file) {
    #if MICROPY_MODULE_FROZEN || MICROPY_PERSISTENT_CODE_LOAD || MICROPY_ENABLE_COMPILER
    char *file_str = micropy_vstr_null_terminated_str(mp_state, file);
    #endif

    // If we support frozen modules (either as str or mpy) then try to find the
    // requested filename in the list of frozen module filenames.
    #if MICROPY_MODULE_FROZEN
    void *modref;
    int frozen_type = micropy_find_frozen_module(mp_state, file_str, file->len, &modref);
    #endif

    // If we support frozen str modules and the compiler is enabled, and we
    // found the filename in the list of frozen files, then load and execute it.
    #if MICROPY_MODULE_FROZEN_STR
    if (frozen_type == MP_FROZEN_STR) {
        micropy_do_load_from_lexer(mp_state, module_obj, modref, file_str);
        return;
    }
    #endif

    // If we support frozen mpy modules and we found a corresponding file (and
    // its data) in the list of frozen files, execute it.
    #if MICROPY_MODULE_FROZEN_MPY
    if (frozen_type == MP_FROZEN_MPY) {
        micropy_do_execute_raw_code(mp_state, module_obj, modref);
        return;
    }
    #endif

    // If we support loading .mpy files then check if the file extension is of
    // the correct format and, if so, load and execute the file.
    #if MICROPY_PERSISTENT_CODE_LOAD
    if (file_str[file->len - 3] == 'm') {
        mp_raw_code_t *raw_code = micropy_raw_code_load_file(mp_state, file_str);
        micropy_do_execute_raw_code(mp_state, module_obj, raw_code);
        return;
    }
    #endif

    // If we can compile scripts then load the file and compile and execute it.
    #if MICROPY_ENABLE_COMPILER
    {
        mp_lexer_t *lex = micropy_lexer_new_from_file(mp_state, file_str);
        micropy_do_load_from_lexer(mp_state, module_obj, lex, file_str);
        return;
    }
    #endif

    // If we get here then the file was not frozen and we can't compile scripts.
    micropy_nlr_raise(mp_state, micropy_obj_new_exception_msg_varg(mp_state, &mp_type_ImportError,
        "script compilation not supported"));
}

STATIC void micropy_chop_component(struct _mp_state_ctx_t *mp_state, const char *start, const char **end) {
    const char *p = *end;
    while (p > start) {
        if (*--p == '.') {
            *end = p;
            return;
        }
    }
    *end = p;
}

mp_obj_t micropy_builtin___import__(struct _mp_state_ctx_t *mp_state, size_t n_args, const mp_obj_t *args) {
#if DEBUG_PRINT
    DEBUG_printf("__import__:\n");
    for (mp_uint_t i = 0; i < n_args; i++) {
        DEBUG_printf("  ");
        micropy_obj_print(mp_state, args[i], PRINT_REPR);
        DEBUG_printf("\n");
    }
#endif

    mp_obj_t module_name = args[0];
    mp_obj_t fromtuple = mp_const_none;
    mp_int_t level = 0;
    if (n_args >= 4) {
        fromtuple = args[3];
        if (n_args >= 5) {
            level = MP_OBJ_SMALL_INT_VALUE(args[4]);
        }
    }

    mp_uint_t mod_len;
    const char *mod_str = micropy_obj_str_get_data(mp_state, module_name, &mod_len);

    if (level != 0) {
        // What we want to do here is to take name of current module,
        // chop <level> trailing components, and concatenate with passed-in
        // module name, thus resolving relative import name into absolue.
        // This even appears to be correct per
        // http://legacy.python.org/dev/peps/pep-0328/#relative-imports-and-name
        // "Relative imports use a module's __name__ attribute to determine that
        // module's position in the package hierarchy."
        level--;
        mp_obj_t this_name_q = micropy_obj_dict_get(mp_state, MP_OBJ_FROM_PTR(mp_state->dict_globals), MP_OBJ_NEW_QSTR(MP_QSTR___name__));
        assert(this_name_q != MP_OBJ_NULL);
        #if MICROPY_CPYTHON_COMPAT
        if (MP_OBJ_QSTR_VALUE(this_name_q) == MP_QSTR___main__) {
            // This is a module run by -m command-line switch, get its real name from backup attribute
            this_name_q = micropy_obj_dict_get(mp_state, MP_OBJ_FROM_PTR(mp_state->dict_globals), MP_OBJ_NEW_QSTR(MP_QSTR___main__));
        }
        #endif
        mp_map_t *globals_map = &mp_state->dict_globals->map;
        mp_map_elem_t *elem = micropy_map_lookup(mp_state, globals_map, MP_OBJ_NEW_QSTR(MP_QSTR___path__), MP_MAP_LOOKUP);
        bool is_pkg = (elem != NULL);

#if DEBUG_PRINT
        DEBUG_printf("Current module/package: ");
        micropy_obj_print(mp_state, this_name_q, PRINT_REPR);
        DEBUG_printf(", is_package: %d", is_pkg);
        DEBUG_printf("\n");
#endif

        mp_uint_t this_name_l;
        const char *this_name = micropy_obj_str_get_data(mp_state, this_name_q, &this_name_l);

        const char *p = this_name + this_name_l;
        if (!is_pkg) {
            // We have module, but relative imports are anchored at package, so
            // go there.
            micropy_chop_component(mp_state, this_name, &p);
        }


        uint dots_seen = 0;
        while (level--) {
            micropy_chop_component(mp_state, this_name, &p);
            dots_seen++;
        }

        if (dots_seen == 0 && level >= 1) {
            // http://legacy.python.org/dev/peps/pep-0328/#relative-imports-and-name
            // "If the module's name does not contain any package information
            // (e.g. it is set to '__main__') then relative imports are
            // resolved as if the module were a top level module, regardless
            // of where the module is actually located on the file system."
            // Supposedly this if catches this condition and resolve it properly
            // TODO: But nobody knows for sure. This condition happens when
            // package's __init__.py does something like "import .submod". So,
            // maybe we should check for package here? But quote above doesn't
            // talk about packages, it talks about dot-less module names.
            DEBUG_printf("Warning: no dots in current module name and level>0\n");
            p = this_name + this_name_l;
        } else if (level != -1) {
            micropy_nlr_raise(mp_state, micropy_obj_new_exception_msg(mp_state, &mp_type_ImportError, "Invalid relative import"));
        }

        uint new_mod_l = (mod_len == 0 ? (size_t)(p - this_name) : (size_t)(p - this_name) + 1 + mod_len);
        char *new_mod = alloca(new_mod_l);
        memcpy(new_mod, this_name, p - this_name);
        if (mod_len != 0) {
            new_mod[p - this_name] = '.';
            memcpy(new_mod + (p - this_name) + 1, mod_str, mod_len);
        }

        qstr new_mod_q = micropy_qstr_from_strn(mp_state, new_mod, new_mod_l);
        DEBUG_printf("Resolved base name for relative import: '%s'\n", micropy_qstr_str(mp_state, new_mod_q));
        if (new_mod_q == MP_QSTR_) {
            // CPython raises SystemError
            micropy_nlr_raise(mp_state, micropy_obj_new_exception_msg(mp_state, &mp_type_ImportError, "cannot perform relative import"));
        }
        module_name = MP_OBJ_NEW_QSTR(new_mod_q);
        mod_str = new_mod;
        mod_len = new_mod_l;
    }

    // check if module already exists
    qstr module_name_qstr = micropy_obj_str_get_qstr(mp_state, module_name);
    mp_obj_t module_obj = micropy_module_get(mp_state, module_name_qstr);
    if (module_obj != MP_OBJ_NULL) {
        DEBUG_printf("Module already loaded\n");
        // If it's not a package, return module right away
        char *p = strchr(mod_str, '.');
        if (p == NULL) {
            return module_obj;
        }
        // If fromlist is not empty, return leaf module
        if (fromtuple != mp_const_none) {
            return module_obj;
        }
        // Otherwise, we need to return top-level package
        qstr pkg_name = micropy_qstr_from_strn(mp_state, mod_str, p - mod_str);
        return micropy_module_get(mp_state, pkg_name);
    }
    DEBUG_printf("Module not yet loaded\n");

    uint last = 0;
    VSTR_FIXED(path, MICROPY_ALLOC_PATH_MAX)
    module_obj = MP_OBJ_NULL;
    mp_obj_t top_module_obj = MP_OBJ_NULL;
    mp_obj_t outer_module_obj = MP_OBJ_NULL;
    uint i;
    for (i = 1; i <= mod_len; i++) {
        if (i == mod_len || mod_str[i] == '.') {
            // create a qstr for the module name up to this depth
            qstr mod_name = micropy_qstr_from_strn(mp_state, mod_str, i);
            DEBUG_printf("Processing module: %s\n", micropy_qstr_str(mp_state, mod_name));
            DEBUG_printf("Previous path: =%.*s=\n", micropy_vstr_len(mp_state, &path), micropy_vstr_str(mp_state, &path));

            // find the file corresponding to the module name
            mp_import_stat_t stat;
            if (micropy_vstr_len(mp_state, &path) == 0) {
                // first module in the dotted-name; search for a directory or file
                stat = micropy_find_file(mp_state, mod_str, i, &path);
            } else {
                // latter module in the dotted-name; append to path
                micropy_vstr_add_char(mp_state, &path, PATH_SEP_CHAR);
                micropy_vstr_add_strn(mp_state, &path, mod_str + last, i - last);
                stat = micropy_stat_dir_or_file(mp_state, &path);
            }
            DEBUG_printf("Current path: %.*s\n", micropy_vstr_len(mp_state, &path), micropy_vstr_str(mp_state, &path));

            if (stat == MP_IMPORT_STAT_NO_EXIST) {
                #if MICROPY_MODULE_WEAK_LINKS
                // check if there is a weak link to this module
                if (i == mod_len) {
                    mp_map_elem_t *el = micropy_map_lookup(mp_state, (mp_map_t*)&mp_builtin_module_weak_links_map, MP_OBJ_NEW_QSTR(mod_name), MP_MAP_LOOKUP);
                    if (el == NULL) {
                        goto no_exist;
                    }
                    // found weak linked module
                    module_obj = el->value;
                } else {
                    no_exist:
                #else
                {
                #endif
                    // couldn't find the file, so fail
                    if (MICROPY_ERROR_REPORTING == MICROPY_ERROR_REPORTING_TERSE) {
                        micropy_nlr_raise(mp_state, micropy_obj_new_exception_msg(mp_state, &mp_type_ImportError, "module not found"));
                    } else {
                        micropy_nlr_raise(mp_state, micropy_obj_new_exception_msg_varg(mp_state, &mp_type_ImportError,
                            "no module named '%q'", mod_name));
                    }
                }
            } else {
                // found the file, so get the module
                module_obj = micropy_module_get(mp_state, mod_name);
            }

            if (module_obj == MP_OBJ_NULL) {
                // module not already loaded, so load it!

                module_obj = micropy_obj_new_module(mp_state, mod_name);

                // if args[3] (fromtuple) has magic value False, set up
                // this module for command-line "-m" option (set module's
                // name to __main__ instead of real name).
                if (i == mod_len && fromtuple == mp_const_false) {
                    mp_obj_module_t *o = MP_OBJ_TO_PTR(module_obj);
                    micropy_obj_dict_store(mp_state, MP_OBJ_FROM_PTR(o->globals), MP_OBJ_NEW_QSTR(MP_QSTR___name__), MP_OBJ_NEW_QSTR(MP_QSTR___main__));
                    #if MICROPY_CPYTHON_COMPAT
                    // Store real name in "__main__" attribute. Choosen semi-randonly, to reuse existing qstr's.
                    micropy_obj_dict_store(mp_state, MP_OBJ_FROM_PTR(o->globals), MP_OBJ_NEW_QSTR(MP_QSTR___main__), MP_OBJ_NEW_QSTR(mod_name));
                    #endif
                }

                if (stat == MP_IMPORT_STAT_DIR) {
                    DEBUG_printf("%.*s is dir\n", micropy_vstr_len(mp_state, &path), micropy_vstr_str(mp_state, &path));
                    // https://docs.python.org/3/reference/import.html
                    // "Specifically, any module that contains a __path__ attribute is considered a package."
                    micropy_store_attr(mp_state, module_obj, MP_QSTR___path__, micropy_obj_new_str(mp_state, micropy_vstr_str(mp_state, &path), micropy_vstr_len(mp_state, &path), false));
                    micropy_vstr_add_char(mp_state, &path, PATH_SEP_CHAR);
                    micropy_vstr_add_str(mp_state, &path, "__init__.py");
                    if (micropy_import_stat_any(mp_state, micropy_vstr_null_terminated_str(mp_state, &path)) != MP_IMPORT_STAT_FILE) {
                        micropy_vstr_cut_tail_bytes(mp_state, &path, sizeof("/__init__.py") - 1); // cut off /__init__.py
                        micropy_warning(mp_state, "%s is imported as namespace package", micropy_vstr_str(mp_state, &path));
                    } else {
                        micropy_do_load(mp_state, module_obj, &path);
                        micropy_vstr_cut_tail_bytes(mp_state, &path, sizeof("/__init__.py") - 1); // cut off /__init__.py
                    }
                } else { // MP_IMPORT_STAT_FILE
                    micropy_do_load(mp_state, module_obj, &path);
                    // TODO: We cannot just break here, at the very least, we must execute
                    // trailer code below. But otherwise if there're remaining components,
                    // that would be (??) object path within module, not modules path within FS.
                    // break;
                }
            }
            if (outer_module_obj != MP_OBJ_NULL) {
                qstr s = micropy_qstr_from_strn(mp_state, mod_str + last, i - last);
                micropy_store_attr(mp_state, outer_module_obj, s, module_obj);
            }
            outer_module_obj = module_obj;
            if (top_module_obj == MP_OBJ_NULL) {
                top_module_obj = module_obj;
            }
            last = i + 1;
        }
    }

    if (i < mod_len) {
        // we loaded a package, now need to load objects from within that package
        // TODO
        assert(0);
    }

    // If fromlist is not empty, return leaf module
    if (fromtuple != mp_const_none) {
        return module_obj;
    }
    // Otherwise, we need to return top-level package
    return top_module_obj;
}
MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(mp_builtin___import___obj, 1, 5, micropy_builtin___import__);
/*
 * This file is part of the Micro Python project, http://micropython.org/
 *
 * The MIT License (MIT)
 *
 * Copyright (c) 2013, 2014 Damien P. George
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

#include <stdint.h>

//#include "py/nlr.h"
//#include "py/objfun.h"
//#include "py/compile.h"
//#include "py/runtime.h"
//#include "py/builtin.h"

#if MICROPY_PY_BUILTINS_COMPILE

typedef struct _mp_obj_code_t {
    mp_obj_base_t base;
    mp_obj_t module_fun;
} mp_obj_code_t;

STATIC const mp_obj_type_t mp_type_code = {
    { &mp_type_type },
    .name = MP_QSTR_code,
};

STATIC mp_obj_t micropy_code_execute(struct _mp_state_ctx_t *mp_state, mp_obj_code_t *self, mp_obj_dict_t *globals, mp_obj_dict_t *locals) {
    // save context and set new context
    mp_obj_dict_t *old_globals = mp_state->dict_globals;
    mp_obj_dict_t *old_locals = mp_state->dict_locals;
    mp_state->dict_globals = globals;
    mp_state->dict_locals = locals;

    // a bit of a hack: fun_bc will re-set globals, so need to make sure it's
    // the correct one
    if (MP_OBJ_IS_TYPE(self->module_fun, &mp_type_fun_bc)) {
        mp_obj_fun_bc_t *fun_bc = MP_OBJ_TO_PTR(self->module_fun);
        fun_bc->globals = globals;
    }

    // execute code
    nlr_buf_t nlr;
    if (micropy_nlr_push(mp_state, &nlr) == 0) {
        mp_obj_t ret = micropy_call_function_0(mp_state, self->module_fun);
        micropy_nlr_pop(mp_state);
        mp_state->dict_globals = old_globals;
        mp_state->dict_locals = old_locals;
        return ret;
    } else {
        // exception; restore context and re-raise same exception
        mp_state->dict_globals = old_globals;
        mp_state->dict_locals = old_locals;
        micropy_nlr_jump(mp_state, nlr.ret_val);
    }
}

STATIC mp_obj_t micropy_builtin_compile(struct _mp_state_ctx_t *mp_state, size_t n_args, const mp_obj_t *args) {
    (void)n_args;

    // get the source
    mp_uint_t str_len;
    const char *str = micropy_obj_str_get_data(mp_state, args[0], &str_len);

    // get the filename
    qstr filename = micropy_obj_str_get_qstr(mp_state, args[1]);

    // create the lexer
    mp_lexer_t *lex = micropy_lexer_new_from_str_len(mp_state, filename, str, str_len, 0);

    // get the compile mode
    qstr mode = micropy_obj_str_get_qstr(mp_state, args[2]);
    mp_parse_input_kind_t parse_input_kind;
    switch (mode) {
        case MP_QSTR_single: parse_input_kind = MP_PARSE_SINGLE_INPUT; break;
        case MP_QSTR_exec: parse_input_kind = MP_PARSE_FILE_INPUT; break;
        case MP_QSTR_eval: parse_input_kind = MP_PARSE_EVAL_INPUT; break;
        default:
            micropy_nlr_raise(mp_state, micropy_obj_new_exception_msg(mp_state, &mp_type_ValueError, "bad compile mode"));
    }

    mp_obj_code_t *code = micropy_m_new_obj(mp_state, mp_obj_code_t);
    code->base.type = &mp_type_code;
    code->module_fun = micropy_parse_compile_execute(mp_state, lex, parse_input_kind, NULL, NULL);
    return MP_OBJ_FROM_PTR(code);
}
MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(mp_builtin_compile_obj, 3, 6, micropy_builtin_compile);

#endif // MICROPY_PY_BUILTINS_COMPILE

#if MICROPY_PY_BUILTINS_EVAL_EXEC

STATIC mp_obj_t micropy_eval_exec_helper(struct _mp_state_ctx_t *mp_state, size_t n_args, const mp_obj_t *args, mp_parse_input_kind_t parse_input_kind) {
    // work out the context
    mp_obj_dict_t *globals = mp_state->dict_globals;
    mp_obj_dict_t *locals = mp_state->dict_locals;
    if (n_args > 1) {
        globals = MP_OBJ_TO_PTR(args[1]);
        if (n_args > 2) {
            locals = MP_OBJ_TO_PTR(args[2]);
        } else {
            locals = globals;
        }
    }

    #if MICROPY_PY_BUILTINS_COMPILE
    if (MP_OBJ_IS_TYPE(args[0], &mp_type_code)) {
        return micropy_code_execute(mp_state, MP_OBJ_TO_PTR(args[0]), globals, locals);
    }
    #endif

    mp_uint_t str_len;
    const char *str = micropy_obj_str_get_data(mp_state, args[0], &str_len);

    // create the lexer
    // MP_PARSE_SINGLE_INPUT is used to indicate a file input
    mp_lexer_t *lex;
    if (MICROPY_PY_BUILTINS_EXECFILE && parse_input_kind == MP_PARSE_SINGLE_INPUT) {
        lex = micropy_lexer_new_from_file(mp_state, str);
        if (lex == NULL) {
            micropy_nlr_raise(mp_state, micropy_obj_new_exception_msg_varg(mp_state, &mp_type_OSError, "could not open file '%s'", str));
        }
        parse_input_kind = MP_PARSE_FILE_INPUT;
    } else {
        lex = micropy_lexer_new_from_str_len(mp_state, MP_QSTR__lt_string_gt_, str, str_len, 0);
    }

    return micropy_parse_compile_execute(mp_state, lex, parse_input_kind, globals, locals);
}

STATIC mp_obj_t micropy_builtin_eval(struct _mp_state_ctx_t *mp_state, size_t n_args, const mp_obj_t *args) {
    return micropy_eval_exec_helper(mp_state, n_args, args, MP_PARSE_EVAL_INPUT);
}
MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(mp_builtin_eval_obj, 1, 3, micropy_builtin_eval);

STATIC mp_obj_t micropy_builtin_exec(struct _mp_state_ctx_t *mp_state, size_t n_args, const mp_obj_t *args) {
    return micropy_eval_exec_helper(mp_state, n_args, args, MP_PARSE_FILE_INPUT);
}
MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(mp_builtin_exec_obj, 1, 3, micropy_builtin_exec);

#endif // MICROPY_PY_BUILTINS_EVAL_EXEC

#if MICROPY_PY_BUILTINS_EXECFILE
STATIC mp_obj_t micropy_builtin_execfile(struct _mp_state_ctx_t *mp_state, size_t n_args, const mp_obj_t *args) {
    // MP_PARSE_SINGLE_INPUT is used to indicate a file input
    return micropy_eval_exec_helper(mp_state, n_args, args, MP_PARSE_SINGLE_INPUT);
}
MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(mp_builtin_execfile_obj, 1, 3, micropy_builtin_execfile);
#endif
/*
 * This file is part of the Micro Python project, http://micropython.org/
 *
 * The MIT License (MIT)
 *
 * Copyright (c) 2013, 2014 Damien P. George
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

#include <stdint.h>
#include <stdio.h>
#include <stdarg.h>
#include <assert.h>

//#include "py/nlr.h"
//#include "py/obj.h"
//#include "py/objtype.h"
//#include "py/objint.h"
//#include "py/objstr.h"
//#include "py/runtime0.h"
//#include "py/runtime.h"
//#include "py/stackctrl.h"
//#include "py/stream.h" // for mp_obj_print

mp_obj_type_t *micropy_obj_get_type(struct _mp_state_ctx_t *mp_state, mp_const_obj_t o_in) {
    if (MP_OBJ_IS_SMALL_INT(o_in)) {
        return (mp_obj_type_t*)&mp_type_int;
    } else if (MP_OBJ_IS_QSTR(o_in)) {
        return (mp_obj_type_t*)&mp_type_str;
    #if MICROPY_PY_BUILTINS_FLOAT
    } else if (micropy_obj_is_float(mp_state, o_in)) {
        return (mp_obj_type_t*)&mp_type_float;
    #endif
    } else {
        const mp_obj_base_t *o = MP_OBJ_TO_PTR(o_in);
        return (mp_obj_type_t*)o->type;
    }
}

const char *micropy_obj_get_type_str(struct _mp_state_ctx_t *mp_state, mp_const_obj_t o_in) {
    return micropy_qstr_str(mp_state, micropy_obj_get_type(mp_state, o_in)->name);
}

void micropy_obj_print_helper(struct _mp_state_ctx_t *mp_state, const mp_print_t *print, mp_obj_t o_in, mp_print_kind_t kind) {
    // There can be data structures nested too deep, or just recursive
    MP_STACK_CHECK();
#ifndef NDEBUG
    if (o_in == MP_OBJ_NULL) {
        micropy_print_str(mp_state, print, "(nil)");
        return;
    }
#endif
    mp_obj_type_t *type = micropy_obj_get_type(mp_state, o_in);
    if (type->print != NULL) {
        type->print(mp_state, (mp_print_t*)print, o_in, kind);
    } else {
        micropy_printf(mp_state, print, "<%q>", type->name);
    }
}

void micropy_obj_print(struct _mp_state_ctx_t *mp_state, mp_obj_t o_in, mp_print_kind_t kind) {
#if MICROPY_PY_IO
    micropy_obj_print_helper(mp_state, &mp_sys_stdout_print, o_in, kind);
#else
    micropy_obj_print_helper(mp_state, &mp_plat_print, o_in, kind);
#endif
}

// helper function to print an exception with traceback
void micropy_obj_print_exception(struct _mp_state_ctx_t *mp_state, const mp_print_t *print, mp_obj_t exc) {
    if (micropy_obj_is_exception_instance(mp_state, exc)) {
        size_t n, *values;
        micropy_obj_exception_get_traceback(mp_state, exc, &n, &values);
        if (n > 0) {
            assert(n % 3 == 0);
            micropy_print_str(mp_state, print, "Traceback (most recent call last):\n");
            for (int i = n - 3; i >= 0; i -= 3) {
#if MICROPY_ENABLE_SOURCE_LINE
                micropy_printf(mp_state, print, "  File \"%q\", line %d", values[i], (int)values[i + 1]);
#else
                micropy_printf(mp_state, print, "  File \"%q\"", values[i]);
#endif
                // the block name can be NULL if it's unknown
                qstr block = values[i + 2];
                if (block == MP_QSTR_NULL) {
                    micropy_print_str(mp_state, print, "\n");
                } else {
                    micropy_printf(mp_state, print, ", in %q\n", block);
                }
            }
        }
    }
    micropy_obj_print_helper(mp_state, print, exc, PRINT_EXC);
    micropy_print_str(mp_state, print, "\n");
}

bool micropy_obj_is_true(struct _mp_state_ctx_t *mp_state, mp_obj_t arg) {
    if (arg == mp_const_false) {
        return 0;
    } else if (arg == mp_const_true) {
        return 1;
    } else if (arg == mp_const_none) {
        return 0;
    } else if (MP_OBJ_IS_SMALL_INT(arg)) {
        if (MP_OBJ_SMALL_INT_VALUE(arg) == 0) {
            return 0;
        } else {
            return 1;
        }
    } else {
        mp_obj_type_t *type = micropy_obj_get_type(mp_state, arg);
        if (type->unary_op != NULL) {
            mp_obj_t result = type->unary_op(mp_state, MP_UNARY_OP_BOOL, arg);
            if (result != MP_OBJ_NULL) {
                return result == mp_const_true;
            }
        }

        mp_obj_t len = micropy_obj_len_maybe(mp_state, arg);
        if (len != MP_OBJ_NULL) {
            // obj has a length, truth determined if len != 0
            return len != MP_OBJ_NEW_SMALL_INT(0);
        } else {
            // any other obj is true per Python semantics
            return 1;
        }
    }
}

bool micropy_obj_is_callable(struct _mp_state_ctx_t *mp_state, mp_obj_t o_in) {
    mp_call_fun_t call = micropy_obj_get_type(mp_state, o_in)->call;
    if (call != micropy_obj_instance_call) {
        return call != NULL;
    }
    return micropy_obj_instance_is_callable(mp_state, o_in);
}

// This function implements the '==' operator (and so the inverse of '!=').
//
// From the Python language reference:
// (https://docs.python.org/3/reference/expressions.html#not-in)
// "The objects need not have the same type. If both are numbers, they are converted
// to a common type. Otherwise, the == and != operators always consider objects of
// different types to be unequal."
//
// This means that False==0 and True==1 are true expressions.
//
// Furthermore, from the v3.4.2 code for object.c: "Practical amendments: If rich
// comparison returns NotImplemented, == and != are decided by comparing the object
// pointer."
bool micropy_obj_equal(struct _mp_state_ctx_t *mp_state, mp_obj_t o1, mp_obj_t o2) {
    if (o1 == o2) {
        return true;
    }
    if (o1 == mp_const_none || o2 == mp_const_none) {
        return false;
    }

    // fast path for small ints
    if (MP_OBJ_IS_SMALL_INT(o1)) {
        if (MP_OBJ_IS_SMALL_INT(o2)) {
            // both SMALL_INT, and not equal if we get here
            return false;
        } else {
            mp_obj_t temp = o2; o2 = o1; o1 = temp;
            // o2 is now the SMALL_INT, o1 is not
            // fall through to generic op
        }
    }

    // fast path for strings
    if (MP_OBJ_IS_STR(o1)) {
        if (MP_OBJ_IS_STR(o2)) {
            // both strings, use special function
            return micropy_obj_str_equal(mp_state, o1, o2);
        } else {
            // a string is never equal to anything else
            return false;
        }
    } else if (MP_OBJ_IS_STR(o2)) {
        // o1 is not a string (else caught above), so the objects are not equal
        return false;
    }

    // generic type, call binary_op(MP_BINARY_OP_EQUAL)
    mp_obj_type_t *type = micropy_obj_get_type(mp_state, o1);
    if (type->binary_op != NULL) {
        mp_obj_t r = type->binary_op(mp_state, MP_BINARY_OP_EQUAL, o1, o2);
        if (r != MP_OBJ_NULL) {
            return r == mp_const_true ? true : false;
        }
    }

    // equality not implemented, and objects are not the same object, so
    // they are defined as not equal
    return false;
}

mp_int_t micropy_obj_get_int(struct _mp_state_ctx_t *mp_state, mp_const_obj_t arg) {
    // This function essentially performs implicit type conversion to int
    // Note that Python does NOT provide implicit type conversion from
    // float to int in the core expression language, try some_list[1.0].
    if (arg == mp_const_false) {
        return 0;
    } else if (arg == mp_const_true) {
        return 1;
    } else if (MP_OBJ_IS_SMALL_INT(arg)) {
        return MP_OBJ_SMALL_INT_VALUE(arg);
    } else if (MP_OBJ_IS_TYPE(arg, &mp_type_int)) {
        return micropy_obj_int_get_checked(mp_state, arg);
    } else {
        if (MICROPY_ERROR_REPORTING == MICROPY_ERROR_REPORTING_TERSE) {
            micropy_nlr_raise(mp_state, micropy_obj_new_exception_msg(mp_state, &mp_type_TypeError,
                "can't convert to int"));
        } else {
            micropy_nlr_raise(mp_state, micropy_obj_new_exception_msg_varg(mp_state, &mp_type_TypeError,
                "can't convert %s to int", micropy_obj_get_type_str(mp_state, arg)));
        }
    }
}

mp_int_t micropy_obj_get_int_truncated(struct _mp_state_ctx_t *mp_state, mp_const_obj_t arg) {
    if (MP_OBJ_IS_INT(arg)) {
        return micropy_obj_int_get_truncated(mp_state, arg);
    } else {
        return micropy_obj_get_int(mp_state, arg);
    }
}

// returns false if arg is not of integral type
// returns true and sets *value if it is of integral type
// can throw OverflowError if arg is of integral type, but doesn't fit in a mp_int_t
bool micropy_obj_get_int_maybe(struct _mp_state_ctx_t *mp_state, mp_const_obj_t arg, mp_int_t *value) {
    if (arg == mp_const_false) {
        *value = 0;
    } else if (arg == mp_const_true) {
        *value = 1;
    } else if (MP_OBJ_IS_SMALL_INT(arg)) {
        *value = MP_OBJ_SMALL_INT_VALUE(arg);
    } else if (MP_OBJ_IS_TYPE(arg, &mp_type_int)) {
        *value = micropy_obj_int_get_checked(mp_state, arg);
    } else {
        return false;
    }
    return true;
}

#if MICROPY_PY_BUILTINS_FLOAT
mp_float_t micropy_obj_get_float(struct _mp_state_ctx_t *mp_state, mp_obj_t arg) {
    if (arg == mp_const_false) {
        return 0;
    } else if (arg == mp_const_true) {
        return 1;
    } else if (MP_OBJ_IS_SMALL_INT(arg)) {
        return MP_OBJ_SMALL_INT_VALUE(arg);
    } else if (MP_OBJ_IS_TYPE(arg, &mp_type_int)) {
        return micropy_obj_int_as_float(mp_state, arg);
    } else if (micropy_obj_is_float(mp_state, arg)) {
        return micropy_obj_float_get(mp_state, arg);
    } else {
        if (MICROPY_ERROR_REPORTING == MICROPY_ERROR_REPORTING_TERSE) {
            micropy_nlr_raise(mp_state, micropy_obj_new_exception_msg(mp_state, &mp_type_TypeError,
                "can't convert to float"));
        } else {
            micropy_nlr_raise(mp_state, micropy_obj_new_exception_msg_varg(mp_state, &mp_type_TypeError,
                "can't convert %s to float", micropy_obj_get_type_str(mp_state, arg)));
        }
    }
}

#if MICROPY_PY_BUILTINS_COMPLEX
void micropy_obj_get_complex(struct _mp_state_ctx_t *mp_state, mp_obj_t arg, mp_float_t *real, mp_float_t *imag) {
    if (arg == mp_const_false) {
        *real = 0;
        *imag = 0;
    } else if (arg == mp_const_true) {
        *real = 1;
        *imag = 0;
    } else if (MP_OBJ_IS_SMALL_INT(arg)) {
        *real = MP_OBJ_SMALL_INT_VALUE(arg);
        *imag = 0;
    } else if (MP_OBJ_IS_TYPE(arg, &mp_type_int)) {
        *real = micropy_obj_int_as_float(mp_state, arg);
        *imag = 0;
    } else if (micropy_obj_is_float(mp_state, arg)) {
        *real = micropy_obj_float_get(mp_state, arg);
        *imag = 0;
    } else if (MP_OBJ_IS_TYPE(arg, &mp_type_complex)) {
        micropy_obj_complex_get(mp_state, arg, real, imag);
    } else {
        if (MICROPY_ERROR_REPORTING == MICROPY_ERROR_REPORTING_TERSE) {
            micropy_nlr_raise(mp_state, micropy_obj_new_exception_msg(mp_state, &mp_type_TypeError,
                "can't convert to complex"));
        } else {
            micropy_nlr_raise(mp_state, micropy_obj_new_exception_msg_varg(mp_state, &mp_type_TypeError,
                "can't convert %s to complex", micropy_obj_get_type_str(mp_state, arg)));
        }
    }
}
#endif
#endif

// note: returned value in *items may point to the interior of a GC block
void micropy_obj_get_array(struct _mp_state_ctx_t *mp_state, mp_obj_t o, mp_uint_t *len, mp_obj_t **items) {
    if (MP_OBJ_IS_TYPE(o, &mp_type_tuple)) {
        micropy_obj_tuple_get(mp_state, o, len, items);
    } else if (MP_OBJ_IS_TYPE(o, &mp_type_list)) {
        micropy_obj_list_get(mp_state, o, len, items);
    } else {
        if (MICROPY_ERROR_REPORTING == MICROPY_ERROR_REPORTING_TERSE) {
            micropy_nlr_raise(mp_state, micropy_obj_new_exception_msg(mp_state, &mp_type_TypeError,
                "expected tuple/list"));
        } else {
            micropy_nlr_raise(mp_state, micropy_obj_new_exception_msg_varg(mp_state, &mp_type_TypeError,
                "object '%s' is not a tuple or list", micropy_obj_get_type_str(mp_state, o)));
        }
    }
}

// note: returned value in *items may point to the interior of a GC block
void micropy_obj_get_array_fixed_n(struct _mp_state_ctx_t *mp_state, mp_obj_t o, mp_uint_t len, mp_obj_t **items) {
    mp_uint_t seq_len;
    micropy_obj_get_array(mp_state, o, &seq_len, items);
    if (seq_len != len) {
        if (MICROPY_ERROR_REPORTING == MICROPY_ERROR_REPORTING_TERSE) {
            micropy_nlr_raise(mp_state, micropy_obj_new_exception_msg(mp_state, &mp_type_ValueError,
                "tuple/list has wrong length"));
        } else {
            micropy_nlr_raise(mp_state, micropy_obj_new_exception_msg_varg(mp_state, &mp_type_ValueError,
                "requested length %d but object has length %d", (int)len, (int)seq_len));
        }
    }
}

// is_slice determines whether the index is a slice index
mp_uint_t micropy_get_index(struct _mp_state_ctx_t *mp_state, const mp_obj_type_t *type, mp_uint_t len, mp_obj_t index, bool is_slice) {
    mp_int_t i;
    if (MP_OBJ_IS_SMALL_INT(index)) {
        i = MP_OBJ_SMALL_INT_VALUE(index);
    } else if (!micropy_obj_get_int_maybe(mp_state, index, &i)) {
        if (MICROPY_ERROR_REPORTING == MICROPY_ERROR_REPORTING_TERSE) {
            micropy_nlr_raise(mp_state, micropy_obj_new_exception_msg(mp_state, &mp_type_TypeError,
                "indices must be integers"));
        } else {
            micropy_nlr_raise(mp_state, micropy_obj_new_exception_msg_varg(mp_state, &mp_type_TypeError,
                "%q indices must be integers, not %s",
                type->name, micropy_obj_get_type_str(mp_state, index)));
        }
    }

    if (i < 0) {
        i += len;
    }
    if (is_slice) {
        if (i < 0) {
            i = 0;
        } else if ((mp_uint_t)i > len) {
            i = len;
        }
    } else {
        if (i < 0 || (mp_uint_t)i >= len) {
            if (MICROPY_ERROR_REPORTING == MICROPY_ERROR_REPORTING_TERSE) {
                micropy_nlr_raise(mp_state, micropy_obj_new_exception_msg(mp_state, &mp_type_IndexError, "index out of range"));
            } else {
                micropy_nlr_raise(mp_state, micropy_obj_new_exception_msg_varg(mp_state, &mp_type_IndexError,
                    "%q index out of range", type->name));
            }
        }
    }
    return i;
}

mp_obj_t micropy_obj_id(struct _mp_state_ctx_t *mp_state, mp_obj_t o_in) {
    mp_int_t id = (mp_int_t)o_in;
    if (!MP_OBJ_IS_OBJ(o_in)) {
        return micropy_obj_new_int(mp_state, id);
    } else if (id >= 0) {
        // Many OSes and CPUs have affinity for putting "user" memories
        // into low half of address space, and "system" into upper half.
        // We're going to take advantage of that and return small int
        // (signed) for such "user" addresses.
        return MP_OBJ_NEW_SMALL_INT(id);
    } else {
        // If that didn't work, well, let's return long int, just as
        // a (big) positve value, so it will never clash with the range
        // of small int returned in previous case.
        return micropy_obj_new_int_from_uint(mp_state, (mp_uint_t)id);
    }
}

// will raise a TypeError if object has no length
mp_obj_t micropy_obj_len(struct _mp_state_ctx_t *mp_state, mp_obj_t o_in) {
    mp_obj_t len = micropy_obj_len_maybe(mp_state, o_in);
    if (len == MP_OBJ_NULL) {
        if (MICROPY_ERROR_REPORTING == MICROPY_ERROR_REPORTING_TERSE) {
            micropy_nlr_raise(mp_state, micropy_obj_new_exception_msg(mp_state, &mp_type_TypeError,
                "object has no len"));
        } else {
            micropy_nlr_raise(mp_state, micropy_obj_new_exception_msg_varg(mp_state, &mp_type_TypeError,
                "object of type '%s' has no micropy_len(mp_state)", micropy_obj_get_type_str(mp_state, o_in)));
        }
    } else {
        return len;
    }
}

// may return MP_OBJ_NULL
mp_obj_t micropy_obj_len_maybe(struct _mp_state_ctx_t *mp_state, mp_obj_t o_in) {
    if (
#if !MICROPY_PY_BUILTINS_STR_UNICODE
        // It's simple - unicode is slow, non-unicode is fast
        MP_OBJ_IS_STR(o_in) ||
#endif
        MP_OBJ_IS_TYPE(o_in, &mp_type_bytes)) {
        GET_STR_LEN(o_in, l);
        return MP_OBJ_NEW_SMALL_INT(l);
    } else {
        mp_obj_type_t *type = micropy_obj_get_type(mp_state, o_in);
        if (type->unary_op != NULL) {
            return type->unary_op(mp_state, MP_UNARY_OP_LEN, o_in);
        } else {
            return MP_OBJ_NULL;
        }
    }
}

mp_obj_t micropy_obj_subscr(struct _mp_state_ctx_t *mp_state, mp_obj_t base, mp_obj_t index, mp_obj_t value) {
    mp_obj_type_t *type = micropy_obj_get_type(mp_state, base);
    if (type->subscr != NULL) {
        mp_obj_t ret = type->subscr(mp_state, base, index, value);
        if (ret != MP_OBJ_NULL) {
            return ret;
        }
        // TODO: call base classes here?
    }
    if (value == MP_OBJ_NULL) {
        if (MICROPY_ERROR_REPORTING == MICROPY_ERROR_REPORTING_TERSE) {
            micropy_nlr_raise(mp_state, micropy_obj_new_exception_msg(mp_state, &mp_type_TypeError,
                "object does not support item deletion"));
        } else {
            micropy_nlr_raise(mp_state, micropy_obj_new_exception_msg_varg(mp_state, &mp_type_TypeError,
                "'%s' object does not support item deletion", micropy_obj_get_type_str(mp_state, base)));
        }
    } else if (value == MP_OBJ_SENTINEL) {
        if (MICROPY_ERROR_REPORTING == MICROPY_ERROR_REPORTING_TERSE) {
            micropy_nlr_raise(mp_state, micropy_obj_new_exception_msg_varg(mp_state, &mp_type_TypeError,
                "object is not subscriptable"));
        } else {
            micropy_nlr_raise(mp_state, micropy_obj_new_exception_msg_varg(mp_state, &mp_type_TypeError,
                "'%s' object is not subscriptable", micropy_obj_get_type_str(mp_state, base)));
        }
    } else {
        if (MICROPY_ERROR_REPORTING == MICROPY_ERROR_REPORTING_TERSE) {
            micropy_nlr_raise(mp_state, micropy_obj_new_exception_msg(mp_state, &mp_type_TypeError,
                "object does not support item assignment"));
        } else {
            micropy_nlr_raise(mp_state, micropy_obj_new_exception_msg_varg(mp_state, &mp_type_TypeError,
                "'%s' object does not support item assignment", micropy_obj_get_type_str(mp_state, base)));
        }
    }
}

// Return input argument. Useful as .getiter for objects which are
// their own iterators, etc.
mp_obj_t micropy_identity(struct _mp_state_ctx_t *mp_state, mp_obj_t self) {
    return self;
}
MP_DEFINE_CONST_FUN_OBJ_1(mp_identity_obj, micropy_identity);

bool micropy_get_buffer(struct _mp_state_ctx_t *mp_state, mp_obj_t obj, mp_buffer_info_t *bufinfo, mp_uint_t flags) {
    mp_obj_type_t *type = micropy_obj_get_type(mp_state, obj);
    if (type->buffer_p.get_buffer == NULL) {
        return false;
    }
    int ret = type->buffer_p.get_buffer(mp_state, obj, bufinfo, flags);
    if (ret != 0) {
        return false;
    }
    return true;
}

void micropy_get_buffer_raise(struct _mp_state_ctx_t *mp_state, mp_obj_t obj, mp_buffer_info_t *bufinfo, mp_uint_t flags) {
    if (!micropy_get_buffer(mp_state, obj, bufinfo, flags)) {
        micropy_nlr_raise(mp_state, micropy_obj_new_exception_msg(mp_state, &mp_type_TypeError, "object with buffer protocol required"));
    }
}

mp_obj_t micropy_generic_unary_op(struct _mp_state_ctx_t *mp_state, mp_uint_t op, mp_obj_t o_in) {
    switch (op) {
        case MP_UNARY_OP_HASH: return MP_OBJ_NEW_SMALL_INT((mp_uint_t)o_in);
        default: return MP_OBJ_NULL; // op not supported
    }
}
/*
 * This file is part of the Micro Python project, http://micropython.org/
 *
 * The MIT License (MIT)
 *
 * Copyright (c) 2015 Damien P. George
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

//#include "py/objtuple.h"

#if MICROPY_PY_ATTRTUPLE || MICROPY_PY_COLLECTIONS

// this helper function is used by collections.namedtuple
#if !MICROPY_PY_COLLECTIONS
STATIC
#endif
void micropy_obj_attrtuple_print_helper(struct _mp_state_ctx_t *mp_state, const mp_print_t *print, const qstr *fields, mp_obj_tuple_t *o) {
    micropy_print_str(mp_state, print, "(");
    for (mp_uint_t i = 0; i < o->len; i++) {
        if (i > 0) {
            micropy_print_str(mp_state, print, ", ");
        }
        micropy_printf(mp_state, print, "%q=", fields[i]);
        micropy_obj_print_helper(mp_state, print, o->items[i], PRINT_REPR);
    }
    micropy_print_str(mp_state, print, ")");
}

#endif

#if MICROPY_PY_ATTRTUPLE

STATIC void micropy_obj_attrtuple_print(struct _mp_state_ctx_t *mp_state, const mp_print_t *print, mp_obj_t o_in, mp_print_kind_t kind) {
    (void)kind;
    mp_obj_tuple_t *o = MP_OBJ_TO_PTR(o_in);
    const qstr *fields = (const qstr*)MP_OBJ_TO_PTR(o->items[o->len]);
    micropy_obj_attrtuple_print_helper(mp_state, print, fields, o);
}

STATIC void micropy_obj_attrtuple_attr(struct _mp_state_ctx_t *mp_state, mp_obj_t self_in, qstr attr, mp_obj_t *dest) {
    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        mp_obj_tuple_t *self = MP_OBJ_TO_PTR(self_in);
        mp_uint_t len = self->len;
        const qstr *fields = (const qstr*)MP_OBJ_TO_PTR(self->items[len]);
        for (mp_uint_t i = 0; i < len; i++) {
            if (fields[i] == attr) {
                dest[0] = self->items[i];
                return;
            }
        }
    }
}

mp_obj_t micropy_obj_new_attrtuple(struct _mp_state_ctx_t *mp_state, const qstr *fields, mp_uint_t n, const mp_obj_t *items) {
    mp_obj_tuple_t *o = micropy_m_new_obj_var(mp_state, mp_obj_tuple_t, mp_obj_t, n + 1);
    o->base.type = &mp_type_attrtuple;
    o->len = n;
    for (mp_uint_t i = 0; i < n; i++) {
        o->items[i] = items[i];
    }
    o->items[n] = MP_OBJ_FROM_PTR(fields);
    return MP_OBJ_FROM_PTR(o);
}

const mp_obj_type_t mp_type_attrtuple = {
    { &mp_type_type },
    .name = MP_QSTR_tuple, // reuse tuple to save on a qstr
    .print = micropy_obj_attrtuple_print,
    .unary_op = micropy_obj_tuple_unary_op,
    .binary_op = micropy_obj_tuple_binary_op,
    .attr = micropy_obj_attrtuple_attr,
    .subscr = micropy_obj_tuple_subscr,
    .getiter = micropy_obj_tuple_getiter,
};

#endif // MICROPY_PY_ATTRTUPLE
/*
 * This file is part of the Micro Python project, http://micropython.org/
 *
 * The MIT License (MIT)
 *
 * Copyright (c) 2013, 2014 Damien P. George
 * Copyright (c) 2014 Paul Sokolovsky
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

#include <string.h>
#include <assert.h>
#include <stdint.h>

//#include "py/nlr.h"
//#include "py/runtime0.h"
//#include "py/runtime.h"
//#include "py/binary.h"
//#include "py/objstr.h"

#if MICROPY_PY_ARRAY || MICROPY_PY_BUILTINS_BYTEARRAY || MICROPY_PY_BUILTINS_MEMORYVIEW

// About memoryview object: We want to reuse as much code as possible from
// array, and keep the memoryview object 4 words in size so it fits in 1 GC
// block.  Also, memoryview must keep a pointer to the base of the buffer so
// that the buffer is not GC'd if the original parent object is no longer
// around (we are assuming that all memoryview'able objects return a pointer
// which points to the start of a GC chunk).  Given the above constraints we
// do the following:
//  - typecode high bit is set if the buffer is read-write (else read-only)
//  - free is the offset in elements to the first item in the memoryview
//  - len is the length in elements
//  - items points to the start of the original buffer
// Note that we don't handle the case where the original buffer might change
// size due to a resize of the original parent object.

// make (& TYPECODE_MASK) a null operation if memorview not enabled
#if MICROPY_PY_BUILTINS_MEMORYVIEW
#define TYPECODE_MASK (0x7f)
#else
#define TYPECODE_MASK (~(mp_uint_t)0)
#endif

typedef struct _mp_obj_array_t {
    mp_obj_base_t base;
    mp_uint_t typecode : 8;
    // free is number of unused elements after len used elements
    // alloc size = len + free
    mp_uint_t free : (8 * sizeof(mp_uint_t) - 8);
    mp_uint_t len; // in elements
    void *items;
} mp_obj_array_t;

STATIC mp_obj_t micropy_array_iterator_new(struct _mp_state_ctx_t *mp_state, mp_obj_t array_in);
STATIC mp_obj_t micropy_array_append(struct _mp_state_ctx_t *mp_state, mp_obj_t self_in, mp_obj_t arg);
STATIC mp_obj_t micropy_array_extend(struct _mp_state_ctx_t *mp_state, mp_obj_t self_in, mp_obj_t arg_in);
STATIC mp_int_t micropy_array_get_buffer(struct _mp_state_ctx_t *mp_state, mp_obj_t o_in, mp_buffer_info_t *bufinfo, mp_uint_t flags);

/******************************************************************************/
// array

#if MICROPY_PY_BUILTINS_BYTEARRAY || MICROPY_PY_ARRAY
STATIC void micropy_array_print(struct _mp_state_ctx_t *mp_state, const mp_print_t *print, mp_obj_t o_in, mp_print_kind_t kind) {
    (void)kind;
    mp_obj_array_t *o = MP_OBJ_TO_PTR(o_in);
    if (o->typecode == BYTEARRAY_TYPECODE) {
        micropy_print_str(mp_state, print, "bytearray(b");
        micropy_str_print_quoted(mp_state, print, o->items, o->len, true);
    } else {
        micropy_printf(mp_state, print, "array('%c'", o->typecode);
        if (o->len > 0) {
            micropy_print_str(mp_state, print, ", [");
            for (mp_uint_t i = 0; i < o->len; i++) {
                if (i > 0) {
                    micropy_print_str(mp_state, print, ", ");
                }
                micropy_obj_print_helper(mp_state, print, micropy_binary_get_val_array(mp_state, o->typecode, o->items, i), PRINT_REPR);
            }
            micropy_print_str(mp_state, print, "]");
        }
    }
    micropy_print_str(mp_state, print, ")");
}
#endif

#if MICROPY_PY_BUILTINS_BYTEARRAY || MICROPY_PY_ARRAY
STATIC mp_obj_array_t *micropy_array_new(struct _mp_state_ctx_t *mp_state, char typecode, mp_uint_t n) {
    int typecode_size = micropy_binary_get_size(mp_state, '@', typecode, NULL);
    if (typecode_size == 0) {
        micropy_nlr_raise(mp_state, micropy_obj_new_exception_msg(mp_state, &mp_type_ValueError, "bad typecode"));
    }
    mp_obj_array_t *o = micropy_m_new_obj(mp_state, mp_obj_array_t);
    #if MICROPY_PY_BUILTINS_BYTEARRAY && MICROPY_PY_ARRAY
    o->base.type = (typecode == BYTEARRAY_TYPECODE) ? &mp_type_bytearray : &mp_type_array;
    #elif MICROPY_PY_BUILTINS_BYTEARRAY
    o->base.type = &mp_type_bytearray;
    #else
    o->base.type = &mp_type_array;
    #endif
    o->typecode = typecode;
    o->free = 0;
    o->len = n;
    o->items = micropy_m_new(mp_state, byte, typecode_size * o->len);
    return o;
}
#endif

#if MICROPY_PY_BUILTINS_BYTEARRAY || MICROPY_PY_ARRAY
STATIC mp_obj_t micropy_array_construct(struct _mp_state_ctx_t *mp_state, char typecode, mp_obj_t initializer) {
    // bytearrays can be raw-initialised from anything with the buffer protocol
    // other arrays can only be raw-initialised from bytes and bytearray objects
    mp_buffer_info_t bufinfo;
    if (((MICROPY_PY_BUILTINS_BYTEARRAY
            && typecode == BYTEARRAY_TYPECODE)
        || (MICROPY_PY_ARRAY
            && (MP_OBJ_IS_TYPE(initializer, &mp_type_bytes)
                || (MICROPY_PY_BUILTINS_BYTEARRAY && MP_OBJ_IS_TYPE(initializer, &mp_type_bytearray)))))
        && micropy_get_buffer(mp_state, initializer, &bufinfo, MP_BUFFER_READ)) {
        // construct array from raw bytes
        // we round-down the len to make it a multiple of sz (CPython raises error)
        size_t sz = micropy_binary_get_size(mp_state, '@', typecode, NULL);
        mp_uint_t len = bufinfo.len / sz;
        mp_obj_array_t *o = micropy_array_new(mp_state, typecode, len);
        memcpy(o->items, bufinfo.buf, len * sz);
        return MP_OBJ_FROM_PTR(o);
    }

    mp_uint_t len;
    // Try to create array of exact len if initializer len is known
    mp_obj_t len_in = micropy_obj_len_maybe(mp_state, initializer);
    if (len_in == MP_OBJ_NULL) {
        len = 0;
    } else {
        len = MP_OBJ_SMALL_INT_VALUE(len_in);
    }

    mp_obj_array_t *array = micropy_array_new(mp_state, typecode, len);

    mp_obj_t iterable = micropy_getiter(mp_state, initializer);
    mp_obj_t item;
    mp_uint_t i = 0;
    while ((item = micropy_iternext(mp_state, iterable)) != MP_OBJ_STOP_ITERATION) {
        if (len == 0) {
            micropy_array_append(mp_state, MP_OBJ_FROM_PTR(array), item);
        } else {
            micropy_binary_set_val_array(mp_state, typecode, array->items, i++, item);
        }
    }

    return MP_OBJ_FROM_PTR(array);
}
#endif

#if MICROPY_PY_ARRAY
STATIC mp_obj_t micropy_array_make_new(struct _mp_state_ctx_t *mp_state, const mp_obj_type_t *type_in, size_t n_args, size_t n_kw, const mp_obj_t *args) {
    (void)type_in;
    micropy_arg_check_num(mp_state, n_args, n_kw, 1, 2, false);

    // get typecode
    mp_uint_t l;
    const char *typecode = micropy_obj_str_get_data(mp_state, args[0], &l);

    if (n_args == 1) {
        // 1 arg: make an empty array
        return MP_OBJ_FROM_PTR(micropy_array_new(mp_state, *typecode, 0));
    } else {
        // 2 args: construct the array from the given object
        return micropy_array_construct(mp_state, *typecode, args[1]);
    }
}
#endif

#if MICROPY_PY_BUILTINS_BYTEARRAY
STATIC mp_obj_t micropy_bytearray_make_new(struct _mp_state_ctx_t *mp_state, const mp_obj_type_t *type_in, size_t n_args, size_t n_kw, const mp_obj_t *args) {
    (void)type_in;
    micropy_arg_check_num(mp_state, n_args, n_kw, 0, 1, false);

    if (n_args == 0) {
        // no args: construct an empty bytearray
        return MP_OBJ_FROM_PTR(micropy_array_new(mp_state, BYTEARRAY_TYPECODE, 0));
    } else if (MP_OBJ_IS_INT(args[0])) {
        // 1 arg, an integer: construct a blank bytearray of that length
        mp_uint_t len = micropy_obj_get_int(mp_state, args[0]);
        mp_obj_array_t *o = micropy_array_new(mp_state, BYTEARRAY_TYPECODE, len);
        memset(o->items, 0, len);
        return MP_OBJ_FROM_PTR(o);
    } else {
        // 1 arg: construct the bytearray from that
        return micropy_array_construct(mp_state, BYTEARRAY_TYPECODE, args[0]);
    }
}
#endif

#if MICROPY_PY_BUILTINS_MEMORYVIEW

mp_obj_t micropy_obj_new_memoryview(struct _mp_state_ctx_t *mp_state, byte typecode, mp_uint_t nitems, void *items) {
    mp_obj_array_t *self = micropy_m_new_obj(mp_state, mp_obj_array_t);
    self->base.type = &mp_type_memoryview;
    self->typecode = typecode;
    self->free = 0;
    self->len = nitems;
    self->items = items;
    return MP_OBJ_FROM_PTR(self);
}

STATIC mp_obj_t micropy_memoryview_make_new(struct _mp_state_ctx_t *mp_state, const mp_obj_type_t *type_in, size_t n_args, size_t n_kw, const mp_obj_t *args) {
    (void)type_in;

    // TODO possibly allow memoryview constructor to take start/stop so that one
    // can do memoryview(b, 4, 8) instead of memoryview(b)[4:8] (uses less RAM)

    micropy_arg_check_num(mp_state, n_args, n_kw, 1, 1, false);

    mp_buffer_info_t bufinfo;
    micropy_get_buffer_raise(mp_state, args[0], &bufinfo, MP_BUFFER_READ);

    mp_obj_array_t *self = MP_OBJ_TO_PTR(micropy_obj_new_memoryview(mp_state, bufinfo.typecode,
        bufinfo.len / micropy_binary_get_size(mp_state, '@', bufinfo.typecode, NULL),
        bufinfo.buf));

    // test if the object can be written to
    if (micropy_get_buffer(mp_state, args[0], &bufinfo, MP_BUFFER_RW)) {
        self->typecode |= 0x80; // used to indicate writable buffer
    }

    return MP_OBJ_FROM_PTR(self);
}
#endif

STATIC mp_obj_t micropy_array_unary_op(struct _mp_state_ctx_t *mp_state, mp_uint_t op, mp_obj_t o_in) {
    mp_obj_array_t *o = MP_OBJ_TO_PTR(o_in);
    switch (op) {
        case MP_UNARY_OP_BOOL: return micropy_obj_new_bool(mp_state, o->len != 0);
        case MP_UNARY_OP_LEN: return MP_OBJ_NEW_SMALL_INT(o->len);
        default: return MP_OBJ_NULL; // op not supported
    }
}

STATIC mp_obj_t micropy_array_binary_op(struct _mp_state_ctx_t *mp_state, mp_uint_t op, mp_obj_t lhs_in, mp_obj_t rhs_in) {
    mp_obj_array_t *lhs = MP_OBJ_TO_PTR(lhs_in);
    switch (op) {
        case MP_BINARY_OP_ADD: {
            // allow to add anything that has the buffer protocol (extension to CPython)
            mp_buffer_info_t lhs_bufinfo;
            mp_buffer_info_t rhs_bufinfo;
            micropy_array_get_buffer(mp_state, lhs_in, &lhs_bufinfo, MP_BUFFER_READ);
            micropy_get_buffer_raise(mp_state, rhs_in, &rhs_bufinfo, MP_BUFFER_READ);

            size_t sz = micropy_binary_get_size(mp_state, '@', lhs_bufinfo.typecode, NULL);

            // convert byte count to element count (in case rhs is not multiple of sz)
            mp_uint_t rhs_len = rhs_bufinfo.len / sz;

            // note: lhs->len is element count of lhs, lhs_bufinfo.len is byte count
            mp_obj_array_t *res = micropy_array_new(mp_state, lhs_bufinfo.typecode, lhs->len + rhs_len);
            micropy_seq_cat(mp_state, (byte*)res->items, lhs_bufinfo.buf, lhs_bufinfo.len, rhs_bufinfo.buf, rhs_len * sz, byte);
            return MP_OBJ_FROM_PTR(res);
        }

        case MP_BINARY_OP_INPLACE_ADD: {
            #if MICROPY_PY_BUILTINS_MEMORYVIEW
            if (lhs->base.type == &mp_type_memoryview) {
                return MP_OBJ_NULL; // op not supported
            }
            #endif
            micropy_array_extend(mp_state, lhs_in, rhs_in);
            return lhs_in;
        }

        case MP_BINARY_OP_IN: {
            /* NOTE `a in b` is `b.__contains__(a)` */
            mp_buffer_info_t lhs_bufinfo;
            mp_buffer_info_t rhs_bufinfo;

            // Can search string only in bytearray
            if (micropy_get_buffer(mp_state, rhs_in, &rhs_bufinfo, MP_BUFFER_READ)) {
                if (!MP_OBJ_IS_TYPE(lhs_in, &mp_type_bytearray)) {
                    return mp_const_false;
                }
                micropy_array_get_buffer(mp_state, lhs_in, &lhs_bufinfo, MP_BUFFER_READ);
                return micropy_obj_new_bool(mp_state, 
                    micropy_find_subbytes(mp_state, lhs_bufinfo.buf, lhs_bufinfo.len, rhs_bufinfo.buf, rhs_bufinfo.len, 1) != NULL);
            }

            // Otherwise, can only look for a scalar numeric value in an array
            if (MP_OBJ_IS_INT(rhs_in) || micropy_obj_is_float(mp_state, rhs_in)) {
                micropy_not_implemented(mp_state, "");
            }

            return mp_const_false;
        }

        case MP_BINARY_OP_EQUAL: {
            mp_buffer_info_t lhs_bufinfo;
            mp_buffer_info_t rhs_bufinfo;
            micropy_array_get_buffer(mp_state, lhs_in, &lhs_bufinfo, MP_BUFFER_READ);
            if (!micropy_get_buffer(mp_state, rhs_in, &rhs_bufinfo, MP_BUFFER_READ)) {
                return mp_const_false;
            }
            return micropy_obj_new_bool(mp_state, micropy_seq_cmp_bytes(mp_state, op, lhs_bufinfo.buf, lhs_bufinfo.len, rhs_bufinfo.buf, rhs_bufinfo.len));
        }

        default:
            return MP_OBJ_NULL; // op not supported
    }
}

#if MICROPY_PY_BUILTINS_BYTEARRAY || MICROPY_PY_ARRAY
STATIC mp_obj_t micropy_array_append(struct _mp_state_ctx_t *mp_state, mp_obj_t self_in, mp_obj_t arg) {
    // self is not a memoryview, so we don't need to use (& TYPECODE_MASK)
    assert((MICROPY_PY_BUILTINS_BYTEARRAY && MP_OBJ_IS_TYPE(self_in, &mp_type_bytearray))
        || (MICROPY_PY_ARRAY && MP_OBJ_IS_TYPE(self_in, &mp_type_array)));
    mp_obj_array_t *self = MP_OBJ_TO_PTR(self_in);

    if (self->free == 0) {
        size_t item_sz = micropy_binary_get_size(mp_state, '@', self->typecode, NULL);
        // TODO: alloc policy
        self->free = 8;
        self->items = micropy_m_renew(mp_state, byte, self->items, item_sz * self->len, item_sz * (self->len + self->free));
        micropy_seq_clear(mp_state, self->items, self->len + 1, self->len + self->free, item_sz);
    }
    micropy_binary_set_val_array(mp_state, self->typecode, self->items, self->len, arg);
    // only update length/free if set succeeded
    self->len++;
    self->free--;
    return mp_const_none; // return None, as per CPython
}
STATIC MP_DEFINE_CONST_FUN_OBJ_2(array_append_obj, micropy_array_append);

STATIC mp_obj_t micropy_array_extend(struct _mp_state_ctx_t *mp_state, mp_obj_t self_in, mp_obj_t arg_in) {
    // self is not a memoryview, so we don't need to use (& TYPECODE_MASK)
    assert((MICROPY_PY_BUILTINS_BYTEARRAY && MP_OBJ_IS_TYPE(self_in, &mp_type_bytearray))
        || (MICROPY_PY_ARRAY && MP_OBJ_IS_TYPE(self_in, &mp_type_array)));
    mp_obj_array_t *self = MP_OBJ_TO_PTR(self_in);

    // allow to extend by anything that has the buffer protocol (extension to CPython)
    mp_buffer_info_t arg_bufinfo;
    micropy_get_buffer_raise(mp_state, arg_in, &arg_bufinfo, MP_BUFFER_READ);

    size_t sz = micropy_binary_get_size(mp_state, '@', self->typecode, NULL);

    // convert byte count to element count
    mp_uint_t len = arg_bufinfo.len / sz;

    // make sure we have enough room to extend
    // TODO: alloc policy; at the moment we go conservative
    if (self->free < len) {
        self->items = micropy_m_renew(mp_state, byte, self->items, (self->len + self->free) * sz, (self->len + len) * sz);
        self->free = 0;
    } else {
        self->free -= len;
    }

    // extend
    micropy_seq_copy(mp_state, (byte*)self->items + self->len * sz, arg_bufinfo.buf, len * sz, byte);
    self->len += len;

    return mp_const_none;
}
STATIC MP_DEFINE_CONST_FUN_OBJ_2(array_extend_obj, micropy_array_extend);
#endif

STATIC mp_obj_t micropy_array_subscr(struct _mp_state_ctx_t *mp_state, mp_obj_t self_in, mp_obj_t index_in, mp_obj_t value) {
    if (value == MP_OBJ_NULL) {
        // delete item
        // TODO implement
        // TODO: confirmed that both bytearray and array.array support
        // slice deletion
        return MP_OBJ_NULL; // op not supported
    } else {
        mp_obj_array_t *o = MP_OBJ_TO_PTR(self_in);
        if (0) {
#if MICROPY_PY_BUILTINS_SLICE
        } else if (MP_OBJ_IS_TYPE(index_in, &mp_type_slice)) {
            mp_bound_slice_t slice;
            if (!micropy_seq_get_fast_slice_indexes(mp_state, o->len, index_in, &slice)) {
                micropy_not_implemented(mp_state, "only slices with step=1 (aka None) are supported");
            }
            if (value != MP_OBJ_SENTINEL) {
                #if MICROPY_PY_ARRAY_SLICE_ASSIGN
                // Assign
                mp_uint_t src_len;
                void *src_items;
                size_t item_sz = micropy_binary_get_size(mp_state, '@', o->typecode & TYPECODE_MASK, NULL);
                if (MP_OBJ_IS_OBJ(value) && ((mp_obj_base_t*)MP_OBJ_TO_PTR(value))->type->subscr == micropy_array_subscr) {
                    // value is array, bytearray or memoryview
                    mp_obj_array_t *src_slice = MP_OBJ_TO_PTR(value);
                    if (item_sz != micropy_binary_get_size(mp_state, '@', src_slice->typecode & TYPECODE_MASK, NULL)) {
                    compat_error:
                        micropy_nlr_raise(mp_state, micropy_obj_new_exception_msg(mp_state, &mp_type_ValueError, "lhs and rhs should be compatible"));
                    }
                    src_len = src_slice->len;
                    src_items = src_slice->items;
                    #if MICROPY_PY_BUILTINS_MEMORYVIEW
                    if (MP_OBJ_IS_TYPE(value, &mp_type_memoryview)) {
                        src_items = (uint8_t*)src_items + (src_slice->free * item_sz);
                    }
                    #endif
                } else if (MP_OBJ_IS_TYPE(value, &mp_type_bytes)) {
                    if (item_sz != 1) {
                        goto compat_error;
                    }
                    mp_buffer_info_t bufinfo;
                    micropy_get_buffer_raise(mp_state, value, &bufinfo, MP_BUFFER_READ);
                    src_len = bufinfo.len;
                    src_items = bufinfo.buf;
                } else {
                    micropy_not_implemented(mp_state, "array/bytes required on right side");
                }

                // TODO: check src/dst compat
                mp_int_t len_adj = src_len - (slice.stop - slice.start);
                uint8_t* dest_items = o->items;
                #if MICROPY_PY_BUILTINS_MEMORYVIEW
                if (o->base.type == &mp_type_memoryview) {
                    if (len_adj != 0) {
                        goto compat_error;
                    }
                    dest_items += o->free * item_sz;
                }
                #endif
                if (len_adj > 0) {
                    if (len_adj > o->free) {
                        // TODO: alloc policy; at the moment we go conservative
                        o->items = micropy_m_renew(mp_state, byte, o->items, (o->len + o->free) * item_sz, (o->len + len_adj) * item_sz);
                        o->free = 0;
                        dest_items = o->items;
                    }
                    micropy_seq_replace_slice_grow_inplace(mp_state, dest_items, o->len,
                        slice.start, slice.stop, src_items, src_len, len_adj, item_sz);
                } else {
                    micropy_seq_replace_slice_no_grow(mp_state, dest_items, o->len,
                        slice.start, slice.stop, src_items, src_len, item_sz);
                    // Clear "freed" elements at the end of list
                    // TODO: This is actually only needed for typecode=='O'
                    micropy_seq_clear(mp_state, dest_items, o->len + len_adj, o->len, item_sz);
                    // TODO: alloc policy after shrinking
                }
                o->len += len_adj;
                return mp_const_none;
                #else
                return MP_OBJ_NULL; // op not supported
                #endif
            }

            mp_obj_array_t *res;
            size_t sz = micropy_binary_get_size(mp_state, '@', o->typecode & TYPECODE_MASK, NULL);
            assert(sz > 0);
            if (0) {
                // dummy
            #if MICROPY_PY_BUILTINS_MEMORYVIEW
            } else if (o->base.type == &mp_type_memoryview) {
                res = micropy_m_new_obj(mp_state, mp_obj_array_t);
                *res = *o;
                res->free += slice.start;
                res->len = slice.stop - slice.start;
            #endif
            } else {
                res = micropy_array_new(mp_state, o->typecode, slice.stop - slice.start);
                memcpy(res->items, (uint8_t*)o->items + slice.start * sz, (slice.stop - slice.start) * sz);
            }
            return MP_OBJ_FROM_PTR(res);
#endif
        } else {
            mp_uint_t index = micropy_get_index(mp_state, o->base.type, o->len, index_in, false);
            #if MICROPY_PY_BUILTINS_MEMORYVIEW
            if (o->base.type == &mp_type_memoryview) {
                index += o->free;
                if (value != MP_OBJ_SENTINEL && (o->typecode & 0x80) == 0) {
                    // store to read-only memoryview
                    return MP_OBJ_NULL;
                }
            }
            #endif
            if (value == MP_OBJ_SENTINEL) {
                // load
                return micropy_binary_get_val_array(mp_state, o->typecode & TYPECODE_MASK, o->items, index);
            } else {
                // store
                micropy_binary_set_val_array(mp_state, o->typecode & TYPECODE_MASK, o->items, index, value);
                return mp_const_none;
            }
        }
    }
}

STATIC mp_int_t micropy_array_get_buffer(struct _mp_state_ctx_t *mp_state, mp_obj_t o_in, mp_buffer_info_t *bufinfo, mp_uint_t flags) {
    mp_obj_array_t *o = MP_OBJ_TO_PTR(o_in);
    size_t sz = micropy_binary_get_size(mp_state, '@', o->typecode & TYPECODE_MASK, NULL);
    bufinfo->buf = o->items;
    bufinfo->len = o->len * sz;
    bufinfo->typecode = o->typecode & TYPECODE_MASK;
    #if MICROPY_PY_BUILTINS_MEMORYVIEW
    if (o->base.type == &mp_type_memoryview) {
        if ((o->typecode & 0x80) == 0 && (flags & MP_BUFFER_WRITE)) {
            // read-only memoryview
            return 1;
        }
        bufinfo->buf = (uint8_t*)bufinfo->buf + (mp_uint_t)o->free * sz;
    }
    #else
    (void)flags;
    #endif
    return 0;
}

#if MICROPY_PY_BUILTINS_BYTEARRAY || MICROPY_PY_ARRAY
STATIC const mp_rom_map_elem_t array_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_append), MP_ROM_PTR(&array_append_obj) },
    { MP_ROM_QSTR(MP_QSTR_extend), MP_ROM_PTR(&array_extend_obj) },
};

STATIC MP_DEFINE_CONST_DICT(array_locals_dict, array_locals_dict_table);
#endif

#if MICROPY_PY_ARRAY
const mp_obj_type_t mp_type_array = {
    { &mp_type_type },
    .name = MP_QSTR_array,
    .print = micropy_array_print,
    .make_new = micropy_array_make_new,
    .getiter = micropy_array_iterator_new,
    .unary_op = micropy_array_unary_op,
    .binary_op = micropy_array_binary_op,
    .subscr = micropy_array_subscr,
    .buffer_p = { .get_buffer = micropy_array_get_buffer, },
    .locals_dict = (mp_obj_dict_t*)&array_locals_dict,
};
#endif

#if MICROPY_PY_BUILTINS_BYTEARRAY
const mp_obj_type_t mp_type_bytearray = {
    { &mp_type_type },
    .name = MP_QSTR_bytearray,
    .print = micropy_array_print,
    .make_new = micropy_bytearray_make_new,
    .getiter = micropy_array_iterator_new,
    .unary_op = micropy_array_unary_op,
    .binary_op = micropy_array_binary_op,
    .subscr = micropy_array_subscr,
    .buffer_p = { .get_buffer = micropy_array_get_buffer, },
    .locals_dict = (mp_obj_dict_t*)&array_locals_dict,
};
#endif

#if MICROPY_PY_BUILTINS_MEMORYVIEW
const mp_obj_type_t mp_type_memoryview = {
    { &mp_type_type },
    .name = MP_QSTR_memoryview,
    .make_new = micropy_memoryview_make_new,
    .getiter = micropy_array_iterator_new,
    .unary_op = micropy_array_unary_op,
    .binary_op = micropy_array_binary_op,
    .subscr = micropy_array_subscr,
    .buffer_p = { .get_buffer = micropy_array_get_buffer, },
};
#endif

/* unused
mp_uint_t micropy_obj_array_len(struct _mp_state_ctx_t *mp_state, mp_obj_t self_in) {
    return ((mp_obj_array_t *)self_in)->len;
}
*/

#if MICROPY_PY_BUILTINS_BYTEARRAY
mp_obj_t micropy_obj_new_bytearray(struct _mp_state_ctx_t *mp_state, mp_uint_t n, void *items) {
    mp_obj_array_t *o = micropy_array_new(mp_state, BYTEARRAY_TYPECODE, n);
    memcpy(o->items, items, n);
    return MP_OBJ_FROM_PTR(o);
}

// Create bytearray which references specified memory area
mp_obj_t micropy_obj_new_bytearray_by_ref(struct _mp_state_ctx_t *mp_state, mp_uint_t n, void *items) {
    mp_obj_array_t *o = micropy_m_new_obj(mp_state, mp_obj_array_t);
    o->base.type = &mp_type_bytearray;
    o->typecode = BYTEARRAY_TYPECODE;
    o->free = 0;
    o->len = n;
    o->items = items;
    return MP_OBJ_FROM_PTR(o);
}
#endif

/******************************************************************************/
// array iterator

typedef struct _mp_obj_array_it_t {
    mp_obj_base_t base;
    mp_obj_array_t *array;
    mp_uint_t offset;
    mp_uint_t cur;
} mp_obj_array_it_t;

STATIC mp_obj_t micropy_array_it_iternext(struct _mp_state_ctx_t *mp_state, mp_obj_t self_in) {
    mp_obj_array_it_t *self = MP_OBJ_TO_PTR(self_in);
    if (self->cur < self->array->len) {
        return micropy_binary_get_val_array(mp_state, self->array->typecode & TYPECODE_MASK, self->array->items, self->offset + self->cur++);
    } else {
        return MP_OBJ_STOP_ITERATION;
    }
}

STATIC const mp_obj_type_t array_it_type = {
    { &mp_type_type },
    .name = MP_QSTR_iterator,
    .getiter = micropy_identity,
    .iternext = micropy_array_it_iternext,
};

STATIC mp_obj_t micropy_array_iterator_new(struct _mp_state_ctx_t *mp_state, mp_obj_t array_in) {
    mp_obj_array_t *array = MP_OBJ_TO_PTR(array_in);
    mp_obj_array_it_t *o = micropy_m_new0(mp_state, mp_obj_array_it_t, 1);
    o->base.type = &array_it_type;
    o->array = array;
    #if MICROPY_PY_BUILTINS_MEMORYVIEW
    if (array->base.type == &mp_type_memoryview) {
        o->offset = array->free;
    }
    #endif
    return MP_OBJ_FROM_PTR(o);
}

#endif // MICROPY_PY_ARRAY || MICROPY_PY_BUILTINS_BYTEARRAY || MICROPY_PY_BUILTINS_MEMORYVIEW
/*
 * This file is part of the Micro Python project, http://micropython.org/
 *
 * The MIT License (MIT)
 *
 * Copyright (c) 2013, 2014 Damien P. George
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

#include <stdlib.h>

//#include "py/obj.h"
//#include "py/runtime0.h"
//#include "py/runtime.h"

typedef struct _mp_obj_bool_t {
    mp_obj_base_t base;
    bool value;
} mp_obj_bool_t;

STATIC void micropy_bool_print(struct _mp_state_ctx_t *mp_state, const mp_print_t *print, mp_obj_t self_in, mp_print_kind_t kind) {
    mp_obj_bool_t *self = MP_OBJ_TO_PTR(self_in);
    if (MICROPY_PY_UJSON && kind == PRINT_JSON) {
        if (self->value) {
            micropy_print_str(mp_state, print, "true");
        } else {
            micropy_print_str(mp_state, print, "false");
        }
    } else {
        if (self->value) {
            micropy_print_str(mp_state, print, "True");
        } else {
            micropy_print_str(mp_state, print, "False");
        }
    }
}

STATIC mp_obj_t micropy_bool_make_new(struct _mp_state_ctx_t *mp_state, const mp_obj_type_t *type_in, size_t n_args, size_t n_kw, const mp_obj_t *args) {
    (void)type_in;
    micropy_arg_check_num(mp_state, n_args, n_kw, 0, 1, false);

    switch (n_args) {
        case 0:
            return mp_const_false;
        case 1:
        default: // must be 0 or 1
            if (micropy_obj_is_true(mp_state, args[0])) { return mp_const_true; } else { return mp_const_false; }
    }
}

STATIC mp_obj_t micropy_bool_unary_op(struct _mp_state_ctx_t *mp_state, mp_uint_t op, mp_obj_t o_in) {
    mp_int_t value = ((mp_obj_bool_t*)MP_OBJ_TO_PTR(o_in))->value;
    switch (op) {
        case MP_UNARY_OP_BOOL: return o_in;
        // needs to hash to the same value as if converting to an integer
        case MP_UNARY_OP_HASH: return MP_OBJ_NEW_SMALL_INT(value);
        case MP_UNARY_OP_POSITIVE: return MP_OBJ_NEW_SMALL_INT(value);
        case MP_UNARY_OP_NEGATIVE: return MP_OBJ_NEW_SMALL_INT(-value);
        case MP_UNARY_OP_INVERT: return MP_OBJ_NEW_SMALL_INT(~value);
        default: return MP_OBJ_NULL; // op not supported
    }
}

STATIC mp_obj_t micropy_bool_binary_op(struct _mp_state_ctx_t *mp_state, mp_uint_t op, mp_obj_t lhs_in, mp_obj_t rhs_in) {
    mp_obj_bool_t *self = MP_OBJ_TO_PTR(lhs_in);
    return micropy_binary_op(mp_state, op, MP_OBJ_NEW_SMALL_INT(self->value), rhs_in);
}

const mp_obj_type_t mp_type_bool = {
    { &mp_type_type },
    .name = MP_QSTR_bool,
    .print = micropy_bool_print,
    .make_new = micropy_bool_make_new,
    .unary_op = micropy_bool_unary_op,
    .binary_op = micropy_bool_binary_op,
};

const mp_obj_bool_t mp_const_false_obj = {{&mp_type_bool}, false};
const mp_obj_bool_t mp_const_true_obj = {{&mp_type_bool}, true};
/*
 * This file is part of the Micro Python project, http://micropython.org/
 *
 * The MIT License (MIT)
 *
 * Copyright (c) 2013, 2014 Damien P. George
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

#include <string.h>

//#include "py/obj.h"
//#include "py/runtime.h"

typedef struct _mp_obj_bound_meth_t {
    mp_obj_base_t base;
    mp_obj_t meth;
    mp_obj_t self;
} mp_obj_bound_meth_t;

#if MICROPY_ERROR_REPORTING == MICROPY_ERROR_REPORTING_DETAILED
STATIC void micropy_bound_meth_print(struct _mp_state_ctx_t *mp_state, const mp_print_t *print, mp_obj_t o_in, mp_print_kind_t kind) {
    (void)kind;
    mp_obj_bound_meth_t *o = MP_OBJ_TO_PTR(o_in);
    micropy_printf(mp_state, print, "<bound_method %p ", o);
    micropy_obj_print_helper(mp_state, print, o->self, PRINT_REPR);
    micropy_print_str(mp_state, print, ".");
    micropy_obj_print_helper(mp_state, print, o->meth, PRINT_REPR);
    micropy_print_str(mp_state, print, ">");
}
#endif

STATIC mp_obj_t micropy_bound_meth_call(struct _mp_state_ctx_t *mp_state, mp_obj_t self_in, size_t n_args, size_t n_kw, const mp_obj_t *args) {
    mp_obj_bound_meth_t *self = MP_OBJ_TO_PTR(self_in);

    // need to insert self->self before all other args and then call self->meth

    size_t n_total = n_args + 2 * n_kw;
    mp_obj_t *args2 = NULL;
    mp_obj_t *free_args2 = NULL;
    if (n_total > 4) {
        // try to use heap to allocate temporary args array
        args2 = micropy_m_new_maybe(mp_state, mp_obj_t, 1 + n_total);
        free_args2 = args2;
    }
    if (args2 == NULL) {
        // (fallback to) use stack to allocate temporary args array
        args2 = alloca(sizeof(mp_obj_t) * (1 + n_total));
    }
    args2[0] = self->self;
    memcpy(args2 + 1, args, n_total * sizeof(mp_obj_t));
    mp_obj_t res = micropy_call_function_n_kw(mp_state, self->meth, n_args + 1, n_kw, &args2[0]);
    if (free_args2 != NULL) {
        micropy_m_del(mp_state, mp_obj_t, free_args2, 1 + n_total);
    }
    return res;
}

#if MICROPY_PY_FUNCTION_ATTRS
STATIC void micropy_bound_meth_attr(struct _mp_state_ctx_t *mp_state, mp_obj_t self_in, qstr attr, mp_obj_t *dest) {
    if (dest[0] != MP_OBJ_NULL) {
        // not load attribute
        return;
    }
    if (attr == MP_QSTR___name__) {
        mp_obj_bound_meth_t *o = MP_OBJ_TO_PTR(self_in);
        dest[0] = MP_OBJ_NEW_QSTR(micropy_obj_fun_get_name(mp_state, o->meth));
    }
}
#endif

STATIC const mp_obj_type_t mp_type_bound_meth = {
    { &mp_type_type },
    .name = MP_QSTR_bound_method,
#if MICROPY_ERROR_REPORTING == MICROPY_ERROR_REPORTING_DETAILED
    .print = micropy_bound_meth_print,
#endif
    .call = micropy_bound_meth_call,
#if MICROPY_PY_FUNCTION_ATTRS
    .attr = micropy_bound_meth_attr,
#endif
};

mp_obj_t micropy_obj_new_bound_meth(struct _mp_state_ctx_t *mp_state, mp_obj_t meth, mp_obj_t self) {
    mp_obj_bound_meth_t *o = micropy_m_new_obj(mp_state, mp_obj_bound_meth_t);
    o->base.type = &mp_type_bound_meth;
    o->meth = meth;
    o->self = self;
    return MP_OBJ_FROM_PTR(o);
}
/*
 * This file is part of the Micro Python project, http://micropython.org/
 *
 * The MIT License (MIT)
 *
 * Copyright (c) 2013, 2014 Damien P. George
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

//#include "py/obj.h"

typedef struct _mp_obj_cell_t {
    mp_obj_base_t base;
    mp_obj_t obj;
} mp_obj_cell_t;

mp_obj_t micropy_obj_cell_get(struct _mp_state_ctx_t *mp_state, mp_obj_t self_in) {
    mp_obj_cell_t *self = MP_OBJ_TO_PTR(self_in);
    return self->obj;
}

void micropy_obj_cell_set(struct _mp_state_ctx_t *mp_state, mp_obj_t self_in, mp_obj_t obj) {
    mp_obj_cell_t *self = MP_OBJ_TO_PTR(self_in);
    self->obj = obj;
}

#if MICROPY_ERROR_REPORTING == MICROPY_ERROR_REPORTING_DETAILED
STATIC void micropy_cell_print(struct _mp_state_ctx_t *mp_state, const mp_print_t *print, mp_obj_t o_in, mp_print_kind_t kind) {
    (void)kind;
    mp_obj_cell_t *o = MP_OBJ_TO_PTR(o_in);
    micropy_printf(mp_state, print, "<cell %p ", o->obj);
    if (o->obj == MP_OBJ_NULL) {
        micropy_print_str(mp_state, print, "(nil)");
    } else {
        micropy_obj_print_helper(mp_state, print, o->obj, PRINT_REPR);
    }
    micropy_print_str(mp_state, print, ">");
}
#endif

STATIC const mp_obj_type_t mp_type_cell = {
    { &mp_type_type },
    .name = MP_QSTR_, // cell representation is just value in < >
#if MICROPY_ERROR_REPORTING == MICROPY_ERROR_REPORTING_DETAILED
    .print = micropy_cell_print,
#endif
};

mp_obj_t micropy_obj_new_cell(struct _mp_state_ctx_t *mp_state, mp_obj_t obj) {
    mp_obj_cell_t *o = micropy_m_new_obj(mp_state, mp_obj_cell_t);
    o->base.type = &mp_type_cell;
    o->obj = obj;
    return MP_OBJ_FROM_PTR(o);
}
/*
 * This file is part of the Micro Python project, http://micropython.org/
 *
 * The MIT License (MIT)
 *
 * Copyright (c) 2013, 2014 Damien P. George
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

#include <string.h>

//#include "py/obj.h"
//#include "py/runtime.h"

typedef struct _mp_obj_closure_t {
    mp_obj_base_t base;
    mp_obj_t fun;
    mp_uint_t n_closed;
    mp_obj_t closed[];
} mp_obj_closure_t;

STATIC mp_obj_t micropy_closure_call(struct _mp_state_ctx_t *mp_state, mp_obj_t self_in, size_t n_args, size_t n_kw, const mp_obj_t *args) {
    mp_obj_closure_t *self = MP_OBJ_TO_PTR(self_in);

    // need to concatenate closed-over-vars and args

    mp_uint_t n_total = self->n_closed + n_args + 2 * n_kw;
    if (n_total <= 5) {
        // use stack to allocate temporary args array
        mp_obj_t args2[5];
        memcpy(args2, self->closed, self->n_closed * sizeof(mp_obj_t));
        memcpy(args2 + self->n_closed, args, (n_args + 2 * n_kw) * sizeof(mp_obj_t));
        return micropy_call_function_n_kw(mp_state, self->fun, self->n_closed + n_args, n_kw, args2);
    } else {
        // use heap to allocate temporary args array
        mp_obj_t *args2 = micropy_m_new(mp_state, mp_obj_t, n_total);
        memcpy(args2, self->closed, self->n_closed * sizeof(mp_obj_t));
        memcpy(args2 + self->n_closed, args, (n_args + 2 * n_kw) * sizeof(mp_obj_t));
        mp_obj_t res = micropy_call_function_n_kw(mp_state, self->fun, self->n_closed + n_args, n_kw, args2);
        micropy_m_del(mp_state, mp_obj_t, args2, n_total);
        return res;
    }
}

#if MICROPY_ERROR_REPORTING == MICROPY_ERROR_REPORTING_DETAILED
STATIC void micropy_closure_print(struct _mp_state_ctx_t *mp_state, const mp_print_t *print, mp_obj_t o_in, mp_print_kind_t kind) {
    (void)kind;
    mp_obj_closure_t *o = MP_OBJ_TO_PTR(o_in);
    micropy_print_str(mp_state, print, "<closure ");
    micropy_obj_print_helper(mp_state, print, o->fun, PRINT_REPR);
    micropy_printf(mp_state, print, " at %p, n_closed=%u ", o, (int)o->n_closed);
    for (mp_uint_t i = 0; i < o->n_closed; i++) {
        if (o->closed[i] == MP_OBJ_NULL) {
            micropy_print_str(mp_state, print, "(nil)");
        } else {
            micropy_obj_print_helper(mp_state, print, o->closed[i], PRINT_REPR);
        }
        micropy_print_str(mp_state, print, " ");
    }
    micropy_print_str(mp_state, print, ">");
}
#endif

const mp_obj_type_t closure_type = {
    { &mp_type_type },
    .name = MP_QSTR_closure,
#if MICROPY_ERROR_REPORTING == MICROPY_ERROR_REPORTING_DETAILED
    .print = micropy_closure_print,
#endif
    .call = micropy_closure_call,
};

mp_obj_t micropy_obj_new_closure(struct _mp_state_ctx_t *mp_state, mp_obj_t fun, mp_uint_t n_closed_over, const mp_obj_t *closed) {
    mp_obj_closure_t *o = micropy_m_new_obj_var(mp_state, mp_obj_closure_t, mp_obj_t, n_closed_over);
    o->base.type = &closure_type;
    o->fun = fun;
    o->n_closed = n_closed_over;
    memcpy(o->closed, closed, n_closed_over * sizeof(mp_obj_t));
    return MP_OBJ_FROM_PTR(o);
}
/*
 * This file is part of the Micro Python project, http://micropython.org/
 *
 * The MIT License (MIT)
 *
 * Copyright (c) 2013, 2014 Damien P. George
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

#include <stdlib.h>
#include <stdio.h>
#include <assert.h>

//#include "py/nlr.h"
//#include "py/obj.h"
//#include "py/parsenum.h"
//#include "py/runtime0.h"
//#include "py/runtime.h"

#if MICROPY_PY_BUILTINS_COMPLEX

#include <math.h>
//#include "py/formatfloat.h"

typedef struct _mp_obj_complex_t {
    mp_obj_base_t base;
    mp_float_t real;
    mp_float_t imag;
} mp_obj_complex_t;

STATIC void micropy_complex_print(struct _mp_state_ctx_t *mp_state, const mp_print_t *print, mp_obj_t o_in, mp_print_kind_t kind) {
    (void)kind;
    mp_obj_complex_t *o = MP_OBJ_TO_PTR(o_in);
#if MICROPY_FLOAT_IMPL == MICROPY_FLOAT_IMPL_FLOAT
    char buf[16];
    const int precision = 7;
#else
    char buf[32];
    const int precision = 16;
#endif
    if (o->real == 0) {
        micropy_format_float(mp_state, o->imag, buf, sizeof(buf), 'g', precision, '\0');
        micropy_printf(mp_state, print, "%sj", buf);
    } else {
        micropy_format_float(mp_state, o->real, buf, sizeof(buf), 'g', precision, '\0');
        micropy_printf(mp_state, print, "(%s", buf);
        if (o->imag >= 0 || isnan(o->imag)) {
            micropy_print_str(mp_state, print, "+");
        }
        micropy_format_float(mp_state, o->imag, buf, sizeof(buf), 'g', precision, '\0');
        micropy_printf(mp_state, print, "%sj)", buf);
    }
}

STATIC mp_obj_t micropy_complex_make_new(struct _mp_state_ctx_t *mp_state, const mp_obj_type_t *type_in, size_t n_args, size_t n_kw, const mp_obj_t *args) {
    (void)type_in;
    micropy_arg_check_num(mp_state, n_args, n_kw, 0, 2, false);

    switch (n_args) {
        case 0:
            return micropy_obj_new_complex(mp_state, 0, 0);

        case 1:
            if (MP_OBJ_IS_STR(args[0])) {
                // a string, parse it
                mp_uint_t l;
                const char *s = micropy_obj_str_get_data(mp_state, args[0], &l);
                return micropy_parse_num_decimal(mp_state, s, l, true, true, NULL);
            } else if (MP_OBJ_IS_TYPE(args[0], &mp_type_complex)) {
                // a complex, just return it
                return args[0];
            } else {
                // something else, try to cast it to a complex
                return micropy_obj_new_complex(mp_state, micropy_obj_get_float(mp_state, args[0]), 0);
            }

        case 2:
        default: {
            mp_float_t real, imag;
            if (MP_OBJ_IS_TYPE(args[0], &mp_type_complex)) {
                micropy_obj_complex_get(mp_state, args[0], &real, &imag);
            } else {
                real = micropy_obj_get_float(mp_state, args[0]);
                imag = 0;
            }
            if (MP_OBJ_IS_TYPE(args[1], &mp_type_complex)) {
                mp_float_t real2, imag2;
                micropy_obj_complex_get(mp_state, args[1], &real2, &imag2);
                real -= imag2;
                imag += real2;
            } else {
                imag += micropy_obj_get_float(mp_state, args[1]);
            }
            return micropy_obj_new_complex(mp_state, real, imag);
        }
    }
}

STATIC mp_obj_t micropy_complex_unary_op(struct _mp_state_ctx_t *mp_state, mp_uint_t op, mp_obj_t o_in) {
    mp_obj_complex_t *o = MP_OBJ_TO_PTR(o_in);
    switch (op) {
        case MP_UNARY_OP_BOOL: return micropy_obj_new_bool(mp_state, o->real != 0 || o->imag != 0);
        case MP_UNARY_OP_POSITIVE: return o_in;
        case MP_UNARY_OP_NEGATIVE: return micropy_obj_new_complex(mp_state, -o->real, -o->imag);
        default: return MP_OBJ_NULL; // op not supported
    }
}

STATIC mp_obj_t micropy_complex_binary_op(struct _mp_state_ctx_t *mp_state, mp_uint_t op, mp_obj_t lhs_in, mp_obj_t rhs_in) {
    mp_obj_complex_t *lhs = MP_OBJ_TO_PTR(lhs_in);
    return micropy_obj_complex_binary_op(mp_state, op, lhs->real, lhs->imag, rhs_in);
}

STATIC void micropy_complex_attr(struct _mp_state_ctx_t *mp_state, mp_obj_t self_in, qstr attr, mp_obj_t *dest) {
    if (dest[0] != MP_OBJ_NULL) {
        // not load attribute
        return;
    }
    mp_obj_complex_t *self = MP_OBJ_TO_PTR(self_in);
    if (attr == MP_QSTR_real) {
        dest[0] = micropy_obj_new_float(mp_state, self->real);
    } else if (attr == MP_QSTR_imag) {
        dest[0] = micropy_obj_new_float(mp_state, self->imag);
    }
}

const mp_obj_type_t mp_type_complex = {
    { &mp_type_type },
    .name = MP_QSTR_complex,
    .print = micropy_complex_print,
    .make_new = micropy_complex_make_new,
    .unary_op = micropy_complex_unary_op,
    .binary_op = micropy_complex_binary_op,
    .attr = micropy_complex_attr,
};

mp_obj_t micropy_obj_new_complex(struct _mp_state_ctx_t *mp_state, mp_float_t real, mp_float_t imag) {
    mp_obj_complex_t *o = micropy_m_new_obj(mp_state, mp_obj_complex_t);
    o->base.type = &mp_type_complex;
    o->real = real;
    o->imag = imag;
    return MP_OBJ_FROM_PTR(o);
}

void micropy_obj_complex_get(struct _mp_state_ctx_t *mp_state, mp_obj_t self_in, mp_float_t *real, mp_float_t *imag) {
    assert(MP_OBJ_IS_TYPE(self_in, &mp_type_complex));
    mp_obj_complex_t *self = MP_OBJ_TO_PTR(self_in);
    *real = self->real;
    *imag = self->imag;
}

mp_obj_t micropy_obj_complex_binary_op(struct _mp_state_ctx_t *mp_state, mp_uint_t op, mp_float_t lhs_real, mp_float_t lhs_imag, mp_obj_t rhs_in) {
    mp_float_t rhs_real, rhs_imag;
    micropy_obj_get_complex(mp_state, rhs_in, &rhs_real, &rhs_imag); // can be any type, this function will convert to float (if possible)
    switch (op) {
        case MP_BINARY_OP_ADD:
        case MP_BINARY_OP_INPLACE_ADD:
            lhs_real += rhs_real;
            lhs_imag += rhs_imag;
            break;
        case MP_BINARY_OP_SUBTRACT:
        case MP_BINARY_OP_INPLACE_SUBTRACT:
            lhs_real -= rhs_real;
            lhs_imag -= rhs_imag;
            break;
        case MP_BINARY_OP_MULTIPLY:
        case MP_BINARY_OP_INPLACE_MULTIPLY: {
            mp_float_t real;
            multiply:
            real = lhs_real * rhs_real - lhs_imag * rhs_imag;
            lhs_imag = lhs_real * rhs_imag + lhs_imag * rhs_real;
            lhs_real = real;
            break;
        }
        case MP_BINARY_OP_FLOOR_DIVIDE:
        case MP_BINARY_OP_INPLACE_FLOOR_DIVIDE:
            micropy_nlr_raise(mp_state, micropy_obj_new_exception_msg_varg(mp_state, &mp_type_TypeError, "can't do truncated division of a complex number"));

        case MP_BINARY_OP_TRUE_DIVIDE:
        case MP_BINARY_OP_INPLACE_TRUE_DIVIDE:
            if (rhs_imag == 0) {
                if (rhs_real == 0) {
                    micropy_nlr_raise(mp_state, micropy_obj_new_exception_msg(mp_state, &mp_type_ZeroDivisionError, "complex division by zero"));
                }
                lhs_real /= rhs_real;
                lhs_imag /= rhs_real;
            } else if (rhs_real == 0) {
                mp_float_t real = lhs_imag / rhs_imag;
                lhs_imag = -lhs_real / rhs_imag;
                lhs_real = real;
            } else {
                mp_float_t rhs_len_sq = rhs_real*rhs_real + rhs_imag*rhs_imag;
                rhs_real /= rhs_len_sq;
                rhs_imag /= -rhs_len_sq;
                goto multiply;
            }
            break;

        case MP_BINARY_OP_POWER:
        case MP_BINARY_OP_INPLACE_POWER: {
            // z1**z2 = exp(z2*ln(z1))
            //        = exp(z2*(ln(|z1|)+i*arg(z1)))
            //        = exp( (x2*ln1 - y2*arg1) + i*(y2*ln1 + x2*arg1) )
            //        = exp(x3 + i*y3)
            //        = exp(x3)*(cos(y3) + i*sin(y3))
            mp_float_t abs1 = MICROPY_FLOAT_C_FUN(sqrt)(lhs_real*lhs_real + lhs_imag*lhs_imag);
            if (abs1 == 0) {
                if (rhs_imag == 0) {
                    lhs_real = 1;
                    rhs_real = 0;
                } else {
                    micropy_nlr_raise(mp_state, micropy_obj_new_exception_msg(mp_state, &mp_type_ZeroDivisionError, "0.0 to a complex power"));
                }
            } else {
                mp_float_t ln1 = MICROPY_FLOAT_C_FUN(log)(abs1);
                mp_float_t arg1 = MICROPY_FLOAT_C_FUN(atan2)(lhs_imag, lhs_real);
                mp_float_t x3 = rhs_real * ln1 - rhs_imag * arg1;
                mp_float_t y3 = rhs_imag * ln1 + rhs_real * arg1;
                mp_float_t exp_x3 = MICROPY_FLOAT_C_FUN(exp)(x3);
                lhs_real = exp_x3 * MICROPY_FLOAT_C_FUN(cos)(y3);
                lhs_imag = exp_x3 * MICROPY_FLOAT_C_FUN(sin)(y3);
            }
            break;
        }

        case MP_BINARY_OP_EQUAL: return micropy_obj_new_bool(mp_state, lhs_real == rhs_real && lhs_imag == rhs_imag);

        default:
            return MP_OBJ_NULL; // op not supported
    }
    return micropy_obj_new_complex(mp_state, lhs_real, lhs_imag);
}

#endif
/*
 * This file is part of the Micro Python project, http://micropython.org/
 *
 * The MIT License (MIT)
 *
 * Copyright (c) 2013, 2014 Damien P. George
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

#include <string.h>
#include <assert.h>

//#include "py/nlr.h"
//#include "py/obj.h"
//#include "py/runtime0.h"
//#include "py/runtime.h"
//#include "py/builtin.h"
//#include "py/objtype.h"

#define MP_OBJ_IS_DICT_TYPE(o) (MP_OBJ_IS_OBJ(o) && ((mp_obj_base_t*)MP_OBJ_TO_PTR(o))->type->make_new == micropy_dict_make_new)

STATIC mp_obj_t micropy_dict_update(struct _mp_state_ctx_t *mp_state, size_t n_args, const mp_obj_t *args, mp_map_t *kwargs);

// This is a helper function to iterate through a dictionary.  The state of
// the iteration is held in *cur and should be initialised with zero for the
// first call.  Will return NULL when no more elements are available.
STATIC mp_map_elem_t *micropy_dict_iter_next(struct _mp_state_ctx_t *mp_state, mp_obj_dict_t *dict, mp_uint_t *cur) {
    mp_uint_t max = dict->map.alloc;
    mp_map_t *map = &dict->map;

    for (mp_uint_t i = *cur; i < max; i++) {
        if (MP_MAP_SLOT_IS_FILLED(map, i)) {
            *cur = i + 1;
            return &(map->table[i]);
        }
    }

    return NULL;
}

STATIC void micropy_dict_print(struct _mp_state_ctx_t *mp_state, const mp_print_t *print, mp_obj_t self_in, mp_print_kind_t kind) {
    mp_obj_dict_t *self = MP_OBJ_TO_PTR(self_in);
    bool first = true;
    if (!(MICROPY_PY_UJSON && kind == PRINT_JSON)) {
        kind = PRINT_REPR;
    }
    if (MICROPY_PY_COLLECTIONS_ORDEREDDICT && self->base.type != &mp_type_dict) {
        micropy_printf(mp_state, print, "%q(", self->base.type->name);
    }
    micropy_print_str(mp_state, print, "{");
    mp_uint_t cur = 0;
    mp_map_elem_t *next = NULL;
    while ((next = micropy_dict_iter_next(mp_state, self, &cur)) != NULL) {
        if (!first) {
            micropy_print_str(mp_state, print, ", ");
        }
        first = false;
        micropy_obj_print_helper(mp_state, print, next->key, kind);
        micropy_print_str(mp_state, print, ": ");
        micropy_obj_print_helper(mp_state, print, next->value, kind);
    }
    micropy_print_str(mp_state, print, "}");
    if (MICROPY_PY_COLLECTIONS_ORDEREDDICT && self->base.type != &mp_type_dict) {
        micropy_print_str(mp_state, print, ")");
    }
}

STATIC mp_obj_t micropy_dict_make_new(struct _mp_state_ctx_t *mp_state, const mp_obj_type_t *type, size_t n_args, size_t n_kw, const mp_obj_t *args) {
    mp_obj_t dict_out = micropy_obj_new_dict(mp_state, 0);
    mp_obj_dict_t *dict = MP_OBJ_TO_PTR(dict_out);
    dict->base.type = type;
    #if MICROPY_PY_COLLECTIONS_ORDEREDDICT
    if (type == &mp_type_ordereddict) {
        dict->map.is_ordered = 1;
    }
    #endif
    if (n_args > 0 || n_kw > 0) {
        mp_obj_t args2[2] = {dict_out, args[0]}; // args[0] is always valid, even if it's not a positional arg
        mp_map_t kwargs;
        micropy_map_init_fixed_table(mp_state, &kwargs, n_kw, args + n_args);
        micropy_dict_update(mp_state, n_args + 1, args2, &kwargs); // dict_update will check that n_args + 1 == 1 or 2
    }
    return dict_out;
}

STATIC mp_obj_t micropy_dict_unary_op(struct _mp_state_ctx_t *mp_state, mp_uint_t op, mp_obj_t self_in) {
    mp_obj_dict_t *self = MP_OBJ_TO_PTR(self_in);
    switch (op) {
        case MP_UNARY_OP_BOOL: return micropy_obj_new_bool(mp_state, self->map.used != 0);
        case MP_UNARY_OP_LEN: return MP_OBJ_NEW_SMALL_INT(self->map.used);
        default: return MP_OBJ_NULL; // op not supported
    }
}

STATIC mp_obj_t micropy_dict_binary_op(struct _mp_state_ctx_t *mp_state, mp_uint_t op, mp_obj_t lhs_in, mp_obj_t rhs_in) {
    mp_obj_dict_t *o = MP_OBJ_TO_PTR(lhs_in);
    switch (op) {
        case MP_BINARY_OP_IN: {
            mp_map_elem_t *elem = micropy_map_lookup(mp_state, &o->map, rhs_in, MP_MAP_LOOKUP);
            return micropy_obj_new_bool(mp_state, elem != NULL);
        }
        case MP_BINARY_OP_EQUAL: {
            #if MICROPY_PY_COLLECTIONS_ORDEREDDICT
            if (MP_UNLIKELY(MP_OBJ_IS_TYPE(lhs_in, &mp_type_ordereddict) && MP_OBJ_IS_TYPE(rhs_in, &mp_type_ordereddict))) {
                //TODO: implement
                return MP_OBJ_NULL;
            } else
            #endif
            if (MP_OBJ_IS_TYPE(rhs_in, &mp_type_dict)) {
                mp_obj_dict_t *rhs = MP_OBJ_TO_PTR(rhs_in);
                if (o->map.used != rhs->map.used) {
                    return mp_const_false;
                }

                mp_uint_t cur = 0;
                mp_map_elem_t *next = NULL;
                while ((next = micropy_dict_iter_next(mp_state, o, &cur)) != NULL) {
                    mp_map_elem_t *elem = micropy_map_lookup(mp_state, &rhs->map, next->key, MP_MAP_LOOKUP);
                    if (elem == NULL || !micropy_obj_equal(mp_state, next->value, elem->value)) {
                        return mp_const_false;
                    }
                }
                return mp_const_true;
            } else {
                // dict is not equal to instance of any other type
                return mp_const_false;
            }
        }
        default:
            // op not supported
            return MP_OBJ_NULL;
    }
}

// TODO: Make sure this is inlined in dict_subscr() below.
mp_obj_t micropy_obj_dict_get(struct _mp_state_ctx_t *mp_state, mp_obj_t self_in, mp_obj_t index) {
    mp_obj_dict_t *self = MP_OBJ_TO_PTR(self_in);
    mp_map_elem_t *elem = micropy_map_lookup(mp_state, &self->map, index, MP_MAP_LOOKUP);
    if (elem == NULL) {
        micropy_nlr_raise(mp_state, micropy_obj_new_exception_msg(mp_state, &mp_type_KeyError, "<value>"));
    } else {
        return elem->value;
    }
}

STATIC mp_obj_t micropy_dict_subscr(struct _mp_state_ctx_t *mp_state, mp_obj_t self_in, mp_obj_t index, mp_obj_t value) {
    if (value == MP_OBJ_NULL) {
        // delete
        micropy_obj_dict_delete(mp_state, self_in, index);
        return mp_const_none;
    } else if (value == MP_OBJ_SENTINEL) {
        // load
        mp_obj_dict_t *self = MP_OBJ_TO_PTR(self_in);
        mp_map_elem_t *elem = micropy_map_lookup(mp_state, &self->map, index, MP_MAP_LOOKUP);
        if (elem == NULL) {
            micropy_nlr_raise(mp_state, micropy_obj_new_exception_msg(mp_state, &mp_type_KeyError, "<value>"));
        } else {
            return elem->value;
        }
    } else {
        // store
        micropy_obj_dict_store(mp_state, self_in, index, value);
        return mp_const_none;
    }
}

/******************************************************************************/
/* dict iterator                                                              */

typedef struct _mp_obj_dict_it_t {
    mp_obj_base_t base;
    mp_fun_1_t iternext;
    mp_obj_t dict;
    mp_uint_t cur;
} mp_obj_dict_it_t;

STATIC mp_obj_t micropy_dict_it_iternext(struct _mp_state_ctx_t *mp_state, mp_obj_t self_in) {
    mp_obj_dict_it_t *self = MP_OBJ_TO_PTR(self_in);
    mp_map_elem_t *next = micropy_dict_iter_next(mp_state, MP_OBJ_TO_PTR(self->dict), &self->cur);

    if (next == NULL) {
        return MP_OBJ_STOP_ITERATION;
    } else {
        return next->key;
    }
}

STATIC mp_obj_t micropy_dict_getiter(struct _mp_state_ctx_t *mp_state, mp_obj_t self_in) {
    mp_obj_dict_it_t *o = micropy_m_new_obj(mp_state, mp_obj_dict_it_t);
    o->base.type = &mp_type_polymorph_iter;
    o->iternext = micropy_dict_it_iternext;
    o->dict = self_in;
    o->cur = 0;
    return MP_OBJ_FROM_PTR(o);
}

/******************************************************************************/
/* dict methods                                                               */

STATIC mp_obj_t micropy_dict_clear(struct _mp_state_ctx_t *mp_state, mp_obj_t self_in) {
    assert(MP_OBJ_IS_DICT_TYPE(self_in));
    mp_obj_dict_t *self = MP_OBJ_TO_PTR(self_in);

    micropy_map_clear(mp_state, &self->map);

    return mp_const_none;
}
STATIC MP_DEFINE_CONST_FUN_OBJ_1(dict_clear_obj, micropy_dict_clear);

STATIC mp_obj_t micropy_dict_copy(struct _mp_state_ctx_t *mp_state, mp_obj_t self_in) {
    assert(MP_OBJ_IS_DICT_TYPE(self_in));
    mp_obj_dict_t *self = MP_OBJ_TO_PTR(self_in);
    mp_obj_t other_out = micropy_obj_new_dict(mp_state, self->map.alloc);
    mp_obj_dict_t *other = MP_OBJ_TO_PTR(other_out);
    other->base.type = self->base.type;
    other->map.used = self->map.used;
    other->map.all_keys_are_qstrs = self->map.all_keys_are_qstrs;
    other->map.is_fixed = 0;
    other->map.is_ordered = self->map.is_ordered;
    memcpy(other->map.table, self->map.table, self->map.alloc * sizeof(mp_map_elem_t));
    return other_out;
}
STATIC MP_DEFINE_CONST_FUN_OBJ_1(dict_copy_obj, micropy_dict_copy);

// this is a classmethod
STATIC mp_obj_t micropy_dict_fromkeys(struct _mp_state_ctx_t *mp_state, size_t n_args, const mp_obj_t *args) {
    assert(2 <= n_args && n_args <= 3);
    mp_obj_t iter = micropy_getiter(mp_state, args[1]);
    mp_obj_t len = micropy_obj_len_maybe(mp_state, iter);
    mp_obj_t value = mp_const_none;
    mp_obj_t next = MP_OBJ_NULL;
    mp_obj_t self_out;

    if (n_args > 2) {
        value = args[2];
    }

    if (len == MP_OBJ_NULL) {
        /* object's type doesn't have a __len__ slot */
        self_out = micropy_obj_new_dict(mp_state, 0);
    } else {
        self_out = micropy_obj_new_dict(mp_state, MP_OBJ_SMALL_INT_VALUE(len));
    }

    mp_obj_dict_t *self = MP_OBJ_TO_PTR(self_out);
    while ((next = micropy_iternext(mp_state, iter)) != MP_OBJ_STOP_ITERATION) {
        micropy_map_lookup(mp_state, &self->map, next, MP_MAP_LOOKUP_ADD_IF_NOT_FOUND)->value = value;
    }

    return self_out;
}
STATIC MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(dict_fromkeys_fun_obj, 2, 3, micropy_dict_fromkeys);
STATIC MP_DEFINE_CONST_CLASSMETHOD_OBJ(dict_fromkeys_obj, MP_ROM_PTR(&dict_fromkeys_fun_obj));

STATIC mp_obj_t micropy_dict_get_helper(struct _mp_state_ctx_t *mp_state, mp_map_t *self, mp_obj_t key, mp_obj_t deflt, mp_map_lookup_kind_t lookup_kind) {
    mp_map_elem_t *elem = micropy_map_lookup(mp_state, self, key, lookup_kind);
    mp_obj_t value;
    if (elem == NULL || elem->value == MP_OBJ_NULL) {
        if (deflt == MP_OBJ_NULL) {
            if (lookup_kind == MP_MAP_LOOKUP_REMOVE_IF_FOUND) {
                micropy_nlr_raise(mp_state, micropy_obj_new_exception_msg(mp_state, &mp_type_KeyError, "<value>"));
            } else {
                value = mp_const_none;
            }
        } else {
            value = deflt;
        }
        if (lookup_kind == MP_MAP_LOOKUP_ADD_IF_NOT_FOUND) {
            elem->value = value;
        }
    } else {
        value = elem->value;
        if (lookup_kind == MP_MAP_LOOKUP_REMOVE_IF_FOUND) {
            elem->value = MP_OBJ_NULL; // so that GC can collect the deleted value
        }
    }
    return value;
}

STATIC mp_obj_t micropy_dict_get(struct _mp_state_ctx_t *mp_state, size_t n_args, const mp_obj_t *args) {
    assert(2 <= n_args && n_args <= 3);
    assert(MP_OBJ_IS_DICT_TYPE(args[0]));
    mp_obj_dict_t *self = MP_OBJ_TO_PTR(args[0]);

    return micropy_dict_get_helper(mp_state, &self->map,
                           args[1],
                           n_args == 3 ? args[2] : MP_OBJ_NULL,
                           MP_MAP_LOOKUP);
}
STATIC MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(dict_get_obj, 2, 3, micropy_dict_get);

STATIC mp_obj_t micropy_dict_pop(struct _mp_state_ctx_t *mp_state, size_t n_args, const mp_obj_t *args) {
    assert(2 <= n_args && n_args <= 3);
    assert(MP_OBJ_IS_DICT_TYPE(args[0]));
    mp_obj_dict_t *self = MP_OBJ_TO_PTR(args[0]);

    return micropy_dict_get_helper(mp_state, &self->map,
                           args[1],
                           n_args == 3 ? args[2] : MP_OBJ_NULL,
                           MP_MAP_LOOKUP_REMOVE_IF_FOUND);
}
STATIC MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(dict_pop_obj, 2, 3, micropy_dict_pop);


STATIC mp_obj_t micropy_dict_setdefault(struct _mp_state_ctx_t *mp_state, size_t n_args, const mp_obj_t *args) {
    assert(2 <= n_args && n_args <= 3);
    assert(MP_OBJ_IS_DICT_TYPE(args[0]));
    mp_obj_dict_t *self = MP_OBJ_TO_PTR(args[0]);

    return micropy_dict_get_helper(mp_state, &self->map,
                           args[1],
                           n_args == 3 ? args[2] : MP_OBJ_NULL,
                           MP_MAP_LOOKUP_ADD_IF_NOT_FOUND);
}
STATIC MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(dict_setdefault_obj, 2, 3, micropy_dict_setdefault);


STATIC mp_obj_t micropy_dict_popitem(struct _mp_state_ctx_t *mp_state, mp_obj_t self_in) {
    assert(MP_OBJ_IS_DICT_TYPE(self_in));
    mp_obj_dict_t *self = MP_OBJ_TO_PTR(self_in);
    mp_uint_t cur = 0;
    mp_map_elem_t *next = micropy_dict_iter_next(mp_state, self, &cur);
    if (next == NULL) {
        micropy_nlr_raise(mp_state, micropy_obj_new_exception_msg(mp_state, &mp_type_KeyError, "popitem(): dictionary is empty"));
    }
    self->map.used--;
    mp_obj_t items[] = {next->key, next->value};
    next->key = MP_OBJ_SENTINEL; // must mark key as sentinel to indicate that it was deleted
    next->value = MP_OBJ_NULL;
    mp_obj_t tuple = micropy_obj_new_tuple(mp_state, 2, items);

    return tuple;
}
STATIC MP_DEFINE_CONST_FUN_OBJ_1(dict_popitem_obj, micropy_dict_popitem);

STATIC mp_obj_t micropy_dict_update(struct _mp_state_ctx_t *mp_state, size_t n_args, const mp_obj_t *args, mp_map_t *kwargs) {
    assert(MP_OBJ_IS_DICT_TYPE(args[0]));
    mp_obj_dict_t *self = MP_OBJ_TO_PTR(args[0]);

    micropy_arg_check_num(mp_state, n_args, kwargs->used, 1, 2, true);

    if (n_args == 2) {
        // given a positional argument

        if (MP_OBJ_IS_DICT_TYPE(args[1])) {
            // update from other dictionary (make sure other is not self)
            if (args[1] != args[0]) {
                mp_uint_t cur = 0;
                mp_map_elem_t *elem = NULL;
                while ((elem = micropy_dict_iter_next(mp_state, (mp_obj_dict_t*)MP_OBJ_TO_PTR(args[1]), &cur)) != NULL) {
                    micropy_map_lookup(mp_state, &self->map, elem->key, MP_MAP_LOOKUP_ADD_IF_NOT_FOUND)->value = elem->value;
                }
            }
        } else {
            // update from a generic iterable of pairs
            mp_obj_t iter = micropy_getiter(mp_state, args[1]);
            mp_obj_t next = MP_OBJ_NULL;
            while ((next = micropy_iternext(mp_state, iter)) != MP_OBJ_STOP_ITERATION) {
                mp_obj_t inneriter = micropy_getiter(mp_state, next);
                mp_obj_t key = micropy_iternext(mp_state, inneriter);
                mp_obj_t value = micropy_iternext(mp_state, inneriter);
                mp_obj_t stop = micropy_iternext(mp_state, inneriter);
                if (key == MP_OBJ_STOP_ITERATION
                    || value == MP_OBJ_STOP_ITERATION
                    || stop != MP_OBJ_STOP_ITERATION) {
                    micropy_nlr_raise(mp_state, micropy_obj_new_exception_msg(mp_state, 
                                 &mp_type_ValueError,
                                 "dictionary update sequence has the wrong length"));
                } else {
                    micropy_map_lookup(mp_state, &self->map, key, MP_MAP_LOOKUP_ADD_IF_NOT_FOUND)->value = value;
                }
            }
        }
    }

    // update the dict with any keyword args
    for (mp_uint_t i = 0; i < kwargs->alloc; i++) {
        if (MP_MAP_SLOT_IS_FILLED(kwargs, i)) {
            micropy_map_lookup(mp_state, &self->map, kwargs->table[i].key, MP_MAP_LOOKUP_ADD_IF_NOT_FOUND)->value = kwargs->table[i].value;
        }
    }

    return mp_const_none;
}
STATIC MP_DEFINE_CONST_FUN_OBJ_KW(dict_update_obj, 1, micropy_dict_update);


/******************************************************************************/
/* dict views                                                                 */

STATIC const mp_obj_type_t dict_view_type;
STATIC const mp_obj_type_t dict_view_it_type;

typedef enum _mp_dict_view_kind_t {
    MP_DICT_VIEW_ITEMS,
    MP_DICT_VIEW_KEYS,
    MP_DICT_VIEW_VALUES,
} mp_dict_view_kind_t;

STATIC const char *const mp_dict_view_names[] = {"dict_items", "dict_keys", "dict_values"};

typedef struct _mp_obj_dict_view_it_t {
    mp_obj_base_t base;
    mp_dict_view_kind_t kind;
    mp_obj_t dict;
    mp_uint_t cur;
} mp_obj_dict_view_it_t;

typedef struct _mp_obj_dict_view_t {
    mp_obj_base_t base;
    mp_obj_t dict;
    mp_dict_view_kind_t kind;
} mp_obj_dict_view_t;

STATIC mp_obj_t micropy_dict_view_it_iternext(struct _mp_state_ctx_t *mp_state, mp_obj_t self_in) {
    assert(MP_OBJ_IS_TYPE(self_in, &dict_view_it_type));
    mp_obj_dict_view_it_t *self = MP_OBJ_TO_PTR(self_in);
    mp_map_elem_t *next = micropy_dict_iter_next(mp_state, MP_OBJ_TO_PTR(self->dict), &self->cur);

    if (next == NULL) {
        return MP_OBJ_STOP_ITERATION;
    } else {
        switch (self->kind) {
            case MP_DICT_VIEW_ITEMS:
            default: {
                mp_obj_t items[] = {next->key, next->value};
                return micropy_obj_new_tuple(mp_state, 2, items);
            }
            case MP_DICT_VIEW_KEYS:
                return next->key;
            case MP_DICT_VIEW_VALUES:
                return next->value;
        }
    }
}

STATIC const mp_obj_type_t dict_view_it_type = {
    { &mp_type_type },
    .name = MP_QSTR_iterator,
    .getiter = micropy_identity,
    .iternext = micropy_dict_view_it_iternext,
};

STATIC mp_obj_t micropy_dict_view_getiter(struct _mp_state_ctx_t *mp_state, mp_obj_t view_in) {
    assert(MP_OBJ_IS_TYPE(view_in, &dict_view_type));
    mp_obj_dict_view_t *view = MP_OBJ_TO_PTR(view_in);
    mp_obj_dict_view_it_t *o = micropy_m_new_obj(mp_state, mp_obj_dict_view_it_t);
    o->base.type = &dict_view_it_type;
    o->kind = view->kind;
    o->dict = view->dict;
    o->cur = 0;
    return MP_OBJ_FROM_PTR(o);
}

STATIC void micropy_dict_view_print(struct _mp_state_ctx_t *mp_state, const mp_print_t *print, mp_obj_t self_in, mp_print_kind_t kind) {
    (void)kind;
    assert(MP_OBJ_IS_TYPE(self_in, &dict_view_type));
    mp_obj_dict_view_t *self = MP_OBJ_TO_PTR(self_in);
    bool first = true;
    micropy_print_str(mp_state, print, mp_dict_view_names[self->kind]);
    micropy_print_str(mp_state, print, "([");
    mp_obj_t self_iter = micropy_dict_view_getiter(mp_state, self_in);
    mp_obj_t next = MP_OBJ_NULL;
    while ((next = micropy_dict_view_it_iternext(mp_state, self_iter)) != MP_OBJ_STOP_ITERATION) {
        if (!first) {
            micropy_print_str(mp_state, print, ", ");
        }
        first = false;
        micropy_obj_print_helper(mp_state, print, next, PRINT_REPR);
    }
    micropy_print_str(mp_state, print, "])");
}

STATIC mp_obj_t micropy_dict_view_binary_op(struct _mp_state_ctx_t *mp_state, mp_uint_t op, mp_obj_t lhs_in, mp_obj_t rhs_in) {
    // only supported for the 'keys' kind until sets and dicts are refactored
    mp_obj_dict_view_t *o = MP_OBJ_TO_PTR(lhs_in);
    if (o->kind != MP_DICT_VIEW_KEYS) {
        return MP_OBJ_NULL; // op not supported
    }
    if (op != MP_BINARY_OP_IN) {
        return MP_OBJ_NULL; // op not supported
    }
    return micropy_dict_binary_op(mp_state, op, o->dict, rhs_in);
}

STATIC const mp_obj_type_t dict_view_type = {
    { &mp_type_type },
    .name = MP_QSTR_dict_view,
    .print = micropy_dict_view_print,
    .binary_op = micropy_dict_view_binary_op,
    .getiter = micropy_dict_view_getiter,
};

STATIC mp_obj_t micropy_obj_new_dict_view(struct _mp_state_ctx_t *mp_state, mp_obj_t dict, mp_dict_view_kind_t kind) {
    mp_obj_dict_view_t *o = micropy_m_new_obj(mp_state, mp_obj_dict_view_t);
    o->base.type = &dict_view_type;
    o->dict = dict;
    o->kind = kind;
    return MP_OBJ_FROM_PTR(o);
}

STATIC mp_obj_t micropy_dict_view(struct _mp_state_ctx_t *mp_state, mp_obj_t self_in, mp_dict_view_kind_t kind) {
    assert(MP_OBJ_IS_DICT_TYPE(self_in));
    return micropy_obj_new_dict_view(mp_state, self_in, kind);
}

STATIC mp_obj_t micropy_dict_items(struct _mp_state_ctx_t *mp_state, mp_obj_t self_in) {
    return micropy_dict_view(mp_state, self_in, MP_DICT_VIEW_ITEMS);
}
STATIC MP_DEFINE_CONST_FUN_OBJ_1(dict_items_obj, micropy_dict_items);

STATIC mp_obj_t micropy_dict_keys(struct _mp_state_ctx_t *mp_state, mp_obj_t self_in) {
    return micropy_dict_view(mp_state, self_in, MP_DICT_VIEW_KEYS);
}
STATIC MP_DEFINE_CONST_FUN_OBJ_1(dict_keys_obj, micropy_dict_keys);

STATIC mp_obj_t micropy_dict_values(struct _mp_state_ctx_t *mp_state, mp_obj_t self_in) {
    return micropy_dict_view(mp_state, self_in, MP_DICT_VIEW_VALUES);
}
STATIC MP_DEFINE_CONST_FUN_OBJ_1(dict_values_obj, micropy_dict_values);

/******************************************************************************/
/* dict constructors & public C API                                           */

STATIC const mp_rom_map_elem_t dict_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_clear), MP_ROM_PTR(&dict_clear_obj) },
    { MP_ROM_QSTR(MP_QSTR_copy), MP_ROM_PTR(&dict_copy_obj) },
    { MP_ROM_QSTR(MP_QSTR_fromkeys), MP_ROM_PTR(&dict_fromkeys_obj) },
    { MP_ROM_QSTR(MP_QSTR_get), MP_ROM_PTR(&dict_get_obj) },
    { MP_ROM_QSTR(MP_QSTR_items), MP_ROM_PTR(&dict_items_obj) },
    { MP_ROM_QSTR(MP_QSTR_keys), MP_ROM_PTR(&dict_keys_obj) },
    { MP_ROM_QSTR(MP_QSTR_pop), MP_ROM_PTR(&dict_pop_obj) },
    { MP_ROM_QSTR(MP_QSTR_popitem), MP_ROM_PTR(&dict_popitem_obj) },
    { MP_ROM_QSTR(MP_QSTR_setdefault), MP_ROM_PTR(&dict_setdefault_obj) },
    { MP_ROM_QSTR(MP_QSTR_update), MP_ROM_PTR(&dict_update_obj) },
    { MP_ROM_QSTR(MP_QSTR_values), MP_ROM_PTR(&dict_values_obj) },
    { MP_ROM_QSTR(MP_QSTR___getitem__), MP_ROM_PTR(&mp_op_getitem_obj) },
    { MP_ROM_QSTR(MP_QSTR___setitem__), MP_ROM_PTR(&mp_op_setitem_obj) },
    { MP_ROM_QSTR(MP_QSTR___delitem__), MP_ROM_PTR(&mp_op_delitem_obj) },
};

STATIC MP_DEFINE_CONST_DICT(dict_locals_dict, dict_locals_dict_table);

const mp_obj_type_t mp_type_dict = {
    { &mp_type_type },
    .name = MP_QSTR_dict,
    .print = micropy_dict_print,
    .make_new = micropy_dict_make_new,
    .unary_op = micropy_dict_unary_op,
    .binary_op = micropy_dict_binary_op,
    .subscr = micropy_dict_subscr,
    .getiter = micropy_dict_getiter,
    .locals_dict = (mp_obj_dict_t*)&dict_locals_dict,
};

#if MICROPY_PY_COLLECTIONS_ORDEREDDICT
STATIC const mp_rom_obj_tuple_t ordereddict_base_tuple = {{&mp_type_tuple}, 1, {MP_ROM_PTR(&mp_type_dict)}};

const mp_obj_type_t mp_type_ordereddict = {
    { &mp_type_type },
    .name = MP_QSTR_OrderedDict,
    .print = micropy_dict_print,
    .make_new = micropy_dict_make_new,
    .unary_op = micropy_dict_unary_op,
    .binary_op = micropy_dict_binary_op,
    .subscr = micropy_dict_subscr,
    .getiter = micropy_dict_getiter,
    .bases_tuple = (mp_obj_tuple_t*)(mp_rom_obj_tuple_t*)&ordereddict_base_tuple,
    .locals_dict = (mp_obj_dict_t*)&dict_locals_dict,
};
#endif

void micropy_obj_dict_init(struct _mp_state_ctx_t *mp_state, mp_obj_dict_t *dict, mp_uint_t n_args) {
    dict->base.type = &mp_type_dict;
    micropy_map_init(mp_state, &dict->map, n_args);
}

mp_obj_t micropy_obj_new_dict(struct _mp_state_ctx_t *mp_state, mp_uint_t n_args) {
    mp_obj_dict_t *o = micropy_m_new_obj(mp_state, mp_obj_dict_t);
    micropy_obj_dict_init(mp_state, o, n_args);
    return MP_OBJ_FROM_PTR(o);
}

mp_uint_t micropy_obj_dict_len(struct _mp_state_ctx_t *mp_state, mp_obj_t self_in) {
    mp_obj_dict_t *self = MP_OBJ_TO_PTR(self_in);
    return self->map.used;
}

mp_obj_t micropy_obj_dict_store(struct _mp_state_ctx_t *mp_state, mp_obj_t self_in, mp_obj_t key, mp_obj_t value) {
    assert(MP_OBJ_IS_DICT_TYPE(self_in));
    mp_obj_dict_t *self = MP_OBJ_TO_PTR(self_in);
    micropy_map_lookup(mp_state, &self->map, key, MP_MAP_LOOKUP_ADD_IF_NOT_FOUND)->value = value;
    return self_in;
}

mp_obj_t micropy_obj_dict_delete(struct _mp_state_ctx_t *mp_state, mp_obj_t self_in, mp_obj_t key) {
    assert(MP_OBJ_IS_DICT_TYPE(self_in));
    mp_obj_dict_t *self = MP_OBJ_TO_PTR(self_in);
    micropy_dict_get_helper(mp_state, &self->map, key, MP_OBJ_NULL, MP_MAP_LOOKUP_REMOVE_IF_FOUND);
    return self_in;
}

mp_map_t *micropy_obj_dict_get_map(struct _mp_state_ctx_t *mp_state, mp_obj_t self_in) {
    assert(MP_OBJ_IS_DICT_TYPE(self_in));
    mp_obj_dict_t *self = MP_OBJ_TO_PTR(self_in);
    return &self->map;
}
/*
 * This file is part of the Micro Python project, http://micropython.org/
 *
 * The MIT License (MIT)
 *
 * Copyright (c) 2013, 2014 Damien P. George
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

#include <stdlib.h>
#include <assert.h>

//#include "py/runtime.h"

#if MICROPY_PY_BUILTINS_ENUMERATE

typedef struct _mp_obj_enumerate_t {
    mp_obj_base_t base;
    mp_obj_t iter;
    mp_int_t cur;
} mp_obj_enumerate_t;

STATIC mp_obj_t micropy_enumerate_iternext(struct _mp_state_ctx_t *mp_state, mp_obj_t self_in);

STATIC mp_obj_t micropy_enumerate_make_new(struct _mp_state_ctx_t *mp_state, const mp_obj_type_t *type, size_t n_args, size_t n_kw, const mp_obj_t *args) {
#if MICROPY_CPYTHON_COMPAT
    static const mp_arg_t allowed_args[] = {
        { MP_QSTR_iterable, MP_ARG_REQUIRED | MP_ARG_OBJ, {.u_obj = MP_OBJ_NULL} },
        { MP_QSTR_start, MP_ARG_INT, {.u_int = 0} },
    };

    // parse args
    struct {
        mp_arg_val_t iterable, start;
    } arg_vals;
    micropy_arg_parse_all_kw_array(mp_state, n_args, n_kw, args,
        MP_ARRAY_SIZE(allowed_args), allowed_args, (mp_arg_val_t*)&arg_vals);

    // create enumerate object
    mp_obj_enumerate_t *o = micropy_m_new_obj(mp_state, mp_obj_enumerate_t);
    o->base.type = type;
    o->iter = micropy_getiter(mp_state, arg_vals.iterable.u_obj);
    o->cur = arg_vals.start.u_int;
#else
    (void)n_kw;
    mp_obj_enumerate_t *o = micropy_m_new_obj(mp_state, mp_obj_enumerate_t);
    o->base.type = type;
    o->iter = micropy_getiter(mp_state, args[0]);
    o->cur = n_args > 1 ? micropy_obj_get_int(mp_state, args[1]) : 0;
#endif

    return MP_OBJ_FROM_PTR(o);
}

const mp_obj_type_t mp_type_enumerate = {
    { &mp_type_type },
    .name = MP_QSTR_enumerate,
    .make_new = micropy_enumerate_make_new,
    .iternext = micropy_enumerate_iternext,
    .getiter = micropy_identity,
};

STATIC mp_obj_t micropy_enumerate_iternext(struct _mp_state_ctx_t *mp_state, mp_obj_t self_in) {
    assert(MP_OBJ_IS_TYPE(self_in, &mp_type_enumerate));
    mp_obj_enumerate_t *self = MP_OBJ_TO_PTR(self_in);
    mp_obj_t next = micropy_iternext(mp_state, self->iter);
    if (next == MP_OBJ_STOP_ITERATION) {
        return MP_OBJ_STOP_ITERATION;
    } else {
        mp_obj_t items[] = {MP_OBJ_NEW_SMALL_INT(self->cur++), next};
        return micropy_obj_new_tuple(mp_state, 2, items);
    }
}

#endif // MICROPY_PY_BUILTINS_ENUMERATE
/*
 * This file is part of the Micro Python project, http://micropython.org/
 *
 * The MIT License (MIT)
 *
 * Copyright (c) 2013, 2014 Damien P. George
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

#include <string.h>
#include <stdarg.h>
#include <assert.h>
#include <stdio.h>

//#include "py/mpstate.h"
//#include "py/objlist.h"
//#include "py/objstr.h"
//#include "py/objtuple.h"
//#include "py/objtype.h"
//#include "py/runtime.h"
//#include "py/gc.h"
//#include "py/mperrno.h"

// Instance of MemoryError exception - needed by mp_malloc_fail
const mp_obj_exception_t mp_const_MemoryError_obj = {{&mp_type_MemoryError}, 0, 0, NULL, (mp_obj_tuple_t*)&mp_const_empty_tuple_obj};

// Optionally allocated buffer for storing the first argument of an exception
// allocated when the heap is locked.
#if MICROPY_ENABLE_EMERGENCY_EXCEPTION_BUF
#   if MICROPY_EMERGENCY_EXCEPTION_BUF_SIZE > 0
#define mp_emergency_exception_buf_size MICROPY_EMERGENCY_EXCEPTION_BUF_SIZE

void micropy_init_emergency_exception_buf(struct _mp_state_ctx_t *mp_state) {
    // Nothing to do since the buffer was declared statically. We put this
    // definition here so that the calling code can call this function
    // regardless of how its configured (makes the calling code a bit cleaner).
}

#else
#define mp_emergency_exception_buf_size (mp_state)->vm.mp_emergency_exception_buf_size

void micropy_init_emergency_exception_buf(struct _mp_state_ctx_t *mp_state) {
    mp_emergency_exception_buf_size = 0;
    (mp_state)->vm.mp_emergency_exception_buf = NULL;
}

mp_obj_t micropy_alloc_emergency_exception_buf(struct _mp_state_ctx_t *mp_state, mp_obj_t size_in) {
    mp_int_t size = micropy_obj_get_int(mp_state, size_in);
    void *buf = NULL;
    if (size > 0) {
        buf = micropy_m_new(mp_state, byte, size);
    }

    int old_size = mp_emergency_exception_buf_size;
    void *old_buf = (mp_state)->vm.mp_emergency_exception_buf;

    // Update the 2 variables atomically so that an interrupt can't occur
    // between the assignments.
    mp_uint_t atomic_state = MICROPY_BEGIN_ATOMIC_SECTION();
    mp_emergency_exception_buf_size = size;
    (mp_state)->vm.mp_emergency_exception_buf = buf;
    MICROPY_END_ATOMIC_SECTION(atomic_state);

    if (old_buf != NULL) {
        micropy_m_del(mp_state, byte, old_buf, old_size);
    }
    return mp_const_none;
}
#endif
#endif  // MICROPY_ENABLE_EMERGENCY_EXCEPTION_BUF

// Instance of GeneratorExit exception - needed by generator.close()
// This would belong to objgenerator.c, but to keep mp_obj_exception_t
// definition module-private so far, have it here.
const mp_obj_exception_t mp_const_GeneratorExit_obj = {{&mp_type_GeneratorExit}, 0, 0, NULL, (mp_obj_tuple_t*)&mp_const_empty_tuple_obj};

STATIC void micropy_obj_exception_print(struct _mp_state_ctx_t *mp_state, const mp_print_t *print, mp_obj_t o_in, mp_print_kind_t kind) {
    mp_obj_exception_t *o = MP_OBJ_TO_PTR(o_in);
    mp_print_kind_t k = kind & ~PRINT_EXC_SUBCLASS;
    bool is_subclass = kind & PRINT_EXC_SUBCLASS;
    if (!is_subclass && (k == PRINT_REPR || k == PRINT_EXC)) {
        micropy_print_str(mp_state, print, micropy_qstr_str(mp_state, o->base.type->name));
    }

    if (k == PRINT_EXC) {
        micropy_print_str(mp_state, print, ": ");
    }

    if (k == PRINT_STR || k == PRINT_EXC) {
        if (o->args == NULL || o->args->len == 0) {
            micropy_print_str(mp_state, print, "");
            return;
        } else if (o->args->len == 1) {
            #if MICROPY_PY_UERRNO
            // try to provide a nice OSError error message
            if (o->base.type == &mp_type_OSError && MP_OBJ_IS_SMALL_INT(o->args->items[0])) {
                qstr qst = micropy_errno_to_str(mp_state, o->args->items[0]);
                if (qst != MP_QSTR_NULL) {
                    micropy_printf(mp_state, print, "[Errno %d] %q", MP_OBJ_SMALL_INT_VALUE(o->args->items[0]), qst);
                    return;
                }
            }
            #endif
            micropy_obj_print_helper(mp_state, print, o->args->items[0], PRINT_STR);
            return;
        }
    }
    micropy_obj_tuple_print(mp_state, print, MP_OBJ_FROM_PTR(o->args), kind);
}

mp_obj_t micropy_obj_exception_make_new(struct _mp_state_ctx_t *mp_state, const mp_obj_type_t *type, size_t n_args, size_t n_kw, const mp_obj_t *args) {
    micropy_arg_check_num(mp_state, n_args, n_kw, 0, MP_OBJ_FUN_ARGS_MAX, false);
    mp_obj_exception_t *o = micropy_m_new_obj_var_maybe(mp_state, mp_obj_exception_t, mp_obj_t, 0);
    if (o == NULL) {
        // Couldn't allocate heap memory; use local data instead.
        o = &(mp_state)->vm.mp_emergency_exception_obj;
        // We can't store any args.
        o->args = (mp_obj_tuple_t*)&mp_const_empty_tuple_obj;
    } else {
        o->args = MP_OBJ_TO_PTR(micropy_obj_new_tuple(mp_state, n_args, args));
    }
    o->base.type = type;
    o->traceback_data = NULL;
    return MP_OBJ_FROM_PTR(o);
}

// Get exception "value" - that is, first argument, or None
mp_obj_t micropy_obj_exception_get_value(struct _mp_state_ctx_t *mp_state, mp_obj_t self_in) {
    mp_obj_exception_t *self = MP_OBJ_TO_PTR(self_in);
    if (self->args->len == 0) {
        return mp_const_none;
    } else {
        return self->args->items[0];
    }
}

STATIC void micropy_exception_attr(struct _mp_state_ctx_t *mp_state, mp_obj_t self_in, qstr attr, mp_obj_t *dest) {
    if (dest[0] != MP_OBJ_NULL) {
        // not load attribute
        return;
    }
    mp_obj_exception_t *self = MP_OBJ_TO_PTR(self_in);
    if (attr == MP_QSTR_args) {
        dest[0] = MP_OBJ_FROM_PTR(self->args);
    } else if (self->base.type == &mp_type_StopIteration && attr == MP_QSTR_value) {
        dest[0] = micropy_obj_exception_get_value(mp_state, self_in);
    }
}

STATIC mp_obj_t micropy_exc___init__(struct _mp_state_ctx_t *mp_state, size_t n_args, const mp_obj_t *args) {
    mp_obj_exception_t *self = MP_OBJ_TO_PTR(args[0]);
    mp_obj_t argst = micropy_obj_new_tuple(mp_state, n_args - 1, args + 1);
    self->args = MP_OBJ_TO_PTR(argst);
    return mp_const_none;
}
STATIC MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(exc___init___obj, 1, MP_OBJ_FUN_ARGS_MAX, micropy_exc___init__);

STATIC const mp_rom_map_elem_t exc_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR___init__), MP_ROM_PTR(&exc___init___obj) },
};

STATIC MP_DEFINE_CONST_DICT(exc_locals_dict, exc_locals_dict_table);

const mp_obj_type_t mp_type_BaseException = {
    { &mp_type_type },
    .name = MP_QSTR_BaseException,
    .print = micropy_obj_exception_print,
    .make_new = micropy_obj_exception_make_new,
    .attr = micropy_exception_attr,
    .locals_dict = (mp_obj_dict_t*)&exc_locals_dict,
};

#define MP_DEFINE_EXCEPTION_BASE(base_name) \
STATIC const mp_rom_obj_tuple_t mp_type_ ## base_name ## _base_tuple = {{&mp_type_tuple}, 1, {MP_ROM_PTR(&mp_type_ ## base_name)}};\

#define MP_DEFINE_EXCEPTION(exc_name, base_name) \
const mp_obj_type_t mp_type_ ## exc_name = { \
    { &mp_type_type }, \
    .name = MP_QSTR_ ## exc_name, \
    .print = micropy_obj_exception_print, \
    .make_new = micropy_obj_exception_make_new, \
    .attr = micropy_exception_attr, \
    .bases_tuple = (mp_obj_tuple_t*)(mp_rom_obj_tuple_t*)&mp_type_ ## base_name ## _base_tuple, \
};

// List of all exceptions, arranged as in the table at:
// http://docs.python.org/3/library/exceptions.html
MP_DEFINE_EXCEPTION_BASE(BaseException)
MP_DEFINE_EXCEPTION(SystemExit, BaseException)
MP_DEFINE_EXCEPTION(KeyboardInterrupt, BaseException)
MP_DEFINE_EXCEPTION(GeneratorExit, BaseException)
MP_DEFINE_EXCEPTION(Exception, BaseException)
  MP_DEFINE_EXCEPTION_BASE(Exception)
  #if MICROPY_PY_ASYNC_AWAIT
  MP_DEFINE_EXCEPTION(StopAsyncIteration, Exception)
  #endif
  MP_DEFINE_EXCEPTION(StopIteration, Exception)
  MP_DEFINE_EXCEPTION(ArithmeticError, Exception)
    MP_DEFINE_EXCEPTION_BASE(ArithmeticError)
    //MP_DEFINE_EXCEPTION(FloatingPointError, ArithmeticError)
    MP_DEFINE_EXCEPTION(OverflowError, ArithmeticError)
    MP_DEFINE_EXCEPTION(ZeroDivisionError, ArithmeticError)
  MP_DEFINE_EXCEPTION(AssertionError, Exception)
  MP_DEFINE_EXCEPTION(AttributeError, Exception)
  //MP_DEFINE_EXCEPTION(BufferError, Exception)
  //MP_DEFINE_EXCEPTION(EnvironmentError, Exception) use OSError instead
  MP_DEFINE_EXCEPTION(EOFError, Exception)
  MP_DEFINE_EXCEPTION(ImportError, Exception)
  //MP_DEFINE_EXCEPTION(IOError, Exception) use OSError instead
  MP_DEFINE_EXCEPTION(LookupError, Exception)
    MP_DEFINE_EXCEPTION_BASE(LookupError)
    MP_DEFINE_EXCEPTION(IndexError, LookupError)
    MP_DEFINE_EXCEPTION(KeyError, LookupError)
  MP_DEFINE_EXCEPTION(MemoryError, Exception)
  MP_DEFINE_EXCEPTION(NameError, Exception)
    /*
    MP_DEFINE_EXCEPTION_BASE(NameError)
    MP_DEFINE_EXCEPTION(UnboundLocalError, NameError)
    */
  MP_DEFINE_EXCEPTION(OSError, Exception)
#if MICROPY_PY_BUILTINS_TIMEOUTERROR
    MP_DEFINE_EXCEPTION_BASE(OSError)
    MP_DEFINE_EXCEPTION(TimeoutError, OSError)
#endif
    /*
    MP_DEFINE_EXCEPTION(BlockingIOError, OSError)
    MP_DEFINE_EXCEPTION(ChildProcessError, OSError)
    MP_DEFINE_EXCEPTION(ConnectionError, OSError)
      MP_DEFINE_EXCEPTION(BrokenPipeError, ConnectionError)
      MP_DEFINE_EXCEPTION(ConnectionAbortedError, ConnectionError)
      MP_DEFINE_EXCEPTION(ConnectionRefusedError, ConnectionError)
      MP_DEFINE_EXCEPTION(ConnectionResetError, ConnectionError)
    MP_DEFINE_EXCEPTION(InterruptedError, OSError)
    MP_DEFINE_EXCEPTION(IsADirectoryError, OSError)
    MP_DEFINE_EXCEPTION(NotADirectoryError, OSError)
    MP_DEFINE_EXCEPTION(PermissionError, OSError)
    MP_DEFINE_EXCEPTION(ProcessLookupError, OSError)
    MP_DEFINE_EXCEPTION(FileExistsError, OSError)
    MP_DEFINE_EXCEPTION(FileNotFoundError, OSError)
    MP_DEFINE_EXCEPTION(ReferenceError, Exception)
    */
  MP_DEFINE_EXCEPTION(RuntimeError, Exception)
    MP_DEFINE_EXCEPTION_BASE(RuntimeError)
    MP_DEFINE_EXCEPTION(NotImplementedError, RuntimeError)
  MP_DEFINE_EXCEPTION(SyntaxError, Exception)
    MP_DEFINE_EXCEPTION_BASE(SyntaxError)
    MP_DEFINE_EXCEPTION(IndentationError, SyntaxError)
    /*
      MP_DEFINE_EXCEPTION_BASE(IndentationError)
      MP_DEFINE_EXCEPTION(TabError, IndentationError)
      */
  //MP_DEFINE_EXCEPTION(SystemError, Exception)
  MP_DEFINE_EXCEPTION(TypeError, Exception)
#if MICROPY_EMIT_NATIVE
    MP_DEFINE_EXCEPTION_BASE(TypeError)
    MP_DEFINE_EXCEPTION(ViperTypeError, TypeError)
#endif
  MP_DEFINE_EXCEPTION(ValueError, Exception)
#if MICROPY_PY_BUILTINS_STR_UNICODE
    MP_DEFINE_EXCEPTION_BASE(ValueError)
    MP_DEFINE_EXCEPTION(UnicodeError, ValueError)
    //TODO: Implement more UnicodeError subclasses which take arguments
#endif
  /*
  MP_DEFINE_EXCEPTION(Warning, Exception)
    MP_DEFINE_EXCEPTION_BASE(Warning)
    MP_DEFINE_EXCEPTION(DeprecationWarning, Warning)
    MP_DEFINE_EXCEPTION(PendingDeprecationWarning, Warning)
    MP_DEFINE_EXCEPTION(RuntimeWarning, Warning)
    MP_DEFINE_EXCEPTION(SyntaxWarning, Warning)
    MP_DEFINE_EXCEPTION(UserWarning, Warning)
    MP_DEFINE_EXCEPTION(FutureWarning, Warning)
    MP_DEFINE_EXCEPTION(ImportWarning, Warning)
    MP_DEFINE_EXCEPTION(UnicodeWarning, Warning)
    MP_DEFINE_EXCEPTION(BytesWarning, Warning)
    MP_DEFINE_EXCEPTION(ResourceWarning, Warning)
    */

mp_obj_t micropy_obj_new_exception(struct _mp_state_ctx_t *mp_state, const mp_obj_type_t *exc_type) {
    return micropy_obj_new_exception_args(mp_state, exc_type, 0, NULL);
}

// "Optimized" version for common(?) case of having 1 exception arg
mp_obj_t micropy_obj_new_exception_arg1(struct _mp_state_ctx_t *mp_state, const mp_obj_type_t *exc_type, mp_obj_t arg) {
    return micropy_obj_new_exception_args(mp_state, exc_type, 1, &arg);
}

mp_obj_t micropy_obj_new_exception_args(struct _mp_state_ctx_t *mp_state, const mp_obj_type_t *exc_type, mp_uint_t n_args, const mp_obj_t *args) {
    assert(exc_type->make_new == micropy_obj_exception_make_new);
    return exc_type->make_new(mp_state, exc_type, n_args, 0, args);
}

mp_obj_t micropy_obj_new_exception_msg(struct _mp_state_ctx_t *mp_state, const mp_obj_type_t *exc_type, const char *msg) {
    return micropy_obj_new_exception_msg_varg(mp_state, exc_type, msg);
}

mp_obj_t micropy_obj_new_exception_msg_varg(struct _mp_state_ctx_t *mp_state, const mp_obj_type_t *exc_type, const char *fmt, ...) {
    // check that the given type is an exception type
    assert(exc_type->make_new == micropy_obj_exception_make_new);

    // make exception object
    mp_obj_exception_t *o = micropy_m_new_obj_var_maybe(mp_state, mp_obj_exception_t, mp_obj_t, 0);
    if (o == NULL) {
        // Couldn't allocate heap memory; use local data instead.
        // Unfortunately, we won't be able to format the string...
        o = &(mp_state)->vm.mp_emergency_exception_obj;
        o->base.type = exc_type;
        o->traceback_data = NULL;
        o->args = (mp_obj_tuple_t*)&mp_const_empty_tuple_obj;

#if MICROPY_ENABLE_EMERGENCY_EXCEPTION_BUF
        // If the user has provided a buffer, then we try to create a tuple
        // of length 1, which has a string object and the string data.

        if (mp_emergency_exception_buf_size > (sizeof(mp_obj_tuple_t) + sizeof(mp_obj_str_t) + sizeof(mp_obj_t))) {
            mp_obj_tuple_t *tuple = (mp_obj_tuple_t *)(mp_state)->vm.mp_emergency_exception_buf;
            mp_obj_str_t *str = (mp_obj_str_t *)&tuple->items[1];

            tuple->base.type = &mp_type_tuple;
            tuple->len = 1;
            tuple->items[0] = MP_OBJ_FROM_PTR(str);

            byte *str_data = (byte *)&str[1];
            uint max_len = (mp_state)->vm.mp_emergency_exception_buf + mp_emergency_exception_buf_size
                         - str_data;

            vstr_t vstr;
            micropy_vstr_init_fixed_buf(mp_state, &vstr, max_len, (char *)str_data);

            va_list ap;
            va_start(ap, fmt);
            micropy_vstr_vprintf(mp_state, &vstr, fmt, ap);
            va_end(ap);

            str->base.type = &mp_type_str;
            str->hash = micropy_qstr_compute_hash(mp_state, str_data, str->len);
            str->len = vstr.len;
            str->data = str_data;

            o->args = tuple;

            uint offset = &str_data[str->len] - (mp_state)->vm.mp_emergency_exception_buf;
            offset += sizeof(void *) - 1;
            offset &= ~(sizeof(void *) - 1);

            if ((mp_emergency_exception_buf_size - offset) > (sizeof(o->traceback_data[0]) * 3)) {
                // We have room to store some traceback.
                o->traceback_data = (size_t*)((byte *)(mp_state)->vm.mp_emergency_exception_buf + offset);
                o->traceback_alloc = ((mp_state)->vm.mp_emergency_exception_buf + mp_emergency_exception_buf_size - (byte *)o->traceback_data) / sizeof(o->traceback_data[0]);
                o->traceback_len = 0;
            }
        }
#endif // MICROPY_ENABLE_EMERGENCY_EXCEPTION_BUF
    } else {
        o->base.type = exc_type;
        o->traceback_data = NULL;
        o->args = MP_OBJ_TO_PTR(micropy_obj_new_tuple(mp_state, 1, NULL));

        if (fmt == NULL) {
            // no message
            assert(0);
        } else {
            if (strchr(fmt, '%') == NULL) {
                // no formatting substitutions, avoid allocating vstr.
                o->args->items[0] = micropy_obj_new_str(mp_state, fmt, strlen(fmt), false);
            } else {
                // render exception message and store as .args[0]
                va_list ap;
                vstr_t vstr;
                micropy_vstr_init(mp_state, &vstr, 16);
                va_start(ap, fmt);
                micropy_vstr_vprintf(mp_state, &vstr, fmt, ap);
                va_end(ap);
                o->args->items[0] = micropy_obj_new_str_from_vstr(mp_state, &mp_type_str, &vstr);
            }
        }
    }

    return MP_OBJ_FROM_PTR(o);
}

// return true if the given object is an exception type
bool micropy_obj_is_exception_type(struct _mp_state_ctx_t *mp_state, mp_obj_t self_in) {
    if (MP_OBJ_IS_TYPE(self_in, &mp_type_type)) {
        // optimisation when self_in is a builtin exception
        mp_obj_type_t *self = MP_OBJ_TO_PTR(self_in);
        if (self->make_new == micropy_obj_exception_make_new) {
            return true;
        }
    }
    return micropy_obj_is_subclass_fast(mp_state, self_in, MP_OBJ_FROM_PTR(&mp_type_BaseException));
}

// return true if the given object is an instance of an exception type
bool micropy_obj_is_exception_instance(struct _mp_state_ctx_t *mp_state, mp_obj_t self_in) {
    return micropy_obj_is_exception_type(mp_state, MP_OBJ_FROM_PTR(micropy_obj_get_type(mp_state, self_in)));
}

// Return true if exception (type or instance) is a subclass of given
// exception type.  Assumes exc_type is a subclass of BaseException, as
// defined by mp_obj_is_exception_type(exc_type).
bool micropy_obj_exception_match(struct _mp_state_ctx_t *mp_state, mp_obj_t exc, mp_const_obj_t exc_type) {
    // if exc is an instance of an exception, then extract and use its type
    if (micropy_obj_is_exception_instance(mp_state, exc)) {
        exc = MP_OBJ_FROM_PTR(micropy_obj_get_type(mp_state, exc));
    }
    return micropy_obj_is_subclass_fast(mp_state, exc, exc_type);
}

// traceback handling functions

#define GET_NATIVE_EXCEPTION(self, self_in) \
    /* make sure self_in is an exception instance */ \
    assert(micropy_obj_is_exception_instance(mp_state, self_in)); \
    mp_obj_exception_t *self; \
    if (micropy_obj_is_native_exception_instance(mp_state, self_in)) { \
        self = MP_OBJ_TO_PTR(self_in); \
    } else { \
        self = MP_OBJ_TO_PTR(((mp_obj_instance_t*)MP_OBJ_TO_PTR(self_in))->subobj[0]); \
    }

void micropy_obj_exception_clear_traceback(struct _mp_state_ctx_t *mp_state, mp_obj_t self_in) {
    GET_NATIVE_EXCEPTION(self, self_in);
    // just set the traceback to the null object
    // we don't want to call any memory management functions here
    self->traceback_data = NULL;
}

void micropy_obj_exception_add_traceback(struct _mp_state_ctx_t *mp_state, mp_obj_t self_in, qstr file, size_t line, qstr block) {
    GET_NATIVE_EXCEPTION(self, self_in);

    // append this traceback info to traceback data
    // if memory allocation fails (eg because gc is locked), just return

    if (self->traceback_data == NULL) {
        self->traceback_data = micropy_m_new_maybe(mp_state, size_t, 3);
        if (self->traceback_data == NULL) {
            return;
        }
        self->traceback_alloc = 3;
        self->traceback_len = 0;
    } else if (self->traceback_len + 3 > self->traceback_alloc) {
        // be conservative with growing traceback data
        size_t *tb_data = micropy_m_renew_maybe(mp_state, size_t, self->traceback_data, self->traceback_alloc, self->traceback_alloc + 3, true);
        if (tb_data == NULL) {
            return;
        }
        self->traceback_data = tb_data;
        self->traceback_alloc += 3;
    }

    size_t *tb_data = &self->traceback_data[self->traceback_len];
    self->traceback_len += 3;
    tb_data[0] = file;
    tb_data[1] = line;
    tb_data[2] = block;
}

void micropy_obj_exception_get_traceback(struct _mp_state_ctx_t *mp_state, mp_obj_t self_in, size_t *n, size_t **values) {
    GET_NATIVE_EXCEPTION(self, self_in);

    if (self->traceback_data == NULL) {
        *n = 0;
        *values = NULL;
    } else {
        *n = self->traceback_len;
        *values = self->traceback_data;
    }
}
/*
 * This file is part of the Micro Python project, http://micropython.org/
 *
 * The MIT License (MIT)
 *
 * Copyright (c) 2013, 2014 Damien P. George
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

//#include "py/runtime.h"

#if MICROPY_PY_BUILTINS_FILTER

typedef struct _mp_obj_filter_t {
    mp_obj_base_t base;
    mp_obj_t fun;
    mp_obj_t iter;
} mp_obj_filter_t;

STATIC mp_obj_t micropy_filter_make_new(struct _mp_state_ctx_t *mp_state, const mp_obj_type_t *type, size_t n_args, size_t n_kw, const mp_obj_t *args) {
    micropy_arg_check_num(mp_state, n_args, n_kw, 2, 2, false);
    mp_obj_filter_t *o = micropy_m_new_obj(mp_state, mp_obj_filter_t);
    o->base.type = type;
    o->fun = args[0];
    o->iter = micropy_getiter(mp_state, args[1]);
    return MP_OBJ_FROM_PTR(o);
}

STATIC mp_obj_t micropy_filter_iternext(struct _mp_state_ctx_t *mp_state, mp_obj_t self_in) {
    assert(MP_OBJ_IS_TYPE(self_in, &mp_type_filter));
    mp_obj_filter_t *self = MP_OBJ_TO_PTR(self_in);
    mp_obj_t next;
    while ((next = micropy_iternext(mp_state, self->iter)) != MP_OBJ_STOP_ITERATION) {
        mp_obj_t val;
        if (self->fun != mp_const_none) {
            val = micropy_call_function_n_kw(mp_state, self->fun, 1, 0, &next);
        } else {
            val = next;
        }
        if (micropy_obj_is_true(mp_state, val)) {
            return next;
        }
    }
    return MP_OBJ_STOP_ITERATION;
}

const mp_obj_type_t mp_type_filter = {
    { &mp_type_type },
    .name = MP_QSTR_filter,
    .make_new = micropy_filter_make_new,
    .getiter = micropy_identity,
    .iternext = micropy_filter_iternext,
};

#endif // MICROPY_PY_BUILTINS_FILTER
/*
 * This file is part of the Micro Python project, http://micropython.org/
 *
 * The MIT License (MIT)
 *
 * Copyright (c) 2013, 2014 Damien P. George
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <assert.h>

//#include "py/nlr.h"
//#include "py/parsenum.h"
//#include "py/runtime0.h"
//#include "py/runtime.h"

#if MICROPY_PY_BUILTINS_FLOAT

#include <math.h>
//#include "py/formatfloat.h"

#if MICROPY_OBJ_REPR != MICROPY_OBJ_REPR_C && MICROPY_OBJ_REPR != MICROPY_OBJ_REPR_D

// M_E and M_PI are not part of the math.h standard and may not be defined
#ifndef M_E
#define M_E (2.7182818284590452354)
#endif
#ifndef M_PI
#define M_PI (3.14159265358979323846)
#endif

typedef struct _mp_obj_float_t {
    mp_obj_base_t base;
    mp_float_t value;
} mp_obj_float_t;

const mp_obj_float_t mp_const_float_e_obj = {{&mp_type_float}, M_E};
const mp_obj_float_t mp_const_float_pi_obj = {{&mp_type_float}, M_PI};

#endif

STATIC void micropy_float_print(struct _mp_state_ctx_t *mp_state, const mp_print_t *print, mp_obj_t o_in, mp_print_kind_t kind) {
    (void)kind;
    mp_float_t o_val = micropy_obj_float_get(mp_state, o_in);
#if MICROPY_FLOAT_IMPL == MICROPY_FLOAT_IMPL_FLOAT
    char buf[16];
    const int precision = 7;
#else
    char buf[32];
    const int precision = 16;
#endif
    micropy_format_float(mp_state, o_val, buf, sizeof(buf), 'g', precision, '\0');
    micropy_print_str(mp_state, print, buf);
    if (strchr(buf, '.') == NULL && strchr(buf, 'e') == NULL && strchr(buf, 'n') == NULL) {
        // Python floats always have decimal point (unless inf or nan)
        micropy_print_str(mp_state, print, ".0");
    }
}

STATIC mp_obj_t micropy_float_make_new(struct _mp_state_ctx_t *mp_state, const mp_obj_type_t *type_in, size_t n_args, size_t n_kw, const mp_obj_t *args) {
    (void)type_in;
    micropy_arg_check_num(mp_state, n_args, n_kw, 0, 1, false);

    switch (n_args) {
        case 0:
            return micropy_obj_new_float(mp_state, 0);

        case 1:
        default:
            if (MP_OBJ_IS_STR(args[0])) {
                // a string, parse it
                mp_uint_t l;
                const char *s = micropy_obj_str_get_data(mp_state, args[0], &l);
                return micropy_parse_num_decimal(mp_state, s, l, false, false, NULL);
            } else if (micropy_obj_is_float(mp_state, args[0])) {
                // a float, just return it
                return args[0];
            } else {
                // something else, try to cast it to a float
                return micropy_obj_new_float(mp_state, micropy_obj_get_float(mp_state, args[0]));
            }
    }
}

STATIC mp_obj_t micropy_float_unary_op(struct _mp_state_ctx_t *mp_state, mp_uint_t op, mp_obj_t o_in) {
    mp_float_t val = micropy_obj_float_get(mp_state, o_in);
    switch (op) {
        case MP_UNARY_OP_BOOL: return micropy_obj_new_bool(mp_state, val != 0);
        case MP_UNARY_OP_POSITIVE: return o_in;
        case MP_UNARY_OP_NEGATIVE: return micropy_obj_new_float(mp_state, -val);
        default: return MP_OBJ_NULL; // op not supported
    }
}

STATIC mp_obj_t micropy_float_binary_op(struct _mp_state_ctx_t *mp_state, mp_uint_t op, mp_obj_t lhs_in, mp_obj_t rhs_in) {
    mp_float_t lhs_val = micropy_obj_float_get(mp_state, lhs_in);
#if MICROPY_PY_BUILTINS_COMPLEX
    if (MP_OBJ_IS_TYPE(rhs_in, &mp_type_complex)) {
        return micropy_obj_complex_binary_op(mp_state, op, lhs_val, 0, rhs_in);
    } else
#endif
    {
        return micropy_obj_float_binary_op(mp_state, op, lhs_val, rhs_in);
    }
}

const mp_obj_type_t mp_type_float = {
    { &mp_type_type },
    .name = MP_QSTR_float,
    .print = micropy_float_print,
    .make_new = micropy_float_make_new,
    .unary_op = micropy_float_unary_op,
    .binary_op = micropy_float_binary_op,
};

#if MICROPY_OBJ_REPR != MICROPY_OBJ_REPR_C && MICROPY_OBJ_REPR != MICROPY_OBJ_REPR_D

mp_obj_t micropy_obj_new_float(struct _mp_state_ctx_t *mp_state, mp_float_t value) {
    mp_obj_float_t *o = micropy_m_new(mp_state, mp_obj_float_t, 1);
    o->base.type = &mp_type_float;
    o->value = value;
    return MP_OBJ_FROM_PTR(o);
}

mp_float_t micropy_obj_float_get(struct _mp_state_ctx_t *mp_state, mp_obj_t self_in) {
    assert(micropy_obj_is_float(mp_state, self_in));
    mp_obj_float_t *self = MP_OBJ_TO_PTR(self_in);
    return self->value;
}

#endif

STATIC void micropy_obj_float_divmod(struct _mp_state_ctx_t *mp_state, mp_float_t *x, mp_float_t *y) {
    // logic here follows that of CPython
    // https://docs.python.org/3/reference/expressions.html#binary-arithmetic-operations
    // x == (x//y)*y + (x%y)
    // divmod(x, y) == (x//y, x%y)
    mp_float_t mod = MICROPY_FLOAT_C_FUN(fmod)(*x, *y);
    mp_float_t div = (*x - mod) / *y;

    // Python specs require that mod has same sign as second operand
    if (mod == 0.0) {
        mod = MICROPY_FLOAT_C_FUN(copysign)(0.0, *y);
    } else {
        if ((mod < 0.0) != (*y < 0.0)) {
            mod += *y;
            div -= 1.0;
        }
    }

    mp_float_t floordiv;
    if (div == 0.0) {
        // if division is zero, take the correct sign of zero
        floordiv = MICROPY_FLOAT_C_FUN(copysign)(0.0, *x / *y);
    } else {
        // Python specs require that x == (x//y)*y + (x%y)
        floordiv = MICROPY_FLOAT_C_FUN(floor)(div);
        if (div - floordiv > 0.5) {
            floordiv += 1.0;
        }
    }

    // return results
    *x = floordiv;
    *y = mod;
}

mp_obj_t micropy_obj_float_binary_op(struct _mp_state_ctx_t *mp_state, mp_uint_t op, mp_float_t lhs_val, mp_obj_t rhs_in) {
    mp_float_t rhs_val = micropy_obj_get_float(mp_state, rhs_in); // can be any type, this function will convert to float (if possible)
    switch (op) {
        case MP_BINARY_OP_ADD:
        case MP_BINARY_OP_INPLACE_ADD: lhs_val += rhs_val; break;
        case MP_BINARY_OP_SUBTRACT:
        case MP_BINARY_OP_INPLACE_SUBTRACT: lhs_val -= rhs_val; break;
        case MP_BINARY_OP_MULTIPLY:
        case MP_BINARY_OP_INPLACE_MULTIPLY: lhs_val *= rhs_val; break;
        case MP_BINARY_OP_FLOOR_DIVIDE:
        case MP_BINARY_OP_INPLACE_FLOOR_DIVIDE:
            if (rhs_val == 0) {
                zero_division_error:
                micropy_nlr_raise(mp_state, micropy_obj_new_exception_msg(mp_state, &mp_type_ZeroDivisionError, "division by zero"));
            }
            // Python specs require that x == (x//y)*y + (x%y) so we must
            // call divmod to compute the correct floor division, which
            // returns the floor divide in lhs_val.
            micropy_obj_float_divmod(mp_state, &lhs_val, &rhs_val);
            break;
        case MP_BINARY_OP_TRUE_DIVIDE:
        case MP_BINARY_OP_INPLACE_TRUE_DIVIDE:
            if (rhs_val == 0) {
                goto zero_division_error;
            }
            lhs_val /= rhs_val;
            break;
        case MP_BINARY_OP_MODULO:
        case MP_BINARY_OP_INPLACE_MODULO:
            if (rhs_val == 0) {
                goto zero_division_error;
            }
            lhs_val = MICROPY_FLOAT_C_FUN(fmod)(lhs_val, rhs_val);
            // Python specs require that mod has same sign as second operand
            if (lhs_val == 0.0) {
                lhs_val = MICROPY_FLOAT_C_FUN(copysign)(0.0, rhs_val);
            } else {
                if ((lhs_val < 0.0) != (rhs_val < 0.0)) {
                    lhs_val += rhs_val;
                }
            }
            break;
        case MP_BINARY_OP_POWER:
        case MP_BINARY_OP_INPLACE_POWER: lhs_val = MICROPY_FLOAT_C_FUN(pow)(lhs_val, rhs_val); break;
        case MP_BINARY_OP_DIVMOD: {
            if (rhs_val == 0) {
                goto zero_division_error;
            }
            micropy_obj_float_divmod(mp_state, &lhs_val, &rhs_val);
            mp_obj_t tuple[2] = {
                micropy_obj_new_float(mp_state, lhs_val),
                micropy_obj_new_float(mp_state, rhs_val),
            };
            return micropy_obj_new_tuple(mp_state, 2, tuple);
        }
        case MP_BINARY_OP_LESS: return micropy_obj_new_bool(mp_state, lhs_val < rhs_val);
        case MP_BINARY_OP_MORE: return micropy_obj_new_bool(mp_state, lhs_val > rhs_val);
        case MP_BINARY_OP_EQUAL: return micropy_obj_new_bool(mp_state, lhs_val == rhs_val);
        case MP_BINARY_OP_LESS_EQUAL: return micropy_obj_new_bool(mp_state, lhs_val <= rhs_val);
        case MP_BINARY_OP_MORE_EQUAL: return micropy_obj_new_bool(mp_state, lhs_val >= rhs_val);

        default:
            return MP_OBJ_NULL; // op not supported
    }
    return micropy_obj_new_float(mp_state, lhs_val);
}

#endif // MICROPY_PY_BUILTINS_FLOAT
/*
 * This file is part of the Micro Python project, http://micropython.org/
 *
 * The MIT License (MIT)
 *
 * Copyright (c) 2013, 2014 Damien P. George
 * Copyright (c) 2014 Paul Sokolovsky
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

#include <string.h>
#include <assert.h>

//#include "py/nlr.h"
//#include "py/objtuple.h"
//#include "py/objfun.h"
//#include "py/runtime0.h"
//#include "py/runtime.h"
//#include "py/bc.h"
//#include "py/stackctrl.h"

#if 0 // print debugging info
#define DEBUG_PRINT (1)
#else // don't print debugging info
#define DEBUG_PRINT (0)
#define DEBUG_printf(...) (void)0
#endif

// Note: the "name" entry in mp_obj_type_t for a function type must be
// MP_QSTR_function because it is used to determine if an object is of generic
// function type.

/******************************************************************************/
/* builtin functions                                                          */

// mp_obj_fun_builtin_t defined in obj.h

STATIC mp_obj_t micropy_fun_builtin_call(struct _mp_state_ctx_t *mp_state, mp_obj_t self_in, size_t n_args, size_t n_kw, const mp_obj_t *args) {
    assert(MP_OBJ_IS_TYPE(self_in, &mp_type_fun_builtin));
    mp_obj_fun_builtin_t *self = MP_OBJ_TO_PTR(self_in);

    // check number of arguments
    micropy_arg_check_num(mp_state, n_args, n_kw, self->n_args_min, self->n_args_max, self->is_kw);

    if (self->is_kw) {
        // function allows keywords

        // we create a map directly from the given args array
        mp_map_t kw_args;
        micropy_map_init_fixed_table(mp_state, &kw_args, n_kw, args + n_args);

        return self->fun.kw(mp_state, n_args, args, &kw_args);

    } else if (self->n_args_min <= 3 && self->n_args_min == self->n_args_max) {
        // function requires a fixed number of arguments

        // dispatch function call
        switch (self->n_args_min) {
            case 0:
                return self->fun._0(mp_state);

            case 1:
                return self->fun._1(mp_state, args[0]);

            case 2:
                return self->fun._2(mp_state, args[0], args[1]);

            case 3:
            default:
                return self->fun._3(mp_state, args[0], args[1], args[2]);
        }

    } else {
        // function takes a variable number of arguments, but no keywords

        return self->fun.var(mp_state, n_args, args);
    }
}

const mp_obj_type_t mp_type_fun_builtin = {
    { &mp_type_type },
    .name = MP_QSTR_function,
    .call = micropy_fun_builtin_call,
    .unary_op = micropy_generic_unary_op,
};

/******************************************************************************/
/* byte code functions                                                        */

qstr micropy_obj_code_get_name(struct _mp_state_ctx_t *mp_state, const byte *code_info) {
    micropy_decode_uint(mp_state, &code_info); // skip code_info_size entry
    #if MICROPY_PERSISTENT_CODE
    return code_info[0] | (code_info[1] << 8);
    #else
    return micropy_decode_uint(mp_state, &code_info);
    #endif
}

#if MICROPY_EMIT_NATIVE
STATIC const mp_obj_type_t mp_type_fun_native;
#endif

qstr micropy_obj_fun_get_name(struct _mp_state_ctx_t *mp_state, mp_const_obj_t fun_in) {
    const mp_obj_fun_bc_t *fun = MP_OBJ_TO_PTR(fun_in);
    #if MICROPY_EMIT_NATIVE
    if (fun->base.type == &mp_type_fun_native) {
        // TODO native functions don't have name stored
        return MP_QSTR_;
    }
    #endif

    const byte *bc = fun->bytecode;
    micropy_decode_uint(mp_state, &bc); // skip n_state
    micropy_decode_uint(mp_state, &bc); // skip n_exc_stack
    bc++; // skip scope_params
    bc++; // skip n_pos_args
    bc++; // skip n_kwonly_args
    bc++; // skip n_def_pos_args
    return micropy_obj_code_get_name(mp_state, bc);
}

#if MICROPY_CPYTHON_COMPAT
STATIC void micropy_fun_bc_print(struct _mp_state_ctx_t *mp_state, const mp_print_t *print, mp_obj_t o_in, mp_print_kind_t kind) {
    (void)kind;
    mp_obj_fun_bc_t *o = MP_OBJ_TO_PTR(o_in);
    micropy_printf(mp_state, print, "<function %q at 0x%p>", micropy_obj_fun_get_name(mp_state, o_in), o);
}
#endif

#if DEBUG_PRINT
STATIC void micropy_dump_args(struct _mp_state_ctx_t *mp_state, const mp_obj_t *a, mp_uint_t sz) {
    DEBUG_printf("%p: ", a);
    for (mp_uint_t i = 0; i < sz; i++) {
        DEBUG_printf("%p ", a[i]);
    }
    DEBUG_printf("\n");
}
#else
#define micropy_dump_args(mp_state, ...) (void)0
#endif

// With this macro you can tune the maximum number of function state bytes
// that will be allocated on the stack.  Any function that needs more
// than this will try to use the heap, with fallback to stack allocation.
#define VM_MAX_STATE_ON_STACK (11 * sizeof(mp_uint_t))

// Set this to enable a simple stack overflow check.
#define VM_DETECT_STACK_OVERFLOW (0)

#if MICROPY_STACKLESS
mp_code_state *mp_obj_fun_bc_prepare_codestate(mp_obj_t self_in, size_t n_args, size_t n_kw, const mp_obj_t *args) {
    MP_STACK_CHECK();
    mp_obj_fun_bc_t *self = MP_OBJ_TO_PTR(self_in);

    // get start of bytecode
    const byte *ip = self->bytecode;

    // bytecode prelude: state size and exception stack size
    size_t n_state = micropy_decode_uint(mp_state, &ip);
    size_t n_exc_stack = micropy_decode_uint(mp_state, &ip);

    // allocate state for locals and stack
    size_t state_size = n_state * sizeof(mp_obj_t) + n_exc_stack * sizeof(mp_exc_stack_t);
    mp_code_state *code_state;
    code_state = micropy_m_new_obj_var_maybe(mp_state, mp_code_state, byte, state_size);
    if (!code_state) {
        return NULL;
    }

    code_state->ip = (byte*)(ip - self->bytecode); // offset to after n_state/n_exc_stack
    code_state->n_state = n_state;
    micropy_setup_code_state(mp_state, code_state, self, n_args, n_kw, args);

    // execute the byte code with the correct globals context
    code_state->old_globals = mp_state->dict_globals;
    mp_state->dict_globals = self->globals;

    return code_state;
}
#endif

STATIC mp_obj_t micropy_fun_bc_call(struct _mp_state_ctx_t *mp_state, mp_obj_t self_in, size_t n_args, size_t n_kw, const mp_obj_t *args) {
    MP_STACK_CHECK();

    DEBUG_printf("Input n_args: " UINT_FMT ", n_kw: " UINT_FMT "\n", n_args, n_kw);
    DEBUG_printf("Input pos args: ");
    micropy_dump_args(mp_state, args, n_args);
    DEBUG_printf("Input kw args: ");
    micropy_dump_args(mp_state, args + n_args, n_kw * 2);
    mp_obj_fun_bc_t *self = MP_OBJ_TO_PTR(self_in);
    DEBUG_printf("Func n_def_args: %d\n", self->n_def_args);

    // get start of bytecode
    const byte *ip = self->bytecode;

    // bytecode prelude: state size and exception stack size
    mp_uint_t n_state = micropy_decode_uint(mp_state, &ip);
    mp_uint_t n_exc_stack = micropy_decode_uint(mp_state, &ip);

#if VM_DETECT_STACK_OVERFLOW
    n_state += 1;
#endif

    // allocate state for locals and stack
    mp_uint_t state_size = n_state * sizeof(mp_obj_t) + n_exc_stack * sizeof(mp_exc_stack_t);
    mp_code_state *code_state = NULL;
    if (state_size > VM_MAX_STATE_ON_STACK) {
        code_state = micropy_m_new_obj_var_maybe(mp_state, mp_code_state, byte, state_size);
    }
    if (code_state == NULL) {
        code_state = alloca(sizeof(mp_code_state) + state_size);
        state_size = 0; // indicate that we allocated using alloca
    }

    code_state->ip = (byte*)(ip - self->bytecode); // offset to after n_state/n_exc_stack
    code_state->n_state = n_state;
    micropy_setup_code_state(mp_state, code_state, self, n_args, n_kw, args);

    // execute the byte code with the correct globals context
    code_state->old_globals = mp_state->dict_globals;
    mp_state->dict_globals = self->globals;
    mp_vm_return_kind_t vm_return_kind = micropy_execute_bytecode(mp_state, code_state, MP_OBJ_NULL);
    mp_state->dict_globals = code_state->old_globals;

#if VM_DETECT_STACK_OVERFLOW
    if (vm_return_kind == MP_VM_RETURN_NORMAL) {
        if (code_state->sp < code_state->state) {
            printf("VM stack underflow: " INT_FMT "\n", code_state->sp - code_state->state);
            assert(0);
        }
    }
    // We can't check the case when an exception is returned in state[n_state - 1]
    // and there are no arguments, because in this case our detection slot may have
    // been overwritten by the returned exception (which is allowed).
    if (!(vm_return_kind == MP_VM_RETURN_EXCEPTION && self->n_pos_args + self->n_kwonly_args == 0)) {
        // Just check to see that we have at least 1 null object left in the state.
        bool overflow = true;
        for (mp_uint_t i = 0; i < n_state - self->n_pos_args - self->n_kwonly_args; i++) {
            if (code_state->state[i] == MP_OBJ_NULL) {
                overflow = false;
                break;
            }
        }
        if (overflow) {
            printf("VM stack overflow state=%p n_state+1=" UINT_FMT "\n", code_state->state, n_state);
            assert(0);
        }
    }
#endif

    mp_obj_t result;
    switch (vm_return_kind) {
        case MP_VM_RETURN_NORMAL:
            // return value is in *sp
            result = *code_state->sp;
            break;

        case MP_VM_RETURN_EXCEPTION:
            // return value is in state[n_state - 1]
            result = code_state->state[n_state - 1];
            break;

        case MP_VM_RETURN_YIELD: // byte-code shouldn't yield
        default:
            assert(0);
            result = mp_const_none;
            vm_return_kind = MP_VM_RETURN_NORMAL;
            break;
    }

    // free the state if it was allocated on the heap
    if (state_size != 0) {
        micropy_m_del_var(mp_state, mp_code_state, byte, state_size, code_state);
    }

    if (vm_return_kind == MP_VM_RETURN_NORMAL) {
        return result;
    } else { // MP_VM_RETURN_EXCEPTION
        micropy_nlr_raise(mp_state, result);
    }
}

#if MICROPY_PY_FUNCTION_ATTRS
STATIC void micropy_fun_bc_attr(struct _mp_state_ctx_t *mp_state, mp_obj_t self_in, qstr attr, mp_obj_t *dest) {
    if (dest[0] != MP_OBJ_NULL) {
        // not load attribute
        return;
    }
    if (attr == MP_QSTR___name__) {
        dest[0] = MP_OBJ_NEW_QSTR(micropy_obj_fun_get_name(mp_state, self_in));
    }
}
#endif

const mp_obj_type_t mp_type_fun_bc = {
    { &mp_type_type },
    .name = MP_QSTR_function,
#if MICROPY_CPYTHON_COMPAT
    .print = micropy_fun_bc_print,
#endif
    .call = micropy_fun_bc_call,
    .unary_op = micropy_generic_unary_op,
#if MICROPY_PY_FUNCTION_ATTRS
    .attr = micropy_fun_bc_attr,
#endif
};

mp_obj_t micropy_obj_new_fun_bc(struct _mp_state_ctx_t *mp_state, mp_obj_t def_args_in, mp_obj_t def_kw_args, const byte *code, const mp_uint_t *const_table) {
    mp_uint_t n_def_args = 0;
    mp_uint_t n_extra_args = 0;
    mp_obj_tuple_t *def_args = MP_OBJ_TO_PTR(def_args_in);
    if (def_args_in != MP_OBJ_NULL) {
        assert(MP_OBJ_IS_TYPE(def_args_in, &mp_type_tuple));
        n_def_args = def_args->len;
        n_extra_args = def_args->len;
    }
    if (def_kw_args != MP_OBJ_NULL) {
        n_extra_args += 1;
    }
    mp_obj_fun_bc_t *o = micropy_m_new_obj_var(mp_state, mp_obj_fun_bc_t, mp_obj_t, n_extra_args);
    o->base.type = &mp_type_fun_bc;
    o->globals = mp_state->dict_globals;
    o->bytecode = code;
    o->const_table = const_table;
    if (def_args != NULL) {
        memcpy(o->extra_args, def_args->items, n_def_args * sizeof(mp_obj_t));
    }
    if (def_kw_args != MP_OBJ_NULL) {
        o->extra_args[n_def_args] = def_kw_args;
    }
    return MP_OBJ_FROM_PTR(o);
}

/******************************************************************************/
/* native functions                                                           */

#if MICROPY_EMIT_NATIVE

STATIC mp_obj_t micropy_fun_native_call(struct _mp_state_ctx_t *mp_state, mp_obj_t self_in, size_t n_args, size_t n_kw, const mp_obj_t *args) {
    MP_STACK_CHECK();
    mp_obj_fun_bc_t *self = self_in;
    mp_call_fun_t fun = MICROPY_MAKE_POINTER_CALLABLE((void*)self->bytecode);
    return micropy_fun(mp_state, self_in, n_args, n_kw, args);
}

STATIC const mp_obj_type_t mp_type_fun_native = {
    { &mp_type_type },
    .name = MP_QSTR_function,
    .call = micropy_fun_native_call,
    .unary_op = micropy_generic_unary_op,
};

mp_obj_t micropy_obj_new_fun_native(struct _mp_state_ctx_t *mp_state, mp_obj_t def_args_in, mp_obj_t def_kw_args, const void *fun_data, const mp_uint_t *const_table) {
    mp_obj_fun_bc_t *o = micropy_obj_new_fun_bc(mp_state, def_args_in, def_kw_args, (const byte*)fun_data, const_table);
    o->base.type = &mp_type_fun_native;
    return o;
}

#endif // MICROPY_EMIT_NATIVE

/******************************************************************************/
/* viper functions                                                            */

#if MICROPY_EMIT_NATIVE

typedef struct _mp_obj_fun_viper_t {
    mp_obj_base_t base;
    mp_uint_t n_args;
    void *fun_data; // GC must be able to trace this pointer
    mp_uint_t type_sig;
} mp_obj_fun_viper_t;

typedef mp_uint_t (*viper_fun_0_t)(void);
typedef mp_uint_t (*viper_fun_1_t)(mp_uint_t);
typedef mp_uint_t (*viper_fun_2_t)(mp_uint_t, mp_uint_t);
typedef mp_uint_t (*viper_fun_3_t)(mp_uint_t, mp_uint_t, mp_uint_t);
typedef mp_uint_t (*viper_fun_4_t)(mp_uint_t, mp_uint_t, mp_uint_t, mp_uint_t);

STATIC mp_obj_t micropy_fun_viper_call(struct _mp_state_ctx_t *mp_state, mp_obj_t self_in, size_t n_args, size_t n_kw, const mp_obj_t *args) {
    mp_obj_fun_viper_t *self = self_in;

    micropy_arg_check_num(mp_state, n_args, n_kw, self->n_args, self->n_args, false);

    void *fun = MICROPY_MAKE_POINTER_CALLABLE(self->fun_data);

    mp_uint_t ret;
    if (n_args == 0) {
        ret = ((viper_fun_0_t)fun)();
    } else if (n_args == 1) {
        ret = ((viper_fun_1_t)fun)(micropy_convert_obj_to_native(mp_state, args[0], self->type_sig >> 4));
    } else if (n_args == 2) {
        ret = ((viper_fun_2_t)fun)(micropy_convert_obj_to_native(mp_state, args[0], self->type_sig >> 4), micropy_convert_obj_to_native(mp_state, args[1], self->type_sig >> 8));
    } else if (n_args == 3) {
        ret = ((viper_fun_3_t)fun)(micropy_convert_obj_to_native(mp_state, args[0], self->type_sig >> 4), micropy_convert_obj_to_native(mp_state, args[1], self->type_sig >> 8), micropy_convert_obj_to_native(mp_state, args[2], self->type_sig >> 12));
    } else if (n_args == 4) {
        ret = ((viper_fun_4_t)fun)(
            micropy_convert_obj_to_native(mp_state, args[0], self->type_sig >> 4),
            micropy_convert_obj_to_native(mp_state, args[1], self->type_sig >> 8),
            micropy_convert_obj_to_native(mp_state, args[2], self->type_sig >> 12),
            micropy_convert_obj_to_native(mp_state, args[3], self->type_sig >> 16)
        );
    } else {
        // TODO 5 or more arguments not supported for viper call
        assert(0);
        ret = 0;
    }

    return micropy_convert_native_to_obj(mp_state, ret, self->type_sig);
}

STATIC const mp_obj_type_t mp_type_fun_viper = {
    { &mp_type_type },
    .name = MP_QSTR_function,
    .call = micropy_fun_viper_call,
    .unary_op = micropy_generic_unary_op,
};

mp_obj_t micropy_obj_new_fun_viper(struct _mp_state_ctx_t *mp_state, mp_uint_t n_args, void *fun_data, mp_uint_t type_sig) {
    mp_obj_fun_viper_t *o = micropy_m_new_obj(mp_state, mp_obj_fun_viper_t);
    o->base.type = &mp_type_fun_viper;
    o->n_args = n_args;
    o->fun_data = fun_data;
    o->type_sig = type_sig;
    return o;
}

#endif // MICROPY_EMIT_NATIVE

/******************************************************************************/
/* inline assembler functions                                                 */

#if MICROPY_EMIT_INLINE_THUMB

typedef struct _mp_obj_fun_asm_t {
    mp_obj_base_t base;
    mp_uint_t n_args;
    void *fun_data; // GC must be able to trace this pointer
    mp_uint_t type_sig;
} mp_obj_fun_asm_t;

typedef mp_uint_t (*inline_asm_fun_0_t)(void);
typedef mp_uint_t (*inline_asm_fun_1_t)(mp_uint_t);
typedef mp_uint_t (*inline_asm_fun_2_t)(mp_uint_t, mp_uint_t);
typedef mp_uint_t (*inline_asm_fun_3_t)(mp_uint_t, mp_uint_t, mp_uint_t);
typedef mp_uint_t (*inline_asm_fun_4_t)(mp_uint_t, mp_uint_t, mp_uint_t, mp_uint_t);

// convert a Micro Python object to a sensible value for inline asm
STATIC mp_uint_t micropy_convert_obj_for_inline_asm(struct _mp_state_ctx_t *mp_state, mp_obj_t obj) {
    // TODO for byte_array, pass pointer to the array
    if (MP_OBJ_IS_SMALL_INT(obj)) {
        return MP_OBJ_SMALL_INT_VALUE(obj);
    } else if (obj == mp_const_none) {
        return 0;
    } else if (obj == mp_const_false) {
        return 0;
    } else if (obj == mp_const_true) {
        return 1;
    } else if (MP_OBJ_IS_TYPE(obj, &mp_type_int)) {
        return micropy_obj_int_get_truncated(mp_state, obj);
    } else if (MP_OBJ_IS_STR(obj)) {
        // pointer to the string (it's probably constant though!)
        mp_uint_t l;
        return (mp_uint_t)micropy_obj_str_get_data(mp_state, obj, &l);
    } else {
        mp_obj_type_t *type = micropy_obj_get_type(mp_state, obj);
        if (0) {
#if MICROPY_PY_BUILTINS_FLOAT
        } else if (type == &mp_type_float) {
            // convert float to int (could also pass in float registers)
            return (mp_int_t)micropy_obj_float_get(mp_state, obj);
#endif
        } else if (type == &mp_type_tuple) {
            // pointer to start of tuple (could pass length, but then could use len(x) for that)
            mp_uint_t len;
            mp_obj_t *items;
            micropy_obj_tuple_get(mp_state, obj, &len, &items);
            return (mp_uint_t)items;
        } else if (type == &mp_type_list) {
            // pointer to start of list (could pass length, but then could use len(x) for that)
            mp_uint_t len;
            mp_obj_t *items;
            micropy_obj_list_get(mp_state, obj, &len, &items);
            return (mp_uint_t)items;
        } else {
            mp_buffer_info_t bufinfo;
            if (micropy_get_buffer(mp_state, obj, &bufinfo, MP_BUFFER_WRITE)) {
                // supports the buffer protocol, return a pointer to the data
                return (mp_uint_t)bufinfo.buf;
            } else {
                // just pass along a pointer to the object
                return (mp_uint_t)obj;
            }
        }
    }
}

STATIC mp_obj_t micropy_fun_asm_call(struct _mp_state_ctx_t *mp_state, mp_obj_t self_in, size_t n_args, size_t n_kw, const mp_obj_t *args) {
    mp_obj_fun_asm_t *self = self_in;

    micropy_arg_check_num(mp_state, n_args, n_kw, self->n_args, self->n_args, false);

    void *fun = MICROPY_MAKE_POINTER_CALLABLE(self->fun_data);

    mp_uint_t ret;
    if (n_args == 0) {
        ret = ((inline_asm_fun_0_t)fun)();
    } else if (n_args == 1) {
        ret = ((inline_asm_fun_1_t)fun)(micropy_convert_obj_for_inline_asm(mp_state, args[0]));
    } else if (n_args == 2) {
        ret = ((inline_asm_fun_2_t)fun)(micropy_convert_obj_for_inline_asm(mp_state, args[0]), micropy_convert_obj_for_inline_asm(mp_state, args[1]));
    } else if (n_args == 3) {
        ret = ((inline_asm_fun_3_t)fun)(micropy_convert_obj_for_inline_asm(mp_state, args[0]), micropy_convert_obj_for_inline_asm(mp_state, args[1]), micropy_convert_obj_for_inline_asm(mp_state, args[2]));
    } else {
        // compiler allows at most 4 arguments
        assert(n_args == 4);
        ret = ((inline_asm_fun_4_t)fun)(
            micropy_convert_obj_for_inline_asm(mp_state, args[0]),
            micropy_convert_obj_for_inline_asm(mp_state, args[1]),
            micropy_convert_obj_for_inline_asm(mp_state, args[2]),
            micropy_convert_obj_for_inline_asm(mp_state, args[3])
        );
    }

    return micropy_convert_native_to_obj(mp_state, ret, self->type_sig);
}

STATIC const mp_obj_type_t mp_type_fun_asm = {
    { &mp_type_type },
    .name = MP_QSTR_function,
    .call = micropy_fun_asm_call,
    .unary_op = micropy_generic_unary_op,
};

mp_obj_t micropy_obj_new_fun_asm(struct _mp_state_ctx_t *mp_state, mp_uint_t n_args, void *fun_data, mp_uint_t type_sig) {
    mp_obj_fun_asm_t *o = micropy_m_new_obj(mp_state, mp_obj_fun_asm_t);
    o->base.type = &mp_type_fun_asm;
    o->n_args = n_args;
    o->fun_data = fun_data;
    o->type_sig = type_sig;
    return o;
}

#endif // MICROPY_EMIT_INLINE_THUMB
/*
 * This file is part of the Micro Python project, http://micropython.org/
 *
 * The MIT License (MIT)
 *
 * Copyright (c) 2013, 2014 Damien P. George
 * Copyright (c) 2014 Paul Sokolovsky
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

#include <stdlib.h>
#include <assert.h>

//#include "py/nlr.h"
//#include "py/obj.h"
//#include "py/runtime.h"
//#include "py/bc.h"
//#include "py/objgenerator.h"
//#include "py/objfun.h"

/******************************************************************************/
/* generator wrapper                                                          */

typedef struct _mp_obj_gen_wrap_t {
    mp_obj_base_t base;
    mp_obj_t *fun;
} mp_obj_gen_wrap_t;

typedef struct _mp_obj_gen_instance_t {
    mp_obj_base_t base;
    mp_obj_dict_t *globals;
    mp_code_state code_state;
} mp_obj_gen_instance_t;

STATIC mp_obj_t micropy_gen_wrap_call(struct _mp_state_ctx_t *mp_state, mp_obj_t self_in, size_t n_args, size_t n_kw, const mp_obj_t *args) {
    mp_obj_gen_wrap_t *self = MP_OBJ_TO_PTR(self_in);
    mp_obj_fun_bc_t *self_fun = (mp_obj_fun_bc_t*)self->fun;
    assert(self_fun->base.type == &mp_type_fun_bc);

    // get start of bytecode
    const byte *ip = self_fun->bytecode;

    // bytecode prelude: get state size and exception stack size
    mp_uint_t n_state = micropy_decode_uint(mp_state, &ip);
    mp_uint_t n_exc_stack = micropy_decode_uint(mp_state, &ip);

    // allocate the generator object, with room for local stack and exception stack
    mp_obj_gen_instance_t *o = micropy_m_new_obj_var(mp_state, mp_obj_gen_instance_t, byte,
        n_state * sizeof(mp_obj_t) + n_exc_stack * sizeof(mp_exc_stack_t));
    o->base.type = &mp_type_gen_instance;

    o->globals = self_fun->globals;
    o->code_state.n_state = n_state;
    o->code_state.ip = (byte*)(ip - self_fun->bytecode); // offset to prelude
    micropy_setup_code_state(mp_state, &o->code_state, self_fun, n_args, n_kw, args);
    return MP_OBJ_FROM_PTR(o);
}

const mp_obj_type_t mp_type_gen_wrap = {
    { &mp_type_type },
    .name = MP_QSTR_generator,
    .call = micropy_gen_wrap_call,
};

mp_obj_t micropy_obj_new_gen_wrap(struct _mp_state_ctx_t *mp_state, mp_obj_t fun) {
    mp_obj_gen_wrap_t *o = micropy_m_new_obj(mp_state, mp_obj_gen_wrap_t);
    o->base.type = &mp_type_gen_wrap;
    o->fun = MP_OBJ_TO_PTR(fun);
    return MP_OBJ_FROM_PTR(o);
}

/******************************************************************************/
/* generator instance                                                         */

STATIC void micropy_gen_instance_print(struct _mp_state_ctx_t *mp_state, const mp_print_t *print, mp_obj_t self_in, mp_print_kind_t kind) {
    (void)kind;
    mp_obj_gen_instance_t *self = MP_OBJ_TO_PTR(self_in);
    micropy_printf(mp_state, print, "<generator object '%q' at %p>", micropy_obj_code_get_name(mp_state, self->code_state.code_info), self);
}

mp_vm_return_kind_t micropy_obj_gen_resume(struct _mp_state_ctx_t *mp_state, mp_obj_t self_in, mp_obj_t send_value, mp_obj_t throw_value, mp_obj_t *ret_val) {
    assert(MP_OBJ_IS_TYPE(self_in, &mp_type_gen_instance));
    mp_obj_gen_instance_t *self = MP_OBJ_TO_PTR(self_in);
    if (self->code_state.ip == 0) {
        // Trying to resume already stopped generator
        *ret_val = MP_OBJ_STOP_ITERATION;
        return MP_VM_RETURN_NORMAL;
    }
    if (self->code_state.sp == self->code_state.state - 1) {
        if (send_value != mp_const_none) {
            micropy_nlr_raise(mp_state, micropy_obj_new_exception_msg(mp_state, &mp_type_TypeError, "can't send non-None value to a just-started generator"));
        }
    } else {
        *self->code_state.sp = send_value;
    }
    mp_obj_dict_t *old_globals = mp_state->dict_globals;
    mp_state->dict_globals = self->globals;
    mp_vm_return_kind_t ret_kind = micropy_execute_bytecode(mp_state, &self->code_state, throw_value);
    mp_state->dict_globals = old_globals;

    switch (ret_kind) {
        case MP_VM_RETURN_NORMAL:
        default:
            // Explicitly mark generator as completed. If we don't do this,
            // subsequent next() may re-execute statements after last yield
            // again and again, leading to side effects.
            // TODO: check how return with value behaves under such conditions
            // in CPython.
            self->code_state.ip = 0;
            *ret_val = *self->code_state.sp;
            break;

        case MP_VM_RETURN_YIELD:
            *ret_val = *self->code_state.sp;
            if (*ret_val == MP_OBJ_STOP_ITERATION) {
                self->code_state.ip = 0;
            }
            break;

        case MP_VM_RETURN_EXCEPTION:
            self->code_state.ip = 0;
            *ret_val = self->code_state.state[self->code_state.n_state - 1];
            break;
    }

    return ret_kind;
}

STATIC mp_obj_t micropy_gen_resume_and_raise(struct _mp_state_ctx_t *mp_state, mp_obj_t self_in, mp_obj_t send_value, mp_obj_t throw_value) {
    mp_obj_t ret;
    switch (micropy_obj_gen_resume(mp_state, self_in, send_value, throw_value, &ret)) {
        case MP_VM_RETURN_NORMAL:
        default:
            // Optimize return w/o value in case generator is used in for loop
            if (ret == mp_const_none || ret == MP_OBJ_STOP_ITERATION) {
                return MP_OBJ_STOP_ITERATION;
            } else {
                micropy_nlr_raise(mp_state, micropy_obj_new_exception_args(mp_state, &mp_type_StopIteration, 1, &ret));
            }

        case MP_VM_RETURN_YIELD:
            if (throw_value != MP_OBJ_NULL && micropy_obj_is_subclass_fast(mp_state, MP_OBJ_FROM_PTR(micropy_obj_get_type(mp_state, throw_value)), MP_OBJ_FROM_PTR(&mp_type_GeneratorExit))) {
                micropy_nlr_raise(mp_state, micropy_obj_new_exception_msg(mp_state, &mp_type_RuntimeError, "generator ignored GeneratorExit"));
            }
            return ret;

        case MP_VM_RETURN_EXCEPTION:
            // TODO: Optimization of returning MP_OBJ_STOP_ITERATION is really part
            // of mp_iternext() protocol, but this function is called by other methods
            // too, which may not handled MP_OBJ_STOP_ITERATION.
            if (micropy_obj_is_subclass_fast(mp_state, MP_OBJ_FROM_PTR(micropy_obj_get_type(mp_state, ret)), MP_OBJ_FROM_PTR(&mp_type_StopIteration))) {
                mp_obj_t val = micropy_obj_exception_get_value(mp_state, ret);
                if (val == mp_const_none) {
                    return MP_OBJ_STOP_ITERATION;
                }
            }
            micropy_nlr_raise(mp_state, ret);
    }
}

STATIC mp_obj_t micropy_gen_instance_iternext(struct _mp_state_ctx_t *mp_state, mp_obj_t self_in) {
    return micropy_gen_resume_and_raise(mp_state, self_in, mp_const_none, MP_OBJ_NULL);
}

STATIC mp_obj_t micropy_gen_instance_send(struct _mp_state_ctx_t *mp_state, mp_obj_t self_in, mp_obj_t send_value) {
    mp_obj_t ret = micropy_gen_resume_and_raise(mp_state, self_in, send_value, MP_OBJ_NULL);
    if (ret == MP_OBJ_STOP_ITERATION) {
        micropy_nlr_raise(mp_state, micropy_obj_new_exception(mp_state, &mp_type_StopIteration));
    } else {
        return ret;
    }
}

STATIC MP_DEFINE_CONST_FUN_OBJ_2(gen_instance_send_obj, micropy_gen_instance_send);

STATIC mp_obj_t micropy_gen_instance_close(struct _mp_state_ctx_t *mp_state, mp_obj_t self_in);
STATIC mp_obj_t micropy_gen_instance_throw(struct _mp_state_ctx_t *mp_state, size_t n_args, const mp_obj_t *args) {
    mp_obj_t exc = (n_args == 2) ? args[1] : args[2];
    exc = micropy_make_raise_obj(mp_state, exc);

    mp_obj_t ret = micropy_gen_resume_and_raise(mp_state, args[0], mp_const_none, exc);
    if (ret == MP_OBJ_STOP_ITERATION) {
        micropy_nlr_raise(mp_state, micropy_obj_new_exception(mp_state, &mp_type_StopIteration));
    } else {
        return ret;
    }
}

STATIC MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(gen_instance_throw_obj, 2, 4, micropy_gen_instance_throw);

STATIC mp_obj_t micropy_gen_instance_close(struct _mp_state_ctx_t *mp_state, mp_obj_t self_in) {
    mp_obj_t ret;
    switch (micropy_obj_gen_resume(mp_state, self_in, mp_const_none, MP_OBJ_FROM_PTR(&mp_const_GeneratorExit_obj), &ret)) {
        case MP_VM_RETURN_YIELD:
            micropy_nlr_raise(mp_state, micropy_obj_new_exception_msg(mp_state, &mp_type_RuntimeError, "generator ignored GeneratorExit"));

        // Swallow StopIteration & GeneratorExit (== successful close), and re-raise any other
        case MP_VM_RETURN_EXCEPTION:
            // ret should always be an instance of an exception class
            if (micropy_obj_is_subclass_fast(mp_state, MP_OBJ_FROM_PTR(micropy_obj_get_type(mp_state, ret)), MP_OBJ_FROM_PTR(&mp_type_GeneratorExit)) ||
                micropy_obj_is_subclass_fast(mp_state, MP_OBJ_FROM_PTR(micropy_obj_get_type(mp_state, ret)), MP_OBJ_FROM_PTR(&mp_type_StopIteration))) {
                return mp_const_none;
            }
            micropy_nlr_raise(mp_state, ret);

        default:
            // The only choice left is MP_VM_RETURN_NORMAL which is successful close
            return mp_const_none;
    }
}

STATIC MP_DEFINE_CONST_FUN_OBJ_1(gen_instance_close_obj, micropy_gen_instance_close);

STATIC const mp_rom_map_elem_t gen_instance_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_close), MP_ROM_PTR(&gen_instance_close_obj) },
    { MP_ROM_QSTR(MP_QSTR_send), MP_ROM_PTR(&gen_instance_send_obj) },
    { MP_ROM_QSTR(MP_QSTR_throw), MP_ROM_PTR(&gen_instance_throw_obj) },
};

STATIC MP_DEFINE_CONST_DICT(gen_instance_locals_dict, gen_instance_locals_dict_table);

const mp_obj_type_t mp_type_gen_instance = {
    { &mp_type_type },
    .name = MP_QSTR_generator,
    .print = micropy_gen_instance_print,
    .getiter = micropy_identity,
    .iternext = micropy_gen_instance_iternext,
    .locals_dict = (mp_obj_dict_t*)&gen_instance_locals_dict,
};
/*
 * This file is part of the Micro Python project, http://micropython.org/
 *
 * The MIT License (MIT)
 *
 * Copyright (c) 2013, 2014 Damien P. George
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

#include <stdlib.h>

//#include "py/nlr.h"
//#include "py/runtime.h"

// this is a wrapper object that turns something that has a __getitem__ method into an iterator

typedef struct _mp_obj_getitem_iter_t {
    mp_obj_base_t base;
    mp_obj_t args[3];
} mp_obj_getitem_iter_t;

STATIC mp_obj_t micropy_it_iternext(struct _mp_state_ctx_t *mp_state, mp_obj_t self_in) {
    mp_obj_getitem_iter_t *self = MP_OBJ_TO_PTR(self_in);
    nlr_buf_t nlr;
    if (micropy_nlr_push(mp_state, &nlr) == 0) {
        // try to get next item
        mp_obj_t value = micropy_call_method_n_kw(mp_state, 1, 0, self->args);
        self->args[2] = MP_OBJ_NEW_SMALL_INT(MP_OBJ_SMALL_INT_VALUE(self->args[2]) + 1);
        micropy_nlr_pop(mp_state);
        return value;
    } else {
        // an exception was raised
        mp_obj_type_t *t = (mp_obj_type_t*)((mp_obj_base_t*)nlr.ret_val)->type;
        if (t == &mp_type_StopIteration || t == &mp_type_IndexError) {
            // return MP_OBJ_STOP_ITERATION instead of raising
            return MP_OBJ_STOP_ITERATION;
        } else {
            // re-raise exception
            micropy_nlr_jump(mp_state, nlr.ret_val);
        }
    }
}

STATIC const mp_obj_type_t it_type = {
    { &mp_type_type },
    .name = MP_QSTR_iterator,
    .getiter = micropy_identity,
    .iternext = micropy_it_iternext,
};

// args are those returned from mp_load_method_maybe (ie either an attribute or a method)
mp_obj_t micropy_obj_new_getitem_iter(struct _mp_state_ctx_t *mp_state, mp_obj_t *args) {
    mp_obj_getitem_iter_t *o = micropy_m_new_obj(mp_state, mp_obj_getitem_iter_t);
    o->base.type = &it_type;
    o->args[0] = args[0];
    o->args[1] = args[1];
    o->args[2] = MP_OBJ_NEW_SMALL_INT(0);
    return MP_OBJ_FROM_PTR(o);
}
/*
 * This file is part of the Micro Python project, http://micropython.org/
 *
 * The MIT License (MIT)
 *
 * Copyright (c) 2013, 2014 Damien P. George
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

#include <stdlib.h>
#include <assert.h>
#include <string.h>

//#include "py/nlr.h"
//#include "py/parsenum.h"
//#include "py/smallint.h"
//#include "py/objint.h"
//#include "py/objstr.h"
//#include "py/runtime0.h"
//#include "py/runtime.h"
//#include "py/binary.h"

#if MICROPY_PY_BUILTINS_FLOAT
#include <math.h>
#endif

// This dispatcher function is expected to be independent of the implementation of long int
STATIC mp_obj_t micropy_obj_int_make_new(struct _mp_state_ctx_t *mp_state, const mp_obj_type_t *type_in, size_t n_args, size_t n_kw, const mp_obj_t *args) {
    (void)type_in;
    micropy_arg_check_num(mp_state, n_args, n_kw, 0, 2, false);

    switch (n_args) {
        case 0:
            return MP_OBJ_NEW_SMALL_INT(0);

        case 1:
            if (MP_OBJ_IS_INT(args[0])) {
                // already an int (small or long), just return it
                return args[0];
            } else if (MP_OBJ_IS_STR_OR_BYTES(args[0])) {
                // a string, parse it
                mp_uint_t l;
                const char *s = micropy_obj_str_get_data(mp_state, args[0], &l);
                return micropy_parse_num_integer(mp_state, s, l, 0, NULL);
#if MICROPY_PY_BUILTINS_FLOAT
            } else if (micropy_obj_is_float(mp_state, args[0])) {
                return micropy_obj_new_int_from_float(mp_state, micropy_obj_float_get(mp_state, args[0]));
#endif
            } else {
                // try to convert to small int (eg from bool)
                return MP_OBJ_NEW_SMALL_INT(micropy_obj_get_int(mp_state, args[0]));
            }

        case 2:
        default: {
            // should be a string, parse it
            // TODO proper error checking of argument types
            mp_uint_t l;
            const char *s = micropy_obj_str_get_data(mp_state, args[0], &l);
            return micropy_parse_num_integer(mp_state, s, l, micropy_obj_get_int(mp_state, args[1]), NULL);
        }
    }
}

#if MICROPY_PY_BUILTINS_FLOAT
mp_fp_as_int_class_t micropy_classify_fp_as_int(struct _mp_state_ctx_t *mp_state, mp_float_t val) {
    union {
        mp_float_t f;
#if MICROPY_FLOAT_IMPL == MICROPY_FLOAT_IMPL_FLOAT
        uint32_t i;
#elif MICROPY_FLOAT_IMPL == MICROPY_FLOAT_IMPL_DOUBLE
        uint32_t i[2];
#endif
    } u = {val};

    uint32_t e;
#if MICROPY_FLOAT_IMPL == MICROPY_FLOAT_IMPL_FLOAT
    e = u.i;
#elif MICROPY_FLOAT_IMPL == MICROPY_FLOAT_IMPL_DOUBLE
    e = u.i[MP_ENDIANNESS_LITTLE];
#endif
#define MP_FLOAT_SIGN_SHIFT_I32 ((MP_FLOAT_FRAC_BITS + MP_FLOAT_EXP_BITS) % 32)
#define MP_FLOAT_EXP_SHIFT_I32 (MP_FLOAT_FRAC_BITS % 32)

    if (e & (1 << MP_FLOAT_SIGN_SHIFT_I32)) {
#if MICROPY_FLOAT_IMPL == MICROPY_FLOAT_IMPL_DOUBLE
        e |= u.i[MP_ENDIANNESS_BIG] != 0;
#endif
        e += ((1 << MP_FLOAT_EXP_BITS) - 1) << MP_FLOAT_EXP_SHIFT_I32;
    } else {
        e &= ~((1 << MP_FLOAT_EXP_SHIFT_I32) - 1);
    }
    // 8 * sizeof(uintptr_t) counts the number of bits for a small int
    // TODO provide a way to configure this properly
    if (e <= ((8 * sizeof(uintptr_t) + MP_FLOAT_EXP_BIAS - 3) << MP_FLOAT_EXP_SHIFT_I32)) {
        return MP_FP_CLASS_FIT_SMALLINT;
    }
#if MICROPY_LONGINT_IMPL == MICROPY_LONGINT_IMPL_LONGLONG
    if (e <= (((sizeof(long long) * BITS_PER_BYTE) + MP_FLOAT_EXP_BIAS - 2) << MP_FLOAT_EXP_SHIFT_I32)) {
        return MP_FP_CLASS_FIT_LONGINT;
    }
#endif
#if MICROPY_LONGINT_IMPL == MICROPY_LONGINT_IMPL_MPZ
    return MP_FP_CLASS_FIT_LONGINT;
#else
    return MP_FP_CLASS_OVERFLOW;
#endif
}
#undef MP_FLOAT_SIGN_SHIFT_I32
#undef MP_FLOAT_EXP_SHIFT_I32
#endif

void micropy_obj_int_print(struct _mp_state_ctx_t *mp_state, const mp_print_t *print, mp_obj_t self_in, mp_print_kind_t kind) {
    (void)kind;
    // The size of this buffer is rather arbitrary. If it's not large
    // enough, a dynamic one will be allocated.
    char stack_buf[sizeof(mp_int_t) * 4];
    char *buf = stack_buf;
    mp_uint_t buf_size = sizeof(stack_buf);
    mp_uint_t fmt_size;

    char *str = micropy_obj_int_formatted(mp_state, &buf, &buf_size, &fmt_size, self_in, 10, NULL, '\0', '\0');
    micropy_print_str(mp_state, print, str);

    if (buf != stack_buf) {
        micropy_m_del(mp_state, char, buf, buf_size);
    }
}

#if MICROPY_LONGINT_IMPL == MICROPY_LONGINT_IMPL_LONGLONG
typedef mp_longint_impl_t fmt_int_t;
#else
typedef mp_int_t fmt_int_t;
#endif


STATIC uint micropy_int_as_str_size_formatted(struct _mp_state_ctx_t *mp_state, uint base, const char *prefix, char comma) {
    if (base < 2 || base > 32) {
        return 0;
    }

    uint num_digits = sizeof(fmt_int_t) * 8 / log_base2_floor[base] + 1;
    uint num_commas = comma ? num_digits / 3: 0;
    uint prefix_len = prefix ? strlen(prefix) : 0;
    return num_digits + num_commas + prefix_len + 2; // +1 for sign, +1 for null byte
}

// This routine expects you to pass in a buffer and size (in *buf and *buf_size).
// If, for some reason, this buffer is too small, then it will allocate a
// buffer and return the allocated buffer and size in *buf and *buf_size. It
// is the callers responsibility to free this allocated buffer.
//
// The resulting formatted string will be returned from this function and the
// formatted size will be in *fmt_size.
char *micropy_obj_int_formatted(struct _mp_state_ctx_t *mp_state, char **buf, mp_uint_t *buf_size, mp_uint_t *fmt_size, mp_const_obj_t self_in,
                           int base, const char *prefix, char base_char, char comma) {
    fmt_int_t num;
    if (MP_OBJ_IS_SMALL_INT(self_in)) {
        // A small int; get the integer value to format.
        num = micropy_obj_get_int(mp_state, self_in);
#if MICROPY_LONGINT_IMPL != MICROPY_LONGINT_IMPL_NONE
    } else if (MP_OBJ_IS_TYPE(self_in, &mp_type_int)) {
        // Not a small int.
#if MICROPY_LONGINT_IMPL == MICROPY_LONGINT_IMPL_LONGLONG
        const mp_obj_int_t *self = self_in;
        // Get the value to format; mp_obj_get_int truncates to mp_int_t.
        num = self->val;
#else
        // Delegate to the implementation for the long int.
        return micropy_obj_int_formatted_impl(mp_state, buf, buf_size, fmt_size, self_in, base, prefix, base_char, comma);
#endif
#endif
    } else {
        // Not an int.
        **buf = '\0';
        *fmt_size = 0;
        return *buf;
    }

    char sign = '\0';
    if (num < 0) {
        num = -num;
        sign = '-';
    }

    uint needed_size = micropy_int_as_str_size_formatted(mp_state, base, prefix, comma);
    if (needed_size > *buf_size) {
        *buf = micropy_m_new(mp_state, char, needed_size);
        *buf_size = needed_size;
    }
    char *str = *buf;

    char *b = str + needed_size;
    *(--b) = '\0';
    char *last_comma = b;

    if (num == 0) {
        *(--b) = '0';
    } else {
        do {
            int c = num % base;
            num /= base;
            if (c >= 10) {
                c += base_char - 10;
            } else {
                c += '0';
            }
            *(--b) = c;
            if (comma && num != 0 && b > str && (last_comma - b) == 3) {
                *(--b) = comma;
                last_comma = b;
            }
        }
        while (b > str && num != 0);
    }
    if (prefix) {
        size_t prefix_len = strlen(prefix);
        char *p = b - prefix_len;
        if (p > str) {
            b = p;
            while (*prefix) {
                *p++ = *prefix++;
            }
        }
    }
    if (sign && b > str) {
        *(--b) = sign;
    }
    *fmt_size = *buf + needed_size - b - 1;

    return b;
}

#if MICROPY_LONGINT_IMPL == MICROPY_LONGINT_IMPL_NONE

int micropy_obj_int_sign(struct _mp_state_ctx_t *mp_state, mp_obj_t self_in) {
    mp_int_t val = micropy_obj_get_int(mp_state, self_in);
    if (val < 0) {
        return -1;
    } else if (val > 0) {
        return 1;
    } else {
        return 0;
    }
}

// This must handle int and bool types, and must raise a
// TypeError if the argument is not integral
mp_obj_t micropy_obj_int_abs(struct _mp_state_ctx_t *mp_state, mp_obj_t self_in) {
    mp_int_t val = micropy_obj_get_int(mp_state, self_in);
    if (val < 0) {
        val = -val;
    }
    return MP_OBJ_NEW_SMALL_INT(val);
}

// This is called for operations on SMALL_INT that are not handled by mp_unary_op
mp_obj_t micropy_obj_int_unary_op(struct _mp_state_ctx_t *mp_state, mp_uint_t op, mp_obj_t o_in) {
    return MP_OBJ_NULL; // op not supported
}

// This is called for operations on SMALL_INT that are not handled by mp_binary_op
mp_obj_t micropy_obj_int_binary_op(struct _mp_state_ctx_t *mp_state, mp_uint_t op, mp_obj_t lhs_in, mp_obj_t rhs_in) {
    return micropy_obj_int_binary_op_extra_cases(mp_state, op, lhs_in, rhs_in);
}

// This is called only with strings whose value doesn't fit in SMALL_INT
mp_obj_t micropy_obj_new_int_from_str_len(struct _mp_state_ctx_t *mp_state, const char **str, mp_uint_t len, bool neg, mp_uint_t base) {
    micropy_nlr_raise(mp_state, micropy_obj_new_exception_msg(mp_state, &mp_type_OverflowError, "long int not supported in this build"));
    return mp_const_none;
}

// This is called when an integer larger than a SMALL_INT is needed (although val might still fit in a SMALL_INT)
mp_obj_t micropy_obj_new_int_from_ll(struct _mp_state_ctx_t *mp_state, long long val) {
    micropy_nlr_raise(mp_state, micropy_obj_new_exception_msg(mp_state, &mp_type_OverflowError, "small int overflow"));
    return mp_const_none;
}

// This is called when an integer larger than a SMALL_INT is needed (although val might still fit in a SMALL_INT)
mp_obj_t micropy_obj_new_int_from_ull(struct _mp_state_ctx_t *mp_state, unsigned long long val) {
    micropy_nlr_raise(mp_state, micropy_obj_new_exception_msg(mp_state, &mp_type_OverflowError, "small int overflow"));
    return mp_const_none;
}

mp_obj_t micropy_obj_new_int_from_uint(struct _mp_state_ctx_t *mp_state, mp_uint_t value) {
    // SMALL_INT accepts only signed numbers, so make sure the input
    // value fits completely in the small-int positive range.
    if ((value & ~MP_SMALL_INT_POSITIVE_MASK) == 0) {
        return MP_OBJ_NEW_SMALL_INT(value);
    }
    micropy_nlr_raise(mp_state, micropy_obj_new_exception_msg(mp_state, &mp_type_OverflowError, "small int overflow"));
    return mp_const_none;
}

#if MICROPY_PY_BUILTINS_FLOAT
mp_obj_t micropy_obj_new_int_from_float(struct _mp_state_ctx_t *mp_state, mp_float_t val) {
    int cl = fpclassify(val);
    if (cl == FP_INFINITE) {
        micropy_nlr_raise(mp_state, micropy_obj_new_exception_msg_varg(mp_state, &mp_type_OverflowError, "can't convert inf to int"));
    } else if (cl == FP_NAN) {
        micropy_nlr_raise(mp_state, micropy_obj_new_exception_msg_varg(mp_state, &mp_type_ValueError, "can't convert NaN to int"));
    } else {
        mp_fp_as_int_class_t icl = micropy_classify_fp_as_int(mp_state, val);
        if (icl == MP_FP_CLASS_FIT_SMALLINT) {
            return MP_OBJ_NEW_SMALL_INT((mp_int_t)val);
        } else {
            micropy_nlr_raise(mp_state, micropy_obj_new_exception_msg_varg(mp_state, &mp_type_ValueError, "float too big"));
        }
    }
}
#endif

mp_obj_t micropy_obj_new_int(struct _mp_state_ctx_t *mp_state, mp_int_t value) {
    if (MP_SMALL_INT_FITS(value)) {
        return MP_OBJ_NEW_SMALL_INT(value);
    }
    micropy_nlr_raise(mp_state, micropy_obj_new_exception_msg(mp_state, &mp_type_OverflowError, "small int overflow"));
    return mp_const_none;
}

mp_int_t micropy_obj_int_get_truncated(struct _mp_state_ctx_t *mp_state, mp_const_obj_t self_in) {
    return MP_OBJ_SMALL_INT_VALUE(self_in);
}

mp_int_t micropy_obj_int_get_checked(struct _mp_state_ctx_t *mp_state, mp_const_obj_t self_in) {
    return MP_OBJ_SMALL_INT_VALUE(self_in);
}

#if MICROPY_PY_BUILTINS_FLOAT
mp_float_t micropy_obj_int_as_float(struct _mp_state_ctx_t *mp_state, mp_obj_t self_in) {
    return MP_OBJ_SMALL_INT_VALUE(self_in);
}
#endif

#endif // MICROPY_LONGINT_IMPL == MICROPY_LONGINT_IMPL_NONE

// This dispatcher function is expected to be independent of the implementation of long int
// It handles the extra cases for integer-like arithmetic
mp_obj_t micropy_obj_int_binary_op_extra_cases(struct _mp_state_ctx_t *mp_state, mp_uint_t op, mp_obj_t lhs_in, mp_obj_t rhs_in) {
    if (rhs_in == mp_const_false) {
        // false acts as 0
        return micropy_binary_op(mp_state, op, lhs_in, MP_OBJ_NEW_SMALL_INT(0));
    } else if (rhs_in == mp_const_true) {
        // true acts as 0
        return micropy_binary_op(mp_state, op, lhs_in, MP_OBJ_NEW_SMALL_INT(1));
    } else if (op == MP_BINARY_OP_MULTIPLY) {
        if (MP_OBJ_IS_STR(rhs_in) || MP_OBJ_IS_TYPE(rhs_in, &mp_type_bytes) || MP_OBJ_IS_TYPE(rhs_in, &mp_type_tuple) || MP_OBJ_IS_TYPE(rhs_in, &mp_type_list)) {
            // multiply is commutative for these types, so delegate to them
            return micropy_binary_op(mp_state, op, rhs_in, lhs_in);
        }
    }
    return MP_OBJ_NULL; // op not supported
}

// this is a classmethod
STATIC mp_obj_t micropy_int_from_bytes(struct _mp_state_ctx_t *mp_state, size_t n_args, const mp_obj_t *args) {
    // TODO: Support long ints
    // TODO: Support byteorder param (assumes 'little' at the moment)
    // TODO: Support signed param (assumes signed=False at the moment)
    (void)n_args;

    // get the buffer info
    mp_buffer_info_t bufinfo;
    micropy_get_buffer_raise(mp_state, args[1], &bufinfo, MP_BUFFER_READ);

    // convert the bytes to an integer
    mp_uint_t value = 0;
    for (const byte* buf = (const byte*)bufinfo.buf + bufinfo.len - 1; buf >= (byte*)bufinfo.buf; buf--) {
        value = (value << 8) | *buf;
    }

    return micropy_obj_new_int_from_uint(mp_state, value);
}

STATIC MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(int_from_bytes_fun_obj, 2, 3, micropy_int_from_bytes);
STATIC MP_DEFINE_CONST_CLASSMETHOD_OBJ(int_from_bytes_obj, MP_ROM_PTR(&int_from_bytes_fun_obj));

STATIC mp_obj_t micropy_int_to_bytes(struct _mp_state_ctx_t *mp_state, size_t n_args, const mp_obj_t *args) {
    // TODO: Support byteorder param (assumes 'little')
    // TODO: Support signed param (assumes signed=False)
    (void)n_args;

    mp_uint_t len = MP_OBJ_SMALL_INT_VALUE(args[1]);

    vstr_t vstr;
    micropy_vstr_init_len(mp_state, &vstr, len);
    byte *data = (byte*)vstr.buf;
    memset(data, 0, len);

    #if MICROPY_LONGINT_IMPL != MICROPY_LONGINT_IMPL_NONE
    if (!MP_OBJ_IS_SMALL_INT(args[0])) {
        micropy_obj_int_to_bytes_impl(mp_state, args[0], false, len, data);
    } else
    #endif
    {
        mp_int_t val = MP_OBJ_SMALL_INT_VALUE(args[0]);
        micropy_binary_set_int(mp_state, MIN((size_t)len, sizeof(val)), false, data, val);
    }

    return micropy_obj_new_str_from_vstr(mp_state, &mp_type_bytes, &vstr);
}
STATIC MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(int_to_bytes_obj, 2, 4, micropy_int_to_bytes);

STATIC const mp_rom_map_elem_t int_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_from_bytes), MP_ROM_PTR(&int_from_bytes_obj) },
    { MP_ROM_QSTR(MP_QSTR_to_bytes), MP_ROM_PTR(&int_to_bytes_obj) },
};

STATIC MP_DEFINE_CONST_DICT(int_locals_dict, int_locals_dict_table);

const mp_obj_type_t mp_type_int = {
    { &mp_type_type },
    .name = MP_QSTR_int,
    .print = micropy_obj_int_print,
    .make_new = micropy_obj_int_make_new,
    .unary_op = micropy_obj_int_unary_op,
    .binary_op = micropy_obj_int_binary_op,
    .locals_dict = (mp_obj_dict_t*)&int_locals_dict,
};
/*
 * This file is part of the Micro Python project, http://micropython.org/
 *
 * The MIT License (MIT)
 *
 * Copyright (c) 2013, 2014 Damien P. George
 * Copyright (c) 2014 Paul Sokolovsky
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

#include <stdlib.h>
#include <string.h>

//#include "py/nlr.h"
//#include "py/smallint.h"
//#include "py/objint.h"
//#include "py/runtime0.h"
//#include "py/runtime.h"

#if MICROPY_PY_BUILTINS_FLOAT
#include <math.h>
#endif

#if MICROPY_LONGINT_IMPL == MICROPY_LONGINT_IMPL_LONGLONG

// Python3 no longer has "l" suffix for long ints. We allow to use it
// for debugging purpose though.
#ifdef DEBUG
#define SUFFIX "l"
#else
#define SUFFIX ""
#endif

#if MICROPY_PY_SYS_MAXSIZE
// Export value for sys.maxsize
const mp_obj_int_t mp_maxsize_obj = {{&mp_type_int}, MP_SSIZE_MAX};
#endif

void micropy_obj_int_to_bytes_impl(struct _mp_state_ctx_t *mp_state, mp_obj_t self_in, bool big_endian, mp_uint_t len, byte *buf) {
    assert(MP_OBJ_IS_TYPE(self_in, &mp_type_int));
    mp_obj_int_t *self = self_in;
    long long val = self->val;
    if (big_endian) {
        byte *b = buf + len;
        while (b > buf) {
            *--b = val;
            val >>= 8;
        }
    } else {
        for (; len > 0; --len) {
            *buf++ = val;
            val >>= 8;
        }
    }
}

int micropy_obj_int_sign(struct _mp_state_ctx_t *mp_state, mp_obj_t self_in) {
    mp_longint_impl_t val;
    if (MP_OBJ_IS_SMALL_INT(self_in)) {
        val = MP_OBJ_SMALL_INT_VALUE(self_in);
    } else {
        mp_obj_int_t *self = self_in;
        val = self->val;
    }
    if (val < 0) {
        return -1;
    } else if (val > 0) {
        return 1;
    } else {
        return 0;
    }
}

// This must handle int and bool types, and must raise a
// TypeError if the argument is not integral
mp_obj_t micropy_obj_int_abs(struct _mp_state_ctx_t *mp_state, mp_obj_t self_in) {
    if (MP_OBJ_IS_TYPE(self_in, &mp_type_int)) {
        mp_obj_int_t *self = self_in;
        self = micropy_obj_new_int_from_ll(mp_state, self->val);
        if (self->val < 0) {
            // TODO could overflow long long
            self->val = -self->val;
        }
        return self;
    } else {
        mp_int_t val = micropy_obj_get_int(mp_state, self_in);
        if (val == MP_SMALL_INT_MIN) {
            return micropy_obj_new_int_from_ll(mp_state, -val);
        } else {
            if (val < 0) {
                val = -val;
            }
            return MP_OBJ_NEW_SMALL_INT(val);
        }
    }
}

mp_obj_t micropy_obj_int_unary_op(struct _mp_state_ctx_t *mp_state, mp_uint_t op, mp_obj_t o_in) {
    mp_obj_int_t *o = o_in;
    switch (op) {
        case MP_UNARY_OP_BOOL: return micropy_obj_new_bool(mp_state, o->val != 0);

        // truncate value to fit in mp_int_t, which gives the same hash as
        // small int if the value fits without truncation
        case MP_UNARY_OP_HASH: return MP_OBJ_NEW_SMALL_INT((mp_int_t)o->val);

        case MP_UNARY_OP_POSITIVE: return o_in;
        case MP_UNARY_OP_NEGATIVE: return micropy_obj_new_int_from_ll(mp_state, -o->val);
        case MP_UNARY_OP_INVERT: return micropy_obj_new_int_from_ll(mp_state, ~o->val);
        default: return MP_OBJ_NULL; // op not supported
    }
}

mp_obj_t micropy_obj_int_binary_op(struct _mp_state_ctx_t *mp_state, mp_uint_t op, mp_obj_t lhs_in, mp_obj_t rhs_in) {
    long long lhs_val;
    long long rhs_val;

    if (MP_OBJ_IS_SMALL_INT(lhs_in)) {
        lhs_val = MP_OBJ_SMALL_INT_VALUE(lhs_in);
    } else if (MP_OBJ_IS_TYPE(lhs_in, &mp_type_int)) {
        lhs_val = ((mp_obj_int_t*)lhs_in)->val;
    } else {
        return MP_OBJ_NULL; // op not supported
    }

    if (MP_OBJ_IS_SMALL_INT(rhs_in)) {
        rhs_val = MP_OBJ_SMALL_INT_VALUE(rhs_in);
    } else if (MP_OBJ_IS_TYPE(rhs_in, &mp_type_int)) {
        rhs_val = ((mp_obj_int_t*)rhs_in)->val;
    } else {
        // delegate to generic function to check for extra cases
        return micropy_obj_int_binary_op_extra_cases(mp_state, op, lhs_in, rhs_in);
    }

    switch (op) {
        case MP_BINARY_OP_ADD:
        case MP_BINARY_OP_INPLACE_ADD:
            return micropy_obj_new_int_from_ll(mp_state, lhs_val + rhs_val);
        case MP_BINARY_OP_SUBTRACT:
        case MP_BINARY_OP_INPLACE_SUBTRACT:
            return micropy_obj_new_int_from_ll(mp_state, lhs_val - rhs_val);
        case MP_BINARY_OP_MULTIPLY:
        case MP_BINARY_OP_INPLACE_MULTIPLY:
            return micropy_obj_new_int_from_ll(mp_state, lhs_val * rhs_val);
        case MP_BINARY_OP_FLOOR_DIVIDE:
        case MP_BINARY_OP_INPLACE_FLOOR_DIVIDE:
            return micropy_obj_new_int_from_ll(mp_state, lhs_val / rhs_val);
        case MP_BINARY_OP_MODULO:
        case MP_BINARY_OP_INPLACE_MODULO:
            return micropy_obj_new_int_from_ll(mp_state, lhs_val % rhs_val);

        case MP_BINARY_OP_AND:
        case MP_BINARY_OP_INPLACE_AND:
            return micropy_obj_new_int_from_ll(mp_state, lhs_val & rhs_val);
        case MP_BINARY_OP_OR:
        case MP_BINARY_OP_INPLACE_OR:
            return micropy_obj_new_int_from_ll(mp_state, lhs_val | rhs_val);
        case MP_BINARY_OP_XOR:
        case MP_BINARY_OP_INPLACE_XOR:
            return micropy_obj_new_int_from_ll(mp_state, lhs_val ^ rhs_val);

        case MP_BINARY_OP_LSHIFT:
        case MP_BINARY_OP_INPLACE_LSHIFT:
            return micropy_obj_new_int_from_ll(mp_state, lhs_val << (int)rhs_val);
        case MP_BINARY_OP_RSHIFT:
        case MP_BINARY_OP_INPLACE_RSHIFT:
            return micropy_obj_new_int_from_ll(mp_state, lhs_val >> (int)rhs_val);

        case MP_BINARY_OP_POWER:
        case MP_BINARY_OP_INPLACE_POWER: {
            long long ans = 1;
            while (rhs_val > 0) {
                if (rhs_val & 1) {
                    ans *= lhs_val;
                }
                if (rhs_val == 1) {
                    break;
                }
                rhs_val /= 2;
                lhs_val *= lhs_val;
            }
            return micropy_obj_new_int_from_ll(mp_state, ans);
        }

        case MP_BINARY_OP_LESS:
            return micropy_obj_new_bool(mp_state, lhs_val < rhs_val);
        case MP_BINARY_OP_MORE:
            return micropy_obj_new_bool(mp_state, lhs_val > rhs_val);
        case MP_BINARY_OP_LESS_EQUAL:
            return micropy_obj_new_bool(mp_state, lhs_val <= rhs_val);
        case MP_BINARY_OP_MORE_EQUAL:
            return micropy_obj_new_bool(mp_state, lhs_val >= rhs_val);
        case MP_BINARY_OP_EQUAL:
            return micropy_obj_new_bool(mp_state, lhs_val == rhs_val);

        default:
            return MP_OBJ_NULL; // op not supported
    }
}

mp_obj_t micropy_obj_new_int(struct _mp_state_ctx_t *mp_state, mp_int_t value) {
    if (MP_SMALL_INT_FITS(value)) {
        return MP_OBJ_NEW_SMALL_INT(value);
    }
    return micropy_obj_new_int_from_ll(mp_state, value);
}

mp_obj_t micropy_obj_new_int_from_uint(struct _mp_state_ctx_t *mp_state, mp_uint_t value) {
    // SMALL_INT accepts only signed numbers, so make sure the input
    // value fits completely in the small-int positive range.
    if ((value & ~MP_SMALL_INT_POSITIVE_MASK) == 0) {
        return MP_OBJ_NEW_SMALL_INT(value);
    }
    return micropy_obj_new_int_from_ll(mp_state, value);
}

mp_obj_t micropy_obj_new_int_from_ll(struct _mp_state_ctx_t *mp_state, long long val) {
    mp_obj_int_t *o = micropy_m_new_obj(mp_state, mp_obj_int_t);
    o->base.type = &mp_type_int;
    o->val = val;
    return o;
}

mp_obj_t micropy_obj_new_int_from_ull(struct _mp_state_ctx_t *mp_state, unsigned long long val) {
    // TODO raise an exception if the unsigned long long won't fit
    if (val >> (sizeof(unsigned long long) * 8 - 1) != 0) {
        micropy_nlr_raise(mp_state, micropy_obj_new_exception_msg_varg(mp_state, &mp_type_OverflowError, "ulonglong too large"));
    }
    mp_obj_int_t *o = micropy_m_new_obj(mp_state, mp_obj_int_t);
    o->base.type = &mp_type_int;
    o->val = val;
    return o;
}

#if MICROPY_PY_BUILTINS_FLOAT
mp_obj_t micropy_obj_new_int_from_float(struct _mp_state_ctx_t *mp_state, mp_float_t val) {
    int cl = fpclassify(val);
    if (cl == FP_INFINITE) {
        micropy_nlr_raise(mp_state, micropy_obj_new_exception_msg_varg(mp_state, &mp_type_OverflowError, "can't convert inf to int"));
    } else if (cl == FP_NAN) {
        micropy_nlr_raise(mp_state, micropy_obj_new_exception_msg_varg(mp_state, &mp_type_ValueError, "can't convert NaN to int"));
    } else {
        mp_fp_as_int_class_t icl = micropy_classify_fp_as_int(mp_state, val);
        if (icl == MP_FP_CLASS_FIT_SMALLINT) {
            return MP_OBJ_NEW_SMALL_INT((mp_int_t)val);
        } else if (icl == MP_FP_CLASS_FIT_LONGINT) {
            return micropy_obj_new_int_from_ll(mp_state, (long long)val);
        } else {
            micropy_nlr_raise(mp_state, micropy_obj_new_exception_msg_varg(mp_state, &mp_type_ValueError, "float too big"));
        }
    }
}
#endif

mp_obj_t micropy_obj_new_int_from_str_len(struct _mp_state_ctx_t *mp_state, const char **str, mp_uint_t len, bool neg, mp_uint_t base) {
    // TODO this does not honor the given length of the string, but it all cases it should anyway be null terminated
    // TODO check overflow
    mp_obj_int_t *o = micropy_m_new_obj(mp_state, mp_obj_int_t);
    o->base.type = &mp_type_int;
    char *endptr;
    o->val = micropy_strtoll(mp_state, *str, &endptr, base);
    *str = endptr;
    return o;
}

mp_int_t micropy_obj_int_get_truncated(struct _mp_state_ctx_t *mp_state, mp_const_obj_t self_in) {
    if (MP_OBJ_IS_SMALL_INT(self_in)) {
        return MP_OBJ_SMALL_INT_VALUE(self_in);
    } else {
        const mp_obj_int_t *self = self_in;
        return self->val;
    }
}

mp_int_t micropy_obj_int_get_checked(struct _mp_state_ctx_t *mp_state, mp_const_obj_t self_in) {
    // TODO: Check overflow
    return micropy_obj_int_get_truncated(mp_state, self_in);
}

#if MICROPY_PY_BUILTINS_FLOAT
mp_float_t micropy_obj_int_as_float(struct _mp_state_ctx_t *mp_state, mp_obj_t self_in) {
    if (MP_OBJ_IS_SMALL_INT(self_in)) {
        return MP_OBJ_SMALL_INT_VALUE(self_in);
    } else {
        mp_obj_int_t *self = self_in;
        return self->val;
    }
}
#endif

#endif
/*
 * This file is part of the Micro Python project, http://micropython.org/
 *
 * The MIT License (MIT)
 *
 * Copyright (c) 2013, 2014 Damien P. George
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

#include <string.h>
#include <stdio.h>
#include <assert.h>

//#include "py/nlr.h"
//#include "py/parsenumbase.h"
//#include "py/smallint.h"
//#include "py/objint.h"
//#include "py/runtime0.h"
//#include "py/runtime.h"

#if MICROPY_PY_BUILTINS_FLOAT
#include <math.h>
#endif

#if MICROPY_LONGINT_IMPL == MICROPY_LONGINT_IMPL_MPZ

#if MICROPY_PY_SYS_MAXSIZE
// Export value for sys.maxsize
#undef DIG_MASK
#define DIG_MASK ((MPZ_LONG_1 << MPZ_DIG_SIZE) - 1)
STATIC const mpz_dig_t maxsize_dig[] = {
    #define NUM_DIG 1
    (MP_SSIZE_MAX >> MPZ_DIG_SIZE * 0) & DIG_MASK,
    #if (MP_SSIZE_MAX >> MPZ_DIG_SIZE * 0) > DIG_MASK
     #undef NUM_DIG
     #define NUM_DIG 2
     (MP_SSIZE_MAX >> MPZ_DIG_SIZE * 1) & DIG_MASK,
     #if (MP_SSIZE_MAX >> MPZ_DIG_SIZE * 1) > DIG_MASK
      #undef NUM_DIG
      #define NUM_DIG 3
      (MP_SSIZE_MAX >> MPZ_DIG_SIZE * 2) & DIG_MASK,
      #if (MP_SSIZE_MAX >> MPZ_DIG_SIZE * 2) > DIG_MASK
       #undef NUM_DIG
       #define NUM_DIG 4
       (MP_SSIZE_MAX >> MPZ_DIG_SIZE * 3) & DIG_MASK,
       #if (MP_SSIZE_MAX >> MPZ_DIG_SIZE * 3) > DIG_MASK
        #error cannot encode MP_SSIZE_MAX as mpz
       #endif
      #endif
     #endif
    #endif
};
const mp_obj_int_t mp_maxsize_obj = {
    {&mp_type_int},
    {.fixed_dig = 1, .len = NUM_DIG, .alloc = NUM_DIG, .dig = (mpz_dig_t*)maxsize_dig}
};
#undef DIG_MASK
#undef NUM_DIG
#endif

STATIC mp_obj_int_t *micropy_obj_int_new_mpz(struct _mp_state_ctx_t *mp_state) {
    mp_obj_int_t *o = micropy_m_new_obj(mp_state, mp_obj_int_t);
    o->base.type = &mp_type_int;
    micropy_mpz_init_zero(mp_state, &o->mpz);
    return o;
}

// This routine expects you to pass in a buffer and size (in *buf and buf_size).
// If, for some reason, this buffer is too small, then it will allocate a
// buffer and return the allocated buffer and size in *buf and *buf_size. It
// is the callers responsibility to free this allocated buffer.
//
// The resulting formatted string will be returned from this function and the
// formatted size will be in *fmt_size.
//
// This particular routine should only be called for the mpz representation of the int.
char *micropy_obj_int_formatted_impl(struct _mp_state_ctx_t *mp_state, char **buf, mp_uint_t *buf_size, mp_uint_t *fmt_size, mp_const_obj_t self_in,
                                int base, const char *prefix, char base_char, char comma) {
    assert(MP_OBJ_IS_TYPE(self_in, &mp_type_int));
    const mp_obj_int_t *self = MP_OBJ_TO_PTR(self_in);

    mp_uint_t needed_size = micropy_mpz_as_str_size(mp_state, &self->mpz, base, prefix, comma);
    if (needed_size > *buf_size) {
        *buf = micropy_m_new(mp_state, char, needed_size);
        *buf_size = needed_size;
    }
    char *str = *buf;

    *fmt_size = micropy_mpz_as_str_inpl(mp_state, &self->mpz, base, prefix, base_char, comma, str);

    return str;
}

void micropy_obj_int_to_bytes_impl(struct _mp_state_ctx_t *mp_state, mp_obj_t self_in, bool big_endian, mp_uint_t len, byte *buf) {
    assert(MP_OBJ_IS_TYPE(self_in, &mp_type_int));
    mp_obj_int_t *self = MP_OBJ_TO_PTR(self_in);
    micropy_mpz_as_bytes(mp_state, &self->mpz, big_endian, len, buf);
}

int micropy_obj_int_sign(struct _mp_state_ctx_t *mp_state, mp_obj_t self_in) {
    if (MP_OBJ_IS_SMALL_INT(self_in)) {
        mp_int_t val = MP_OBJ_SMALL_INT_VALUE(self_in);
        if (val < 0) {
            return -1;
        } else if (val > 0) {
            return 1;
        } else {
            return 0;
        }
    }
    mp_obj_int_t *self = MP_OBJ_TO_PTR(self_in);
    if (self->mpz.len == 0) {
        return 0;
    } else if (self->mpz.neg == 0) {
        return 1;
    } else {
        return -1;
    }
}

// This must handle int and bool types, and must raise a
// TypeError if the argument is not integral
mp_obj_t micropy_obj_int_abs(struct _mp_state_ctx_t *mp_state, mp_obj_t self_in) {
    if (MP_OBJ_IS_TYPE(self_in, &mp_type_int)) {
        mp_obj_int_t *self = MP_OBJ_TO_PTR(self_in);
        mp_obj_int_t *self2 = micropy_obj_int_new_mpz(mp_state);
        micropy_mpz_abs_inpl(mp_state, &self2->mpz, &self->mpz);
        return MP_OBJ_FROM_PTR(self2);
    } else {
        mp_int_t val = micropy_obj_get_int(mp_state, self_in);
        if (val == MP_SMALL_INT_MIN) {
            return micropy_obj_new_int_from_ll(mp_state, -val);
        } else {
            if (val < 0) {
                val = -val;
            }
            return MP_OBJ_NEW_SMALL_INT(val);
        }
    }
}

mp_obj_t micropy_obj_int_unary_op(struct _mp_state_ctx_t *mp_state, mp_uint_t op, mp_obj_t o_in) {
    mp_obj_int_t *o = MP_OBJ_TO_PTR(o_in);
    switch (op) {
        case MP_UNARY_OP_BOOL: return micropy_obj_new_bool(mp_state, !micropy_mpz_is_zero(mp_state, &o->mpz));
        case MP_UNARY_OP_HASH: return MP_OBJ_NEW_SMALL_INT(micropy_mpz_hash(mp_state, &o->mpz));
        case MP_UNARY_OP_POSITIVE: return o_in;
        case MP_UNARY_OP_NEGATIVE: { mp_obj_int_t *o2 = micropy_obj_int_new_mpz(mp_state); micropy_mpz_neg_inpl(mp_state, &o2->mpz, &o->mpz); return MP_OBJ_FROM_PTR(o2); }
        case MP_UNARY_OP_INVERT: { mp_obj_int_t *o2 = micropy_obj_int_new_mpz(mp_state); micropy_mpz_not_inpl(mp_state, &o2->mpz, &o->mpz); return MP_OBJ_FROM_PTR(o2); }
        default: return MP_OBJ_NULL; // op not supported
    }
}

mp_obj_t micropy_obj_int_binary_op(struct _mp_state_ctx_t *mp_state, mp_uint_t op, mp_obj_t lhs_in, mp_obj_t rhs_in) {
    const mpz_t *zlhs;
    const mpz_t *zrhs;
    mpz_t z_int;
    mpz_dig_t z_int_dig[MPZ_NUM_DIG_FOR_INT];

    // lhs could be a small int (eg small-int + mpz)
    if (MP_OBJ_IS_SMALL_INT(lhs_in)) {
        micropy_mpz_init_fixed_from_int(mp_state, &z_int, z_int_dig, MPZ_NUM_DIG_FOR_INT, MP_OBJ_SMALL_INT_VALUE(lhs_in));
        zlhs = &z_int;
    } else if (MP_OBJ_IS_TYPE(lhs_in, &mp_type_int)) {
        zlhs = &((mp_obj_int_t*)MP_OBJ_TO_PTR(lhs_in))->mpz;
    } else {
        // unsupported type
        return MP_OBJ_NULL;
    }

    // if rhs is small int, then lhs was not (otherwise mp_binary_op handles it)
    if (MP_OBJ_IS_SMALL_INT(rhs_in)) {
        micropy_mpz_init_fixed_from_int(mp_state, &z_int, z_int_dig, MPZ_NUM_DIG_FOR_INT, MP_OBJ_SMALL_INT_VALUE(rhs_in));
        zrhs = &z_int;
    } else if (MP_OBJ_IS_TYPE(rhs_in, &mp_type_int)) {
        zrhs = &((mp_obj_int_t*)MP_OBJ_TO_PTR(rhs_in))->mpz;
#if MICROPY_PY_BUILTINS_FLOAT
    } else if (micropy_obj_is_float(mp_state, rhs_in)) {
        return micropy_obj_float_binary_op(mp_state, op, micropy_mpz_as_float(mp_state, zlhs), rhs_in);
#if MICROPY_PY_BUILTINS_COMPLEX
    } else if (MP_OBJ_IS_TYPE(rhs_in, &mp_type_complex)) {
        return micropy_obj_complex_binary_op(mp_state, op, micropy_mpz_as_float(mp_state, zlhs), 0, rhs_in);
#endif
#endif
    } else {
        // delegate to generic function to check for extra cases
        return micropy_obj_int_binary_op_extra_cases(mp_state, op, lhs_in, rhs_in);
    }

    if (0) {
#if MICROPY_PY_BUILTINS_FLOAT
    } else if (op == MP_BINARY_OP_TRUE_DIVIDE || op == MP_BINARY_OP_INPLACE_TRUE_DIVIDE) {
        if (micropy_mpz_is_zero(mp_state, zrhs)) {
            goto zero_division_error;
        }
        mp_float_t flhs = micropy_mpz_as_float(mp_state, zlhs);
        mp_float_t frhs = micropy_mpz_as_float(mp_state, zrhs);
        return micropy_obj_new_float(mp_state, flhs / frhs);
#endif

    } else if (op <= MP_BINARY_OP_INPLACE_POWER) {
        mp_obj_int_t *res = micropy_obj_int_new_mpz(mp_state);

        switch (op) {
            case MP_BINARY_OP_ADD:
            case MP_BINARY_OP_INPLACE_ADD:
                micropy_mpz_add_inpl(mp_state, &res->mpz, zlhs, zrhs);
                break;
            case MP_BINARY_OP_SUBTRACT:
            case MP_BINARY_OP_INPLACE_SUBTRACT:
                micropy_mpz_sub_inpl(mp_state, &res->mpz, zlhs, zrhs);
                break;
            case MP_BINARY_OP_MULTIPLY:
            case MP_BINARY_OP_INPLACE_MULTIPLY:
                micropy_mpz_mul_inpl(mp_state, &res->mpz, zlhs, zrhs);
                break;
            case MP_BINARY_OP_FLOOR_DIVIDE:
            case MP_BINARY_OP_INPLACE_FLOOR_DIVIDE: {
                if (micropy_mpz_is_zero(mp_state, zrhs)) {
                    zero_division_error:
                    micropy_nlr_raise(mp_state, micropy_obj_new_exception_msg(mp_state, &mp_type_ZeroDivisionError,
                        "division by zero"));
                }
                mpz_t rem; micropy_mpz_init_zero(mp_state, &rem);
                micropy_mpz_divmod_inpl(mp_state, &res->mpz, &rem, zlhs, zrhs);
                micropy_mpz_deinit(mp_state, &rem);
                break;
            }
            case MP_BINARY_OP_MODULO:
            case MP_BINARY_OP_INPLACE_MODULO: {
                if (micropy_mpz_is_zero(mp_state, zrhs)) {
                    goto zero_division_error;
                }
                mpz_t quo; micropy_mpz_init_zero(mp_state, &quo);
                micropy_mpz_divmod_inpl(mp_state, &quo, &res->mpz, zlhs, zrhs);
                micropy_mpz_deinit(mp_state, &quo);
                break;
            }

            case MP_BINARY_OP_AND:
            case MP_BINARY_OP_INPLACE_AND:
                micropy_mpz_and_inpl(mp_state, &res->mpz, zlhs, zrhs);
                break;
            case MP_BINARY_OP_OR:
            case MP_BINARY_OP_INPLACE_OR:
                micropy_mpz_or_inpl(mp_state, &res->mpz, zlhs, zrhs);
                break;
            case MP_BINARY_OP_XOR:
            case MP_BINARY_OP_INPLACE_XOR:
                micropy_mpz_xor_inpl(mp_state, &res->mpz, zlhs, zrhs);
                break;

            case MP_BINARY_OP_LSHIFT:
            case MP_BINARY_OP_INPLACE_LSHIFT:
            case MP_BINARY_OP_RSHIFT:
            case MP_BINARY_OP_INPLACE_RSHIFT: {
                mp_int_t irhs = micropy_obj_int_get_checked(mp_state, rhs_in);
                if (irhs < 0) {
                    micropy_nlr_raise(mp_state, micropy_obj_new_exception_msg(mp_state, &mp_type_ValueError, "negative shift count"));
                }
                if (op == MP_BINARY_OP_LSHIFT || op == MP_BINARY_OP_INPLACE_LSHIFT) {
                    micropy_mpz_shl_inpl(mp_state, &res->mpz, zlhs, irhs);
                } else {
                    micropy_mpz_shr_inpl(mp_state, &res->mpz, zlhs, irhs);
                }
                break;
            }

            case MP_BINARY_OP_POWER:
            case MP_BINARY_OP_INPLACE_POWER:
                micropy_mpz_pow_inpl(mp_state, &res->mpz, zlhs, zrhs);
                break;

            case MP_BINARY_OP_DIVMOD: {
                if (micropy_mpz_is_zero(mp_state, zrhs)) {
                    goto zero_division_error;
                }
                mp_obj_int_t *quo = micropy_obj_int_new_mpz(mp_state);
                micropy_mpz_divmod_inpl(mp_state, &quo->mpz, &res->mpz, zlhs, zrhs);
                mp_obj_t tuple[2] = {MP_OBJ_FROM_PTR(quo), MP_OBJ_FROM_PTR(res)};
                return micropy_obj_new_tuple(mp_state, 2, tuple);
            }

            default:
                return MP_OBJ_NULL; // op not supported
        }

        return MP_OBJ_FROM_PTR(res);

    } else {
        int cmp = micropy_mpz_cmp(mp_state, zlhs, zrhs);
        switch (op) {
            case MP_BINARY_OP_LESS:
                return micropy_obj_new_bool(mp_state, cmp < 0);
            case MP_BINARY_OP_MORE:
                return micropy_obj_new_bool(mp_state, cmp > 0);
            case MP_BINARY_OP_LESS_EQUAL:
                return micropy_obj_new_bool(mp_state, cmp <= 0);
            case MP_BINARY_OP_MORE_EQUAL:
                return micropy_obj_new_bool(mp_state, cmp >= 0);
            case MP_BINARY_OP_EQUAL:
                return micropy_obj_new_bool(mp_state, cmp == 0);

            default:
                return MP_OBJ_NULL; // op not supported
        }
    }
}

mp_obj_t micropy_obj_new_int(struct _mp_state_ctx_t *mp_state, mp_int_t value) {
    if (MP_SMALL_INT_FITS(value)) {
        return MP_OBJ_NEW_SMALL_INT(value);
    }
    return micropy_obj_new_int_from_ll(mp_state, value);
}

mp_obj_t micropy_obj_new_int_from_ll(struct _mp_state_ctx_t *mp_state, long long val) {
    mp_obj_int_t *o = micropy_obj_int_new_mpz(mp_state);
    micropy_mpz_set_from_ll(mp_state, &o->mpz, val, true);
    return MP_OBJ_FROM_PTR(o);
}

mp_obj_t micropy_obj_new_int_from_ull(struct _mp_state_ctx_t *mp_state, unsigned long long val) {
    mp_obj_int_t *o = micropy_obj_int_new_mpz(mp_state);
    micropy_mpz_set_from_ll(mp_state, &o->mpz, val, false);
    return MP_OBJ_FROM_PTR(o);
}

mp_obj_t micropy_obj_new_int_from_uint(struct _mp_state_ctx_t *mp_state, mp_uint_t value) {
    // SMALL_INT accepts only signed numbers, so make sure the input
    // value fits completely in the small-int positive range.
    if ((value & ~MP_SMALL_INT_POSITIVE_MASK) == 0) {
        return MP_OBJ_NEW_SMALL_INT(value);
    }
    return micropy_obj_new_int_from_ull(mp_state, value);
}

#if MICROPY_PY_BUILTINS_FLOAT
mp_obj_t micropy_obj_new_int_from_float(struct _mp_state_ctx_t *mp_state, mp_float_t val) {
    int cl = fpclassify(val);
    if (cl == FP_INFINITE) {
        micropy_nlr_raise(mp_state, micropy_obj_new_exception_msg_varg(mp_state, &mp_type_OverflowError, "can't convert inf to int"));
    } else if (cl == FP_NAN) {
        micropy_nlr_raise(mp_state, micropy_obj_new_exception_msg_varg(mp_state, &mp_type_ValueError, "can't convert NaN to int"));
    } else {
        mp_fp_as_int_class_t icl = micropy_classify_fp_as_int(mp_state, val);
        if (icl == MP_FP_CLASS_FIT_SMALLINT) {
            return MP_OBJ_NEW_SMALL_INT((mp_int_t)val);
        } else {
            mp_obj_int_t *o = micropy_obj_int_new_mpz(mp_state);
            micropy_mpz_set_from_float(mp_state, &o->mpz, val);
            return MP_OBJ_FROM_PTR(o);
        }
    }
}
#endif

mp_obj_t micropy_obj_new_int_from_str_len(struct _mp_state_ctx_t *mp_state, const char **str, mp_uint_t len, bool neg, mp_uint_t base) {
    mp_obj_int_t *o = micropy_obj_int_new_mpz(mp_state);
    mp_uint_t n = micropy_mpz_set_from_str(mp_state, &o->mpz, *str, len, neg, base);
    *str += n;
    return MP_OBJ_FROM_PTR(o);
}

mp_int_t micropy_obj_int_get_truncated(struct _mp_state_ctx_t *mp_state, mp_const_obj_t self_in) {
    if (MP_OBJ_IS_SMALL_INT(self_in)) {
        return MP_OBJ_SMALL_INT_VALUE(self_in);
    } else {
        const mp_obj_int_t *self = MP_OBJ_TO_PTR(self_in);
        // hash returns actual int value if it fits in mp_int_t
        return micropy_mpz_hash(mp_state, &self->mpz);
    }
}

mp_int_t micropy_obj_int_get_checked(struct _mp_state_ctx_t *mp_state, mp_const_obj_t self_in) {
    if (MP_OBJ_IS_SMALL_INT(self_in)) {
        return MP_OBJ_SMALL_INT_VALUE(self_in);
    } else {
        const mp_obj_int_t *self = MP_OBJ_TO_PTR(self_in);
        mp_int_t value;
        if (micropy_mpz_as_int_checked(mp_state, &self->mpz, &value)) {
            return value;
        } else {
            // overflow
            micropy_nlr_raise(mp_state, micropy_obj_new_exception_msg(mp_state, &mp_type_OverflowError, "overflow converting long int to machine word"));
        }
    }
}

#if MICROPY_PY_BUILTINS_FLOAT
mp_float_t micropy_obj_int_as_float(struct _mp_state_ctx_t *mp_state, mp_obj_t self_in) {
    if (MP_OBJ_IS_SMALL_INT(self_in)) {
        return MP_OBJ_SMALL_INT_VALUE(self_in);
    } else {
        mp_obj_int_t *self = MP_OBJ_TO_PTR(self_in);
        return micropy_mpz_as_float(mp_state, &self->mpz);
    }
}
#endif

#endif
/*
 * This file is part of the Micro Python project, http://micropython.org/
 *
 * The MIT License (MIT)
 *
 * Copyright (c) 2013, 2014 Damien P. George
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

#include <string.h>
#include <assert.h>

//#include "py/nlr.h"
//#include "py/objlist.h"
//#include "py/runtime0.h"
//#include "py/runtime.h"
//#include "py/stackctrl.h"

STATIC mp_obj_t micropy_obj_new_list_iterator(struct _mp_state_ctx_t *mp_state, mp_obj_t list, mp_uint_t cur);
STATIC mp_obj_list_t *micropy_list_new(struct _mp_state_ctx_t *mp_state, mp_uint_t n);
STATIC mp_obj_t micropy_list_extend(struct _mp_state_ctx_t *mp_state, mp_obj_t self_in, mp_obj_t arg_in);
STATIC mp_obj_t micropy_list_pop(struct _mp_state_ctx_t *mp_state, size_t n_args, const mp_obj_t *args);

// TODO: Move to mpconfig.h
#define LIST_MIN_ALLOC 4

/******************************************************************************/
/* list                                                                       */

STATIC void micropy_list_print(struct _mp_state_ctx_t *mp_state, const mp_print_t *print, mp_obj_t o_in, mp_print_kind_t kind) {
    mp_obj_list_t *o = MP_OBJ_TO_PTR(o_in);
    if (!(MICROPY_PY_UJSON && kind == PRINT_JSON)) {
        kind = PRINT_REPR;
    }
    micropy_print_str(mp_state, print, "[");
    for (mp_uint_t i = 0; i < o->len; i++) {
        if (i > 0) {
            micropy_print_str(mp_state, print, ", ");
        }
        micropy_obj_print_helper(mp_state, print, o->items[i], kind);
    }
    micropy_print_str(mp_state, print, "]");
}

STATIC mp_obj_t micropy_list_extend_from_iter(struct _mp_state_ctx_t *mp_state, mp_obj_t list, mp_obj_t iterable) {
    mp_obj_t iter = micropy_getiter(mp_state, iterable);
    mp_obj_t item;
    while ((item = micropy_iternext(mp_state, iter)) != MP_OBJ_STOP_ITERATION) {
        micropy_obj_list_append(mp_state, list, item);
    }
    return list;
}

STATIC mp_obj_t micropy_list_make_new(struct _mp_state_ctx_t *mp_state, const mp_obj_type_t *type_in, size_t n_args, size_t n_kw, const mp_obj_t *args) {
    (void)type_in;
    micropy_arg_check_num(mp_state, n_args, n_kw, 0, 1, false);

    switch (n_args) {
        case 0:
            // return a new, empty list
            return micropy_obj_new_list(mp_state, 0, NULL);

        case 1:
        default: {
            // make list from iterable
            // TODO: optimize list/tuple
            mp_obj_t list = micropy_obj_new_list(mp_state, 0, NULL);
            return micropy_list_extend_from_iter(mp_state, list, args[0]);
        }
    }
}

// Don't pass MP_BINARY_OP_NOT_EQUAL here
STATIC bool micropy_list_cmp_helper(struct _mp_state_ctx_t *mp_state, mp_uint_t op, mp_obj_t self_in, mp_obj_t another_in) {
    assert(MP_OBJ_IS_TYPE(self_in, &mp_type_list));
    if (!MP_OBJ_IS_TYPE(another_in, &mp_type_list)) {
        return false;
    }
    mp_obj_list_t *self = MP_OBJ_TO_PTR(self_in);
    mp_obj_list_t *another = MP_OBJ_TO_PTR(another_in);

    return micropy_seq_cmp_objs(mp_state, op, self->items, self->len, another->items, another->len);
}

STATIC mp_obj_t micropy_list_unary_op(struct _mp_state_ctx_t *mp_state, mp_uint_t op, mp_obj_t self_in) {
    mp_obj_list_t *self = MP_OBJ_TO_PTR(self_in);
    switch (op) {
        case MP_UNARY_OP_BOOL: return micropy_obj_new_bool(mp_state, self->len != 0);
        case MP_UNARY_OP_LEN: return MP_OBJ_NEW_SMALL_INT(self->len);
        default: return MP_OBJ_NULL; // op not supported
    }
}

STATIC mp_obj_t micropy_list_binary_op(struct _mp_state_ctx_t *mp_state, mp_uint_t op, mp_obj_t lhs, mp_obj_t rhs) {
    mp_obj_list_t *o = MP_OBJ_TO_PTR(lhs);
    switch (op) {
        case MP_BINARY_OP_ADD: {
            if (!MP_OBJ_IS_TYPE(rhs, &mp_type_list)) {
                return MP_OBJ_NULL; // op not supported
            }
            mp_obj_list_t *p = MP_OBJ_TO_PTR(rhs);
            mp_obj_list_t *s = micropy_list_new(mp_state, o->len + p->len);
            micropy_seq_cat(mp_state, s->items, o->items, o->len, p->items, p->len, mp_obj_t);
            return MP_OBJ_FROM_PTR(s);
        }
        case MP_BINARY_OP_INPLACE_ADD: {
            micropy_list_extend(mp_state, lhs, rhs);
            return lhs;
        }
        case MP_BINARY_OP_MULTIPLY: {
            mp_int_t n;
            if (!micropy_obj_get_int_maybe(mp_state, rhs, &n)) {
                return MP_OBJ_NULL; // op not supported
            }
            if (n < 0) {
                n = 0;
            }
            mp_obj_list_t *s = micropy_list_new(mp_state, o->len * n);
            micropy_seq_multiply(mp_state, o->items, sizeof(*o->items), o->len, n, s->items);
            return MP_OBJ_FROM_PTR(s);
        }
        case MP_BINARY_OP_EQUAL:
        case MP_BINARY_OP_LESS:
        case MP_BINARY_OP_LESS_EQUAL:
        case MP_BINARY_OP_MORE:
        case MP_BINARY_OP_MORE_EQUAL:
            return micropy_obj_new_bool(mp_state, micropy_list_cmp_helper(mp_state, op, lhs, rhs));

        default:
            return MP_OBJ_NULL; // op not supported
    }
}

STATIC mp_obj_t micropy_list_subscr(struct _mp_state_ctx_t *mp_state, mp_obj_t self_in, mp_obj_t index, mp_obj_t value) {
    if (value == MP_OBJ_NULL) {
        // delete
#if MICROPY_PY_BUILTINS_SLICE
        if (MP_OBJ_IS_TYPE(index, &mp_type_slice)) {
            mp_obj_list_t *self = MP_OBJ_TO_PTR(self_in);
            mp_bound_slice_t slice;
            if (!micropy_seq_get_fast_slice_indexes(mp_state, self->len, index, &slice)) {
                assert(0);
            }

            mp_int_t len_adj = slice.start - slice.stop;
            //printf("Len adj: %d\n", len_adj);
            assert(len_adj <= 0);
            micropy_seq_replace_slice_no_grow(mp_state, self->items, self->len, slice.start, slice.stop, self->items/*NULL*/, 0, sizeof(*self->items));
            // Clear "freed" elements at the end of list
            micropy_seq_clear(mp_state, self->items, self->len + len_adj, self->len, sizeof(*self->items));
            self->len += len_adj;
            return mp_const_none;
        }
#endif
        mp_obj_t args[2] = {self_in, index};
        micropy_list_pop(mp_state, 2, args);
        return mp_const_none;
    } else if (value == MP_OBJ_SENTINEL) {
        // load
        mp_obj_list_t *self = MP_OBJ_TO_PTR(self_in);
#if MICROPY_PY_BUILTINS_SLICE
        if (MP_OBJ_IS_TYPE(index, &mp_type_slice)) {
            mp_bound_slice_t slice;
            if (!micropy_seq_get_fast_slice_indexes(mp_state, self->len, index, &slice)) {
                return micropy_seq_extract_slice(mp_state, self->len, self->items, &slice);
            }
            mp_obj_list_t *res = micropy_list_new(mp_state, slice.stop - slice.start);
            micropy_seq_copy(mp_state, res->items, self->items + slice.start, res->len, mp_obj_t);
            return MP_OBJ_FROM_PTR(res);
        }
#endif
        mp_uint_t index_val = micropy_get_index(mp_state, self->base.type, self->len, index, false);
        return self->items[index_val];
    } else {
#if MICROPY_PY_BUILTINS_SLICE
        if (MP_OBJ_IS_TYPE(index, &mp_type_slice)) {
            mp_obj_list_t *self = MP_OBJ_TO_PTR(self_in);
            assert(MP_OBJ_IS_TYPE(value, &mp_type_list));
            mp_obj_list_t *slice = MP_OBJ_TO_PTR(value);
            mp_bound_slice_t slice_out;
            if (!micropy_seq_get_fast_slice_indexes(mp_state, self->len, index, &slice_out)) {
                assert(0);
            }
            mp_int_t len_adj = slice->len - (slice_out.stop - slice_out.start);
            //printf("Len adj: %d\n", len_adj);
            if (len_adj > 0) {
                if (self->len + len_adj > self->alloc) {
                    // TODO: Might optimize memory copies here by checking if block can
                    // be grown inplace or not
                    self->items = micropy_m_renew(mp_state, mp_obj_t, self->items, self->alloc, self->len + len_adj);
                    self->alloc = self->len + len_adj;
                }
                micropy_seq_replace_slice_grow_inplace(mp_state, self->items, self->len,
                    slice_out.start, slice_out.stop, slice->items, slice->len, len_adj, sizeof(*self->items));
            } else {
                micropy_seq_replace_slice_no_grow(mp_state, self->items, self->len,
                    slice_out.start, slice_out.stop, slice->items, slice->len, sizeof(*self->items));
                // Clear "freed" elements at the end of list
                micropy_seq_clear(mp_state, self->items, self->len + len_adj, self->len, sizeof(*self->items));
                // TODO: apply allocation policy re: alloc_size
            }
            self->len += len_adj;
            return mp_const_none;
        }
#endif
        micropy_obj_list_store(mp_state, self_in, index, value);
        return mp_const_none;
    }
}

STATIC mp_obj_t micropy_list_getiter(struct _mp_state_ctx_t *mp_state, mp_obj_t o_in) {
    return micropy_obj_new_list_iterator(mp_state, o_in, 0);
}

mp_obj_t micropy_obj_list_append(struct _mp_state_ctx_t *mp_state, mp_obj_t self_in, mp_obj_t arg) {
    assert(MP_OBJ_IS_TYPE(self_in, &mp_type_list));
    mp_obj_list_t *self = MP_OBJ_TO_PTR(self_in);
    if (self->len >= self->alloc) {
        self->items = micropy_m_renew(mp_state, mp_obj_t, self->items, self->alloc, self->alloc * 2);
        self->alloc *= 2;
        micropy_seq_clear(mp_state, self->items, self->len + 1, self->alloc, sizeof(*self->items));
    }
    self->items[self->len++] = arg;
    return mp_const_none; // return None, as per CPython
}

STATIC mp_obj_t micropy_list_extend(struct _mp_state_ctx_t *mp_state, mp_obj_t self_in, mp_obj_t arg_in) {
    assert(MP_OBJ_IS_TYPE(self_in, &mp_type_list));
    if (MP_OBJ_IS_TYPE(arg_in, &mp_type_list)) {
        mp_obj_list_t *self = MP_OBJ_TO_PTR(self_in);
        mp_obj_list_t *arg = MP_OBJ_TO_PTR(arg_in);

        if (self->len + arg->len > self->alloc) {
            // TODO: use alloc policy for "4"
            self->items = micropy_m_renew(mp_state, mp_obj_t, self->items, self->alloc, self->len + arg->len + 4);
            self->alloc = self->len + arg->len + 4;
            micropy_seq_clear(mp_state, self->items, self->len + arg->len, self->alloc, sizeof(*self->items));
        }

        memcpy(self->items + self->len, arg->items, sizeof(mp_obj_t) * arg->len);
        self->len += arg->len;
    } else {
        micropy_list_extend_from_iter(mp_state, self_in, arg_in);
    }
    return mp_const_none; // return None, as per CPython
}

STATIC mp_obj_t micropy_list_pop(struct _mp_state_ctx_t *mp_state, size_t n_args, const mp_obj_t *args) {
    assert(1 <= n_args && n_args <= 2);
    assert(MP_OBJ_IS_TYPE(args[0], &mp_type_list));
    mp_obj_list_t *self = MP_OBJ_TO_PTR(args[0]);
    if (self->len == 0) {
        micropy_nlr_raise(mp_state, micropy_obj_new_exception_msg(mp_state, &mp_type_IndexError, "pop from empty list"));
    }
    mp_uint_t index = micropy_get_index(mp_state, self->base.type, self->len, n_args == 1 ? MP_OBJ_NEW_SMALL_INT(-1) : args[1], false);
    mp_obj_t ret = self->items[index];
    self->len -= 1;
    memmove(self->items + index, self->items + index + 1, (self->len - index) * sizeof(mp_obj_t));
    // Clear stale pointer from slot which just got freed to prevent GC issues
    self->items[self->len] = MP_OBJ_NULL;
    if (self->alloc > LIST_MIN_ALLOC && self->alloc > 2 * self->len) {
        self->items = micropy_m_renew(mp_state, mp_obj_t, self->items, self->alloc, self->alloc/2);
        self->alloc /= 2;
    }
    return ret;
}

STATIC void micropy_quicksort(struct _mp_state_ctx_t *mp_state, mp_obj_t *head, mp_obj_t *tail, mp_obj_t key_fn, mp_obj_t binop_less_result) {
    MP_STACK_CHECK();
    while (head < tail) {
        mp_obj_t *h = head - 1;
        mp_obj_t *t = tail;
        mp_obj_t v = key_fn == MP_OBJ_NULL ? tail[0] : micropy_call_function_1(mp_state, key_fn, tail[0]); // get pivot using key_fn
        for (;;) {
            do ++h; while (h < t && micropy_binary_op(mp_state, MP_BINARY_OP_LESS, key_fn == MP_OBJ_NULL ? h[0] : micropy_call_function_1(mp_state, key_fn, h[0]), v) == binop_less_result);
            do --t; while (h < t && micropy_binary_op(mp_state, MP_BINARY_OP_LESS, v, key_fn == MP_OBJ_NULL ? t[0] : micropy_call_function_1(mp_state, key_fn, t[0])) == binop_less_result);
            if (h >= t) break;
            mp_obj_t x = h[0];
            h[0] = t[0];
            t[0] = x;
        }
        mp_obj_t x = h[0];
        h[0] = tail[0];
        tail[0] = x;
        // do the smaller recursive call first, to keep stack within O(log(N))
        if (t - head < tail - h - 1) {
            micropy_quicksort(mp_state, head, t, key_fn, binop_less_result);
            head = h + 1;
        } else {
            micropy_quicksort(mp_state, h + 1, tail, key_fn, binop_less_result);
            tail = t;
        }
    }
}

// TODO Python defines sort to be stable but ours is not
mp_obj_t micropy_obj_list_sort(struct _mp_state_ctx_t *mp_state, size_t n_args, const mp_obj_t *pos_args, mp_map_t *kw_args) {
    static const mp_arg_t allowed_args[] = {
        { MP_QSTR_key, MP_ARG_KW_ONLY | MP_ARG_OBJ, {.u_rom_obj = MP_ROM_PTR(&mp_const_none_obj)} },
        { MP_QSTR_reverse, MP_ARG_KW_ONLY | MP_ARG_BOOL, {.u_bool = false} },
    };

    // parse args
    struct {
        mp_arg_val_t key, reverse;
    } args;
    micropy_arg_parse_all(mp_state, n_args - 1, pos_args + 1, kw_args,
        MP_ARRAY_SIZE(allowed_args), allowed_args, (mp_arg_val_t*)&args);

    assert(MP_OBJ_IS_TYPE(pos_args[0], &mp_type_list));
    mp_obj_list_t *self = MP_OBJ_TO_PTR(pos_args[0]);

    if (self->len > 1) {
        micropy_quicksort(mp_state, self->items, self->items + self->len - 1,
                     args.key.u_obj == mp_const_none ? MP_OBJ_NULL : args.key.u_obj,
                     args.reverse.u_bool ? mp_const_false : mp_const_true);
    }

    return mp_const_none;
}

STATIC mp_obj_t micropy_list_clear(struct _mp_state_ctx_t *mp_state, mp_obj_t self_in) {
    assert(MP_OBJ_IS_TYPE(self_in, &mp_type_list));
    mp_obj_list_t *self = MP_OBJ_TO_PTR(self_in);
    self->len = 0;
    self->items = micropy_m_renew(mp_state, mp_obj_t, self->items, self->alloc, LIST_MIN_ALLOC);
    self->alloc = LIST_MIN_ALLOC;
    micropy_seq_clear(mp_state, self->items, 0, self->alloc, sizeof(*self->items));
    return mp_const_none;
}

STATIC mp_obj_t micropy_list_copy(struct _mp_state_ctx_t *mp_state, mp_obj_t self_in) {
    assert(MP_OBJ_IS_TYPE(self_in, &mp_type_list));
    mp_obj_list_t *self = MP_OBJ_TO_PTR(self_in);
    return micropy_obj_new_list(mp_state, self->len, self->items);
}

STATIC mp_obj_t micropy_list_count(struct _mp_state_ctx_t *mp_state, mp_obj_t self_in, mp_obj_t value) {
    assert(MP_OBJ_IS_TYPE(self_in, &mp_type_list));
    mp_obj_list_t *self = MP_OBJ_TO_PTR(self_in);
    return micropy_seq_count_obj(mp_state, self->items, self->len, value);
}

STATIC mp_obj_t micropy_list_index(struct _mp_state_ctx_t *mp_state, size_t n_args, const mp_obj_t *args) {
    assert(2 <= n_args && n_args <= 4);
    assert(MP_OBJ_IS_TYPE(args[0], &mp_type_list));
    mp_obj_list_t *self = MP_OBJ_TO_PTR(args[0]);
    return micropy_seq_index_obj(mp_state, self->items, self->len, n_args, args);
}

STATIC mp_obj_t micropy_list_insert(struct _mp_state_ctx_t *mp_state, mp_obj_t self_in, mp_obj_t idx, mp_obj_t obj) {
    assert(MP_OBJ_IS_TYPE(self_in, &mp_type_list));
    mp_obj_list_t *self = MP_OBJ_TO_PTR(self_in);
    // insert has its own strange index logic
    mp_int_t index = MP_OBJ_SMALL_INT_VALUE(idx);
    if (index < 0) {
         index += self->len;
    }
    if (index < 0) {
         index = 0;
    }
    if ((mp_uint_t)index > self->len) {
         index = self->len;
    }

    micropy_obj_list_append(mp_state, self_in, mp_const_none);

    for (mp_int_t i = self->len-1; i > index; i--) {
         self->items[i] = self->items[i-1];
    }
    self->items[index] = obj;

    return mp_const_none;
}

mp_obj_t micropy_obj_list_remove(struct _mp_state_ctx_t *mp_state, mp_obj_t self_in, mp_obj_t value) {
    assert(MP_OBJ_IS_TYPE(self_in, &mp_type_list));
    mp_obj_t args[] = {self_in, value};
    args[1] = micropy_list_index(mp_state, 2, args);
    micropy_list_pop(mp_state, 2, args);

    return mp_const_none;
}

STATIC mp_obj_t micropy_list_reverse(struct _mp_state_ctx_t *mp_state, mp_obj_t self_in) {
    assert(MP_OBJ_IS_TYPE(self_in, &mp_type_list));
    mp_obj_list_t *self = MP_OBJ_TO_PTR(self_in);

    mp_int_t len = self->len;
    for (mp_int_t i = 0; i < len/2; i++) {
         mp_obj_t a = self->items[i];
         self->items[i] = self->items[len-i-1];
         self->items[len-i-1] = a;
    }

    return mp_const_none;
}

STATIC MP_DEFINE_CONST_FUN_OBJ_2(list_append_obj, micropy_obj_list_append);
STATIC MP_DEFINE_CONST_FUN_OBJ_2(list_extend_obj, micropy_list_extend);
STATIC MP_DEFINE_CONST_FUN_OBJ_1(list_clear_obj, micropy_list_clear);
STATIC MP_DEFINE_CONST_FUN_OBJ_1(list_copy_obj, micropy_list_copy);
STATIC MP_DEFINE_CONST_FUN_OBJ_2(list_count_obj, micropy_list_count);
STATIC MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(list_index_obj, 2, 4, micropy_list_index);
STATIC MP_DEFINE_CONST_FUN_OBJ_3(list_insert_obj, micropy_list_insert);
STATIC MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(list_pop_obj, 1, 2, micropy_list_pop);
STATIC MP_DEFINE_CONST_FUN_OBJ_2(list_remove_obj, micropy_obj_list_remove);
STATIC MP_DEFINE_CONST_FUN_OBJ_1(list_reverse_obj, micropy_list_reverse);
STATIC MP_DEFINE_CONST_FUN_OBJ_KW(list_sort_obj, 1, micropy_obj_list_sort);

STATIC const mp_rom_map_elem_t list_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_append), MP_ROM_PTR(&list_append_obj) },
    { MP_ROM_QSTR(MP_QSTR_clear), MP_ROM_PTR(&list_clear_obj) },
    { MP_ROM_QSTR(MP_QSTR_copy), MP_ROM_PTR(&list_copy_obj) },
    { MP_ROM_QSTR(MP_QSTR_count), MP_ROM_PTR(&list_count_obj) },
    { MP_ROM_QSTR(MP_QSTR_extend), MP_ROM_PTR(&list_extend_obj) },
    { MP_ROM_QSTR(MP_QSTR_index), MP_ROM_PTR(&list_index_obj) },
    { MP_ROM_QSTR(MP_QSTR_insert), MP_ROM_PTR(&list_insert_obj) },
    { MP_ROM_QSTR(MP_QSTR_pop), MP_ROM_PTR(&list_pop_obj) },
    { MP_ROM_QSTR(MP_QSTR_remove), MP_ROM_PTR(&list_remove_obj) },
    { MP_ROM_QSTR(MP_QSTR_reverse), MP_ROM_PTR(&list_reverse_obj) },
    { MP_ROM_QSTR(MP_QSTR_sort), MP_ROM_PTR(&list_sort_obj) },
};

STATIC MP_DEFINE_CONST_DICT(list_locals_dict, list_locals_dict_table);

const mp_obj_type_t mp_type_list = {
    { &mp_type_type },
    .name = MP_QSTR_list,
    .print = micropy_list_print,
    .make_new = micropy_list_make_new,
    .unary_op = micropy_list_unary_op,
    .binary_op = micropy_list_binary_op,
    .subscr = micropy_list_subscr,
    .getiter = micropy_list_getiter,
    .locals_dict = (mp_obj_dict_t*)&list_locals_dict,
};

void micropy_obj_list_init(struct _mp_state_ctx_t *mp_state, mp_obj_list_t *o, mp_uint_t n) {
    o->base.type = &mp_type_list;
    o->alloc = n < LIST_MIN_ALLOC ? LIST_MIN_ALLOC : n;
    o->len = n;
    o->items = micropy_m_new(mp_state, mp_obj_t, o->alloc);
    micropy_seq_clear(mp_state, o->items, n, o->alloc, sizeof(*o->items));
}

STATIC mp_obj_list_t *micropy_list_new(struct _mp_state_ctx_t *mp_state, mp_uint_t n) {
    mp_obj_list_t *o = micropy_m_new_obj(mp_state, mp_obj_list_t);
    micropy_obj_list_init(mp_state, o, n);
    return o;
}

mp_obj_t micropy_obj_new_list(struct _mp_state_ctx_t *mp_state, mp_uint_t n, mp_obj_t *items) {
    mp_obj_list_t *o = micropy_list_new(mp_state, n);
    if (items != NULL) {
        for (mp_uint_t i = 0; i < n; i++) {
            o->items[i] = items[i];
        }
    }
    return MP_OBJ_FROM_PTR(o);
}

void micropy_obj_list_get(struct _mp_state_ctx_t *mp_state, mp_obj_t self_in, mp_uint_t *len, mp_obj_t **items) {
    mp_obj_list_t *self = MP_OBJ_TO_PTR(self_in);
    *len = self->len;
    *items = self->items;
}

void micropy_obj_list_set_len(struct _mp_state_ctx_t *mp_state, mp_obj_t self_in, mp_uint_t len) {
    // trust that the caller knows what it's doing
    // TODO realloc if len got much smaller than alloc
    mp_obj_list_t *self = MP_OBJ_TO_PTR(self_in);
    self->len = len;
}

void micropy_obj_list_store(struct _mp_state_ctx_t *mp_state, mp_obj_t self_in, mp_obj_t index, mp_obj_t value) {
    mp_obj_list_t *self = MP_OBJ_TO_PTR(self_in);
    mp_uint_t i = micropy_get_index(mp_state, self->base.type, self->len, index, false);
    self->items[i] = value;
}

/******************************************************************************/
/* list iterator                                                              */

typedef struct _mp_obj_list_it_t {
    mp_obj_base_t base;
    mp_fun_1_t iternext;
    mp_obj_t list;
    mp_uint_t cur;
} mp_obj_list_it_t;

STATIC mp_obj_t micropy_list_it_iternext(struct _mp_state_ctx_t *mp_state, mp_obj_t self_in) {
    mp_obj_list_it_t *self = MP_OBJ_TO_PTR(self_in);
    mp_obj_list_t *list = MP_OBJ_TO_PTR(self->list);
    if (self->cur < list->len) {
        mp_obj_t o_out = list->items[self->cur];
        self->cur += 1;
        return o_out;
    } else {
        return MP_OBJ_STOP_ITERATION;
    }
}

mp_obj_t micropy_obj_new_list_iterator(struct _mp_state_ctx_t *mp_state, mp_obj_t list, mp_uint_t cur) {
    mp_obj_list_it_t *o = micropy_m_new_obj(mp_state, mp_obj_list_it_t);
    o->base.type = &mp_type_polymorph_iter;
    o->iternext = micropy_list_it_iternext;
    o->list = list;
    o->cur = cur;
    return MP_OBJ_FROM_PTR(o);
}
/*
 * This file is part of the Micro Python project, http://micropython.org/
 *
 * The MIT License (MIT)
 *
 * Copyright (c) 2013, 2014 Damien P. George
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

#include <stdlib.h>
#include <assert.h>

//#include "py/runtime.h"

typedef struct _mp_obj_map_t {
    mp_obj_base_t base;
    mp_uint_t n_iters;
    mp_obj_t fun;
    mp_obj_t iters[];
} mp_obj_map_t;

STATIC mp_obj_t micropy_map_make_new(struct _mp_state_ctx_t *mp_state, const mp_obj_type_t *type, size_t n_args, size_t n_kw, const mp_obj_t *args) {
    micropy_arg_check_num(mp_state, n_args, n_kw, 2, MP_OBJ_FUN_ARGS_MAX, false);
    mp_obj_map_t *o = micropy_m_new_obj_var(mp_state, mp_obj_map_t, mp_obj_t, n_args - 1);
    o->base.type = type;
    o->n_iters = n_args - 1;
    o->fun = args[0];
    for (mp_uint_t i = 0; i < n_args - 1; i++) {
        o->iters[i] = micropy_getiter(mp_state, args[i + 1]);
    }
    return MP_OBJ_FROM_PTR(o);
}

STATIC mp_obj_t micropy_map_iternext(struct _mp_state_ctx_t *mp_state, mp_obj_t self_in) {
    assert(MP_OBJ_IS_TYPE(self_in, &mp_type_map));
    mp_obj_map_t *self = MP_OBJ_TO_PTR(self_in);
    mp_obj_t *nextses = micropy_m_new(mp_state, mp_obj_t, self->n_iters);

    for (mp_uint_t i = 0; i < self->n_iters; i++) {
        mp_obj_t next = micropy_iternext(mp_state, self->iters[i]);
        if (next == MP_OBJ_STOP_ITERATION) {
            micropy_m_del(mp_state, mp_obj_t, nextses, self->n_iters);
            return MP_OBJ_STOP_ITERATION;
        }
        nextses[i] = next;
    }
    return micropy_call_function_n_kw(mp_state, self->fun, self->n_iters, 0, nextses);
}

const mp_obj_type_t mp_type_map = {
    { &mp_type_type },
    .name = MP_QSTR_map,
    .make_new = micropy_map_make_new,
    .getiter = micropy_identity,
    .iternext = micropy_map_iternext,
};
/*
 * This file is part of the Micro Python project, http://micropython.org/
 *
 * The MIT License (MIT)
 *
 * Copyright (c) 2013, 2014 Damien P. George
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

#include <stdlib.h>
#include <assert.h>

//#include "py/mpstate.h"
//#include "py/nlr.h"
//#include "py/objmodule.h"
//#include "py/runtime.h"
//#include "py/builtin.h"

STATIC void micropy_module_print(struct _mp_state_ctx_t *mp_state, const mp_print_t *print, mp_obj_t self_in, mp_print_kind_t kind) {
    (void)kind;
    mp_obj_module_t *self = MP_OBJ_TO_PTR(self_in);

#if MICROPY_PY___FILE__
    // If we store __file__ to imported modules then try to lookup this
    // symbol to give more information about the module.
    mp_map_elem_t *elem = micropy_map_lookup(mp_state, &self->globals->map, MP_OBJ_NEW_QSTR(MP_QSTR___file__), MP_MAP_LOOKUP);
    if (elem != NULL) {
        micropy_printf(mp_state, print, "<module '%q' from '%s'>", self->name, micropy_obj_str_get_str(mp_state, elem->value));
        return;
    }
#endif

    micropy_printf(mp_state, print, "<module '%q'>", self->name);
}

STATIC void micropy_module_attr(struct _mp_state_ctx_t *mp_state, mp_obj_t self_in, qstr attr, mp_obj_t *dest) {
    mp_obj_module_t *self = MP_OBJ_TO_PTR(self_in);
    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        mp_map_elem_t *elem = micropy_map_lookup(mp_state, &self->globals->map, MP_OBJ_NEW_QSTR(attr), MP_MAP_LOOKUP);
        if (elem != NULL) {
            dest[0] = elem->value;
        }
    } else {
        // delete/store attribute
        mp_obj_dict_t *dict = self->globals;
        if (dict->map.is_fixed) {
            #if MICROPY_CAN_OVERRIDE_BUILTINS
            if (dict == &mp_module_builtins_globals) {
                if ((mp_state)->vm.mp_module_builtins_override_dict == NULL) {
                    (mp_state)->vm.mp_module_builtins_override_dict = MP_OBJ_TO_PTR(micropy_obj_new_dict(mp_state, 1));
                }
                dict = (mp_state)->vm.mp_module_builtins_override_dict;
            } else
            #endif
            {
                // can't delete or store to fixed map
                return;
            }
        }
        if (dest[1] == MP_OBJ_NULL) {
            // delete attribute
            micropy_obj_dict_delete(mp_state, MP_OBJ_FROM_PTR(dict), MP_OBJ_NEW_QSTR(attr));
        } else {
            // store attribute
            // TODO CPython allows STORE_ATTR to a module, but is this the correct implementation?
            micropy_obj_dict_store(mp_state, MP_OBJ_FROM_PTR(dict), MP_OBJ_NEW_QSTR(attr), dest[1]);
        }
        dest[0] = MP_OBJ_NULL; // indicate success
    }
}

const mp_obj_type_t mp_type_module = {
    { &mp_type_type },
    .name = MP_QSTR_module,
    .print = micropy_module_print,
    .attr = micropy_module_attr,
};

mp_obj_t micropy_obj_new_module(struct _mp_state_ctx_t *mp_state, qstr module_name) {
    mp_map_t *mp_loaded_modules_map = &(mp_state)->vm.mp_loaded_modules_dict.map;
    mp_map_elem_t *el = micropy_map_lookup(mp_state, mp_loaded_modules_map, MP_OBJ_NEW_QSTR(module_name), MP_MAP_LOOKUP_ADD_IF_NOT_FOUND);
    // We could error out if module already exists, but let C extensions
    // add new members to existing modules.
    if (el->value != MP_OBJ_NULL) {
        return el->value;
    }

    // create new module object
    mp_obj_module_t *o = micropy_m_new_obj(mp_state, mp_obj_module_t);
    o->base.type = &mp_type_module;
    o->name = module_name;
    o->globals = MP_OBJ_TO_PTR(micropy_obj_new_dict(mp_state, MICROPY_MODULE_DICT_SIZE));

    // store __name__ entry in the module
    micropy_obj_dict_store(mp_state, MP_OBJ_FROM_PTR(o->globals), MP_OBJ_NEW_QSTR(MP_QSTR___name__), MP_OBJ_NEW_QSTR(module_name));

    // store the new module into the slot in the global dict holding all modules
    el->value = MP_OBJ_FROM_PTR(o);

    // return the new module
    return MP_OBJ_FROM_PTR(o);
}

mp_obj_dict_t *micropy_obj_module_get_globals(struct _mp_state_ctx_t *mp_state, mp_obj_t self_in) {
    assert(MP_OBJ_IS_TYPE(self_in, &mp_type_module));
    mp_obj_module_t *self = MP_OBJ_TO_PTR(self_in);
    return self->globals;
}

/******************************************************************************/
// Global module table and related functions

STATIC const mp_rom_map_elem_t mp_builtin_module_table[] = {
    { MP_ROM_QSTR(MP_QSTR___main__), MP_ROM_PTR(&mp_module___main__) },
    { MP_ROM_QSTR(MP_QSTR_builtins), MP_ROM_PTR(&mp_module_builtins) },
    { MP_ROM_QSTR(MP_QSTR_micropython), MP_ROM_PTR(&mp_module_micropython) },

#if MICROPY_PY_ARRAY
    { MP_ROM_QSTR(MP_QSTR_array), MP_ROM_PTR(&mp_module_array) },
#endif
#if MICROPY_PY_IO
    { MP_ROM_QSTR(MP_QSTR_uio), MP_ROM_PTR(&mp_module_io) },
#endif
#if MICROPY_PY_COLLECTIONS
    { MP_ROM_QSTR(MP_QSTR_ucollections), MP_ROM_PTR(&mp_module_collections) },
#endif
#if MICROPY_PY_STRUCT
    { MP_ROM_QSTR(MP_QSTR_ustruct), MP_ROM_PTR(&mp_module_ustruct) },
#endif

#if MICROPY_PY_BUILTINS_FLOAT
#if MICROPY_PY_MATH
    { MP_ROM_QSTR(MP_QSTR_math), MP_ROM_PTR(&mp_module_math) },
#endif
#if MICROPY_PY_BUILTINS_COMPLEX && MICROPY_PY_CMATH
    { MP_ROM_QSTR(MP_QSTR_cmath), MP_ROM_PTR(&mp_module_cmath) },
#endif
#endif
#if MICROPY_PY_SYS
    { MP_ROM_QSTR(MP_QSTR_sys), MP_ROM_PTR(&mp_module_sys) },
#endif
#if MICROPY_PY_GC && MICROPY_ENABLE_GC
    { MP_ROM_QSTR(MP_QSTR_gc), MP_ROM_PTR(&mp_module_gc) },
#endif

    // extmod modules

#if MICROPY_PY_UERRNO
    { MP_ROM_QSTR(MP_QSTR_uerrno), MP_ROM_PTR(&mp_module_uerrno) },
#endif
#if MICROPY_PY_UCTYPES
    { MP_ROM_QSTR(MP_QSTR_uctypes), MP_ROM_PTR(&mp_module_uctypes) },
#endif
#if MICROPY_PY_UZLIB
    { MP_ROM_QSTR(MP_QSTR_uzlib), MP_ROM_PTR(&mp_module_uzlib) },
#endif
#if MICROPY_PY_UJSON
    { MP_ROM_QSTR(MP_QSTR_ujson), MP_ROM_PTR(&mp_module_ujson) },
#endif
#if MICROPY_PY_URE
    { MP_ROM_QSTR(MP_QSTR_ure), MP_ROM_PTR(&mp_module_ure) },
#endif
#if MICROPY_PY_UHEAPQ
    { MP_ROM_QSTR(MP_QSTR_uheapq), MP_ROM_PTR(&mp_module_uheapq) },
#endif
#if MICROPY_PY_UHASHLIB
    { MP_ROM_QSTR(MP_QSTR_uhashlib), MP_ROM_PTR(&mp_module_uhashlib) },
#endif
#if MICROPY_PY_UBINASCII
    { MP_ROM_QSTR(MP_QSTR_ubinascii), MP_ROM_PTR(&mp_module_ubinascii) },
#endif
#if MICROPY_PY_UCRYPTO
    { MP_ROM_QSTR(MP_QSTR_ucrypto), MP_ROM_PTR(&mp_module_ucrypto) },
#endif
#if MICROPY_PY_URANDOM
    { MP_ROM_QSTR(MP_QSTR_urandom), MP_ROM_PTR(&mp_module_urandom) },
#endif
#if MICROPY_PY_USSL
    { MP_ROM_QSTR(MP_QSTR_ussl), MP_ROM_PTR(&mp_module_ussl) },
#endif
#if MICROPY_PY_LWIP
    { MP_ROM_QSTR(MP_QSTR_lwip), MP_ROM_PTR(&mp_module_lwip) },
#endif
#if MICROPY_PY_WEBSOCKET
    { MP_ROM_QSTR(MP_QSTR_websocket), MP_ROM_PTR(&mp_module_websocket) },
#endif
#if MICROPY_PY_WEBREPL
    { MP_ROM_QSTR(MP_QSTR__webrepl), MP_ROM_PTR(&mp_module_webrepl) },
#endif
#if MICROPY_PY_FRAMEBUF
    { MP_ROM_QSTR(MP_QSTR_framebuf), MP_ROM_PTR(&mp_module_framebuf) },
#endif

    // extra builtin modules as defined by a port
    MICROPY_PORT_BUILTIN_MODULES
};

STATIC MP_DEFINE_CONST_MAP(mp_builtin_module_map, mp_builtin_module_table);

void micropy_module_init(struct _mp_state_ctx_t *mp_state) {
    micropy_obj_dict_init(mp_state, &(mp_state)->vm.mp_loaded_modules_dict, 3);
}

void micropy_module_deinit(struct _mp_state_ctx_t *mp_state) {
    //mp_map_deinit(&MP_STATE_VM(mp_loaded_modules_map));
}

// returns MP_OBJ_NULL if not found
mp_obj_t micropy_module_get(struct _mp_state_ctx_t *mp_state, qstr module_name) {
    mp_map_t *mp_loaded_modules_map = &(mp_state)->vm.mp_loaded_modules_dict.map;
    // lookup module
    mp_map_elem_t *el = micropy_map_lookup(mp_state, mp_loaded_modules_map, MP_OBJ_NEW_QSTR(module_name), MP_MAP_LOOKUP);

    if (el == NULL) {
        // module not found, look for builtin module names
        el = micropy_map_lookup(mp_state, (mp_map_t*)&mp_builtin_module_map, MP_OBJ_NEW_QSTR(module_name), MP_MAP_LOOKUP);
        if (el == NULL) {
            return MP_OBJ_NULL;
        }

        if (MICROPY_MODULE_BUILTIN_INIT) {
            // look for __init__ and call it if it exists
            mp_obj_t dest[2];
            micropy_load_method_maybe(mp_state, el->value, MP_QSTR___init__, dest);
            if (dest[0] != MP_OBJ_NULL) {
                micropy_call_method_n_kw(mp_state, 0, 0, dest);
                // register module so __init__ is not called again
                micropy_module_register(mp_state, module_name, el->value);
            }
        }
    }

    // module found, return it
    return el->value;
}

void micropy_module_register(struct _mp_state_ctx_t *mp_state, qstr qst, mp_obj_t module) {
    mp_map_t *mp_loaded_modules_map = &(mp_state)->vm.mp_loaded_modules_dict.map;
    micropy_map_lookup(mp_state, mp_loaded_modules_map, MP_OBJ_NEW_QSTR(qst), MP_MAP_LOOKUP_ADD_IF_NOT_FOUND)->value = module;
}
/*
 * This file is part of the Micro Python project, http://micropython.org/
 *
 * The MIT License (MIT)
 *
 * Copyright (c) 2013, 2014 Damien P. George
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

#include <stdlib.h>

//#include "py/objtype.h"
//#include "py/runtime.h"

typedef struct _mp_obj_object_t {
    mp_obj_base_t base;
} mp_obj_object_t;

STATIC mp_obj_t micropy_object_make_new(struct _mp_state_ctx_t *mp_state, const mp_obj_type_t *type, size_t n_args, size_t n_kw, const mp_obj_t *args) {
    (void)args;
    micropy_arg_check_num(mp_state, n_args, n_kw, 0, 0, false);
    mp_obj_object_t *o = micropy_m_new_obj(mp_state, mp_obj_object_t);
    o->base.type = type;
    return MP_OBJ_FROM_PTR(o);
}

#if MICROPY_CPYTHON_COMPAT
STATIC mp_obj_t micropy_object___init__(struct _mp_state_ctx_t *mp_state, mp_obj_t self) {
    (void)self;
    return mp_const_none;
}
STATIC MP_DEFINE_CONST_FUN_OBJ_1(object___init___obj, micropy_object___init__);

STATIC mp_obj_t micropy_object___new__(struct _mp_state_ctx_t *mp_state, mp_obj_t cls) {
    if (!MP_OBJ_IS_TYPE(cls, &mp_type_type) || !micropy_obj_is_instance_type(mp_state, (mp_obj_type_t*)MP_OBJ_TO_PTR(cls))) {
        micropy_nlr_raise(mp_state, micropy_obj_new_exception_msg(mp_state, &mp_type_TypeError,
                    "__new__ arg must be a user-type"));
    }
    mp_obj_t o = MP_OBJ_SENTINEL;
    mp_obj_t res = micropy_obj_instance_make_new(mp_state, MP_OBJ_TO_PTR(cls), 1, 0, &o);
    return res;
}
STATIC MP_DEFINE_CONST_FUN_OBJ_1(object___new___fun_obj, micropy_object___new__);
STATIC MP_DEFINE_CONST_STATICMETHOD_OBJ(object___new___obj, MP_ROM_PTR(&object___new___fun_obj));

STATIC const mp_rom_map_elem_t object_locals_dict_table[] = {
    #if MICROPY_CPYTHON_COMPAT
    { MP_ROM_QSTR(MP_QSTR___init__), MP_ROM_PTR(&object___init___obj) },
    #endif
    #if MICROPY_CPYTHON_COMPAT
    { MP_ROM_QSTR(MP_QSTR___new__), MP_ROM_PTR(&object___new___obj) },
    #endif
};

STATIC MP_DEFINE_CONST_DICT(object_locals_dict, object_locals_dict_table);
#endif

const mp_obj_type_t mp_type_object = {
    { &mp_type_type },
    .name = MP_QSTR_object,
    .make_new = micropy_object_make_new,
    #if MICROPY_CPYTHON_COMPAT
    .locals_dict = (mp_obj_dict_t*)&object_locals_dict,
    #endif
};
/*
 * This file is part of the MicroPython project, http://micropython.org/
 *
 * The MIT License (MIT)
 *
 * Copyright (c) 2015 Paul Sokolovsky
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

#include <stdlib.h>

//#include "py/nlr.h"
//#include "py/runtime.h"

// This is universal iterator type which calls "iternext" method stored in
// particular object instance. (So, each instance of this time can have its
// own iteration behavior.) Having this type saves to define type objects
// for various internal iterator objects.

// Any instance should have these 2 fields at the beginning
typedef struct _mp_obj_polymorph_iter_t {
    mp_obj_base_t base;
    mp_fun_1_t iternext;
} mp_obj_polymorph_iter_t;

STATIC mp_obj_t micropy_polymorph_it_iternext(struct _mp_state_ctx_t *mp_state, mp_obj_t self_in) {
    mp_obj_polymorph_iter_t *self = MP_OBJ_TO_PTR(self_in);
    // Redirect call to object instance's iternext method
    return self->iternext(mp_state, self_in);
}

const mp_obj_type_t mp_type_polymorph_iter = {
    { &mp_type_type },
    .name = MP_QSTR_iterator,
    .getiter = micropy_identity,
    .iternext = micropy_polymorph_it_iternext,
};
/*
 * This file is part of the Micro Python project, http://micropython.org/
 *
 * The MIT License (MIT)
 *
 * Copyright (c) 2013, 2014 Damien P. George
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

#include <stdlib.h>
#include <assert.h>

//#include "py/nlr.h"
//#include "py/runtime.h"

#if MICROPY_PY_BUILTINS_PROPERTY

typedef struct _mp_obj_property_t {
    mp_obj_base_t base;
    mp_obj_t proxy[3]; // getter, setter, deleter
} mp_obj_property_t;

STATIC mp_obj_t micropy_property_make_new(struct _mp_state_ctx_t *mp_state, const mp_obj_type_t *type, size_t n_args, size_t n_kw, const mp_obj_t *args) {
    enum { ARG_fget, ARG_fset, ARG_fdel, ARG_doc };
    static const mp_arg_t allowed_args[] = {
        { MP_QSTR_, MP_ARG_OBJ, {.u_rom_obj = MP_ROM_PTR(&mp_const_none_obj)} },
        { MP_QSTR_, MP_ARG_OBJ, {.u_rom_obj = MP_ROM_PTR(&mp_const_none_obj)} },
        { MP_QSTR_, MP_ARG_OBJ, {.u_rom_obj = MP_ROM_PTR(&mp_const_none_obj)} },
        { MP_QSTR_doc, MP_ARG_OBJ, {.u_rom_obj = MP_ROM_PTR(&mp_const_none_obj)} },
    };
    mp_arg_val_t vals[MP_ARRAY_SIZE(allowed_args)];
    micropy_arg_parse_all_kw_array(mp_state, n_args, n_kw, args, MP_ARRAY_SIZE(allowed_args), allowed_args, vals);

    mp_obj_property_t *o = micropy_m_new_obj(mp_state, mp_obj_property_t);
    o->base.type = type;
    o->proxy[0] = vals[ARG_fget].u_obj;
    o->proxy[1] = vals[ARG_fset].u_obj;
    o->proxy[2] = vals[ARG_fdel].u_obj;
    // vals[ARG_doc] is silently discarded
    return MP_OBJ_FROM_PTR(o);
}

STATIC mp_obj_t micropy_property_getter(struct _mp_state_ctx_t *mp_state, mp_obj_t self_in, mp_obj_t getter) {
    mp_obj_property_t *p2 = micropy_m_new_obj(mp_state, mp_obj_property_t);
    *p2 = *(mp_obj_property_t*)MP_OBJ_TO_PTR(self_in);
    p2->proxy[0] = getter;
    return MP_OBJ_FROM_PTR(p2);
}

STATIC MP_DEFINE_CONST_FUN_OBJ_2(property_getter_obj, micropy_property_getter);

STATIC mp_obj_t micropy_property_setter(struct _mp_state_ctx_t *mp_state, mp_obj_t self_in, mp_obj_t setter) {
    mp_obj_property_t *p2 = micropy_m_new_obj(mp_state, mp_obj_property_t);
    *p2 = *(mp_obj_property_t*)MP_OBJ_TO_PTR(self_in);
    p2->proxy[1] = setter;
    return MP_OBJ_FROM_PTR(p2);
}

STATIC MP_DEFINE_CONST_FUN_OBJ_2(property_setter_obj, micropy_property_setter);

STATIC mp_obj_t micropy_property_deleter(struct _mp_state_ctx_t *mp_state, mp_obj_t self_in, mp_obj_t deleter) {
    mp_obj_property_t *p2 = micropy_m_new_obj(mp_state, mp_obj_property_t);
    *p2 = *(mp_obj_property_t*)MP_OBJ_TO_PTR(self_in);
    p2->proxy[2] = deleter;
    return MP_OBJ_FROM_PTR(p2);
}

STATIC MP_DEFINE_CONST_FUN_OBJ_2(property_deleter_obj, micropy_property_deleter);

STATIC const mp_rom_map_elem_t property_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_getter), MP_ROM_PTR(&property_getter_obj) },
    { MP_ROM_QSTR(MP_QSTR_setter), MP_ROM_PTR(&property_setter_obj) },
    { MP_ROM_QSTR(MP_QSTR_deleter), MP_ROM_PTR(&property_deleter_obj) },
};

STATIC MP_DEFINE_CONST_DICT(property_locals_dict, property_locals_dict_table);

const mp_obj_type_t mp_type_property = {
    { &mp_type_type },
    .name = MP_QSTR_property,
    .make_new = micropy_property_make_new,
    .locals_dict = (mp_obj_dict_t*)&property_locals_dict,
};

const mp_obj_t *micropy_obj_property_get(struct _mp_state_ctx_t *mp_state, mp_obj_t self_in) {
    assert(MP_OBJ_IS_TYPE(self_in, &mp_type_property));
    mp_obj_property_t *self = MP_OBJ_TO_PTR(self_in);
    return self->proxy;
}

#endif // MICROPY_PY_BUILTINS_PROPERTY
/*
 * This file is part of the Micro Python project, http://micropython.org/
 *
 * The MIT License (MIT)
 *
 * Copyright (c) 2013, 2014 Damien P. George
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

#include <stdlib.h>

//#include "py/nlr.h"
//#include "py/obj.h"
//#include "py/runtime0.h"

typedef struct _mp_obj_none_t {
    mp_obj_base_t base;
} mp_obj_none_t;

STATIC void micropy_none_print(struct _mp_state_ctx_t *mp_state, const mp_print_t *print, mp_obj_t self_in, mp_print_kind_t kind) {
    (void)self_in;
    if (MICROPY_PY_UJSON && kind == PRINT_JSON) {
        micropy_print_str(mp_state, print, "null");
    } else {
        micropy_print_str(mp_state, print, "None");
    }
}

STATIC mp_obj_t micropy_none_unary_op(struct _mp_state_ctx_t *mp_state, mp_uint_t op, mp_obj_t o_in) {
    (void)o_in;
    switch (op) {
        case MP_UNARY_OP_BOOL: return mp_const_false;
        case MP_UNARY_OP_HASH: return MP_OBJ_NEW_SMALL_INT((mp_uint_t)o_in);
        default: return MP_OBJ_NULL; // op not supported
    }
}

const mp_obj_type_t mp_type_NoneType = {
    { &mp_type_type },
    .name = MP_QSTR_NoneType,
    .print = micropy_none_print,
    .unary_op = micropy_none_unary_op,
};

const mp_obj_none_t mp_const_none_obj = {{&mp_type_NoneType}};
/*
 * This file is part of the Micro Python project, http://micropython.org/
 *
 * The MIT License (MIT)
 *
 * Copyright (c) 2013, 2014 Damien P. George
 * Copyright (c) 2014 Paul Sokolovsky
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

#include <string.h>

//#include "py/nlr.h"
//#include "py/objtuple.h"
//#include "py/runtime.h"
//#include "py/objstr.h"

#if MICROPY_PY_COLLECTIONS

typedef struct _mp_obj_namedtuple_type_t {
    mp_obj_type_t base;
    mp_uint_t n_fields;
    qstr fields[];
} mp_obj_namedtuple_type_t;

typedef struct _mp_obj_namedtuple_t {
    mp_obj_tuple_t tuple;
} mp_obj_namedtuple_t;

STATIC mp_uint_t micropy_namedtuple_find_field(struct _mp_state_ctx_t *mp_state, const mp_obj_namedtuple_type_t *type, qstr name) {
    for (mp_uint_t i = 0; i < type->n_fields; i++) {
        if (type->fields[i] == name) {
            return i;
        }
    }
    return -1;
}

STATIC void micropy_namedtuple_print(struct _mp_state_ctx_t *mp_state, const mp_print_t *print, mp_obj_t o_in, mp_print_kind_t kind) {
    (void)kind;
    mp_obj_namedtuple_t *o = MP_OBJ_TO_PTR(o_in);
    micropy_printf(mp_state, print, "%q", o->tuple.base.type->name);
    const qstr *fields = ((mp_obj_namedtuple_type_t*)o->tuple.base.type)->fields;
    micropy_obj_attrtuple_print_helper(mp_state, print, fields, &o->tuple);
}

STATIC void micropy_namedtuple_attr(struct _mp_state_ctx_t *mp_state, mp_obj_t self_in, qstr attr, mp_obj_t *dest) {
    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        mp_obj_namedtuple_t *self = MP_OBJ_TO_PTR(self_in);
        int id = micropy_namedtuple_find_field(mp_state, (mp_obj_namedtuple_type_t*)self->tuple.base.type, attr);
        if (id == -1) {
            return;
        }
        dest[0] = self->tuple.items[id];
    } else {
        // delete/store attribute
        // provide more detailed error message than we'd get by just returning
        micropy_nlr_raise(mp_state, micropy_obj_new_exception_msg(mp_state, &mp_type_AttributeError, "can't set attribute"));
    }
}

STATIC mp_obj_t micropy_namedtuple_make_new(struct _mp_state_ctx_t *mp_state, const mp_obj_type_t *type_in, size_t n_args, size_t n_kw, const mp_obj_t *args) {
    const mp_obj_namedtuple_type_t *type = (const mp_obj_namedtuple_type_t*)type_in;
    size_t num_fields = type->n_fields;
    if (n_args + n_kw != num_fields) {
        if (MICROPY_ERROR_REPORTING == MICROPY_ERROR_REPORTING_TERSE) {
            micropy_arg_error_terse_mismatch(mp_state);
        } else if (MICROPY_ERROR_REPORTING == MICROPY_ERROR_REPORTING_NORMAL) {
            micropy_nlr_raise(mp_state, micropy_obj_new_exception_msg_varg(mp_state, &mp_type_TypeError,
                "function takes %d positional arguments but %d were given",
                num_fields, n_args + n_kw));
        } else if (MICROPY_ERROR_REPORTING == MICROPY_ERROR_REPORTING_DETAILED) {
            micropy_nlr_raise(mp_state, micropy_obj_new_exception_msg_varg(mp_state, &mp_type_TypeError,
                "%q() takes %d positional arguments but %d were given",
                type->base.name, num_fields, n_args + n_kw));
        }
    }

    mp_obj_t *arg_objects;
    if (n_args == num_fields) {
        arg_objects = (mp_obj_t*)args;
    } else {
        size_t alloc_size = sizeof(mp_obj_t) * num_fields;
        arg_objects = alloca(alloc_size);
        memset(arg_objects, 0, alloc_size);

        for (mp_uint_t i = 0; i < n_args; i++) {
            arg_objects[i] = args[i];
        }

        for (mp_uint_t i = n_args; i < n_args + 2 * n_kw; i += 2) {
            qstr kw = micropy_obj_str_get_qstr(mp_state, args[i]);
            int id = micropy_namedtuple_find_field(mp_state, type, kw);
            if (id == -1) {
                if (MICROPY_ERROR_REPORTING == MICROPY_ERROR_REPORTING_TERSE) {
                    micropy_arg_error_terse_mismatch(mp_state);
                } else {
                    micropy_nlr_raise(mp_state, micropy_obj_new_exception_msg_varg(mp_state, &mp_type_TypeError,
                        "unexpected keyword argument '%q'", kw));
                }
            }
            if (arg_objects[id] != MP_OBJ_NULL) {
                if (MICROPY_ERROR_REPORTING == MICROPY_ERROR_REPORTING_TERSE) {
                    micropy_arg_error_terse_mismatch(mp_state);
                } else {
                    micropy_nlr_raise(mp_state, micropy_obj_new_exception_msg_varg(mp_state, &mp_type_TypeError,
                        "function got multiple values for argument '%q'", kw));
                }
            }
            arg_objects[id] = args[i + 1];
        }
    }

    mp_obj_tuple_t *tuple = MP_OBJ_TO_PTR(micropy_obj_new_tuple(mp_state, num_fields, arg_objects));
    tuple->base.type = type_in;
    return MP_OBJ_FROM_PTR(tuple);
}

STATIC const mp_rom_obj_tuple_t namedtuple_base_tuple = {{&mp_type_tuple}, 1, {MP_ROM_PTR(&mp_type_tuple)}};

STATIC mp_obj_t micropy_obj_new_namedtuple_type(struct _mp_state_ctx_t *mp_state, qstr name, mp_uint_t n_fields, mp_obj_t *fields) {
    mp_obj_namedtuple_type_t *o = micropy_m_new_obj_var(mp_state, mp_obj_namedtuple_type_t, qstr, n_fields);
    memset(&o->base, 0, sizeof(o->base));
    o->base.base.type = &mp_type_type;
    o->base.name = name;
    o->base.print = micropy_namedtuple_print;
    o->base.make_new = micropy_namedtuple_make_new;
    o->base.unary_op = micropy_obj_tuple_unary_op;
    o->base.binary_op = micropy_obj_tuple_binary_op;
    o->base.attr = micropy_namedtuple_attr;
    o->base.subscr = micropy_obj_tuple_subscr;
    o->base.getiter = micropy_obj_tuple_getiter;
    o->base.bases_tuple = (mp_obj_tuple_t*)(mp_rom_obj_tuple_t*)&namedtuple_base_tuple;
    o->n_fields = n_fields;
    for (mp_uint_t i = 0; i < n_fields; i++) {
        o->fields[i] = micropy_obj_str_get_qstr(mp_state, fields[i]);
    }
    return MP_OBJ_FROM_PTR(o);
}

STATIC mp_obj_t micropy_new_namedtuple_type(struct _mp_state_ctx_t *mp_state, mp_obj_t name_in, mp_obj_t fields_in) {
    qstr name = micropy_obj_str_get_qstr(mp_state, name_in);
    mp_uint_t n_fields;
    mp_obj_t *fields;
    #if MICROPY_CPYTHON_COMPAT
    if (MP_OBJ_IS_STR(fields_in)) {
        fields_in = micropy_obj_str_split(mp_state, 1, &fields_in);
    }
    #endif
    micropy_obj_get_array(mp_state, fields_in, &n_fields, &fields);
    return micropy_obj_new_namedtuple_type(mp_state, name, n_fields, fields);
}
MP_DEFINE_CONST_FUN_OBJ_2(mp_namedtuple_obj, micropy_new_namedtuple_type);

#endif // MICROPY_PY_COLLECTIONS
/*
 * This file is part of the Micro Python project, http://micropython.org/
 *
 * The MIT License (MIT)
 *
 * Copyright (c) 2013, 2014 Damien P. George
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

#include <stdlib.h>

//#include "py/nlr.h"
//#include "py/runtime0.h"
//#include "py/runtime.h"

/******************************************************************************/
/* range iterator                                                             */

typedef struct _mp_obj_range_it_t {
    mp_obj_base_t base;
    // TODO make these values generic objects or something
    mp_int_t cur;
    mp_int_t stop;
    mp_int_t step;
} mp_obj_range_it_t;

STATIC mp_obj_t micropy_range_it_iternext(struct _mp_state_ctx_t *mp_state, mp_obj_t o_in) {
    mp_obj_range_it_t *o = MP_OBJ_TO_PTR(o_in);
    if ((o->step > 0 && o->cur < o->stop) || (o->step < 0 && o->cur > o->stop)) {
        mp_obj_t o_out = MP_OBJ_NEW_SMALL_INT(o->cur);
        o->cur += o->step;
        return o_out;
    } else {
        return MP_OBJ_STOP_ITERATION;
    }
}

STATIC const mp_obj_type_t range_it_type = {
    { &mp_type_type },
    .name = MP_QSTR_iterator,
    .getiter = micropy_identity,
    .iternext = micropy_range_it_iternext,
};

STATIC mp_obj_t micropy_obj_new_range_iterator(struct _mp_state_ctx_t *mp_state, mp_int_t cur, mp_int_t stop, mp_int_t step) {
    mp_obj_range_it_t *o = micropy_m_new_obj(mp_state, mp_obj_range_it_t);
    o->base.type = &range_it_type;
    o->cur = cur;
    o->stop = stop;
    o->step = step;
    return MP_OBJ_FROM_PTR(o);
}

/******************************************************************************/
/* range                                                                      */

typedef struct _mp_obj_range_t {
    mp_obj_base_t base;
    // TODO make these values generic objects or something
    mp_int_t start;
    mp_int_t stop;
    mp_int_t step;
} mp_obj_range_t;

STATIC void micropy_range_print(struct _mp_state_ctx_t *mp_state, const mp_print_t *print, mp_obj_t self_in, mp_print_kind_t kind) {
    (void)kind;
    mp_obj_range_t *self = MP_OBJ_TO_PTR(self_in);
    micropy_printf(mp_state, print, "range(" INT_FMT ", " INT_FMT "", self->start, self->stop);
    if (self->step == 1) {
        micropy_print_str(mp_state, print, ")");
    } else {
        micropy_printf(mp_state, print, ", " INT_FMT ")", self->step);
    }
}

STATIC mp_obj_t micropy_range_make_new(struct _mp_state_ctx_t *mp_state, const mp_obj_type_t *type, size_t n_args, size_t n_kw, const mp_obj_t *args) {
    micropy_arg_check_num(mp_state, n_args, n_kw, 1, 3, false);

    mp_obj_range_t *o = micropy_m_new_obj(mp_state, mp_obj_range_t);
    o->base.type = type;
    o->start = 0;
    o->step = 1;

    if (n_args == 1) {
        o->stop = micropy_obj_get_int(mp_state, args[0]);
    } else {
        o->start = micropy_obj_get_int(mp_state, args[0]);
        o->stop = micropy_obj_get_int(mp_state, args[1]);
        if (n_args == 3) {
            // TODO check step is non-zero
            o->step = micropy_obj_get_int(mp_state, args[2]);
        }
    }

    return MP_OBJ_FROM_PTR(o);
}

STATIC mp_int_t micropy_range_len(struct _mp_state_ctx_t *mp_state, mp_obj_range_t *self) {
    // When computing length, need to take into account step!=1 and step<0.
    mp_int_t len = self->stop - self->start + self->step;
    if (self->step > 0) {
        len -= 1;
    } else {
        len += 1;
    }
    len = len / self->step;
    if (len < 0) {
        len = 0;
    }
    return len;
}

STATIC mp_obj_t micropy_range_unary_op(struct _mp_state_ctx_t *mp_state, mp_uint_t op, mp_obj_t self_in) {
    mp_obj_range_t *self = MP_OBJ_TO_PTR(self_in);
    mp_int_t len = micropy_range_len(mp_state, self);
    switch (op) {
        case MP_UNARY_OP_BOOL: return micropy_obj_new_bool(mp_state, len > 0);
        case MP_UNARY_OP_LEN: return MP_OBJ_NEW_SMALL_INT(len);
        default: return MP_OBJ_NULL; // op not supported
    }
}

STATIC mp_obj_t micropy_range_subscr(struct _mp_state_ctx_t *mp_state, mp_obj_t self_in, mp_obj_t index, mp_obj_t value) {
    if (value == MP_OBJ_SENTINEL) {
        // load
        mp_obj_range_t *self = MP_OBJ_TO_PTR(self_in);
        mp_int_t len = micropy_range_len(mp_state, self);
#if MICROPY_PY_BUILTINS_SLICE
        if (MP_OBJ_IS_TYPE(index, &mp_type_slice)) {
            mp_bound_slice_t slice;
            micropy_seq_get_fast_slice_indexes(mp_state, len, index, &slice);
            mp_obj_range_t *o = micropy_m_new_obj(mp_state, mp_obj_range_t);
            o->base.type = &mp_type_range;
            o->start = self->start + slice.start * self->step;
            o->stop = self->start + slice.stop * self->step;
            o->step = slice.step * self->step;
            return MP_OBJ_FROM_PTR(o);
        }
#endif
        uint index_val = micropy_get_index(mp_state, self->base.type, len, index, false);
        return MP_OBJ_NEW_SMALL_INT(self->start + index_val * self->step);
    } else {
        return MP_OBJ_NULL; // op not supported
    }
}

STATIC mp_obj_t micropy_range_getiter(struct _mp_state_ctx_t *mp_state, mp_obj_t o_in) {
    mp_obj_range_t *o = MP_OBJ_TO_PTR(o_in);
    return micropy_obj_new_range_iterator(mp_state, o->start, o->stop, o->step);
}


#if MICROPY_PY_BUILTINS_RANGE_ATTRS
STATIC void micropy_range_attr(struct _mp_state_ctx_t *mp_state, mp_obj_t o_in, qstr attr, mp_obj_t *dest) {
    if (dest[0] != MP_OBJ_NULL) {
        // not load attribute
        return;
    }
    mp_obj_range_t *o = MP_OBJ_TO_PTR(o_in);
    if (attr == MP_QSTR_start) {
        dest[0] = micropy_obj_new_int(mp_state, o->start);
    } else if (attr == MP_QSTR_stop) {
        dest[0] = micropy_obj_new_int(mp_state, o->stop);
    } else if (attr == MP_QSTR_step) {
        dest[0] = micropy_obj_new_int(mp_state, o->step);
    }
}
#endif

const mp_obj_type_t mp_type_range = {
    { &mp_type_type },
    .name = MP_QSTR_range,
    .print = micropy_range_print,
    .make_new = micropy_range_make_new,
    .unary_op = micropy_range_unary_op,
    .subscr = micropy_range_subscr,
    .getiter = micropy_range_getiter,
#if MICROPY_PY_BUILTINS_RANGE_ATTRS
    .attr = micropy_range_attr,
#endif
};
/*
 * This file is part of the Micro Python project, http://micropython.org/
 *
 * The MIT License (MIT)
 *
 * Copyright (c) 2014 Damien P. George
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

#include <stdlib.h>
#include <assert.h>

//#include "py/nlr.h"
//#include "py/runtime.h"

#if MICROPY_PY_BUILTINS_REVERSED

typedef struct _mp_obj_reversed_t {
    mp_obj_base_t base;
    mp_obj_t seq;           // sequence object that we are reversing
    mp_uint_t cur_index;    // current index, plus 1; 0=no more, 1=last one (index 0)
} mp_obj_reversed_t;

STATIC mp_obj_t micropy_reversed_make_new(struct _mp_state_ctx_t *mp_state, const mp_obj_type_t *type, size_t n_args, size_t n_kw, const mp_obj_t *args) {
    micropy_arg_check_num(mp_state, n_args, n_kw, 1, 1, false);

    // check if __reversed__ exists, and if so delegate to it
    mp_obj_t dest[2];
    micropy_load_method_maybe(mp_state, args[0], MP_QSTR___reversed__, dest);
    if (dest[0] != MP_OBJ_NULL) {
        return micropy_call_method_n_kw(mp_state, 0, 0, dest);
    }

    mp_obj_reversed_t *o = micropy_m_new_obj(mp_state, mp_obj_reversed_t);
    o->base.type = type;
    o->seq = args[0];
    o->cur_index = micropy_obj_get_int(mp_state, micropy_obj_len(mp_state, args[0])); // start at the end of the sequence

    return MP_OBJ_FROM_PTR(o);
}

STATIC mp_obj_t micropy_reversed_iternext(struct _mp_state_ctx_t *mp_state, mp_obj_t self_in) {
    assert(MP_OBJ_IS_TYPE(self_in, &mp_type_reversed));
    mp_obj_reversed_t *self = MP_OBJ_TO_PTR(self_in);

    // "raise" stop iteration if we are at the end (the start) of the sequence
    if (self->cur_index == 0) {
        return MP_OBJ_STOP_ITERATION;
    }

    // pre-decrement and index sequence
    self->cur_index -= 1;
    return micropy_obj_subscr(mp_state, self->seq, MP_OBJ_NEW_SMALL_INT(self->cur_index), MP_OBJ_SENTINEL);
}

const mp_obj_type_t mp_type_reversed = {
    { &mp_type_type },
    .name = MP_QSTR_reversed,
    .make_new = micropy_reversed_make_new,
    .getiter = micropy_identity,
    .iternext = micropy_reversed_iternext,
};

#endif // MICROPY_PY_BUILTINS_REVERSED
/*
 * This file is part of the Micro Python project, http://micropython.org/
 *
 * The MIT License (MIT)
 *
 * Copyright (c) 2013, 2014 Damien P. George
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

#include <stdbool.h>
#include <string.h>
#include <assert.h>

//#include "py/nlr.h"
//#include "py/runtime.h"
//#include "py/runtime0.h"
//#include "py/builtin.h"

#if MICROPY_PY_BUILTINS_SET

typedef struct _mp_obj_set_t {
    mp_obj_base_t base;
    mp_set_t set;
} mp_obj_set_t;

typedef struct _mp_obj_set_it_t {
    mp_obj_base_t base;
    mp_fun_1_t iternext;
    mp_obj_set_t *set;
    mp_uint_t cur;
} mp_obj_set_it_t;

STATIC mp_obj_t micropy_set_it_iternext(struct _mp_state_ctx_t *mp_state, mp_obj_t self_in);

STATIC bool micropy_is_set_or_frozenset(struct _mp_state_ctx_t *mp_state, mp_obj_t o) {
    return MP_OBJ_IS_TYPE(o, &mp_type_set)
#if MICROPY_PY_BUILTINS_FROZENSET
        || MP_OBJ_IS_TYPE(o, &mp_type_frozenset)
#endif
    ;
}

#if MICROPY_PY_BUILTINS_FROZENSET
STATIC void micropy_check_set_or_frozenset(struct _mp_state_ctx_t *mp_state, mp_obj_t o) {
    if (!micropy_is_set_or_frozenset(mp_state, o)) {
        micropy_nlr_raise(mp_state, micropy_obj_new_exception_msg_varg(mp_state, &mp_type_TypeError, "'set' object required"));
    }
}
#else
#define micropy_check_set_or_frozenset(mp_state, o) micropy_check_set(mp_state, o)
#endif

STATIC void micropy_check_set(struct _mp_state_ctx_t *mp_state, mp_obj_t o) {
    if (!MP_OBJ_IS_TYPE(o, &mp_type_set)) {
        // Emulate CPython behavior
        // AttributeError: 'frozenset' object has no attribute 'add'
        #if MICROPY_PY_BUILTINS_FROZENSET
        if (MP_OBJ_IS_TYPE(o, &mp_type_frozenset)) {
            micropy_nlr_raise(mp_state, micropy_obj_new_exception_msg(mp_state, &mp_type_AttributeError, "'frozenset' has no such attribute"));
        }
        #endif
        micropy_nlr_raise(mp_state, micropy_obj_new_exception_msg_varg(mp_state, &mp_type_TypeError, "'set' object required"));
    }
}

STATIC void micropy_set_print(struct _mp_state_ctx_t *mp_state, const mp_print_t *print, mp_obj_t self_in, mp_print_kind_t kind) {
    (void)kind;
    mp_obj_set_t *self = MP_OBJ_TO_PTR(self_in);
    #if MICROPY_PY_BUILTINS_FROZENSET
    bool is_frozen = MP_OBJ_IS_TYPE(self_in, &mp_type_frozenset);
    #endif
    if (self->set.used == 0) {
        #if MICROPY_PY_BUILTINS_FROZENSET
        if (is_frozen) {
            micropy_print_str(mp_state, print, "frozen");
        }
        #endif
        micropy_print_str(mp_state, print, "set()");
        return;
    }
    bool first = true;
    #if MICROPY_PY_BUILTINS_FROZENSET
    if (is_frozen) {
        micropy_print_str(mp_state, print, "frozenset(");
    }
    #endif
    micropy_print_str(mp_state, print, "{");
    for (mp_uint_t i = 0; i < self->set.alloc; i++) {
        if (MP_SET_SLOT_IS_FILLED(&self->set, i)) {
            if (!first) {
                micropy_print_str(mp_state, print, ", ");
            }
            first = false;
            micropy_obj_print_helper(mp_state, print, self->set.table[i], PRINT_REPR);
        }
    }
    micropy_print_str(mp_state, print, "}");
    #if MICROPY_PY_BUILTINS_FROZENSET
    if (is_frozen) {
        micropy_print_str(mp_state, print, ")");
    }
    #endif
}

STATIC mp_obj_t micropy_set_make_new(struct _mp_state_ctx_t *mp_state, const mp_obj_type_t *type, size_t n_args, size_t n_kw, const mp_obj_t *args) {
    micropy_arg_check_num(mp_state, n_args, n_kw, 0, 1, false);

    switch (n_args) {
        case 0: {
            // create a new, empty set
            mp_obj_set_t *set = MP_OBJ_TO_PTR(micropy_obj_new_set(mp_state, 0, NULL));
            // set actual set/frozenset type
            set->base.type = type;
            return MP_OBJ_FROM_PTR(set);
        }

        case 1:
        default: { // can only be 0 or 1 arg
            // 1 argument, an iterable from which we make a new set
            mp_obj_t set = micropy_obj_new_set(mp_state, 0, NULL);
            mp_obj_t iterable = micropy_getiter(mp_state, args[0]);
            mp_obj_t item;
            while ((item = micropy_iternext(mp_state, iterable)) != MP_OBJ_STOP_ITERATION) {
                micropy_obj_set_store(mp_state, set, item);
            }
            // Set actual set/frozenset type
            ((mp_obj_set_t*)MP_OBJ_TO_PTR(set))->base.type = type;
            return set;
        }
    }
}

STATIC mp_obj_t micropy_set_it_iternext(struct _mp_state_ctx_t *mp_state, mp_obj_t self_in) {
    mp_obj_set_it_t *self = MP_OBJ_TO_PTR(self_in);
    mp_uint_t max = self->set->set.alloc;
    mp_set_t *set = &self->set->set;

    for (mp_uint_t i = self->cur; i < max; i++) {
        if (MP_SET_SLOT_IS_FILLED(set, i)) {
            self->cur = i + 1;
            return set->table[i];
        }
    }

    return MP_OBJ_STOP_ITERATION;
}

STATIC mp_obj_t micropy_set_getiter(struct _mp_state_ctx_t *mp_state, mp_obj_t set_in) {
    mp_obj_set_it_t *o = micropy_m_new_obj(mp_state, mp_obj_set_it_t);
    o->base.type = &mp_type_polymorph_iter;
    o->iternext = micropy_set_it_iternext;
    o->set = (mp_obj_set_t *)MP_OBJ_TO_PTR(set_in);
    o->cur = 0;
    return MP_OBJ_FROM_PTR(o);
}


/******************************************************************************/
/* set methods                                                                */

STATIC mp_obj_t micropy_set_add(struct _mp_state_ctx_t *mp_state, mp_obj_t self_in, mp_obj_t item) {
    micropy_check_set(mp_state, self_in);
    mp_obj_set_t *self = MP_OBJ_TO_PTR(self_in);
    micropy_set_lookup(mp_state, &self->set, item, MP_MAP_LOOKUP_ADD_IF_NOT_FOUND);
    return mp_const_none;
}
STATIC MP_DEFINE_CONST_FUN_OBJ_2(set_add_obj, micropy_set_add);

STATIC mp_obj_t micropy_obj_set_clear(struct _mp_state_ctx_t *mp_state, mp_obj_t self_in) {
    micropy_check_set(mp_state, self_in);
    mp_obj_set_t *self = MP_OBJ_TO_PTR(self_in);

    micropy_set_clear(mp_state, &self->set);

    return mp_const_none;
}
STATIC MP_DEFINE_CONST_FUN_OBJ_1(set_clear_obj, micropy_obj_set_clear);

STATIC mp_obj_t micropy_set_copy_as_mutable(struct _mp_state_ctx_t *mp_state, mp_obj_t self_in) {
    mp_obj_set_t *self = MP_OBJ_TO_PTR(self_in);

    mp_obj_set_t *other = micropy_m_new_obj(mp_state, mp_obj_set_t);
    other->base.type = &mp_type_set;
    micropy_set_init(mp_state, &other->set, self->set.alloc);
    other->set.used = self->set.used;
    memcpy(other->set.table, self->set.table, self->set.alloc * sizeof(mp_obj_t));

    return MP_OBJ_FROM_PTR(other);
}

STATIC mp_obj_t micropy_set_copy(struct _mp_state_ctx_t *mp_state, mp_obj_t self_in) {
    micropy_check_set_or_frozenset(mp_state, self_in);

    mp_obj_t other = micropy_set_copy_as_mutable(mp_state, self_in);
    ((mp_obj_base_t*)MP_OBJ_TO_PTR(other))->type = ((mp_obj_base_t*)MP_OBJ_TO_PTR(self_in))->type;

    return other;
}
STATIC MP_DEFINE_CONST_FUN_OBJ_1(set_copy_obj, micropy_set_copy);

STATIC mp_obj_t micropy_set_discard(struct _mp_state_ctx_t *mp_state, mp_obj_t self_in, mp_obj_t item) {
    micropy_check_set(mp_state, self_in);
    mp_obj_set_t *self = MP_OBJ_TO_PTR(self_in);
    micropy_set_lookup(mp_state, &self->set, item, MP_MAP_LOOKUP_REMOVE_IF_FOUND);
    return mp_const_none;
}
STATIC MP_DEFINE_CONST_FUN_OBJ_2(set_discard_obj, micropy_set_discard);

STATIC mp_obj_t micropy_set_diff_int(struct _mp_state_ctx_t *mp_state, size_t n_args, const mp_obj_t *args, bool update) {
    assert(n_args > 0);

    mp_obj_t self;
    if (update) {
        micropy_check_set(mp_state, args[0]);
        self = args[0];
    } else {
        micropy_check_set_or_frozenset(mp_state, args[0]);
        self = micropy_set_copy_as_mutable(mp_state, args[0]);
    }


    for (mp_uint_t i = 1; i < n_args; i++) {
        mp_obj_t other = args[i];
        if (self == other) {
            micropy_obj_set_clear(mp_state, self);
        } else {
            mp_obj_t iter = micropy_getiter(mp_state, other);
            mp_obj_t next;
            while ((next = micropy_iternext(mp_state, iter)) != MP_OBJ_STOP_ITERATION) {
                micropy_set_discard(mp_state, self, next);
            }
        }
    }

    ((mp_obj_base_t*)MP_OBJ_TO_PTR(self))->type = ((mp_obj_base_t*)MP_OBJ_TO_PTR(args[0]))->type;
    return self;
}

STATIC mp_obj_t micropy_set_diff(struct _mp_state_ctx_t *mp_state, size_t n_args, const mp_obj_t *args) {
    return micropy_set_diff_int(mp_state, n_args, args, false);
}
STATIC MP_DEFINE_CONST_FUN_OBJ_VAR(set_diff_obj, 1, micropy_set_diff);

STATIC mp_obj_t micropy_set_diff_update(struct _mp_state_ctx_t *mp_state, size_t n_args, const mp_obj_t *args) {
    micropy_set_diff_int(mp_state, n_args, args, true);
    return mp_const_none;
}
STATIC MP_DEFINE_CONST_FUN_OBJ_VAR(set_diff_update_obj, 1, micropy_set_diff_update);

STATIC mp_obj_t micropy_set_intersect_int(struct _mp_state_ctx_t *mp_state, mp_obj_t self_in, mp_obj_t other, bool update) {
    if (update) {
        micropy_check_set(mp_state, self_in);
    } else {
        micropy_check_set_or_frozenset(mp_state, self_in);
    }

    if (self_in == other) {
        return update ? mp_const_none : micropy_set_copy(mp_state, self_in);
    }

    mp_obj_set_t *self = MP_OBJ_TO_PTR(self_in);
    mp_obj_set_t *out = MP_OBJ_TO_PTR(micropy_obj_new_set(mp_state, 0, NULL));

    mp_obj_t iter = micropy_getiter(mp_state, other);
    mp_obj_t next;
    while ((next = micropy_iternext(mp_state, iter)) != MP_OBJ_STOP_ITERATION) {
        if (micropy_set_lookup(mp_state, &self->set, next, MP_MAP_LOOKUP)) {
            micropy_set_add(mp_state, MP_OBJ_FROM_PTR(out), next);
        }
    }

    if (update) {
        micropy_m_del(mp_state, mp_obj_t, self->set.table, self->set.alloc);
        self->set.alloc = out->set.alloc;
        self->set.used = out->set.used;
        self->set.table = out->set.table;
    }

    return update ? mp_const_none : MP_OBJ_FROM_PTR(out);
}

STATIC mp_obj_t micropy_set_intersect(struct _mp_state_ctx_t *mp_state, mp_obj_t self_in, mp_obj_t other) {
    return micropy_set_intersect_int(mp_state, self_in, other, false);
}
STATIC MP_DEFINE_CONST_FUN_OBJ_2(set_intersect_obj, micropy_set_intersect);

STATIC mp_obj_t micropy_set_intersect_update(struct _mp_state_ctx_t *mp_state, mp_obj_t self_in, mp_obj_t other) {
    return micropy_set_intersect_int(mp_state, self_in, other, true);
}
STATIC MP_DEFINE_CONST_FUN_OBJ_2(set_intersect_update_obj, micropy_set_intersect_update);

STATIC mp_obj_t micropy_set_isdisjoint(struct _mp_state_ctx_t *mp_state, mp_obj_t self_in, mp_obj_t other) {
    micropy_check_set_or_frozenset(mp_state, self_in);
    mp_obj_set_t *self = MP_OBJ_TO_PTR(self_in);

    mp_obj_t iter = micropy_getiter(mp_state, other);
    mp_obj_t next;
    while ((next = micropy_iternext(mp_state, iter)) != MP_OBJ_STOP_ITERATION) {
        if (micropy_set_lookup(mp_state, &self->set, next, MP_MAP_LOOKUP)) {
            return mp_const_false;
        }
    }
    return mp_const_true;
}
STATIC MP_DEFINE_CONST_FUN_OBJ_2(set_isdisjoint_obj, micropy_set_isdisjoint);

STATIC mp_obj_t micropy_set_issubset_internal(struct _mp_state_ctx_t *mp_state, mp_obj_t self_in, mp_obj_t other_in, bool proper) {
    mp_obj_set_t *self;
    bool cleanup_self = false;
    if (micropy_is_set_or_frozenset(mp_state, self_in)) {
        self = MP_OBJ_TO_PTR(self_in);
    } else {
        self = MP_OBJ_TO_PTR(micropy_set_make_new(mp_state, &mp_type_set, 1, 0, &self_in));
        cleanup_self = true;
    }

    mp_obj_set_t *other;
    bool cleanup_other = false;
    if (micropy_is_set_or_frozenset(mp_state, other_in)) {
        other = MP_OBJ_TO_PTR(other_in);
    } else {
        other = MP_OBJ_TO_PTR(micropy_set_make_new(mp_state, &mp_type_set, 1, 0, &other_in));
        cleanup_other = true;
    }
    bool out = true;
    if (proper && self->set.used == other->set.used) {
        out = false;
    } else {
        mp_obj_t iter = micropy_set_getiter(mp_state, MP_OBJ_FROM_PTR(self));
        mp_obj_t next;
        while ((next = micropy_set_it_iternext(mp_state, iter)) != MP_OBJ_STOP_ITERATION) {
            if (!micropy_set_lookup(mp_state, &other->set, next, MP_MAP_LOOKUP)) {
                out = false;
                break;
            }
        }
    }
    // TODO: Should free objects altogether
    if (cleanup_self) {
        micropy_obj_set_clear(mp_state, MP_OBJ_FROM_PTR(self));
    }
    if (cleanup_other) {
        micropy_obj_set_clear(mp_state, MP_OBJ_FROM_PTR(other));
    }
    return micropy_obj_new_bool(mp_state, out);
}
STATIC mp_obj_t micropy_set_issubset(struct _mp_state_ctx_t *mp_state, mp_obj_t self_in, mp_obj_t other_in) {
    return micropy_set_issubset_internal(mp_state, self_in, other_in, false);
}
STATIC MP_DEFINE_CONST_FUN_OBJ_2(set_issubset_obj, micropy_set_issubset);

STATIC mp_obj_t micropy_set_issubset_proper(struct _mp_state_ctx_t *mp_state, mp_obj_t self_in, mp_obj_t other_in) {
    return micropy_set_issubset_internal(mp_state, self_in, other_in, true);
}

STATIC mp_obj_t micropy_set_issuperset(struct _mp_state_ctx_t *mp_state, mp_obj_t self_in, mp_obj_t other_in) {
    return micropy_set_issubset_internal(mp_state, other_in, self_in, false);
}
STATIC MP_DEFINE_CONST_FUN_OBJ_2(set_issuperset_obj, micropy_set_issuperset);

STATIC mp_obj_t micropy_set_issuperset_proper(struct _mp_state_ctx_t *mp_state, mp_obj_t self_in, mp_obj_t other_in) {
    return micropy_set_issubset_internal(mp_state, other_in, self_in, true);
}

STATIC mp_obj_t micropy_set_equal(struct _mp_state_ctx_t *mp_state, mp_obj_t self_in, mp_obj_t other_in) {
    micropy_check_set_or_frozenset(mp_state, self_in);
    mp_obj_set_t *self = MP_OBJ_TO_PTR(self_in);
    if (!micropy_is_set_or_frozenset(mp_state, other_in)) {
        return mp_const_false;
    }
    mp_obj_set_t *other = MP_OBJ_TO_PTR(other_in);
    if (self->set.used != other->set.used) {
        return mp_const_false;
    }
    return micropy_set_issubset(mp_state, self_in, other_in);
}

STATIC mp_obj_t micropy_set_pop(struct _mp_state_ctx_t *mp_state, mp_obj_t self_in) {
    micropy_check_set(mp_state, self_in);
    mp_obj_set_t *self = MP_OBJ_TO_PTR(self_in);
    mp_obj_t obj = micropy_set_remove_first(mp_state, &self->set);
    if (obj == MP_OBJ_NULL) {
        micropy_nlr_raise(mp_state, micropy_obj_new_exception_msg(mp_state, &mp_type_KeyError, "pop from an empty set"));
    }
    return obj;
}
STATIC MP_DEFINE_CONST_FUN_OBJ_1(set_pop_obj, micropy_set_pop);

STATIC mp_obj_t micropy_set_remove(struct _mp_state_ctx_t *mp_state, mp_obj_t self_in, mp_obj_t item) {
    micropy_check_set(mp_state, self_in);
    mp_obj_set_t *self = MP_OBJ_TO_PTR(self_in);
    if (micropy_set_lookup(mp_state, &self->set, item, MP_MAP_LOOKUP_REMOVE_IF_FOUND) == MP_OBJ_NULL) {
        micropy_nlr_raise(mp_state, micropy_obj_new_exception(mp_state, &mp_type_KeyError));
    }
    return mp_const_none;
}
STATIC MP_DEFINE_CONST_FUN_OBJ_2(set_remove_obj, micropy_set_remove);

STATIC mp_obj_t micropy_set_symmetric_difference_update(struct _mp_state_ctx_t *mp_state, mp_obj_t self_in, mp_obj_t other_in) {
    micropy_check_set(mp_state, self_in);
    mp_obj_set_t *self = MP_OBJ_TO_PTR(self_in);
    mp_obj_t iter = micropy_getiter(mp_state, other_in);
    mp_obj_t next;
    while ((next = micropy_iternext(mp_state, iter)) != MP_OBJ_STOP_ITERATION) {
        micropy_set_lookup(mp_state, &self->set, next, MP_MAP_LOOKUP_ADD_IF_NOT_FOUND_OR_REMOVE_IF_FOUND);
    }
    return mp_const_none;
}
STATIC MP_DEFINE_CONST_FUN_OBJ_2(set_symmetric_difference_update_obj, micropy_set_symmetric_difference_update);

STATIC mp_obj_t micropy_set_symmetric_difference(struct _mp_state_ctx_t *mp_state, mp_obj_t self_in, mp_obj_t other_in) {
    micropy_check_set_or_frozenset(mp_state, self_in);
    mp_obj_t self_out = micropy_set_copy_as_mutable(mp_state, self_in);
    micropy_set_symmetric_difference_update(mp_state, self_out, other_in);
    ((mp_obj_base_t*)MP_OBJ_TO_PTR(self_out))->type = ((mp_obj_base_t*)MP_OBJ_TO_PTR(self_in))->type;
    return self_out;
}
STATIC MP_DEFINE_CONST_FUN_OBJ_2(set_symmetric_difference_obj, micropy_set_symmetric_difference);

STATIC void micropy_set_update_int(struct _mp_state_ctx_t *mp_state, mp_obj_set_t *self, mp_obj_t other_in) {
    mp_obj_t iter = micropy_getiter(mp_state, other_in);
    mp_obj_t next;
    while ((next = micropy_iternext(mp_state, iter)) != MP_OBJ_STOP_ITERATION) {
        micropy_set_lookup(mp_state, &self->set, next, MP_MAP_LOOKUP_ADD_IF_NOT_FOUND);
    }
}

STATIC mp_obj_t micropy_set_update(struct _mp_state_ctx_t *mp_state, size_t n_args, const mp_obj_t *args) {
    assert(n_args > 0);

    for (mp_uint_t i = 1; i < n_args; i++) {
        micropy_set_update_int(mp_state, MP_OBJ_TO_PTR(args[0]), args[i]);
    }

    return mp_const_none;
}
STATIC MP_DEFINE_CONST_FUN_OBJ_VAR(set_update_obj, 1, micropy_set_update);

STATIC mp_obj_t micropy_set_union(struct _mp_state_ctx_t *mp_state, mp_obj_t self_in, mp_obj_t other_in) {
    micropy_check_set_or_frozenset(mp_state, self_in);
    mp_obj_t self = micropy_set_copy(mp_state, self_in);
    micropy_set_update_int(mp_state, MP_OBJ_TO_PTR(self), other_in);
    return self;
}
STATIC MP_DEFINE_CONST_FUN_OBJ_2(set_union_obj, micropy_set_union);

STATIC mp_obj_t micropy_set_unary_op(struct _mp_state_ctx_t *mp_state, mp_uint_t op, mp_obj_t self_in) {
    mp_obj_set_t *self = MP_OBJ_TO_PTR(self_in);
    switch (op) {
        case MP_UNARY_OP_BOOL: return micropy_obj_new_bool(mp_state, self->set.used != 0);
        case MP_UNARY_OP_LEN: return MP_OBJ_NEW_SMALL_INT(self->set.used);
#if MICROPY_PY_BUILTINS_FROZENSET
        case MP_UNARY_OP_HASH:
            if (MP_OBJ_IS_TYPE(self_in, &mp_type_frozenset)) {
                // start hash with unique value
                mp_int_t hash = (mp_int_t)(uintptr_t)&mp_type_frozenset;
                mp_uint_t max = self->set.alloc;
                mp_set_t *set = &self->set;

                for (mp_uint_t i = 0; i < max; i++) {
                    if (MP_SET_SLOT_IS_FILLED(set, i)) {
                        hash += MP_OBJ_SMALL_INT_VALUE(micropy_unary_op(mp_state, MP_UNARY_OP_HASH, set->table[i]));
                    }
                }
                return MP_OBJ_NEW_SMALL_INT(hash);
            }
#endif
        default: return MP_OBJ_NULL; // op not supported
    }
}

STATIC mp_obj_t micropy_set_binary_op(struct _mp_state_ctx_t *mp_state, mp_uint_t op, mp_obj_t lhs, mp_obj_t rhs) {
    mp_obj_t args[] = {lhs, rhs};
    switch (op) {
        case MP_BINARY_OP_OR:
            return micropy_set_union(mp_state, lhs, rhs);
        case MP_BINARY_OP_XOR:
            return micropy_set_symmetric_difference(mp_state, lhs, rhs);
        case MP_BINARY_OP_AND:
            return micropy_set_intersect(mp_state, lhs, rhs);
        case MP_BINARY_OP_SUBTRACT:
            return micropy_set_diff(mp_state, 2, args);
        case MP_BINARY_OP_INPLACE_OR:
            return micropy_set_union(mp_state, lhs, rhs);
        case MP_BINARY_OP_INPLACE_XOR:
            return micropy_set_symmetric_difference(mp_state, lhs, rhs);
        case MP_BINARY_OP_INPLACE_AND:
            return micropy_set_intersect(mp_state, lhs, rhs);
        case MP_BINARY_OP_INPLACE_SUBTRACT:
            return micropy_set_diff(mp_state, 2, args);
        case MP_BINARY_OP_LESS:
            return micropy_set_issubset_proper(mp_state, lhs, rhs);
        case MP_BINARY_OP_MORE:
            return micropy_set_issuperset_proper(mp_state, lhs, rhs);
        case MP_BINARY_OP_EQUAL:
            return micropy_set_equal(mp_state, lhs, rhs);
        case MP_BINARY_OP_LESS_EQUAL:
            return micropy_set_issubset(mp_state, lhs, rhs);
        case MP_BINARY_OP_MORE_EQUAL:
            return micropy_set_issuperset(mp_state, lhs, rhs);
        case MP_BINARY_OP_IN: {
            mp_obj_set_t *o = MP_OBJ_TO_PTR(lhs);
            mp_obj_t elem = micropy_set_lookup(mp_state, &o->set, rhs, MP_MAP_LOOKUP);
            return micropy_obj_new_bool(mp_state, elem != MP_OBJ_NULL);
        }
        default:
            return MP_OBJ_NULL; // op not supported
    }
}

/******************************************************************************/
/* set constructors & public C API                                            */


STATIC const mp_rom_map_elem_t set_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_add), MP_ROM_PTR(&set_add_obj) },
    { MP_ROM_QSTR(MP_QSTR_clear), MP_ROM_PTR(&set_clear_obj) },
    { MP_ROM_QSTR(MP_QSTR_copy), MP_ROM_PTR(&set_copy_obj) },
    { MP_ROM_QSTR(MP_QSTR_discard), MP_ROM_PTR(&set_discard_obj) },
    { MP_ROM_QSTR(MP_QSTR_difference), MP_ROM_PTR(&set_diff_obj) },
    { MP_ROM_QSTR(MP_QSTR_difference_update), MP_ROM_PTR(&set_diff_update_obj) },
    { MP_ROM_QSTR(MP_QSTR_intersection), MP_ROM_PTR(&set_intersect_obj) },
    { MP_ROM_QSTR(MP_QSTR_intersection_update), MP_ROM_PTR(&set_intersect_update_obj) },
    { MP_ROM_QSTR(MP_QSTR_isdisjoint), MP_ROM_PTR(&set_isdisjoint_obj) },
    { MP_ROM_QSTR(MP_QSTR_issubset), MP_ROM_PTR(&set_issubset_obj) },
    { MP_ROM_QSTR(MP_QSTR_issuperset), MP_ROM_PTR(&set_issuperset_obj) },
    { MP_ROM_QSTR(MP_QSTR_pop), MP_ROM_PTR(&set_pop_obj) },
    { MP_ROM_QSTR(MP_QSTR_remove), MP_ROM_PTR(&set_remove_obj) },
    { MP_ROM_QSTR(MP_QSTR_symmetric_difference), MP_ROM_PTR(&set_symmetric_difference_obj) },
    { MP_ROM_QSTR(MP_QSTR_symmetric_difference_update), MP_ROM_PTR(&set_symmetric_difference_update_obj) },
    { MP_ROM_QSTR(MP_QSTR_union), MP_ROM_PTR(&set_union_obj) },
    { MP_ROM_QSTR(MP_QSTR_update), MP_ROM_PTR(&set_update_obj) },
    { MP_ROM_QSTR(MP_QSTR___contains__), MP_ROM_PTR(&mp_op_contains_obj) },
};

STATIC MP_DEFINE_CONST_DICT(set_locals_dict, set_locals_dict_table);

const mp_obj_type_t mp_type_set = {
    { &mp_type_type },
    .name = MP_QSTR_set,
    .print = micropy_set_print,
    .make_new = micropy_set_make_new,
    .unary_op = micropy_set_unary_op,
    .binary_op = micropy_set_binary_op,
    .getiter = micropy_set_getiter,
    .locals_dict = (mp_obj_dict_t*)&set_locals_dict,
};

#if MICROPY_PY_BUILTINS_FROZENSET
const mp_obj_type_t mp_type_frozenset = {
    { &mp_type_type },
    .name = MP_QSTR_frozenset,
    .print = micropy_set_print,
    .make_new = micropy_set_make_new,
    .unary_op = micropy_set_unary_op,
    .binary_op = micropy_set_binary_op,
    .getiter = micropy_set_getiter,
    .locals_dict = (mp_obj_dict_t*)&set_locals_dict,
};
#endif

mp_obj_t micropy_obj_new_set(struct _mp_state_ctx_t *mp_state, mp_uint_t n_args, mp_obj_t *items) {
    mp_obj_set_t *o = micropy_m_new_obj(mp_state, mp_obj_set_t);
    o->base.type = &mp_type_set;
    micropy_set_init(mp_state, &o->set, n_args);
    for (mp_uint_t i = 0; i < n_args; i++) {
        micropy_set_lookup(mp_state, &o->set, items[i], MP_MAP_LOOKUP_ADD_IF_NOT_FOUND);
    }
    return MP_OBJ_FROM_PTR(o);
}

void micropy_obj_set_store(struct _mp_state_ctx_t *mp_state, mp_obj_t self_in, mp_obj_t item) {
    assert(MP_OBJ_IS_TYPE(self_in, &mp_type_set));
    mp_obj_set_t *self = MP_OBJ_TO_PTR(self_in);
    micropy_set_lookup(mp_state, &self->set, item, MP_MAP_LOOKUP_ADD_IF_NOT_FOUND);
}

#endif // MICROPY_PY_BUILTINS_SET
/*
 * This file is part of the Micro Python project, http://micropython.org/
 *
 * The MIT License (MIT)
 *
 * Copyright (c) 2013, 2014 Damien P. George
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

#include <stdlib.h>
#include <assert.h>

//#include "py/nlr.h"
//#include "py/obj.h"
//#include "py/runtime0.h"

/******************************************************************************/
/* singleton objects defined by Python                                        */

typedef struct _mp_obj_singleton_t {
    mp_obj_base_t base;
    qstr name;
} mp_obj_singleton_t;

STATIC void micropy_singleton_print(struct _mp_state_ctx_t *mp_state, const mp_print_t *print, mp_obj_t self_in, mp_print_kind_t kind) {
    (void)kind;
    mp_obj_singleton_t *self = MP_OBJ_TO_PTR(self_in);
    micropy_printf(mp_state, print, "%q", self->name);
}

const mp_obj_type_t mp_type_singleton = {
    { &mp_type_type },
    .name = MP_QSTR_,
    .print = micropy_singleton_print,
};

const mp_obj_singleton_t mp_const_ellipsis_obj = {{&mp_type_singleton}, MP_QSTR_Ellipsis};
#if MICROPY_PY_BUILTINS_NOTIMPLEMENTED
const mp_obj_singleton_t mp_const_notimplemented_obj = {{&mp_type_singleton}, MP_QSTR_NotImplemented};
#endif
/*
 * This file is part of the Micro Python project, http://micropython.org/
 *
 * The MIT License (MIT)
 *
 * Copyright (c) 2013, 2014 Damien P. George
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

#include <stdlib.h>
#include <assert.h>

//#include "py/nlr.h"
//#include "py/obj.h"
//#include "py/runtime0.h"

/******************************************************************************/
/* slice object                                                               */

#if MICROPY_PY_BUILTINS_SLICE

// TODO: This implements only variant of slice with 2 integer args only.
// CPython supports 3rd arg (step), plus args can be arbitrary Python objects.
typedef struct _mp_obj_slice_t {
    mp_obj_base_t base;
    mp_obj_t start;
    mp_obj_t stop;
    mp_obj_t step;
} mp_obj_slice_t;

STATIC void micropy_slice_print(struct _mp_state_ctx_t *mp_state, const mp_print_t *print, mp_obj_t o_in, mp_print_kind_t kind) {
    (void)kind;
    mp_obj_slice_t *o = MP_OBJ_TO_PTR(o_in);
    micropy_print_str(mp_state, print, "slice(");
    micropy_obj_print_helper(mp_state, print, o->start, PRINT_REPR);
    micropy_print_str(mp_state, print, ", ");
    micropy_obj_print_helper(mp_state, print, o->stop, PRINT_REPR);
    micropy_print_str(mp_state, print, ", ");
    micropy_obj_print_helper(mp_state, print, o->step, PRINT_REPR);
    micropy_print_str(mp_state, print, ")");
}

#if MICROPY_PY_BUILTINS_SLICE_ATTRS
STATIC void micropy_slice_attr(struct _mp_state_ctx_t *mp_state, mp_obj_t self_in, qstr attr, mp_obj_t *dest) {
    if (dest[0] != MP_OBJ_NULL) {
        // not load attribute
        return;
    }
    mp_obj_slice_t *self = MP_OBJ_TO_PTR(self_in);
    if (attr == MP_QSTR_start) {
        dest[0] = self->start;
    } else if (attr == MP_QSTR_stop) {
        dest[0] = self->stop;
    } else if (attr == MP_QSTR_step) {
        dest[0] = self->step;
    }
}
#endif

const mp_obj_type_t mp_type_slice = {
    { &mp_type_type },
    .name = MP_QSTR_slice,
    .print = micropy_slice_print,
#if MICROPY_PY_BUILTINS_SLICE_ATTRS
    .attr = micropy_slice_attr,
#endif
};

mp_obj_t micropy_obj_new_slice(struct _mp_state_ctx_t *mp_state, mp_obj_t ostart, mp_obj_t ostop, mp_obj_t ostep) {
    mp_obj_slice_t *o = micropy_m_new_obj(mp_state, mp_obj_slice_t);
    o->base.type = &mp_type_slice;
    o->start = ostart;
    o->stop = ostop;
    o->step = ostep;
    return MP_OBJ_FROM_PTR(o);
}

void micropy_obj_slice_get(struct _mp_state_ctx_t *mp_state, mp_obj_t self_in, mp_obj_t *start, mp_obj_t *stop, mp_obj_t *step) {
    assert(MP_OBJ_IS_TYPE(self_in, &mp_type_slice));
    mp_obj_slice_t *self = MP_OBJ_TO_PTR(self_in);
    *start = self->start;
    *stop = self->stop;
    *step = self->step;
}

#endif
/*
 * This file is part of the Micro Python project, http://micropython.org/
 *
 * The MIT License (MIT)
 *
 * Copyright (c) 2013, 2014 Damien P. George
 * Copyright (c) 2014 Paul Sokolovsky
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

#include <string.h>
#include <assert.h>

//#include "py/nlr.h"
//#include "py/unicode.h"
//#include "py/objstr.h"
//#include "py/objlist.h"
//#include "py/runtime0.h"
//#include "py/runtime.h"
//#include "py/stackctrl.h"

STATIC mp_obj_t micropy_str_modulo_format(struct _mp_state_ctx_t *mp_state, mp_obj_t pattern, mp_uint_t n_args, const mp_obj_t *args, mp_obj_t dict);

STATIC mp_obj_t micropy_obj_new_bytes_iterator(struct _mp_state_ctx_t *mp_state, mp_obj_t str);
STATIC NORETURN void micropy_bad_implicit_conversion(struct _mp_state_ctx_t *mp_state, mp_obj_t self_in);

/******************************************************************************/
/* str                                                                        */

void micropy_str_print_quoted(struct _mp_state_ctx_t *mp_state, const mp_print_t *print, const byte *str_data, mp_uint_t str_len, bool is_bytes) {
    // this escapes characters, but it will be very slow to print (calling print many times)
    bool has_single_quote = false;
    bool has_double_quote = false;
    for (const byte *s = str_data, *top = str_data + str_len; !has_double_quote && s < top; s++) {
        if (*s == '\'') {
            has_single_quote = true;
        } else if (*s == '"') {
            has_double_quote = true;
        }
    }
    int quote_char = '\'';
    if (has_single_quote && !has_double_quote) {
        quote_char = '"';
    }
    micropy_printf(mp_state, print, "%c", quote_char);
    for (const byte *s = str_data, *top = str_data + str_len; s < top; s++) {
        if (*s == quote_char) {
            micropy_printf(mp_state, print, "\\%c", quote_char);
        } else if (*s == '\\') {
            micropy_print_str(mp_state, print, "\\\\");
        } else if (*s >= 0x20 && *s != 0x7f && (!is_bytes || *s < 0x80)) {
            // In strings, anything which is not ascii control character
            // is printed as is, this includes characters in range 0x80-0xff
            // (which can be non-Latin letters, etc.)
            micropy_printf(mp_state, print, "%c", *s);
        } else if (*s == '\n') {
            micropy_print_str(mp_state, print, "\\n");
        } else if (*s == '\r') {
            micropy_print_str(mp_state, print, "\\r");
        } else if (*s == '\t') {
            micropy_print_str(mp_state, print, "\\t");
        } else {
            micropy_printf(mp_state, print, "\\x%02x", *s);
        }
    }
    micropy_printf(mp_state, print, "%c", quote_char);
}

#if MICROPY_PY_UJSON
void micropy_str_print_json(struct _mp_state_ctx_t *mp_state, const mp_print_t *print, const byte *str_data, size_t str_len) {
    // for JSON spec, see http://www.ietf.org/rfc/rfc4627.txt
    // if we are given a valid utf8-encoded string, we will print it in a JSON-conforming way
    micropy_print_str(mp_state, print, "\"");
    for (const byte *s = str_data, *top = str_data + str_len; s < top; s++) {
        if (*s == '"' || *s == '\\') {
            micropy_printf(mp_state, print, "\\%c", *s);
        } else if (*s >= 32) {
            // this will handle normal and utf-8 encoded chars
            micropy_printf(mp_state, print, "%c", *s);
        } else if (*s == '\n') {
            micropy_print_str(mp_state, print, "\\n");
        } else if (*s == '\r') {
            micropy_print_str(mp_state, print, "\\r");
        } else if (*s == '\t') {
            micropy_print_str(mp_state, print, "\\t");
        } else {
            // this will handle control chars
            micropy_printf(mp_state, print, "\\u%04x", *s);
        }
    }
    micropy_print_str(mp_state, print, "\"");
}
#endif

STATIC void micropy_str_print(struct _mp_state_ctx_t *mp_state, const mp_print_t *print, mp_obj_t self_in, mp_print_kind_t kind) {
    GET_STR_DATA_LEN(self_in, str_data, str_len);
    #if MICROPY_PY_UJSON
    if (kind == PRINT_JSON) {
        micropy_str_print_json(mp_state, print, str_data, str_len);
        return;
    }
    #endif
    #if !MICROPY_PY_BUILTINS_STR_UNICODE
    bool is_bytes = MP_OBJ_IS_TYPE(self_in, &mp_type_bytes);
    #else
    bool is_bytes = true;
    #endif
    if (kind == PRINT_RAW || (!MICROPY_PY_BUILTINS_STR_UNICODE && kind == PRINT_STR && !is_bytes)) {
        micropy_printf(mp_state, print, "%.*s", str_len, str_data);
    } else {
        if (is_bytes) {
            micropy_print_str(mp_state, print, "b");
        }
        micropy_str_print_quoted(mp_state, print, str_data, str_len, is_bytes);
    }
}

mp_obj_t micropy_obj_str_make_new(struct _mp_state_ctx_t *mp_state, const mp_obj_type_t *type, size_t n_args, size_t n_kw, const mp_obj_t *args) {
#if MICROPY_CPYTHON_COMPAT
    if (n_kw != 0) {
        micropy_arg_error_unimpl_kw(mp_state);
    }
#endif

    micropy_arg_check_num(mp_state, n_args, n_kw, 0, 3, false);

    switch (n_args) {
        case 0:
            return MP_OBJ_NEW_QSTR(MP_QSTR_);

        case 1: {
            vstr_t vstr;
            mp_print_t print;
            micropy_vstr_init_print(mp_state, &vstr, 16, &print);
            micropy_obj_print_helper(mp_state, &print, args[0], PRINT_STR);
            return micropy_obj_new_str_from_vstr(mp_state, type, &vstr);
        }

        default: // 2 or 3 args
            // TODO: validate 2nd/3rd args
            if (MP_OBJ_IS_TYPE(args[0], &mp_type_bytes)) {
                GET_STR_DATA_LEN(args[0], str_data, str_len);
                GET_STR_HASH(args[0], str_hash);
                mp_obj_str_t *o = MP_OBJ_TO_PTR(micropy_obj_new_str_of_type(mp_state, type, NULL, str_len));
                o->data = str_data;
                o->hash = str_hash;
                return MP_OBJ_FROM_PTR(o);
            } else {
                mp_buffer_info_t bufinfo;
                micropy_get_buffer_raise(mp_state, args[0], &bufinfo, MP_BUFFER_READ);
                return micropy_obj_new_str(mp_state, bufinfo.buf, bufinfo.len, false);
            }
    }
}

STATIC mp_obj_t micropy_bytes_make_new(struct _mp_state_ctx_t *mp_state, const mp_obj_type_t *type_in, size_t n_args, size_t n_kw, const mp_obj_t *args) {
    (void)type_in;

    #if MICROPY_CPYTHON_COMPAT
    if (n_kw != 0) {
        micropy_arg_error_unimpl_kw(mp_state);
    }
    #else
    (void)n_kw;
    #endif

    if (n_args == 0) {
        return mp_const_empty_bytes;
    }

    if (MP_OBJ_IS_STR(args[0])) {
        if (n_args < 2 || n_args > 3) {
            goto wrong_args;
        }
        GET_STR_DATA_LEN(args[0], str_data, str_len);
        GET_STR_HASH(args[0], str_hash);
        mp_obj_str_t *o = MP_OBJ_TO_PTR(micropy_obj_new_str_of_type(mp_state, &mp_type_bytes, NULL, str_len));
        o->data = str_data;
        o->hash = str_hash;
        return MP_OBJ_FROM_PTR(o);
    }

    if (n_args > 1) {
        goto wrong_args;
    }

    if (MP_OBJ_IS_SMALL_INT(args[0])) {
        uint len = MP_OBJ_SMALL_INT_VALUE(args[0]);
        vstr_t vstr;
        micropy_vstr_init_len(mp_state, &vstr, len);
        memset(vstr.buf, 0, len);
        return micropy_obj_new_str_from_vstr(mp_state, &mp_type_bytes, &vstr);
    }

    // check if argument has the buffer protocol
    mp_buffer_info_t bufinfo;
    if (micropy_get_buffer(mp_state, args[0], &bufinfo, MP_BUFFER_READ)) {
        return micropy_obj_new_str_of_type(mp_state, &mp_type_bytes, bufinfo.buf, bufinfo.len);
    }

    vstr_t vstr;
    // Try to create array of exact len if initializer len is known
    mp_obj_t len_in = micropy_obj_len_maybe(mp_state, args[0]);
    if (len_in == MP_OBJ_NULL) {
        micropy_vstr_init(mp_state, &vstr, 16);
    } else {
        mp_int_t len = MP_OBJ_SMALL_INT_VALUE(len_in);
        micropy_vstr_init(mp_state, &vstr, len);
    }

    mp_obj_t iterable = micropy_getiter(mp_state, args[0]);
    mp_obj_t item;
    while ((item = micropy_iternext(mp_state, iterable)) != MP_OBJ_STOP_ITERATION) {
        mp_int_t val = micropy_obj_get_int(mp_state, item);
        #if MICROPY_CPYTHON_COMPAT
        if (val < 0 || val > 255) {
            micropy_nlr_raise(mp_state, micropy_obj_new_exception_msg(mp_state, &mp_type_ValueError, "bytes value out of range"));
        }
        #endif
        micropy_vstr_add_byte(mp_state, &vstr, val);
    }

    return micropy_obj_new_str_from_vstr(mp_state, &mp_type_bytes, &vstr);

wrong_args:
    micropy_nlr_raise(mp_state, micropy_obj_new_exception_msg(mp_state, &mp_type_TypeError, "wrong number of arguments"));
}

// like strstr but with specified length and allows \0 bytes
// TODO replace with something more efficient/standard
const byte *micropy_find_subbytes(struct _mp_state_ctx_t *mp_state, const byte *haystack, mp_uint_t hlen, const byte *needle, mp_uint_t nlen, mp_int_t direction) {
    if (hlen >= nlen) {
        mp_uint_t str_index, str_index_end;
        if (direction > 0) {
            str_index = 0;
            str_index_end = hlen - nlen;
        } else {
            str_index = hlen - nlen;
            str_index_end = 0;
        }
        for (;;) {
            if (memcmp(&haystack[str_index], needle, nlen) == 0) {
                //found
                return haystack + str_index;
            }
            if (str_index == str_index_end) {
                //not found
                break;
            }
            str_index += direction;
        }
    }
    return NULL;
}

// Note: this function is used to check if an object is a str or bytes, which
// works because both those types use it as their binary_op method.  Revisit
// MP_OBJ_IS_STR_OR_BYTES if this fact changes.
mp_obj_t micropy_obj_str_binary_op(struct _mp_state_ctx_t *mp_state, mp_uint_t op, mp_obj_t lhs_in, mp_obj_t rhs_in) {
    // check for modulo
    if (op == MP_BINARY_OP_MODULO) {
        mp_obj_t *args;
        mp_uint_t n_args;
        mp_obj_t dict = MP_OBJ_NULL;
        if (MP_OBJ_IS_TYPE(rhs_in, &mp_type_tuple)) {
            // TODO: Support tuple subclasses?
            micropy_obj_tuple_get(mp_state, rhs_in, &n_args, &args);
        } else if (MP_OBJ_IS_TYPE(rhs_in, &mp_type_dict)) {
            args = NULL;
            n_args = 0;
            dict = rhs_in;
        } else {
            args = &rhs_in;
            n_args = 1;
        }
        return micropy_str_modulo_format(mp_state, lhs_in, n_args, args, dict);
    }

    // from now on we need lhs type and data, so extract them
    mp_obj_type_t *lhs_type = micropy_obj_get_type(mp_state, lhs_in);
    GET_STR_DATA_LEN(lhs_in, lhs_data, lhs_len);

    // check for multiply
    if (op == MP_BINARY_OP_MULTIPLY) {
        mp_int_t n;
        if (!micropy_obj_get_int_maybe(mp_state, rhs_in, &n)) {
            return MP_OBJ_NULL; // op not supported
        }
        if (n <= 0) {
            if (lhs_type == &mp_type_str) {
                return MP_OBJ_NEW_QSTR(MP_QSTR_); // empty str
            } else {
                return mp_const_empty_bytes;
            }
        }
        vstr_t vstr;
        micropy_vstr_init_len(mp_state, &vstr, lhs_len * n);
        micropy_seq_multiply(mp_state, lhs_data, sizeof(*lhs_data), lhs_len, n, vstr.buf);
        return micropy_obj_new_str_from_vstr(mp_state, lhs_type, &vstr);
    }

    // From now on all operations allow:
    //    - str with str
    //    - bytes with bytes
    //    - bytes with bytearray
    //    - bytes with array.array
    // To do this efficiently we use the buffer protocol to extract the raw
    // data for the rhs, but only if the lhs is a bytes object.
    //
    // NOTE: CPython does not allow comparison between bytes ard array.array
    // (even if the array is of type 'b'), even though it allows addition of
    // such types.  We are not compatible with this (we do allow comparison
    // of bytes with anything that has the buffer protocol).  It would be
    // easy to "fix" this with a bit of extra logic below, but it costs code
    // size and execution time so we don't.

    const byte *rhs_data;
    mp_uint_t rhs_len;
    if (lhs_type == micropy_obj_get_type(mp_state, rhs_in)) {
        GET_STR_DATA_LEN(rhs_in, rhs_data_, rhs_len_);
        rhs_data = rhs_data_;
        rhs_len = rhs_len_;
    } else if (lhs_type == &mp_type_bytes) {
        mp_buffer_info_t bufinfo;
        if (!micropy_get_buffer(mp_state, rhs_in, &bufinfo, MP_BUFFER_READ)) {
            return MP_OBJ_NULL; // op not supported
        }
        rhs_data = bufinfo.buf;
        rhs_len = bufinfo.len;
    } else {
        // incompatible types
        return MP_OBJ_NULL; // op not supported
    }

    switch (op) {
        case MP_BINARY_OP_ADD:
        case MP_BINARY_OP_INPLACE_ADD: {
            vstr_t vstr;
            micropy_vstr_init_len(mp_state, &vstr, lhs_len + rhs_len);
            memcpy(vstr.buf, lhs_data, lhs_len);
            memcpy(vstr.buf + lhs_len, rhs_data, rhs_len);
            return micropy_obj_new_str_from_vstr(mp_state, lhs_type, &vstr);
        }

        case MP_BINARY_OP_IN:
            /* NOTE `a in b` is `b.__contains__(a)` */
            return micropy_obj_new_bool(mp_state, micropy_find_subbytes(mp_state, lhs_data, lhs_len, rhs_data, rhs_len, 1) != NULL);

        //case MP_BINARY_OP_NOT_EQUAL: // This is never passed here
        case MP_BINARY_OP_EQUAL: // This will be passed only for bytes, str is dealt with in mp_obj_equal()
        case MP_BINARY_OP_LESS:
        case MP_BINARY_OP_LESS_EQUAL:
        case MP_BINARY_OP_MORE:
        case MP_BINARY_OP_MORE_EQUAL:
            return micropy_obj_new_bool(mp_state, micropy_seq_cmp_bytes(mp_state, op, lhs_data, lhs_len, rhs_data, rhs_len));
    }

    return MP_OBJ_NULL; // op not supported
}

#if !MICROPY_PY_BUILTINS_STR_UNICODE
// objstrunicode defines own version
const byte *micropy_str_index_to_ptr(struct _mp_state_ctx_t *mp_state, const mp_obj_type_t *type, const byte *self_data, size_t self_len,
                             mp_obj_t index, bool is_slice) {
    mp_uint_t index_val = micropy_get_index(mp_state, type, self_len, index, is_slice);
    return self_data + index_val;
}
#endif

// This is used for both bytes and 8-bit strings. This is not used for unicode strings.
STATIC mp_obj_t micropy_bytes_subscr(struct _mp_state_ctx_t *mp_state, mp_obj_t self_in, mp_obj_t index, mp_obj_t value) {
    mp_obj_type_t *type = micropy_obj_get_type(mp_state, self_in);
    GET_STR_DATA_LEN(self_in, self_data, self_len);
    if (value == MP_OBJ_SENTINEL) {
        // load
#if MICROPY_PY_BUILTINS_SLICE
        if (MP_OBJ_IS_TYPE(index, &mp_type_slice)) {
            mp_bound_slice_t slice;
            if (!micropy_seq_get_fast_slice_indexes(mp_state, self_len, index, &slice)) {
                micropy_not_implemented(mp_state, "only slices with step=1 (aka None) are supported");
            }
            return micropy_obj_new_str_of_type(mp_state, type, self_data + slice.start, slice.stop - slice.start);
        }
#endif
        mp_uint_t index_val = micropy_get_index(mp_state, type, self_len, index, false);
        // If we have unicode enabled the type will always be bytes, so take the short cut.
        if (MICROPY_PY_BUILTINS_STR_UNICODE || type == &mp_type_bytes) {
            return MP_OBJ_NEW_SMALL_INT(self_data[index_val]);
        } else {
            return micropy_obj_new_str(mp_state, (char*)&self_data[index_val], 1, true);
        }
    } else {
        return MP_OBJ_NULL; // op not supported
    }
}

STATIC mp_obj_t micropy_str_join(struct _mp_state_ctx_t *mp_state, mp_obj_t self_in, mp_obj_t arg) {
    assert(MP_OBJ_IS_STR_OR_BYTES(self_in));
    const mp_obj_type_t *self_type = micropy_obj_get_type(mp_state, self_in);

    // get separation string
    GET_STR_DATA_LEN(self_in, sep_str, sep_len);

    // process args
    mp_uint_t seq_len;
    mp_obj_t *seq_items;
    if (MP_OBJ_IS_TYPE(arg, &mp_type_tuple)) {
        micropy_obj_tuple_get(mp_state, arg, &seq_len, &seq_items);
    } else {
        if (!MP_OBJ_IS_TYPE(arg, &mp_type_list)) {
            // arg is not a list, try to convert it to one
            // TODO: Try to optimize?
            arg = mp_type_list.make_new(mp_state, &mp_type_list, 1, 0, &arg);
        }
        micropy_obj_list_get(mp_state, arg, &seq_len, &seq_items);
    }

    // count required length
    mp_uint_t required_len = 0;
    for (mp_uint_t i = 0; i < seq_len; i++) {
        if (micropy_obj_get_type(mp_state, seq_items[i]) != self_type) {
            micropy_nlr_raise(mp_state, micropy_obj_new_exception_msg(mp_state, &mp_type_TypeError,
                "join expects a list of str/bytes objects consistent with self object"));
        }
        if (i > 0) {
            required_len += sep_len;
        }
        GET_STR_LEN(seq_items[i], l);
        required_len += l;
    }

    // make joined string
    vstr_t vstr;
    micropy_vstr_init_len(mp_state, &vstr, required_len);
    byte *data = (byte*)vstr.buf;
    for (mp_uint_t i = 0; i < seq_len; i++) {
        if (i > 0) {
            memcpy(data, sep_str, sep_len);
            data += sep_len;
        }
        GET_STR_DATA_LEN(seq_items[i], s, l);
        memcpy(data, s, l);
        data += l;
    }

    // return joined string
    return micropy_obj_new_str_from_vstr(mp_state, self_type, &vstr);
}

mp_obj_t micropy_obj_str_split(struct _mp_state_ctx_t *mp_state, size_t n_args, const mp_obj_t *args) {
    const mp_obj_type_t *self_type = micropy_obj_get_type(mp_state, args[0]);
    mp_int_t splits = -1;
    mp_obj_t sep = mp_const_none;
    if (n_args > 1) {
        sep = args[1];
        if (n_args > 2) {
            splits = micropy_obj_get_int(mp_state, args[2]);
        }
    }

    mp_obj_t res = micropy_obj_new_list(mp_state, 0, NULL);
    GET_STR_DATA_LEN(args[0], s, len);
    const byte *top = s + len;

    if (sep == mp_const_none) {
        // sep not given, so separate on whitespace

        // Initial whitespace is not counted as split, so we pre-do it
        while (s < top && unichar_isspace(*s)) s++;
        while (s < top && splits != 0) {
            const byte *start = s;
            while (s < top && !unichar_isspace(*s)) s++;
            micropy_obj_list_append(mp_state, res, micropy_obj_new_str_of_type(mp_state, self_type, start, s - start));
            if (s >= top) {
                break;
            }
            while (s < top && unichar_isspace(*s)) s++;
            if (splits > 0) {
                splits--;
            }
        }

        if (s < top) {
            micropy_obj_list_append(mp_state, res, micropy_obj_new_str_of_type(mp_state, self_type, s, top - s));
        }

    } else {
        // sep given
        if (micropy_obj_get_type(mp_state, sep) != self_type) {
            micropy_bad_implicit_conversion(mp_state, sep);
        }

        mp_uint_t sep_len;
        const char *sep_str = micropy_obj_str_get_data(mp_state, sep, &sep_len);

        if (sep_len == 0) {
            micropy_nlr_raise(mp_state, micropy_obj_new_exception_msg(mp_state, &mp_type_ValueError, "empty separator"));
        }

        for (;;) {
            const byte *start = s;
            for (;;) {
                if (splits == 0 || s + sep_len > top) {
                    s = top;
                    break;
                } else if (memcmp(s, sep_str, sep_len) == 0) {
                    break;
                }
                s++;
            }
            micropy_obj_list_append(mp_state, res, micropy_obj_new_str_of_type(mp_state, self_type, start, s - start));
            if (s >= top) {
                break;
            }
            s += sep_len;
            if (splits > 0) {
                splits--;
            }
        }
    }

    return res;
}

#if MICROPY_PY_BUILTINS_STR_SPLITLINES
STATIC mp_obj_t micropy_str_splitlines(struct _mp_state_ctx_t *mp_state, size_t n_args, const mp_obj_t *pos_args, mp_map_t *kw_args) {
    enum { ARG_keepends };
    static const mp_arg_t allowed_args[] = {
        { MP_QSTR_keepends, MP_ARG_BOOL, {.u_bool = false} },
    };

    // parse args
    mp_arg_val_t args[MP_ARRAY_SIZE(allowed_args)];
    micropy_arg_parse_all(mp_state, n_args - 1, pos_args + 1, kw_args, MP_ARRAY_SIZE(allowed_args), allowed_args, args);

    const mp_obj_type_t *self_type = micropy_obj_get_type(mp_state, pos_args[0]);
    mp_obj_t res = micropy_obj_new_list(mp_state, 0, NULL);

    GET_STR_DATA_LEN(pos_args[0], s, len);
    const byte *top = s + len;

    while (s < top) {
        const byte *start = s;
        size_t match = 0;
        while (s < top) {
            if (*s == '\n') {
                match = 1;
                break;
            } else if (*s == '\r') {
                if (s[1] == '\n') {
                    match = 2;
                } else {
                    match = 1;
                }
                break;
            }
            s++;
        }
        size_t sub_len = s - start;
        if (args[ARG_keepends].u_bool) {
            sub_len += match;
        }
        micropy_obj_list_append(mp_state, res, micropy_obj_new_str_of_type(mp_state, self_type, start, sub_len));
        s += match;
    }

    return res;
}
#endif

STATIC mp_obj_t micropy_str_rsplit(struct _mp_state_ctx_t *mp_state, size_t n_args, const mp_obj_t *args) {
    if (n_args < 3) {
        // If we don't have split limit, it doesn't matter from which side
        // we split.
        return micropy_obj_str_split(mp_state, n_args, args);
    }
    const mp_obj_type_t *self_type = micropy_obj_get_type(mp_state, args[0]);
    mp_obj_t sep = args[1];
    GET_STR_DATA_LEN(args[0], s, len);

    mp_int_t splits = micropy_obj_get_int(mp_state, args[2]);
    mp_int_t org_splits = splits;
    // Preallocate list to the max expected # of elements, as we
    // will fill it from the end.
    mp_obj_list_t *res = MP_OBJ_TO_PTR(micropy_obj_new_list(mp_state, splits + 1, NULL));
    mp_int_t idx = splits;

    if (sep == mp_const_none) {
        micropy_not_implemented(mp_state, "rsplit(None,n)");
    } else {
        mp_uint_t sep_len;
        const char *sep_str = micropy_obj_str_get_data(mp_state, sep, &sep_len);

        if (sep_len == 0) {
            micropy_nlr_raise(mp_state, micropy_obj_new_exception_msg(mp_state, &mp_type_ValueError, "empty separator"));
        }

        const byte *beg = s;
        const byte *last = s + len;
        for (;;) {
            s = last - sep_len;
            for (;;) {
                if (splits == 0 || s < beg) {
                    break;
                } else if (memcmp(s, sep_str, sep_len) == 0) {
                    break;
                }
                s--;
            }
            if (s < beg || splits == 0) {
                res->items[idx] = micropy_obj_new_str_of_type(mp_state, self_type, beg, last - beg);
                break;
            }
            res->items[idx--] = micropy_obj_new_str_of_type(mp_state, self_type, s + sep_len, last - s - sep_len);
            last = s;
            if (splits > 0) {
                splits--;
            }
        }
        if (idx != 0) {
            // We split less parts than split limit, now go cleanup surplus
            mp_int_t used = org_splits + 1 - idx;
            memmove(res->items, &res->items[idx], used * sizeof(mp_obj_t));
            micropy_seq_clear(mp_state, res->items, used, res->alloc, sizeof(*res->items));
            res->len = used;
        }
    }

    return MP_OBJ_FROM_PTR(res);
}

STATIC mp_obj_t micropy_str_finder(struct _mp_state_ctx_t *mp_state, mp_uint_t n_args, const mp_obj_t *args, mp_int_t direction, bool is_index) {
    const mp_obj_type_t *self_type = micropy_obj_get_type(mp_state, args[0]);
    assert(2 <= n_args && n_args <= 4);
    assert(MP_OBJ_IS_STR_OR_BYTES(args[0]));

    // check argument type
    if (micropy_obj_get_type(mp_state, args[1]) != self_type) {
        micropy_bad_implicit_conversion(mp_state, args[1]);
    }

    GET_STR_DATA_LEN(args[0], haystack, haystack_len);
    GET_STR_DATA_LEN(args[1], needle, needle_len);

    const byte *start = haystack;
    const byte *end = haystack + haystack_len;
    if (n_args >= 3 && args[2] != mp_const_none) {
        start = micropy_str_index_to_ptr(mp_state, self_type, haystack, haystack_len, args[2], true);
    }
    if (n_args >= 4 && args[3] != mp_const_none) {
        end = micropy_str_index_to_ptr(mp_state, self_type, haystack, haystack_len, args[3], true);
    }

    const byte *p = micropy_find_subbytes(mp_state, start, end - start, needle, needle_len, direction);
    if (p == NULL) {
        // not found
        if (is_index) {
            micropy_nlr_raise(mp_state, micropy_obj_new_exception_msg(mp_state, &mp_type_ValueError, "substring not found"));
        } else {
            return MP_OBJ_NEW_SMALL_INT(-1);
        }
    } else {
        // found
        #if MICROPY_PY_BUILTINS_STR_UNICODE
        if (self_type == &mp_type_str) {
            return MP_OBJ_NEW_SMALL_INT(utf8_ptr_to_index(haystack, p));
        }
        #endif
        return MP_OBJ_NEW_SMALL_INT(p - haystack);
    }
}

STATIC mp_obj_t micropy_str_find(struct _mp_state_ctx_t *mp_state, size_t n_args, const mp_obj_t *args) {
    return micropy_str_finder(mp_state, n_args, args, 1, false);
}

STATIC mp_obj_t micropy_str_rfind(struct _mp_state_ctx_t *mp_state, size_t n_args, const mp_obj_t *args) {
    return micropy_str_finder(mp_state, n_args, args, -1, false);
}

STATIC mp_obj_t micropy_str_index(struct _mp_state_ctx_t *mp_state, size_t n_args, const mp_obj_t *args) {
    return micropy_str_finder(mp_state, n_args, args, 1, true);
}

STATIC mp_obj_t micropy_str_rindex(struct _mp_state_ctx_t *mp_state, size_t n_args, const mp_obj_t *args) {
    return micropy_str_finder(mp_state, n_args, args, -1, true);
}

// TODO: (Much) more variety in args
STATIC mp_obj_t micropy_str_startswith(struct _mp_state_ctx_t *mp_state, size_t n_args, const mp_obj_t *args) {
    const mp_obj_type_t *self_type = micropy_obj_get_type(mp_state, args[0]);
    GET_STR_DATA_LEN(args[0], str, str_len);
    GET_STR_DATA_LEN(args[1], prefix, prefix_len);
    const byte *start = str;
    if (n_args > 2) {
        start = micropy_str_index_to_ptr(mp_state, self_type, str, str_len, args[2], true);
    }
    if (prefix_len + (start - str) > str_len) {
        return mp_const_false;
    }
    return micropy_obj_new_bool(mp_state, memcmp(start, prefix, prefix_len) == 0);
}

STATIC mp_obj_t micropy_str_endswith(struct _mp_state_ctx_t *mp_state, size_t n_args, const mp_obj_t *args) {
    GET_STR_DATA_LEN(args[0], str, str_len);
    GET_STR_DATA_LEN(args[1], suffix, suffix_len);
    if (n_args > 2) {
        micropy_not_implemented(mp_state, "start/end indices");
    }

    if (suffix_len > str_len) {
        return mp_const_false;
    }
    return micropy_obj_new_bool(mp_state, memcmp(str + (str_len - suffix_len), suffix, suffix_len) == 0);
}

enum { LSTRIP, RSTRIP, STRIP };

STATIC mp_obj_t micropy_str_uni_strip(struct _mp_state_ctx_t *mp_state, int type, mp_uint_t n_args, const mp_obj_t *args) {
    assert(1 <= n_args && n_args <= 2);
    assert(MP_OBJ_IS_STR_OR_BYTES(args[0]));
    const mp_obj_type_t *self_type = micropy_obj_get_type(mp_state, args[0]);

    const byte *chars_to_del;
    uint chars_to_del_len;
    static const byte whitespace[] = " \t\n\r\v\f";

    if (n_args == 1) {
        chars_to_del = whitespace;
        chars_to_del_len = sizeof(whitespace);
    } else {
        if (micropy_obj_get_type(mp_state, args[1]) != self_type) {
            micropy_bad_implicit_conversion(mp_state, args[1]);
        }
        GET_STR_DATA_LEN(args[1], s, l);
        chars_to_del = s;
        chars_to_del_len = l;
    }

    GET_STR_DATA_LEN(args[0], orig_str, orig_str_len);

    mp_uint_t first_good_char_pos = 0;
    bool first_good_char_pos_set = false;
    mp_uint_t last_good_char_pos = 0;
    mp_uint_t i = 0;
    mp_int_t delta = 1;
    if (type == RSTRIP) {
        i = orig_str_len - 1;
        delta = -1;
    }
    for (mp_uint_t len = orig_str_len; len > 0; len--) {
        if (micropy_find_subbytes(mp_state, chars_to_del, chars_to_del_len, &orig_str[i], 1, 1) == NULL) {
            if (!first_good_char_pos_set) {
                first_good_char_pos_set = true;
                first_good_char_pos = i;
                if (type == LSTRIP) {
                    last_good_char_pos = orig_str_len - 1;
                    break;
                } else if (type == RSTRIP) {
                    first_good_char_pos = 0;
                    last_good_char_pos = i;
                    break;
                }
            }
            last_good_char_pos = i;
        }
        i += delta;
    }

    if (!first_good_char_pos_set) {
        // string is all whitespace, return ''
        if (self_type == &mp_type_str) {
            return MP_OBJ_NEW_QSTR(MP_QSTR_);
        } else {
            return mp_const_empty_bytes;
        }
    }

    assert(last_good_char_pos >= first_good_char_pos);
    //+1 to accomodate the last character
    mp_uint_t stripped_len = last_good_char_pos - first_good_char_pos + 1;
    if (stripped_len == orig_str_len) {
        // If nothing was stripped, don't bother to dup original string
        // TODO: watch out for this case when we'll get to bytearray.strip()
        assert(first_good_char_pos == 0);
        return args[0];
    }
    return micropy_obj_new_str_of_type(mp_state, self_type, orig_str + first_good_char_pos, stripped_len);
}

STATIC mp_obj_t micropy_str_strip(struct _mp_state_ctx_t *mp_state, size_t n_args, const mp_obj_t *args) {
    return micropy_str_uni_strip(mp_state, STRIP, n_args, args);
}

STATIC mp_obj_t micropy_str_lstrip(struct _mp_state_ctx_t *mp_state, size_t n_args, const mp_obj_t *args) {
    return micropy_str_uni_strip(mp_state, LSTRIP, n_args, args);
}

STATIC mp_obj_t micropy_str_rstrip(struct _mp_state_ctx_t *mp_state, size_t n_args, const mp_obj_t *args) {
    return micropy_str_uni_strip(mp_state, RSTRIP, n_args, args);
}

#if MICROPY_PY_BUILTINS_STR_CENTER
STATIC mp_obj_t micropy_str_center(struct _mp_state_ctx_t *mp_state, mp_obj_t str_in, mp_obj_t width_in) {
    GET_STR_DATA_LEN(str_in, str, str_len);
    mp_uint_t width = micropy_obj_get_int(mp_state, width_in);
    if (str_len >= width) {
        return str_in;
    }

    vstr_t vstr;
    micropy_vstr_init_len(mp_state, &vstr, width);
    memset(vstr.buf, ' ', width);
    int left = (width - str_len) / 2;
    memcpy(vstr.buf + left, str, str_len);
    return micropy_obj_new_str_from_vstr(mp_state, micropy_obj_get_type(mp_state, str_in), &vstr);
}
#endif

// Takes an int arg, but only parses unsigned numbers, and only changes
// *num if at least one digit was parsed.
STATIC const char *micropy_str_to_int(struct _mp_state_ctx_t *mp_state, const char *str, const char *top, int *num) {
    if (str < top && '0' <= *str && *str <= '9') {
        *num = 0;
        do {
            *num = *num * 10 + (*str - '0');
            str++;
        }
        while (str < top && '0' <= *str && *str <= '9');
    }
    return str;
}

STATIC bool micropy_isalignment(struct _mp_state_ctx_t *mp_state, char ch) {
    return ch && strchr("<>=^", ch) != NULL;
}

STATIC bool micropy_istype(struct _mp_state_ctx_t *mp_state, char ch) {
    return ch && strchr("bcdeEfFgGnosxX%", ch) != NULL;
}

STATIC bool micropy_arg_looks_integer(struct _mp_state_ctx_t *mp_state, mp_obj_t arg) {
    return MP_OBJ_IS_TYPE(arg, &mp_type_bool) || MP_OBJ_IS_INT(arg);
}

STATIC bool micropy_arg_looks_numeric(struct _mp_state_ctx_t *mp_state, mp_obj_t arg) {
    return micropy_arg_looks_integer(mp_state, arg)
#if MICROPY_PY_BUILTINS_FLOAT
        || micropy_obj_is_float(mp_state, arg)
#endif
    ;
}

STATIC mp_obj_t micropy_arg_as_int(struct _mp_state_ctx_t *mp_state, mp_obj_t arg) {
#if MICROPY_PY_BUILTINS_FLOAT
    if (micropy_obj_is_float(mp_state, arg)) {
        return micropy_obj_new_int_from_float(mp_state, micropy_obj_float_get(mp_state, arg));
    }
#endif
    return arg;
}

STATIC NORETURN void micropy_terse_str_format_value_error(struct _mp_state_ctx_t *mp_state) {
    micropy_nlr_raise(mp_state, micropy_obj_new_exception_msg(mp_state, &mp_type_ValueError, "bad format string"));
}

STATIC vstr_t micropy_obj_str_format_helper(struct _mp_state_ctx_t *mp_state, const char *str, const char *top, int *arg_i, mp_uint_t n_args, const mp_obj_t *args, mp_map_t *kwargs) {
    vstr_t vstr;
    mp_print_t print;
    micropy_vstr_init_print(mp_state, &vstr, 16, &print);

    for (; str < top; str++) {
        if (*str == '}') {
            str++;
            if (str < top && *str == '}') {
                micropy_vstr_add_byte(mp_state, &vstr, '}');
                continue;
            }
            if (MICROPY_ERROR_REPORTING == MICROPY_ERROR_REPORTING_TERSE) {
                micropy_terse_str_format_value_error(mp_state);
            } else {
                micropy_nlr_raise(mp_state, micropy_obj_new_exception_msg(mp_state, &mp_type_ValueError,
                    "single '}' encountered in format string"));
            }
        }
        if (*str != '{') {
            micropy_vstr_add_byte(mp_state, &vstr, *str);
            continue;
        }

        str++;
        if (str < top && *str == '{') {
            micropy_vstr_add_byte(mp_state, &vstr, '{');
            continue;
        }

        // replacement_field ::=  "{" [field_name] ["!" conversion] [":" format_spec] "}"

        const char *field_name = NULL;
        const char *field_name_top = NULL;
        char conversion = '\0';
        const char *format_spec = NULL;

        if (str < top && *str != '}' && *str != '!' && *str != ':') {
            field_name = (const char *)str;
            while (str < top && *str != '}' && *str != '!' && *str != ':') {
                ++str;
            }
            field_name_top = (const char *)str;
        }

        // conversion ::=  "r" | "s"

        if (str < top && *str == '!') {
            str++;
            if (str < top && (*str == 'r' || *str == 's')) {
                conversion = *str++;
            } else {
                if (MICROPY_ERROR_REPORTING == MICROPY_ERROR_REPORTING_TERSE) {
                    micropy_terse_str_format_value_error(mp_state);
                } else if (MICROPY_ERROR_REPORTING == MICROPY_ERROR_REPORTING_NORMAL) {
                    micropy_nlr_raise(mp_state, micropy_obj_new_exception_msg(mp_state, &mp_type_ValueError,
                        "bad conversion specifier"));
                } else {
                    if (str >= top) {
                        micropy_nlr_raise(mp_state, micropy_obj_new_exception_msg(mp_state, &mp_type_ValueError,
                            "end of format while looking for conversion specifier"));
                    } else {
                        micropy_nlr_raise(mp_state, micropy_obj_new_exception_msg_varg(mp_state, &mp_type_ValueError,
                            "unknown conversion specifier %c", *str));
                    }
                }
            }
        }

        if (str < top && *str == ':') {
            str++;
            // {:} is the same as {}, which is the same as {!s}
            // This makes a difference when passing in a True or False
            // '{}'.format(True) returns 'True'
            // '{:d}'.format(True) returns '1'
            // So we treat {:} as {} and this later gets treated to be {!s}
            if (*str != '}') {
                format_spec = str;
                for (int nest = 1; str < top;) {
                    if (*str == '{') {
                        ++nest;
                    } else if (*str == '}') {
                        if (--nest == 0) {
                            break;
                        }
                    }
                    ++str;
                }
            }
        }
        if (str >= top) {
            if (MICROPY_ERROR_REPORTING == MICROPY_ERROR_REPORTING_TERSE) {
                micropy_terse_str_format_value_error(mp_state);
            } else {
                micropy_nlr_raise(mp_state, micropy_obj_new_exception_msg(mp_state, &mp_type_ValueError,
                    "unmatched '{' in format"));
            }
        }
        if (*str != '}') {
            if (MICROPY_ERROR_REPORTING == MICROPY_ERROR_REPORTING_TERSE) {
                micropy_terse_str_format_value_error(mp_state);
            } else {
                micropy_nlr_raise(mp_state, micropy_obj_new_exception_msg(mp_state, &mp_type_ValueError,
                    "expected ':' after format specifier"));
            }
        }

        mp_obj_t arg = mp_const_none;

        if (field_name) {
            int index = 0;
            if (MP_LIKELY(unichar_isdigit(*field_name))) {
                if (*arg_i > 0) {
                    if (MICROPY_ERROR_REPORTING == MICROPY_ERROR_REPORTING_TERSE) {
                        micropy_terse_str_format_value_error(mp_state);
                    } else {
                        micropy_nlr_raise(mp_state, micropy_obj_new_exception_msg(mp_state, &mp_type_ValueError,
                            "can't switch from automatic field numbering to manual field specification"));
                    }
                }
                field_name = micropy_str_to_int(mp_state, field_name, field_name_top, &index);
                if ((uint)index >= n_args - 1) {
                    micropy_nlr_raise(mp_state, micropy_obj_new_exception_msg(mp_state, &mp_type_IndexError, "tuple index out of range"));
                }
                arg = args[index + 1];
                *arg_i = -1;
            } else {
                const char *lookup;
                for (lookup = field_name; lookup < field_name_top && *lookup != '.' && *lookup != '['; lookup++);
                mp_obj_t field_q = micropy_obj_new_str(mp_state, field_name, lookup - field_name, true/*?*/);
                field_name = lookup;
                mp_map_elem_t *key_elem = micropy_map_lookup(mp_state, kwargs, field_q, MP_MAP_LOOKUP);
                if (key_elem == NULL) {
                    micropy_nlr_raise(mp_state, micropy_obj_new_exception_arg1(mp_state, &mp_type_KeyError, field_q));
                }
                arg = key_elem->value;
            }
            if (field_name < field_name_top) {
                micropy_not_implemented(mp_state, "attributes not supported yet");
            }
        } else {
            if (*arg_i < 0) {
                if (MICROPY_ERROR_REPORTING == MICROPY_ERROR_REPORTING_TERSE) {
                    micropy_terse_str_format_value_error(mp_state);
                } else {
                    micropy_nlr_raise(mp_state, micropy_obj_new_exception_msg(mp_state, &mp_type_ValueError,
                        "can't switch from manual field specification to automatic field numbering"));
                }
            }
            if ((uint)*arg_i >= n_args - 1) {
                micropy_nlr_raise(mp_state, micropy_obj_new_exception_msg(mp_state, &mp_type_IndexError, "tuple index out of range"));
            }
            arg = args[(*arg_i) + 1];
            (*arg_i)++;
        }
        if (!format_spec && !conversion) {
            conversion = 's';
        }
        if (conversion) {
            mp_print_kind_t print_kind;
            if (conversion == 's') {
                print_kind = PRINT_STR;
            } else {
                assert(conversion == 'r');
                print_kind = PRINT_REPR;
            }
            vstr_t arg_vstr;
            mp_print_t arg_print;
            micropy_vstr_init_print(mp_state, &arg_vstr, 16, &arg_print);
            micropy_obj_print_helper(mp_state, &arg_print, arg, print_kind);
            arg = micropy_obj_new_str_from_vstr(mp_state, &mp_type_str, &arg_vstr);
        }

        char sign = '\0';
        char fill = '\0';
        char align = '\0';
        int width = -1;
        int precision = -1;
        char type = '\0';
        int flags = 0;

        if (format_spec) {
            // The format specifier (from http://docs.python.org/2/library/string.html#formatspec)
            //
            // [[fill]align][sign][#][0][width][,][.precision][type]
            // fill        ::=  <any character>
            // align       ::=  "<" | ">" | "=" | "^"
            // sign        ::=  "+" | "-" | " "
            // width       ::=  integer
            // precision   ::=  integer
            // type        ::=  "b" | "c" | "d" | "e" | "E" | "f" | "F" | "g" | "G" | "n" | "o" | "s" | "x" | "X" | "%"

            // recursively call the formatter to format any nested specifiers
            MP_STACK_CHECK();
            vstr_t format_spec_vstr = micropy_obj_str_format_helper(mp_state, format_spec, str, arg_i, n_args, args, kwargs);
            const char *s = micropy_vstr_null_terminated_str(mp_state, &format_spec_vstr);
            const char *stop = s + format_spec_vstr.len;
            if (micropy_isalignment(mp_state, *s)) {
                align = *s++;
            } else if (*s && micropy_isalignment(mp_state, s[1])) {
                fill = *s++;
                align = *s++;
            }
            if (*s == '+' || *s == '-' || *s == ' ') {
                if (*s == '+') {
                    flags |= PF_FLAG_SHOW_SIGN;
                } else if (*s == ' ') {
                    flags |= PF_FLAG_SPACE_SIGN;
                }
                sign = *s++;
            }
            if (*s == '#') {
                flags |= PF_FLAG_SHOW_PREFIX;
                s++;
            }
            if (*s == '0') {
                if (!align) {
                    align = '=';
                }
                if (!fill) {
                    fill = '0';
                }
            }
            s = micropy_str_to_int(mp_state, s, stop, &width);
            if (*s == ',') {
                flags |= PF_FLAG_SHOW_COMMA;
                s++;
            }
            if (*s == '.') {
                s++;
                s = micropy_str_to_int(mp_state, s, stop, &precision);
            }
            if (micropy_istype(mp_state, *s)) {
                type = *s++;
            }
            if (*s) {
                if (MICROPY_ERROR_REPORTING == MICROPY_ERROR_REPORTING_TERSE) {
                    micropy_terse_str_format_value_error(mp_state);
                } else {
                    micropy_nlr_raise(mp_state, micropy_obj_new_exception_msg(mp_state, &mp_type_ValueError,
                        "invalid format specifier"));
                }
            }
            micropy_vstr_clear(mp_state, &format_spec_vstr);
        }
        if (!align) {
            if (micropy_arg_looks_numeric(mp_state, arg)) {
                align = '>';
            } else {
                align = '<';
            }
        }
        if (!fill) {
            fill = ' ';
        }

        if (sign) {
            if (type == 's') {
                if (MICROPY_ERROR_REPORTING == MICROPY_ERROR_REPORTING_TERSE) {
                    micropy_terse_str_format_value_error(mp_state);
                } else {
                    micropy_nlr_raise(mp_state, micropy_obj_new_exception_msg(mp_state, &mp_type_ValueError,
                        "sign not allowed in string format specifier"));
                }
            }
            if (type == 'c') {
                if (MICROPY_ERROR_REPORTING == MICROPY_ERROR_REPORTING_TERSE) {
                    micropy_terse_str_format_value_error(mp_state);
                } else {
                    micropy_nlr_raise(mp_state, micropy_obj_new_exception_msg(mp_state, &mp_type_ValueError,
                        "sign not allowed with integer format specifier 'c'"));
                }
            }
        } else {
            sign = '-';
        }

        switch (align) {
            case '<': flags |= PF_FLAG_LEFT_ADJUST;     break;
            case '=': flags |= PF_FLAG_PAD_AFTER_SIGN;  break;
            case '^': flags |= PF_FLAG_CENTER_ADJUST;   break;
        }

        if (micropy_arg_looks_integer(mp_state, arg)) {
            switch (type) {
                case 'b':
                    micropy_print_mp_int(mp_state, &print, arg, 2, 'a', flags, fill, width, 0);
                    continue;

                case 'c':
                {
                    char ch = micropy_obj_get_int(mp_state, arg);
                    micropy_print_strn(mp_state, &print, &ch, 1, flags, fill, width);
                    continue;
                }

                case '\0':  // No explicit format type implies 'd'
                case 'n':   // I don't think we support locales in uPy so use 'd'
                case 'd':
                    micropy_print_mp_int(mp_state, &print, arg, 10, 'a', flags, fill, width, 0);
                    continue;

                case 'o':
                    if (flags & PF_FLAG_SHOW_PREFIX) {
                        flags |= PF_FLAG_SHOW_OCTAL_LETTER;
                    }

                    micropy_print_mp_int(mp_state, &print, arg, 8, 'a', flags, fill, width, 0);
                    continue;

                case 'X':
                case 'x':
                    micropy_print_mp_int(mp_state, &print, arg, 16, type - ('X' - 'A'), flags, fill, width, 0);
                    continue;

                case 'e':
                case 'E':
                case 'f':
                case 'F':
                case 'g':
                case 'G':
                case '%':
                    // The floating point formatters all work with anything that
                    // looks like an integer
                    break;

                default:
                    if (MICROPY_ERROR_REPORTING == MICROPY_ERROR_REPORTING_TERSE) {
                        micropy_terse_str_format_value_error(mp_state);
                    } else {
                        micropy_nlr_raise(mp_state, micropy_obj_new_exception_msg_varg(mp_state, &mp_type_ValueError,
                            "unknown format code '%c' for object of type '%s'",
                            type, micropy_obj_get_type_str(mp_state, arg)));
                    }
            }
        }

        // NOTE: no else here. We need the e, f, g etc formats for integer
        //       arguments (from above if) to take this if.
        if (micropy_arg_looks_numeric(mp_state, arg)) {
            if (!type) {

                // Even though the docs say that an unspecified type is the same
                // as 'g', there is one subtle difference, when the exponent
                // is one less than the precision.
                //
                // '{:10.1}'.format(0.0) ==> '0e+00'
                // '{:10.1g}'.format(0.0) ==> '0'
                //
                // TODO: Figure out how to deal with this.
                //
                // A proper solution would involve adding a special flag
                // or something to format_float, and create a format_double
                // to deal with doubles. In order to fix this when using
                // sprintf, we'd need to use the e format and tweak the
                // returned result to strip trailing zeros like the g format
                // does.
                //
                // {:10.3} and {:10.2e} with 1.23e2 both produce 1.23e+02
                // but with 1.e2 you get 1e+02 and 1.00e+02
                //
                // Stripping the trailing 0's (like g) does would make the
                // e format give us the right format.
                //
                // CPython sources say:
                //   Omitted type specifier.  Behaves in the same way as repr(x)
                //   and str(x) if no precision is given, else like 'g', but with
                //   at least one digit after the decimal point. */

                type = 'g';
            }
            if (type == 'n') {
                type = 'g';
            }

            switch (type) {
#if MICROPY_PY_BUILTINS_FLOAT
                case 'e':
                case 'E':
                case 'f':
                case 'F':
                case 'g':
                case 'G':
                    micropy_print_float(mp_state, &print, micropy_obj_get_float(mp_state, arg), type, flags, fill, width, precision);
                    break;

                case '%':
                    flags |= PF_FLAG_ADD_PERCENT;
                    #if MICROPY_FLOAT_IMPL == MICROPY_FLOAT_IMPL_FLOAT
                    #define F100 100.0F
                    #else
                    #define F100 100.0
                    #endif
                    micropy_print_float(mp_state, &print, micropy_obj_get_float(mp_state, arg) * F100, 'f', flags, fill, width, precision);
                    #undef F100
                    break;
#endif

                default:
                    if (MICROPY_ERROR_REPORTING == MICROPY_ERROR_REPORTING_TERSE) {
                        micropy_terse_str_format_value_error(mp_state);
                    } else {
                        micropy_nlr_raise(mp_state, micropy_obj_new_exception_msg_varg(mp_state, &mp_type_ValueError,
                            "unknown format code '%c' for object of type 'float'",
                            type, micropy_obj_get_type_str(mp_state, arg)));
                    }
            }
        } else {
            // arg doesn't look like a number

            if (align == '=') {
                if (MICROPY_ERROR_REPORTING == MICROPY_ERROR_REPORTING_TERSE) {
                    micropy_terse_str_format_value_error(mp_state);
                } else {
                    micropy_nlr_raise(mp_state, micropy_obj_new_exception_msg(mp_state, &mp_type_ValueError,
                        "'=' alignment not allowed in string format specifier"));
                }
            }

            switch (type) {
                case '\0': // no explicit format type implies 's'
                case 's': {
                    mp_uint_t slen;
                    const char *s = micropy_obj_str_get_data(mp_state, arg, &slen);
                    if (precision < 0) {
                        precision = slen;
                    }
                    if (slen > (mp_uint_t)precision) {
                        slen = precision;
                    }
                    micropy_print_strn(mp_state, &print, s, slen, flags, fill, width);
                    break;
                }

                default:
                    if (MICROPY_ERROR_REPORTING == MICROPY_ERROR_REPORTING_TERSE) {
                        micropy_terse_str_format_value_error(mp_state);
                    } else {
                        micropy_nlr_raise(mp_state, micropy_obj_new_exception_msg_varg(mp_state, &mp_type_ValueError,
                            "unknown format code '%c' for object of type 'str'",
                            type, micropy_obj_get_type_str(mp_state, arg)));
                    }
            }
        }
    }

    return vstr;
}

mp_obj_t micropy_obj_str_format(struct _mp_state_ctx_t *mp_state, size_t n_args, const mp_obj_t *args, mp_map_t *kwargs) {
    assert(MP_OBJ_IS_STR_OR_BYTES(args[0]));

    GET_STR_DATA_LEN(args[0], str, len);
    int arg_i = 0;
    vstr_t vstr = micropy_obj_str_format_helper(mp_state, (const char*)str, (const char*)str + len, &arg_i, n_args, args, kwargs);
    return micropy_obj_new_str_from_vstr(mp_state, &mp_type_str, &vstr);
}

STATIC mp_obj_t micropy_str_modulo_format(struct _mp_state_ctx_t *mp_state, mp_obj_t pattern, mp_uint_t n_args, const mp_obj_t *args, mp_obj_t dict) {
    assert(MP_OBJ_IS_STR_OR_BYTES(pattern));

    GET_STR_DATA_LEN(pattern, str, len);
    const byte *start_str = str;
    bool is_bytes = MP_OBJ_IS_TYPE(pattern, &mp_type_bytes);
    int arg_i = 0;
    vstr_t vstr;
    mp_print_t print;
    micropy_vstr_init_print(mp_state, &vstr, 16, &print);

    for (const byte *top = str + len; str < top; str++) {
        mp_obj_t arg = MP_OBJ_NULL;
        if (*str != '%') {
            micropy_vstr_add_byte(mp_state, &vstr, *str);
            continue;
        }
        if (++str >= top) {
            goto incomplete_format;
        }
        if (*str == '%') {
            micropy_vstr_add_byte(mp_state, &vstr, '%');
            continue;
        }

        // Dictionary value lookup
        if (*str == '(') {
            const byte *key = ++str;
            while (*str != ')') {
                if (str >= top) {
                    if (MICROPY_ERROR_REPORTING == MICROPY_ERROR_REPORTING_TERSE) {
                        micropy_terse_str_format_value_error(mp_state);
                    } else {
                        micropy_nlr_raise(mp_state, micropy_obj_new_exception_msg(mp_state, &mp_type_ValueError,
                            "incomplete format key"));
                    }
                }
                ++str;
            }
            mp_obj_t k_obj = micropy_obj_new_str(mp_state, (const char*)key, str - key, true);
            arg = micropy_obj_dict_get(mp_state, dict, k_obj);
            str++;
        }

        int flags = 0;
        char fill = ' ';
        int alt = 0;
        while (str < top) {
            if (*str == '-')      flags |= PF_FLAG_LEFT_ADJUST;
            else if (*str == '+') flags |= PF_FLAG_SHOW_SIGN;
            else if (*str == ' ') flags |= PF_FLAG_SPACE_SIGN;
            else if (*str == '#') alt = PF_FLAG_SHOW_PREFIX;
            else if (*str == '0') {
                flags |= PF_FLAG_PAD_AFTER_SIGN;
                fill = '0';
            } else break;
            str++;
        }
        // parse width, if it exists
        int width = 0;
        if (str < top) {
            if (*str == '*') {
                if ((uint)arg_i >= n_args) {
                    goto not_enough_args;
                }
                width = micropy_obj_get_int(mp_state, args[arg_i++]);
                str++;
            } else {
                str = (const byte*)micropy_str_to_int(mp_state, (const char*)str, (const char*)top, &width);
            }
        }
        int prec = -1;
        if (str < top && *str == '.') {
            if (++str < top) {
                if (*str == '*') {
                    if ((uint)arg_i >= n_args) {
                        goto not_enough_args;
                    }
                    prec = micropy_obj_get_int(mp_state, args[arg_i++]);
                    str++;
                } else {
                    prec = 0;
                    str = (const byte*)micropy_str_to_int(mp_state, (const char*)str, (const char*)top, &prec);
                }
            }
        }

        if (str >= top) {
incomplete_format:
            if (MICROPY_ERROR_REPORTING == MICROPY_ERROR_REPORTING_TERSE) {
                micropy_terse_str_format_value_error(mp_state);
            } else {
                micropy_nlr_raise(mp_state, micropy_obj_new_exception_msg(mp_state, &mp_type_ValueError,
                    "incomplete format"));
            }
        }

        // Tuple value lookup
        if (arg == MP_OBJ_NULL) {
            if ((uint)arg_i >= n_args) {
not_enough_args:
                micropy_nlr_raise(mp_state, micropy_obj_new_exception_msg(mp_state, &mp_type_TypeError, "not enough arguments for format string"));
            }
            arg = args[arg_i++];
        }
        switch (*str) {
            case 'c':
                if (MP_OBJ_IS_STR(arg)) {
                    mp_uint_t slen;
                    const char *s = micropy_obj_str_get_data(mp_state, arg, &slen);
                    if (slen != 1) {
                        micropy_nlr_raise(mp_state, micropy_obj_new_exception_msg(mp_state, &mp_type_TypeError,
                            "%%c requires int or char"));
                    }
                    micropy_print_strn(mp_state, &print, s, 1, flags, ' ', width);
                } else if (micropy_arg_looks_integer(mp_state, arg)) {
                    char ch = micropy_obj_get_int(mp_state, arg);
                    micropy_print_strn(mp_state, &print, &ch, 1, flags, ' ', width);
                } else {
                    micropy_nlr_raise(mp_state, micropy_obj_new_exception_msg(mp_state, &mp_type_TypeError,
                        "integer required"));
                }
                break;

            case 'd':
            case 'i':
            case 'u':
                micropy_print_mp_int(mp_state, &print, micropy_arg_as_int(mp_state, arg), 10, 'a', flags, fill, width, prec);
                break;

#if MICROPY_PY_BUILTINS_FLOAT
            case 'e':
            case 'E':
            case 'f':
            case 'F':
            case 'g':
            case 'G':
                micropy_print_float(mp_state, &print, micropy_obj_get_float(mp_state, arg), *str, flags, fill, width, prec);
                break;
#endif

            case 'o':
                if (alt) {
                    flags |= (PF_FLAG_SHOW_PREFIX | PF_FLAG_SHOW_OCTAL_LETTER);
                }
                micropy_print_mp_int(mp_state, &print, arg, 8, 'a', flags, fill, width, prec);
                break;

            case 'r':
            case 's':
            {
                vstr_t arg_vstr;
                mp_print_t arg_print;
                micropy_vstr_init_print(mp_state, &arg_vstr, 16, &arg_print);
                mp_print_kind_t print_kind = (*str == 'r' ? PRINT_REPR : PRINT_STR);
                if (print_kind == PRINT_STR && is_bytes && MP_OBJ_IS_TYPE(arg, &mp_type_bytes)) {
                    // If we have something like b"%s" % b"1", bytes arg should be
                    // printed undecorated.
                    print_kind = PRINT_RAW;
                }
                micropy_obj_print_helper(mp_state, &arg_print, arg, print_kind);
                uint vlen = arg_vstr.len;
                if (prec < 0) {
                    prec = vlen;
                }
                if (vlen > (uint)prec) {
                    vlen = prec;
                }
                micropy_print_strn(mp_state, &print, arg_vstr.buf, vlen, flags, ' ', width);
                micropy_vstr_clear(mp_state, &arg_vstr);
                break;
            }

            case 'X':
            case 'x':
                micropy_print_mp_int(mp_state, &print, arg, 16, *str - ('X' - 'A'), flags | alt, fill, width, prec);
                break;

            default:
                if (MICROPY_ERROR_REPORTING == MICROPY_ERROR_REPORTING_TERSE) {
                    micropy_terse_str_format_value_error(mp_state);
                } else {
                    micropy_nlr_raise(mp_state, micropy_obj_new_exception_msg_varg(mp_state, &mp_type_ValueError,
                        "unsupported format character '%c' (0x%x) at index %d",
                        *str, *str, str - start_str));
                }
        }
    }

    if ((uint)arg_i != n_args) {
        micropy_nlr_raise(mp_state, micropy_obj_new_exception_msg(mp_state, &mp_type_TypeError, "not all arguments converted during string formatting"));
    }

    return micropy_obj_new_str_from_vstr(mp_state, is_bytes ? &mp_type_bytes : &mp_type_str, &vstr);
}

// The implementation is optimized, returning the original string if there's
// nothing to replace.
STATIC mp_obj_t micropy_str_replace(struct _mp_state_ctx_t *mp_state, size_t n_args, const mp_obj_t *args) {
    assert(MP_OBJ_IS_STR_OR_BYTES(args[0]));

    mp_int_t max_rep = -1;
    if (n_args == 4) {
        max_rep = micropy_obj_get_int(mp_state, args[3]);
        if (max_rep == 0) {
            return args[0];
        } else if (max_rep < 0) {
            max_rep = -1;
        }
    }

    // if max_rep is still -1 by this point we will need to do all possible replacements

    // check argument types

    const mp_obj_type_t *self_type = micropy_obj_get_type(mp_state, args[0]);

    if (micropy_obj_get_type(mp_state, args[1]) != self_type) {
        micropy_bad_implicit_conversion(mp_state, args[1]);
    }

    if (micropy_obj_get_type(mp_state, args[2]) != self_type) {
        micropy_bad_implicit_conversion(mp_state, args[2]);
    }

    // extract string data

    GET_STR_DATA_LEN(args[0], str, str_len);
    GET_STR_DATA_LEN(args[1], old, old_len);
    GET_STR_DATA_LEN(args[2], new, new_len);

    // old won't exist in str if it's longer, so nothing to replace
    if (old_len > str_len) {
        return args[0];
    }

    // data for the replaced string
    byte *data = NULL;
    vstr_t vstr;

    // do 2 passes over the string:
    //   first pass computes the required length of the replaced string
    //   second pass does the replacements
    for (;;) {
        mp_uint_t replaced_str_index = 0;
        mp_uint_t num_replacements_done = 0;
        const byte *old_occurrence;
        const byte *offset_ptr = str;
        mp_uint_t str_len_remain = str_len;
        if (old_len == 0) {
            // if old_str is empty, copy new_str to start of replaced string
            // copy the replacement string
            if (data != NULL) {
                memcpy(data, new, new_len);
            }
            replaced_str_index += new_len;
            num_replacements_done++;
        }
        while (num_replacements_done != (mp_uint_t)max_rep && str_len_remain > 0 && (old_occurrence = micropy_find_subbytes(mp_state, offset_ptr, str_len_remain, old, old_len, 1)) != NULL) {
            if (old_len == 0) {
                old_occurrence += 1;
            }
            // copy from just after end of last occurrence of to-be-replaced string to right before start of next occurrence
            if (data != NULL) {
                memcpy(data + replaced_str_index, offset_ptr, old_occurrence - offset_ptr);
            }
            replaced_str_index += old_occurrence - offset_ptr;
            // copy the replacement string
            if (data != NULL) {
                memcpy(data + replaced_str_index, new, new_len);
            }
            replaced_str_index += new_len;
            offset_ptr = old_occurrence + old_len;
            str_len_remain = str + str_len - offset_ptr;
            num_replacements_done++;
        }

        // copy from just after end of last occurrence of to-be-replaced string to end of old string
        if (data != NULL) {
            memcpy(data + replaced_str_index, offset_ptr, str_len_remain);
        }
        replaced_str_index += str_len_remain;

        if (data == NULL) {
            // first pass
            if (num_replacements_done == 0) {
                // no substr found, return original string
                return args[0];
            } else {
                // substr found, allocate new string
                micropy_vstr_init_len(mp_state, &vstr, replaced_str_index);
                data = (byte*)vstr.buf;
                assert(data != NULL);
            }
        } else {
            // second pass, we are done
            break;
        }
    }

    return micropy_obj_new_str_from_vstr(mp_state, self_type, &vstr);
}

STATIC mp_obj_t micropy_str_count(struct _mp_state_ctx_t *mp_state, size_t n_args, const mp_obj_t *args) {
    const mp_obj_type_t *self_type = micropy_obj_get_type(mp_state, args[0]);
    assert(2 <= n_args && n_args <= 4);
    assert(MP_OBJ_IS_STR_OR_BYTES(args[0]));

    // check argument type
    if (micropy_obj_get_type(mp_state, args[1]) != self_type) {
        micropy_bad_implicit_conversion(mp_state, args[1]);
    }

    GET_STR_DATA_LEN(args[0], haystack, haystack_len);
    GET_STR_DATA_LEN(args[1], needle, needle_len);

    const byte *start = haystack;
    const byte *end = haystack + haystack_len;
    if (n_args >= 3 && args[2] != mp_const_none) {
        start = micropy_str_index_to_ptr(mp_state, self_type, haystack, haystack_len, args[2], true);
    }
    if (n_args >= 4 && args[3] != mp_const_none) {
        end = micropy_str_index_to_ptr(mp_state, self_type, haystack, haystack_len, args[3], true);
    }

    // if needle_len is zero then we count each gap between characters as an occurrence
    if (needle_len == 0) {
        return MP_OBJ_NEW_SMALL_INT(unichar_charlen((const char*)start, end - start) + 1);
    }

    // count the occurrences
    mp_int_t num_occurrences = 0;
    for (const byte *haystack_ptr = start; haystack_ptr + needle_len <= end;) {
        if (memcmp(haystack_ptr, needle, needle_len) == 0) {
            num_occurrences++;
            haystack_ptr += needle_len;
        } else {
            haystack_ptr = utf8_next_char(haystack_ptr);
        }
    }

    return MP_OBJ_NEW_SMALL_INT(num_occurrences);
}

STATIC mp_obj_t micropy_str_partitioner(struct _mp_state_ctx_t *mp_state, mp_obj_t self_in, mp_obj_t arg, mp_int_t direction) {
    assert(MP_OBJ_IS_STR_OR_BYTES(self_in));
    mp_obj_type_t *self_type = micropy_obj_get_type(mp_state, self_in);
    if (self_type != micropy_obj_get_type(mp_state, arg)) {
        micropy_bad_implicit_conversion(mp_state, arg);
    }

    GET_STR_DATA_LEN(self_in, str, str_len);
    GET_STR_DATA_LEN(arg, sep, sep_len);

    if (sep_len == 0) {
        micropy_nlr_raise(mp_state, micropy_obj_new_exception_msg(mp_state, &mp_type_ValueError, "empty separator"));
    }

    mp_obj_t result[3];
    if (self_type == &mp_type_str) {
        result[0] = MP_OBJ_NEW_QSTR(MP_QSTR_);
        result[1] = MP_OBJ_NEW_QSTR(MP_QSTR_);
        result[2] = MP_OBJ_NEW_QSTR(MP_QSTR_);
    } else {
        result[0] = mp_const_empty_bytes;
        result[1] = mp_const_empty_bytes;
        result[2] = mp_const_empty_bytes;
    }

    if (direction > 0) {
        result[0] = self_in;
    } else {
        result[2] = self_in;
    }

    const byte *position_ptr = micropy_find_subbytes(mp_state, str, str_len, sep, sep_len, direction);
    if (position_ptr != NULL) {
        mp_uint_t position = position_ptr - str;
        result[0] = micropy_obj_new_str_of_type(mp_state, self_type, str, position);
        result[1] = arg;
        result[2] = micropy_obj_new_str_of_type(mp_state, self_type, str + position + sep_len, str_len - position - sep_len);
    }

    return micropy_obj_new_tuple(mp_state, 3, result);
}

STATIC mp_obj_t micropy_str_partition(struct _mp_state_ctx_t *mp_state, mp_obj_t self_in, mp_obj_t arg) {
    return micropy_str_partitioner(mp_state, self_in, arg, 1);
}

STATIC mp_obj_t micropy_str_rpartition(struct _mp_state_ctx_t *mp_state, mp_obj_t self_in, mp_obj_t arg) {
    return micropy_str_partitioner(mp_state, self_in, arg, -1);
}

// Supposedly not too critical operations, so optimize for code size
STATIC mp_obj_t micropy_str_caseconv(struct _mp_state_ctx_t *mp_state, unichar (*op)(unichar), mp_obj_t self_in) {
    GET_STR_DATA_LEN(self_in, self_data, self_len);
    vstr_t vstr;
    micropy_vstr_init_len(mp_state, &vstr, self_len);
    byte *data = (byte*)vstr.buf;
    for (mp_uint_t i = 0; i < self_len; i++) {
        *data++ = op(*self_data++);
    }
    return micropy_obj_new_str_from_vstr(mp_state, micropy_obj_get_type(mp_state, self_in), &vstr);
}

STATIC mp_obj_t micropy_str_lower(struct _mp_state_ctx_t *mp_state, mp_obj_t self_in) {
    return micropy_str_caseconv(mp_state, unichar_tolower, self_in);
}

STATIC mp_obj_t micropy_str_upper(struct _mp_state_ctx_t *mp_state, mp_obj_t self_in) {
    return micropy_str_caseconv(mp_state, unichar_toupper, self_in);
}

STATIC mp_obj_t micropy_str_uni_istype(struct _mp_state_ctx_t *mp_state, bool (*f)(unichar), mp_obj_t self_in) {
    GET_STR_DATA_LEN(self_in, self_data, self_len);

    if (self_len == 0) {
        return mp_const_false; // default to False for empty str
    }

    if (f != unichar_isupper && f != unichar_islower) {
        for (mp_uint_t i = 0; i < self_len; i++) {
            if (!f(*self_data++)) {
                return mp_const_false;
            }
        }
    } else {
        bool contains_alpha = false;

        for (mp_uint_t i = 0; i < self_len; i++) { // only check alphanumeric characters
            if (unichar_isalpha(*self_data++)) {
                contains_alpha = true;
                if (!f(*(self_data - 1))) { // -1 because we already incremented above
                    return mp_const_false;
                }
            }
        }

        if (!contains_alpha) {
            return mp_const_false;
        }
    }

    return mp_const_true;
}

STATIC mp_obj_t micropy_str_isspace(struct _mp_state_ctx_t *mp_state, mp_obj_t self_in) {
    return micropy_str_uni_istype(mp_state, unichar_isspace, self_in);
}

STATIC mp_obj_t micropy_str_isalpha(struct _mp_state_ctx_t *mp_state, mp_obj_t self_in) {
    return micropy_str_uni_istype(mp_state, unichar_isalpha, self_in);
}

STATIC mp_obj_t micropy_str_isdigit(struct _mp_state_ctx_t *mp_state, mp_obj_t self_in) {
    return micropy_str_uni_istype(mp_state, unichar_isdigit, self_in);
}

STATIC mp_obj_t micropy_str_isupper(struct _mp_state_ctx_t *mp_state, mp_obj_t self_in) {
    return micropy_str_uni_istype(mp_state, unichar_isupper, self_in);
}

STATIC mp_obj_t micropy_str_islower(struct _mp_state_ctx_t *mp_state, mp_obj_t self_in) {
    return micropy_str_uni_istype(mp_state, unichar_islower, self_in);
}

#if MICROPY_CPYTHON_COMPAT
// These methods are superfluous in the presense of str() and bytes()
// constructors.
// TODO: should accept kwargs too
STATIC mp_obj_t micropy_bytes_decode(struct _mp_state_ctx_t *mp_state, size_t n_args, const mp_obj_t *args) {
    mp_obj_t new_args[2];
    if (n_args == 1) {
        new_args[0] = args[0];
        new_args[1] = MP_OBJ_NEW_QSTR(MP_QSTR_utf_hyphen_8);
        args = new_args;
        n_args++;
    }
    return micropy_obj_str_make_new(mp_state, &mp_type_str, n_args, 0, args);
}

// TODO: should accept kwargs too
STATIC mp_obj_t micropy_str_encode(struct _mp_state_ctx_t *mp_state, size_t n_args, const mp_obj_t *args) {
    mp_obj_t new_args[2];
    if (n_args == 1) {
        new_args[0] = args[0];
        new_args[1] = MP_OBJ_NEW_QSTR(MP_QSTR_utf_hyphen_8);
        args = new_args;
        n_args++;
    }
    return micropy_bytes_make_new(mp_state, NULL, n_args, 0, args);
}
#endif

mp_int_t micropy_obj_str_get_buffer(struct _mp_state_ctx_t *mp_state, mp_obj_t self_in, mp_buffer_info_t *bufinfo, mp_uint_t flags) {
    if (flags == MP_BUFFER_READ) {
        GET_STR_DATA_LEN(self_in, str_data, str_len);
        bufinfo->buf = (void*)str_data;
        bufinfo->len = str_len;
        bufinfo->typecode = 'B'; // bytes should be unsigned, so should unicode byte-access
        return 0;
    } else {
        // can't write to a string
        bufinfo->buf = NULL;
        bufinfo->len = 0;
        bufinfo->typecode = -1;
        return 1;
    }
}

#if MICROPY_CPYTHON_COMPAT
MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(bytes_decode_obj, 1, 3, micropy_bytes_decode);
MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(str_encode_obj, 1, 3, micropy_str_encode);
#endif
MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(str_find_obj, 2, 4, micropy_str_find);
MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(str_rfind_obj, 2, 4, micropy_str_rfind);
MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(str_index_obj, 2, 4, micropy_str_index);
MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(str_rindex_obj, 2, 4, micropy_str_rindex);
MP_DEFINE_CONST_FUN_OBJ_2(str_join_obj, micropy_str_join);
MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(str_split_obj, 1, 3, micropy_obj_str_split);
#if MICROPY_PY_BUILTINS_STR_SPLITLINES
MP_DEFINE_CONST_FUN_OBJ_KW(str_splitlines_obj, 1, micropy_str_splitlines);
#endif
#if MICROPY_PY_BUILTINS_STR_CENTER
MP_DEFINE_CONST_FUN_OBJ_2(str_center_obj, micropy_str_center);
#endif
MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(str_rsplit_obj, 1, 3, micropy_str_rsplit);
MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(str_startswith_obj, 2, 3, micropy_str_startswith);
MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(str_endswith_obj, 2, 3, micropy_str_endswith);
MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(str_strip_obj, 1, 2, micropy_str_strip);
MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(str_lstrip_obj, 1, 2, micropy_str_lstrip);
MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(str_rstrip_obj, 1, 2, micropy_str_rstrip);
MP_DEFINE_CONST_FUN_OBJ_KW(str_format_obj, 1, micropy_obj_str_format);
MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(str_replace_obj, 3, 4, micropy_str_replace);
MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(str_count_obj, 2, 4, micropy_str_count);
MP_DEFINE_CONST_FUN_OBJ_2(str_partition_obj, micropy_str_partition);
MP_DEFINE_CONST_FUN_OBJ_2(str_rpartition_obj, micropy_str_rpartition);
MP_DEFINE_CONST_FUN_OBJ_1(str_lower_obj, micropy_str_lower);
MP_DEFINE_CONST_FUN_OBJ_1(str_upper_obj, micropy_str_upper);
MP_DEFINE_CONST_FUN_OBJ_1(str_isspace_obj, micropy_str_isspace);
MP_DEFINE_CONST_FUN_OBJ_1(str_isalpha_obj, micropy_str_isalpha);
MP_DEFINE_CONST_FUN_OBJ_1(str_isdigit_obj, micropy_str_isdigit);
MP_DEFINE_CONST_FUN_OBJ_1(str_isupper_obj, micropy_str_isupper);
MP_DEFINE_CONST_FUN_OBJ_1(str_islower_obj, micropy_str_islower);

STATIC const mp_rom_map_elem_t str8_locals_dict_table[] = {
#if MICROPY_CPYTHON_COMPAT
    { MP_ROM_QSTR(MP_QSTR_decode), MP_ROM_PTR(&bytes_decode_obj) },
    #if !MICROPY_PY_BUILTINS_STR_UNICODE
    // If we have separate unicode type, then here we have methods only
    // for bytes type, and it should not have encode() methods. Otherwise,
    // we have non-compliant-but-practical bytestring type, which shares
    // method table with bytes, so they both have encode() and decode()
    // methods (which should do type checking at runtime).
    { MP_ROM_QSTR(MP_QSTR_encode), MP_ROM_PTR(&str_encode_obj) },
    #endif
#endif
    { MP_ROM_QSTR(MP_QSTR_find), MP_ROM_PTR(&str_find_obj) },
    { MP_ROM_QSTR(MP_QSTR_rfind), MP_ROM_PTR(&str_rfind_obj) },
    { MP_ROM_QSTR(MP_QSTR_index), MP_ROM_PTR(&str_index_obj) },
    { MP_ROM_QSTR(MP_QSTR_rindex), MP_ROM_PTR(&str_rindex_obj) },
    { MP_ROM_QSTR(MP_QSTR_join), MP_ROM_PTR(&str_join_obj) },
    { MP_ROM_QSTR(MP_QSTR_split), MP_ROM_PTR(&str_split_obj) },
    #if MICROPY_PY_BUILTINS_STR_SPLITLINES
    { MP_ROM_QSTR(MP_QSTR_splitlines), MP_ROM_PTR(&str_splitlines_obj) },
    #endif
    { MP_ROM_QSTR(MP_QSTR_rsplit), MP_ROM_PTR(&str_rsplit_obj) },
    { MP_ROM_QSTR(MP_QSTR_startswith), MP_ROM_PTR(&str_startswith_obj) },
    { MP_ROM_QSTR(MP_QSTR_endswith), MP_ROM_PTR(&str_endswith_obj) },
    { MP_ROM_QSTR(MP_QSTR_strip), MP_ROM_PTR(&str_strip_obj) },
    { MP_ROM_QSTR(MP_QSTR_lstrip), MP_ROM_PTR(&str_lstrip_obj) },
    { MP_ROM_QSTR(MP_QSTR_rstrip), MP_ROM_PTR(&str_rstrip_obj) },
    { MP_ROM_QSTR(MP_QSTR_format), MP_ROM_PTR(&str_format_obj) },
    { MP_ROM_QSTR(MP_QSTR_replace), MP_ROM_PTR(&str_replace_obj) },
    { MP_ROM_QSTR(MP_QSTR_count), MP_ROM_PTR(&str_count_obj) },
    { MP_ROM_QSTR(MP_QSTR_partition), MP_ROM_PTR(&str_partition_obj) },
    { MP_ROM_QSTR(MP_QSTR_rpartition), MP_ROM_PTR(&str_rpartition_obj) },
#if MICROPY_PY_BUILTINS_STR_CENTER
    { MP_ROM_QSTR(MP_QSTR_center), MP_ROM_PTR(&str_center_obj) },
#endif
    { MP_ROM_QSTR(MP_QSTR_lower), MP_ROM_PTR(&str_lower_obj) },
    { MP_ROM_QSTR(MP_QSTR_upper), MP_ROM_PTR(&str_upper_obj) },
    { MP_ROM_QSTR(MP_QSTR_isspace), MP_ROM_PTR(&str_isspace_obj) },
    { MP_ROM_QSTR(MP_QSTR_isalpha), MP_ROM_PTR(&str_isalpha_obj) },
    { MP_ROM_QSTR(MP_QSTR_isdigit), MP_ROM_PTR(&str_isdigit_obj) },
    { MP_ROM_QSTR(MP_QSTR_isupper), MP_ROM_PTR(&str_isupper_obj) },
    { MP_ROM_QSTR(MP_QSTR_islower), MP_ROM_PTR(&str_islower_obj) },
};

STATIC MP_DEFINE_CONST_DICT(str8_locals_dict, str8_locals_dict_table);

#if !MICROPY_PY_BUILTINS_STR_UNICODE
STATIC mp_obj_t micropy_obj_new_str_iterator(struct _mp_state_ctx_t *mp_state, mp_obj_t str);

const mp_obj_type_t mp_type_str = {
    { &mp_type_type },
    .name = MP_QSTR_str,
    .print = micropy_str_print,
    .make_new = micropy_obj_str_make_new,
    .binary_op = micropy_obj_str_binary_op,
    .subscr = micropy_bytes_subscr,
    .getiter = micropy_obj_new_str_iterator,
    .buffer_p = { .get_buffer = micropy_obj_str_get_buffer, },
    .locals_dict = (mp_obj_dict_t*)&str8_locals_dict,
};
#endif

// Reuses most of methods from str
const mp_obj_type_t mp_type_bytes = {
    { &mp_type_type },
    .name = MP_QSTR_bytes,
    .print = micropy_str_print,
    .make_new = micropy_bytes_make_new,
    .binary_op = micropy_obj_str_binary_op,
    .subscr = micropy_bytes_subscr,
    .getiter = micropy_obj_new_bytes_iterator,
    .buffer_p = { .get_buffer = micropy_obj_str_get_buffer, },
    .locals_dict = (mp_obj_dict_t*)&str8_locals_dict,
};

// the zero-length bytes
const mp_obj_str_t mp_const_empty_bytes_obj = {{&mp_type_bytes}, 0, 0, NULL};

// Create a str/bytes object using the given data.  New memory is allocated and
// the data is copied across.
mp_obj_t micropy_obj_new_str_of_type(struct _mp_state_ctx_t *mp_state, const mp_obj_type_t *type, const byte* data, size_t len) {
    mp_obj_str_t *o = micropy_m_new_obj(mp_state, mp_obj_str_t);
    o->base.type = type;
    o->len = len;
    if (data) {
        o->hash = micropy_qstr_compute_hash(mp_state, data, len);
        byte *p = micropy_m_new(mp_state, byte, len + 1);
        o->data = p;
        memcpy(p, data, len * sizeof(byte));
        p[len] = '\0'; // for now we add null for compatibility with C ASCIIZ strings
    }
    return MP_OBJ_FROM_PTR(o);
}

// Create a str/bytes object from the given vstr.  The vstr buffer is resized to
// the exact length required and then reused for the str/bytes object.  The vstr
// is cleared and can safely be passed to vstr_free if it was heap allocated.
mp_obj_t micropy_obj_new_str_from_vstr(struct _mp_state_ctx_t *mp_state, const mp_obj_type_t *type, vstr_t *vstr) {
    // if not a bytes object, look if a qstr with this data already exists
    if (type == &mp_type_str) {
        qstr q = micropy_qstr_find_strn(mp_state, vstr->buf, vstr->len);
        if (q != MP_QSTR_NULL) {
            micropy_vstr_clear(mp_state, vstr);
            vstr->alloc = 0;
            return MP_OBJ_NEW_QSTR(q);
        }
    }

    // make a new str/bytes object
    mp_obj_str_t *o = micropy_m_new_obj(mp_state, mp_obj_str_t);
    o->base.type = type;
    o->len = vstr->len;
    o->hash = micropy_qstr_compute_hash(mp_state, (byte*)vstr->buf, vstr->len);
    if (vstr->len + 1 == vstr->alloc) {
        o->data = (byte*)vstr->buf;
    } else {
        o->data = (byte*)micropy_m_renew(mp_state, char, vstr->buf, vstr->alloc, vstr->len + 1);
    }
    ((byte*)o->data)[o->len] = '\0'; // add null byte
    vstr->buf = NULL;
    vstr->alloc = 0;
    return MP_OBJ_FROM_PTR(o);
}

mp_obj_t micropy_obj_new_str(struct _mp_state_ctx_t *mp_state, const char* data, mp_uint_t len, bool make_qstr_if_not_already) {
    if (make_qstr_if_not_already) {
        // use existing, or make a new qstr
        return MP_OBJ_NEW_QSTR(micropy_qstr_from_strn(mp_state, data, len));
    } else {
        qstr q = micropy_qstr_find_strn(mp_state, data, len);
        if (q != MP_QSTR_NULL) {
            // qstr with this data already exists
            return MP_OBJ_NEW_QSTR(q);
        } else {
            // no existing qstr, don't make one
            return micropy_obj_new_str_of_type(mp_state, &mp_type_str, (const byte*)data, len);
        }
    }
}

mp_obj_t micropy_obj_str_intern(struct _mp_state_ctx_t *mp_state, mp_obj_t str) {
    GET_STR_DATA_LEN(str, data, len);
    return MP_OBJ_NEW_QSTR(micropy_qstr_from_strn(mp_state, (const char*)data, len));
}

mp_obj_t micropy_obj_new_bytes(struct _mp_state_ctx_t *mp_state, const byte* data, mp_uint_t len) {
    return micropy_obj_new_str_of_type(mp_state, &mp_type_bytes, data, len);
}

bool micropy_obj_str_equal(struct _mp_state_ctx_t *mp_state, mp_obj_t s1, mp_obj_t s2) {
    if (MP_OBJ_IS_QSTR(s1) && MP_OBJ_IS_QSTR(s2)) {
        return s1 == s2;
    } else {
        GET_STR_HASH(s1, h1);
        GET_STR_HASH(s2, h2);
        // If any of hashes is 0, it means it's not valid
        if (h1 != 0 && h2 != 0 && h1 != h2) {
            return false;
        }
        GET_STR_DATA_LEN(s1, d1, l1);
        GET_STR_DATA_LEN(s2, d2, l2);
        if (l1 != l2) {
            return false;
        }
        return memcmp(d1, d2, l1) == 0;
    }
}

STATIC void micropy_bad_implicit_conversion(struct _mp_state_ctx_t *mp_state, mp_obj_t self_in) {
    if (MICROPY_ERROR_REPORTING == MICROPY_ERROR_REPORTING_TERSE) {
        micropy_nlr_raise(mp_state, micropy_obj_new_exception_msg(mp_state, &mp_type_TypeError,
            "can't convert to str implicitly"));
    } else {
        micropy_nlr_raise(mp_state, micropy_obj_new_exception_msg_varg(mp_state, &mp_type_TypeError,
            "can't convert '%s' object to str implicitly",
            micropy_obj_get_type_str(mp_state, self_in)));
    }
}

// use this if you will anyway convert the string to a qstr
// will be more efficient for the case where it's already a qstr
qstr micropy_obj_str_get_qstr(struct _mp_state_ctx_t *mp_state, mp_obj_t self_in) {
    if (MP_OBJ_IS_QSTR(self_in)) {
        return MP_OBJ_QSTR_VALUE(self_in);
    } else if (MP_OBJ_IS_TYPE(self_in, &mp_type_str)) {
        mp_obj_str_t *self = MP_OBJ_TO_PTR(self_in);
        return micropy_qstr_from_strn(mp_state, (char*)self->data, self->len);
    } else {
        micropy_bad_implicit_conversion(mp_state, self_in);
    }
}

// only use this function if you need the str data to be zero terminated
// at the moment all strings are zero terminated to help with C ASCIIZ compatibility
const char *micropy_obj_str_get_str(struct _mp_state_ctx_t *mp_state, mp_obj_t self_in) {
    if (MP_OBJ_IS_STR_OR_BYTES(self_in)) {
        GET_STR_DATA_LEN(self_in, s, l);
        (void)l; // len unused
        return (const char*)s;
    } else {
        micropy_bad_implicit_conversion(mp_state, self_in);
    }
}

const char *micropy_obj_str_get_data(struct _mp_state_ctx_t *mp_state, mp_obj_t self_in, mp_uint_t *len) {
    if (MP_OBJ_IS_STR_OR_BYTES(self_in)) {
        GET_STR_DATA_LEN(self_in, s, l);
        *len = l;
        return (const char*)s;
    } else {
        micropy_bad_implicit_conversion(mp_state, self_in);
    }
}

#if MICROPY_OBJ_REPR == MICROPY_OBJ_REPR_C
const byte *micropy_obj_str_get_data_no_check(struct _mp_state_ctx_t *mp_state, mp_obj_t self_in, size_t *len) {
    if (MP_OBJ_IS_QSTR(self_in)) {
        return micropy_qstr_data(mp_state, MP_OBJ_QSTR_VALUE(self_in), len);
    } else {
        *len = ((mp_obj_str_t*)self_in)->len;
        return ((mp_obj_str_t*)self_in)->data;
    }
}
#endif

/******************************************************************************/
/* str iterator                                                               */

typedef struct _mp_obj_str8_it_t {
    mp_obj_base_t base;
    mp_fun_1_t iternext;
    mp_obj_t str;
    mp_uint_t cur;
} mp_obj_str8_it_t;

#if !MICROPY_PY_BUILTINS_STR_UNICODE
STATIC mp_obj_t micropy_str_it_iternext(struct _mp_state_ctx_t *mp_state, mp_obj_t self_in) {
    mp_obj_str8_it_t *self = self_in;
    GET_STR_DATA_LEN(self->str, str, len);
    if (self->cur < len) {
        mp_obj_t o_out = micropy_obj_new_str(mp_state, (const char*)str + self->cur, 1, true);
        self->cur += 1;
        return o_out;
    } else {
        return MP_OBJ_STOP_ITERATION;
    }
}

STATIC mp_obj_t micropy_obj_new_str_iterator(struct _mp_state_ctx_t *mp_state, mp_obj_t str) {
    mp_obj_str8_it_t *o = micropy_m_new_obj(mp_state, mp_obj_str8_it_t);
    o->base.type = &mp_type_polymorph_iter;
    o->iternext = micropy_str_it_iternext;
    o->str = str;
    o->cur = 0;
    return o;
}
#endif

STATIC mp_obj_t micropy_bytes_it_iternext(struct _mp_state_ctx_t *mp_state, mp_obj_t self_in) {
    mp_obj_str8_it_t *self = MP_OBJ_TO_PTR(self_in);
    GET_STR_DATA_LEN(self->str, str, len);
    if (self->cur < len) {
        mp_obj_t o_out = MP_OBJ_NEW_SMALL_INT(str[self->cur]);
        self->cur += 1;
        return o_out;
    } else {
        return MP_OBJ_STOP_ITERATION;
    }
}

mp_obj_t micropy_obj_new_bytes_iterator(struct _mp_state_ctx_t *mp_state, mp_obj_t str) {
    mp_obj_str8_it_t *o = micropy_m_new_obj(mp_state, mp_obj_str8_it_t);
    o->base.type = &mp_type_polymorph_iter;
    o->iternext = micropy_bytes_it_iternext;
    o->str = str;
    o->cur = 0;
    return MP_OBJ_FROM_PTR(o);
}
/*
 * This file is part of the Micro Python project, http://micropython.org/
 *
 * The MIT License (MIT)
 *
 * Copyright (c) 2013, 2014 Damien P. George
 * Copyright (c) 2014 Paul Sokolovsky
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

#include <string.h>
#include <assert.h>

//#include "py/nlr.h"
//#include "py/objstr.h"
//#include "py/objlist.h"
//#include "py/runtime0.h"
//#include "py/runtime.h"

#if MICROPY_PY_BUILTINS_STR_UNICODE

STATIC mp_obj_t micropy_obj_new_str_iterator(struct _mp_state_ctx_t *mp_state, mp_obj_t str);

/******************************************************************************/
/* str                                                                        */

STATIC void micropy_uni_print_quoted(struct _mp_state_ctx_t *mp_state, const mp_print_t *print, const byte *str_data, uint str_len) {
    // this escapes characters, but it will be very slow to print (calling print many times)
    bool has_single_quote = false;
    bool has_double_quote = false;
    for (const byte *s = str_data, *top = str_data + str_len; !has_double_quote && s < top; s++) {
        if (*s == '\'') {
            has_single_quote = true;
        } else if (*s == '"') {
            has_double_quote = true;
        }
    }
    unichar quote_char = '\'';
    if (has_single_quote && !has_double_quote) {
        quote_char = '"';
    }
    micropy_printf(mp_state, print, "%c", quote_char);
    const byte *s = str_data, *top = str_data + str_len;
    while (s < top) {
        unichar ch;
        ch = utf8_get_char(s);
        s = utf8_next_char(s);
        if (ch == quote_char) {
            micropy_printf(mp_state, print, "\\%c", quote_char);
        } else if (ch == '\\') {
            micropy_print_str(mp_state, print, "\\\\");
        } else if (32 <= ch && ch <= 126) {
            micropy_printf(mp_state, print, "%c", ch);
        } else if (ch == '\n') {
            micropy_print_str(mp_state, print, "\\n");
        } else if (ch == '\r') {
            micropy_print_str(mp_state, print, "\\r");
        } else if (ch == '\t') {
            micropy_print_str(mp_state, print, "\\t");
        } else if (ch < 0x100) {
            micropy_printf(mp_state, print, "\\x%02x", ch);
        } else if (ch < 0x10000) {
            micropy_printf(mp_state, print, "\\u%04x", ch);
        } else {
            micropy_printf(mp_state, print, "\\U%08x", ch);
        }
    }
    micropy_printf(mp_state, print, "%c", quote_char);
}

STATIC void micropy_uni_print(struct _mp_state_ctx_t *mp_state, const mp_print_t *print, mp_obj_t self_in, mp_print_kind_t kind) {
    GET_STR_DATA_LEN(self_in, str_data, str_len);
    #if MICROPY_PY_UJSON
    if (kind == PRINT_JSON) {
        micropy_str_print_json(mp_state, print, str_data, str_len);
        return;
    }
    #endif
    if (kind == PRINT_STR) {
        micropy_printf(mp_state, print, "%.*s", str_len, str_data);
    } else {
        micropy_uni_print_quoted(mp_state, print, str_data, str_len);
    }
}

STATIC mp_obj_t micropy_uni_unary_op(struct _mp_state_ctx_t *mp_state, mp_uint_t op, mp_obj_t self_in) {
    GET_STR_DATA_LEN(self_in, str_data, str_len);
    switch (op) {
        case MP_UNARY_OP_BOOL:
            return micropy_obj_new_bool(mp_state, str_len != 0);
        case MP_UNARY_OP_LEN:
            return MP_OBJ_NEW_SMALL_INT(unichar_charlen((const char *)str_data, str_len));
        default:
            return MP_OBJ_NULL; // op not supported
    }
}

// Convert an index into a pointer to its lead byte. Out of bounds indexing will raise IndexError or
// be capped to the first/last character of the string, depending on is_slice.
const byte *micropy_str_index_to_ptr(struct _mp_state_ctx_t *mp_state, const mp_obj_type_t *type, const byte *self_data, size_t self_len,
                             mp_obj_t index, bool is_slice) {
    (void)type;
    mp_int_t i;
    // Copied from mp_get_index; I don't want bounds checking, just give me
    // the integer as-is. (I can't bounds-check without scanning the whole
    // string; an out-of-bounds index will be caught in the loops below.)
    if (MP_OBJ_IS_SMALL_INT(index)) {
        i = MP_OBJ_SMALL_INT_VALUE(index);
    } else if (!micropy_obj_get_int_maybe(mp_state, index, &i)) {
        micropy_nlr_raise(mp_state, micropy_obj_new_exception_msg_varg(mp_state, &mp_type_TypeError, "string indices must be integers, not %s", micropy_obj_get_type_str(mp_state, index)));
    }
    const byte *s, *top = self_data + self_len;
    if (i < 0)
    {
        // Negative indexing is performed by counting from the end of the string.
        for (s = top - 1; i; --s) {
            if (s < self_data) {
                if (is_slice) {
                    return self_data;
                }
                micropy_nlr_raise(mp_state, micropy_obj_new_exception_msg_varg(mp_state, &mp_type_IndexError, "string index out of range"));
            }
            if (!UTF8_IS_CONT(*s)) {
                ++i;
            }
        }
        ++s;
    } else if (!i) {
        return self_data; // Shortcut - str[0] is its base pointer
    } else {
        // Positive indexing, correspondingly, counts from the start of the string.
        // It's assumed that negative indexing will generally be used with small
        // absolute values (eg str[-1], not str[-1000000]), which means it'll be
        // more efficient this way.
        for (s = self_data; true; ++s) {
            if (s >= top) {
                if (is_slice) {
                    return top;
                }
                micropy_nlr_raise(mp_state, micropy_obj_new_exception_msg_varg(mp_state, &mp_type_IndexError, "string index out of range"));
            }
            while (UTF8_IS_CONT(*s)) {
                ++s;
            }
            if (!i--) {
                return s;
            }
        }
    }
    return s;
}

STATIC mp_obj_t micropy_str_subscr(struct _mp_state_ctx_t *mp_state, mp_obj_t self_in, mp_obj_t index, mp_obj_t value) {
    mp_obj_type_t *type = micropy_obj_get_type(mp_state, self_in);
    assert(type == &mp_type_str);
    GET_STR_DATA_LEN(self_in, self_data, self_len);
    if (value == MP_OBJ_SENTINEL) {
        // load
#if MICROPY_PY_BUILTINS_SLICE
        if (MP_OBJ_IS_TYPE(index, &mp_type_slice)) {
            mp_obj_t ostart, ostop, ostep;
            micropy_obj_slice_get(mp_state, index, &ostart, &ostop, &ostep);
            if (ostep != mp_const_none && ostep != MP_OBJ_NEW_SMALL_INT(1)) {
                micropy_not_implemented(mp_state, "only slices with step=1 (aka None) are supported");
            }

            const byte *pstart, *pstop;
            if (ostart != mp_const_none) {
                pstart = micropy_str_index_to_ptr(mp_state, type, self_data, self_len, ostart, true);
            } else {
                pstart = self_data;
            }
            if (ostop != mp_const_none) {
                // pstop will point just after the stop character. This depends on
                // the \0 at the end of the string.
                pstop = micropy_str_index_to_ptr(mp_state, type, self_data, self_len, ostop, true);
            } else {
                pstop = self_data + self_len;
            }
            if (pstop < pstart) {
                return MP_OBJ_NEW_QSTR(MP_QSTR_);
            }
            return micropy_obj_new_str_of_type(mp_state, type, (const byte *)pstart, pstop - pstart);
        }
#endif
        const byte *s = micropy_str_index_to_ptr(mp_state, type, self_data, self_len, index, false);
        int len = 1;
        if (UTF8_IS_NONASCII(*s)) {
            // Count the number of 1 bits (after the first)
            for (char mask = 0x40; *s & mask; mask >>= 1) {
                ++len;
            }
        }
        return micropy_obj_new_str(mp_state, (const char*)s, len, true); // This will create a one-character string
    } else {
        return MP_OBJ_NULL; // op not supported
    }
}

STATIC const mp_rom_map_elem_t struni_locals_dict_table[] = {
#if MICROPY_CPYTHON_COMPAT
    { MP_ROM_QSTR(MP_QSTR_encode), MP_ROM_PTR(&str_encode_obj) },
#endif
    { MP_ROM_QSTR(MP_QSTR_find), MP_ROM_PTR(&str_find_obj) },
    { MP_ROM_QSTR(MP_QSTR_rfind), MP_ROM_PTR(&str_rfind_obj) },
    { MP_ROM_QSTR(MP_QSTR_index), MP_ROM_PTR(&str_index_obj) },
    { MP_ROM_QSTR(MP_QSTR_rindex), MP_ROM_PTR(&str_rindex_obj) },
    { MP_ROM_QSTR(MP_QSTR_join), MP_ROM_PTR(&str_join_obj) },
    { MP_ROM_QSTR(MP_QSTR_split), MP_ROM_PTR(&str_split_obj) },
    #if MICROPY_PY_BUILTINS_STR_SPLITLINES
    { MP_ROM_QSTR(MP_QSTR_splitlines), MP_ROM_PTR(&str_splitlines_obj) },
    #endif
    { MP_ROM_QSTR(MP_QSTR_rsplit), MP_ROM_PTR(&str_rsplit_obj) },
    { MP_ROM_QSTR(MP_QSTR_startswith), MP_ROM_PTR(&str_startswith_obj) },
    { MP_ROM_QSTR(MP_QSTR_endswith), MP_ROM_PTR(&str_endswith_obj) },
    { MP_ROM_QSTR(MP_QSTR_strip), MP_ROM_PTR(&str_strip_obj) },
    { MP_ROM_QSTR(MP_QSTR_lstrip), MP_ROM_PTR(&str_lstrip_obj) },
    { MP_ROM_QSTR(MP_QSTR_rstrip), MP_ROM_PTR(&str_rstrip_obj) },
    { MP_ROM_QSTR(MP_QSTR_format), MP_ROM_PTR(&str_format_obj) },
    { MP_ROM_QSTR(MP_QSTR_replace), MP_ROM_PTR(&str_replace_obj) },
    { MP_ROM_QSTR(MP_QSTR_count), MP_ROM_PTR(&str_count_obj) },
    { MP_ROM_QSTR(MP_QSTR_partition), MP_ROM_PTR(&str_partition_obj) },
    { MP_ROM_QSTR(MP_QSTR_rpartition), MP_ROM_PTR(&str_rpartition_obj) },
#if MICROPY_PY_BUILTINS_STR_CENTER
    { MP_ROM_QSTR(MP_QSTR_center), MP_ROM_PTR(&str_center_obj) },
#endif
    { MP_ROM_QSTR(MP_QSTR_lower), MP_ROM_PTR(&str_lower_obj) },
    { MP_ROM_QSTR(MP_QSTR_upper), MP_ROM_PTR(&str_upper_obj) },
    { MP_ROM_QSTR(MP_QSTR_isspace), MP_ROM_PTR(&str_isspace_obj) },
    { MP_ROM_QSTR(MP_QSTR_isalpha), MP_ROM_PTR(&str_isalpha_obj) },
    { MP_ROM_QSTR(MP_QSTR_isdigit), MP_ROM_PTR(&str_isdigit_obj) },
    { MP_ROM_QSTR(MP_QSTR_isupper), MP_ROM_PTR(&str_isupper_obj) },
    { MP_ROM_QSTR(MP_QSTR_islower), MP_ROM_PTR(&str_islower_obj) },
};

STATIC MP_DEFINE_CONST_DICT(struni_locals_dict, struni_locals_dict_table);

const mp_obj_type_t mp_type_str = {
    { &mp_type_type },
    .name = MP_QSTR_str,
    .print = micropy_uni_print,
    .make_new = micropy_obj_str_make_new,
    .unary_op = micropy_uni_unary_op,
    .binary_op = micropy_obj_str_binary_op,
    .subscr = micropy_str_subscr,
    .getiter = micropy_obj_new_str_iterator,
    .buffer_p = { .get_buffer = micropy_obj_str_get_buffer, },
    .locals_dict = (mp_obj_dict_t*)&struni_locals_dict,
};

/******************************************************************************/
/* str iterator                                                               */

typedef struct _mp_obj_str_it_t {
    mp_obj_base_t base;
    mp_fun_1_t iternext;
    mp_obj_t str;
    mp_uint_t cur;
} mp_obj_str_it_t;

STATIC mp_obj_t micropy_str_it_iternext(struct _mp_state_ctx_t *mp_state, mp_obj_t self_in) {
    mp_obj_str_it_t *self = MP_OBJ_TO_PTR(self_in);
    GET_STR_DATA_LEN(self->str, str, len);
    if (self->cur < len) {
        const byte *cur = str + self->cur;
        const byte *end = utf8_next_char(str + self->cur);
        mp_obj_t o_out = micropy_obj_new_str(mp_state, (const char*)cur, end - cur, true);
        self->cur += end - cur;
        return o_out;
    } else {
        return MP_OBJ_STOP_ITERATION;
    }
}

STATIC mp_obj_t micropy_obj_new_str_iterator(struct _mp_state_ctx_t *mp_state, mp_obj_t str) {
    mp_obj_str_it_t *o = micropy_m_new_obj(mp_state, mp_obj_str_it_t);
    o->base.type = &mp_type_polymorph_iter;
    o->iternext = micropy_str_it_iternext;
    o->str = str;
    o->cur = 0;
    return MP_OBJ_FROM_PTR(o);
}

#endif // MICROPY_PY_BUILTINS_STR_UNICODE
/*
 * This file is part of the Micro Python project, http://micropython.org/
 *
 * The MIT License (MIT)
 *
 * Copyright (c) 2013, 2014 Damien P. George
 * Copyright (c) 2014 Paul Sokolovsky
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

#include <stdio.h>
#include <string.h>

//#include "py/nlr.h"
//#include "py/objstr.h"
//#include "py/runtime.h"
//#include "py/stream.h"

#if MICROPY_PY_IO

typedef struct _mp_obj_stringio_t {
    mp_obj_base_t base;
    vstr_t *vstr;
    // StringIO has single pointer used for both reading and writing
    mp_uint_t pos;
} mp_obj_stringio_t;

#if MICROPY_CPYTHON_COMPAT
STATIC void micropy_check_stringio_is_open(struct _mp_state_ctx_t *mp_state, const mp_obj_stringio_t *o) {
    if (o->vstr == NULL) {
        micropy_nlr_raise(mp_state, micropy_obj_new_exception_msg(mp_state, &mp_type_ValueError, "I/O operation on closed file"));
    }
}
#else
#define micropy_check_stringio_is_open(mp_state, o)
#endif

STATIC void micropy_stringio_print(struct _mp_state_ctx_t *mp_state, const mp_print_t *print, mp_obj_t self_in, mp_print_kind_t kind) {
    (void)kind;
    mp_obj_stringio_t *self = MP_OBJ_TO_PTR(self_in);
    micropy_printf(mp_state, print, self->base.type == &mp_type_stringio ? "<io.StringIO 0x%x>" : "<io.BytesIO 0x%x>", self);
}

STATIC mp_uint_t micropy_stringio_read(struct _mp_state_ctx_t *mp_state, mp_obj_t o_in, void *buf, mp_uint_t size, int *errcode) {
    (void)errcode;
    mp_obj_stringio_t *o = MP_OBJ_TO_PTR(o_in);
    micropy_check_stringio_is_open(mp_state, o);
    mp_uint_t remaining = o->vstr->len - o->pos;
    if (size > remaining) {
        size = remaining;
    }
    memcpy(buf, o->vstr->buf + o->pos, size);
    o->pos += size;
    return size;
}

STATIC mp_uint_t micropy_stringio_write(struct _mp_state_ctx_t *mp_state, mp_obj_t o_in, const void *buf, mp_uint_t size, int *errcode) {
    (void)errcode;
    mp_obj_stringio_t *o = MP_OBJ_TO_PTR(o_in);
    micropy_check_stringio_is_open(mp_state, o);
    mp_uint_t remaining = o->vstr->alloc - o->pos;
    if (size > remaining) {
        // Take all what's already allocated...
        o->vstr->len = o->vstr->alloc;
        // ... and add more
        micropy_vstr_add_len(mp_state, o->vstr, size - remaining);
    }
    memcpy(o->vstr->buf + o->pos, buf, size);
    o->pos += size;
    if (o->pos > o->vstr->len) {
        o->vstr->len = o->pos;
    }
    return size;
}

#define STREAM_TO_CONTENT_TYPE(o) (((o)->base.type == &mp_type_stringio) ? &mp_type_str : &mp_type_bytes)

STATIC mp_obj_t micropy_stringio_getvalue(struct _mp_state_ctx_t *mp_state, mp_obj_t self_in) {
    mp_obj_stringio_t *self = MP_OBJ_TO_PTR(self_in);
    micropy_check_stringio_is_open(mp_state, self);
    // TODO: Try to avoid copying string
    return micropy_obj_new_str_of_type(mp_state, STREAM_TO_CONTENT_TYPE(self), (byte*)self->vstr->buf, self->vstr->len);
}
STATIC MP_DEFINE_CONST_FUN_OBJ_1(stringio_getvalue_obj, micropy_stringio_getvalue);

STATIC mp_obj_t micropy_stringio_close(struct _mp_state_ctx_t *mp_state, mp_obj_t self_in) {
    mp_obj_stringio_t *self = MP_OBJ_TO_PTR(self_in);
#if MICROPY_CPYTHON_COMPAT
    micropy_vstr_free(mp_state, self->vstr);
    self->vstr = NULL;
#else
    micropy_vstr_clear(mp_state, self->vstr);
    self->vstr->alloc = 0;
    self->vstr->len = 0;
    self->pos = 0;
#endif
    return mp_const_none;
}
STATIC MP_DEFINE_CONST_FUN_OBJ_1(stringio_close_obj, micropy_stringio_close);

STATIC mp_obj_t micropy_stringio___exit__(struct _mp_state_ctx_t *mp_state, size_t n_args, const mp_obj_t *args) {
    (void)n_args;
    return micropy_stringio_close(mp_state, args[0]);
}
STATIC MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(stringio___exit___obj, 4, 4, micropy_stringio___exit__);

STATIC mp_obj_stringio_t *micropy_stringio_new(struct _mp_state_ctx_t *mp_state, const mp_obj_type_t *type) {
    mp_obj_stringio_t *o = micropy_m_new_obj(mp_state, mp_obj_stringio_t);
    o->base.type = type;
    o->vstr = micropy_vstr_new(mp_state);
    o->pos = 0;
    return o;
}

STATIC mp_obj_t micropy_stringio_make_new(struct _mp_state_ctx_t *mp_state, const mp_obj_type_t *type_in, size_t n_args, size_t n_kw, const mp_obj_t *args) {
    (void)n_kw; // TODO check n_kw==0
    mp_obj_stringio_t *o = micropy_stringio_new(mp_state, type_in);

    if (n_args > 0) {
        mp_buffer_info_t bufinfo;
        micropy_get_buffer_raise(mp_state, args[0], &bufinfo, MP_BUFFER_READ);
        micropy_stringio_write(mp_state, MP_OBJ_FROM_PTR(o), bufinfo.buf, bufinfo.len, NULL);
        // Cur ptr is always at the beginning of buffer at the construction
        o->pos = 0;
    }
    return MP_OBJ_FROM_PTR(o);
}

STATIC const mp_rom_map_elem_t stringio_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_read), MP_ROM_PTR(&mp_stream_read_obj) },
    { MP_ROM_QSTR(MP_QSTR_readall), MP_ROM_PTR(&mp_stream_readall_obj) },
    { MP_ROM_QSTR(MP_QSTR_readline), MP_ROM_PTR(&mp_stream_unbuffered_readline_obj) },
    { MP_ROM_QSTR(MP_QSTR_write), MP_ROM_PTR(&mp_stream_write_obj) },
    { MP_ROM_QSTR(MP_QSTR_close), MP_ROM_PTR(&stringio_close_obj) },
    { MP_ROM_QSTR(MP_QSTR_getvalue), MP_ROM_PTR(&stringio_getvalue_obj) },
    { MP_ROM_QSTR(MP_QSTR___enter__), MP_ROM_PTR(&mp_identity_obj) },
    { MP_ROM_QSTR(MP_QSTR___exit__), MP_ROM_PTR(&stringio___exit___obj) },
};

STATIC MP_DEFINE_CONST_DICT(stringio_locals_dict, stringio_locals_dict_table);

STATIC const mp_stream_p_t stringio_stream_p = {
    .read = micropy_stringio_read,
    .write = micropy_stringio_write,
    .is_text = true,
};

STATIC const mp_stream_p_t bytesio_stream_p = {
    .read = micropy_stringio_read,
    .write = micropy_stringio_write,
};

const mp_obj_type_t mp_type_stringio = {
    { &mp_type_type },
    .name = MP_QSTR_StringIO,
    .print = micropy_stringio_print,
    .make_new = micropy_stringio_make_new,
    .getiter = micropy_identity,
    .iternext = micropy_stream_unbuffered_iter,
    .stream_p = &stringio_stream_p,
    .locals_dict = (mp_obj_dict_t*)&stringio_locals_dict,
};

#if MICROPY_PY_IO_BYTESIO
const mp_obj_type_t mp_type_bytesio = {
    { &mp_type_type },
    .name = MP_QSTR_BytesIO,
    .print = micropy_stringio_print,
    .make_new = micropy_stringio_make_new,
    .getiter = micropy_identity,
    .iternext = micropy_stream_unbuffered_iter,
    .stream_p = &bytesio_stream_p,
    .locals_dict = (mp_obj_dict_t*)&stringio_locals_dict,
};
#endif

#endif
/*
 * This file is part of the Micro Python project, http://micropython.org/
 *
 * The MIT License (MIT)
 *
 * Copyright (c) 2013, 2014 Damien P. George
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

#include <string.h>
#include <assert.h>

//#include "py/nlr.h"
//#include "py/objtuple.h"
//#include "py/runtime0.h"
//#include "py/runtime.h"

STATIC mp_obj_t micropy_obj_new_tuple_iterator(struct _mp_state_ctx_t *mp_state, mp_obj_tuple_t *tuple, mp_uint_t cur);

/******************************************************************************/
/* tuple                                                                      */

void micropy_obj_tuple_print(struct _mp_state_ctx_t *mp_state, const mp_print_t *print, mp_obj_t o_in, mp_print_kind_t kind) {
    mp_obj_tuple_t *o = MP_OBJ_TO_PTR(o_in);
    if (MICROPY_PY_UJSON && kind == PRINT_JSON) {
        micropy_print_str(mp_state, print, "[");
    } else {
        micropy_print_str(mp_state, print, "(");
        kind = PRINT_REPR;
    }
    for (mp_uint_t i = 0; i < o->len; i++) {
        if (i > 0) {
            micropy_print_str(mp_state, print, ", ");
        }
        micropy_obj_print_helper(mp_state, print, o->items[i], kind);
    }
    if (MICROPY_PY_UJSON && kind == PRINT_JSON) {
        micropy_print_str(mp_state, print, "]");
    } else {
        if (o->len == 1) {
            micropy_print_str(mp_state, print, ",");
        }
        micropy_print_str(mp_state, print, ")");
    }
}

STATIC mp_obj_t micropy_obj_tuple_make_new(struct _mp_state_ctx_t *mp_state, const mp_obj_type_t *type_in, size_t n_args, size_t n_kw, const mp_obj_t *args) {
    (void)type_in;

    micropy_arg_check_num(mp_state, n_args, n_kw, 0, 1, false);

    switch (n_args) {
        case 0:
            // return a empty tuple
            return mp_const_empty_tuple;

        case 1:
        default: {
            // 1 argument, an iterable from which we make a new tuple
            if (MP_OBJ_IS_TYPE(args[0], &mp_type_tuple)) {
                return args[0];
            }

            // TODO optimise for cases where we know the length of the iterator

            mp_uint_t alloc = 4;
            mp_uint_t len = 0;
            mp_obj_t *items = micropy_m_new(mp_state, mp_obj_t, alloc);

            mp_obj_t iterable = micropy_getiter(mp_state, args[0]);
            mp_obj_t item;
            while ((item = micropy_iternext(mp_state, iterable)) != MP_OBJ_STOP_ITERATION) {
                if (len >= alloc) {
                    items = micropy_m_renew(mp_state, mp_obj_t, items, alloc, alloc * 2);
                    alloc *= 2;
                }
                items[len++] = item;
            }

            mp_obj_t tuple = micropy_obj_new_tuple(mp_state, len, items);
            micropy_m_del(mp_state, mp_obj_t, items, alloc);

            return tuple;
        }
    }
}

// Don't pass MP_BINARY_OP_NOT_EQUAL here
STATIC bool micropy_tuple_cmp_helper(struct _mp_state_ctx_t *mp_state, mp_uint_t op, mp_obj_t self_in, mp_obj_t another_in) {
    mp_obj_type_t *self_type = micropy_obj_get_type(mp_state, self_in);
    if (self_type->getiter != micropy_obj_tuple_getiter) {
        assert(0);
    }
    mp_obj_type_t *another_type = micropy_obj_get_type(mp_state, another_in);
    mp_obj_tuple_t *self = MP_OBJ_TO_PTR(self_in);
    if (another_type->getiter != micropy_obj_tuple_getiter) {
        // Slow path for user subclasses
        another_in = micropy_instance_cast_to_native_base(mp_state, another_in, MP_OBJ_FROM_PTR(&mp_type_tuple));
        if (another_in == MP_OBJ_NULL) {
            return false;
        }
    }
    mp_obj_tuple_t *another = MP_OBJ_TO_PTR(another_in);

    return micropy_seq_cmp_objs(mp_state, op, self->items, self->len, another->items, another->len);
}

mp_obj_t micropy_obj_tuple_unary_op(struct _mp_state_ctx_t *mp_state, mp_uint_t op, mp_obj_t self_in) {
    mp_obj_tuple_t *self = MP_OBJ_TO_PTR(self_in);
    switch (op) {
        case MP_UNARY_OP_BOOL: return micropy_obj_new_bool(mp_state, self->len != 0);
        case MP_UNARY_OP_HASH: {
            // start hash with pointer to empty tuple, to make it fairly unique
            mp_int_t hash = (mp_int_t)mp_const_empty_tuple;
            for (mp_uint_t i = 0; i < self->len; i++) {
                hash += MP_OBJ_SMALL_INT_VALUE(micropy_unary_op(mp_state, MP_UNARY_OP_HASH, self->items[i]));
            }
            return MP_OBJ_NEW_SMALL_INT(hash);
        }
        case MP_UNARY_OP_LEN: return MP_OBJ_NEW_SMALL_INT(self->len);
        default: return MP_OBJ_NULL; // op not supported
    }
}

mp_obj_t micropy_obj_tuple_binary_op(struct _mp_state_ctx_t *mp_state, mp_uint_t op, mp_obj_t lhs, mp_obj_t rhs) {
    mp_obj_tuple_t *o = MP_OBJ_TO_PTR(lhs);
    switch (op) {
        case MP_BINARY_OP_ADD: {
            if (!micropy_obj_is_subclass_fast(mp_state, MP_OBJ_FROM_PTR(micropy_obj_get_type(mp_state, rhs)), MP_OBJ_FROM_PTR(&mp_type_tuple))) {
                return MP_OBJ_NULL; // op not supported
            }
            mp_obj_tuple_t *p = MP_OBJ_TO_PTR(rhs);
            mp_obj_tuple_t *s = MP_OBJ_TO_PTR(micropy_obj_new_tuple(mp_state, o->len + p->len, NULL));
            micropy_seq_cat(mp_state, s->items, o->items, o->len, p->items, p->len, mp_obj_t);
            return MP_OBJ_FROM_PTR(s);
        }
        case MP_BINARY_OP_MULTIPLY: {
            mp_int_t n;
            if (!micropy_obj_get_int_maybe(mp_state, rhs, &n)) {
                return MP_OBJ_NULL; // op not supported
            }
            if (n <= 0) {
                return mp_const_empty_tuple;
            }
            mp_obj_tuple_t *s = MP_OBJ_TO_PTR(micropy_obj_new_tuple(mp_state, o->len * n, NULL));
            micropy_seq_multiply(mp_state, o->items, sizeof(*o->items), o->len, n, s->items);
            return MP_OBJ_FROM_PTR(s);
        }
        case MP_BINARY_OP_EQUAL:
        case MP_BINARY_OP_LESS:
        case MP_BINARY_OP_LESS_EQUAL:
        case MP_BINARY_OP_MORE:
        case MP_BINARY_OP_MORE_EQUAL:
            return micropy_obj_new_bool(mp_state, micropy_tuple_cmp_helper(mp_state, op, lhs, rhs));

        default:
            return MP_OBJ_NULL; // op not supported
    }
}

mp_obj_t micropy_obj_tuple_subscr(struct _mp_state_ctx_t *mp_state, mp_obj_t self_in, mp_obj_t index, mp_obj_t value) {
    if (value == MP_OBJ_SENTINEL) {
        // load
        mp_obj_tuple_t *self = MP_OBJ_TO_PTR(self_in);
#if MICROPY_PY_BUILTINS_SLICE
        if (MP_OBJ_IS_TYPE(index, &mp_type_slice)) {
            mp_bound_slice_t slice;
            if (!micropy_seq_get_fast_slice_indexes(mp_state, self->len, index, &slice)) {
                micropy_not_implemented(mp_state, "only slices with step=1 (aka None) are supported");
            }
            mp_obj_tuple_t *res = MP_OBJ_TO_PTR(micropy_obj_new_tuple(mp_state, slice.stop - slice.start, NULL));
            micropy_seq_copy(mp_state, res->items, self->items + slice.start, res->len, mp_obj_t);
            return MP_OBJ_FROM_PTR(res);
        }
#endif
        mp_uint_t index_value = micropy_get_index(mp_state, self->base.type, self->len, index, false);
        return self->items[index_value];
    } else {
        return MP_OBJ_NULL; // op not supported
    }
}

mp_obj_t micropy_obj_tuple_getiter(struct _mp_state_ctx_t *mp_state, mp_obj_t o_in) {
    return micropy_obj_new_tuple_iterator(mp_state, MP_OBJ_TO_PTR(o_in), 0);
}

STATIC mp_obj_t micropy_tuple_count(struct _mp_state_ctx_t *mp_state, mp_obj_t self_in, mp_obj_t value) {
    assert(MP_OBJ_IS_TYPE(self_in, &mp_type_tuple));
    mp_obj_tuple_t *self = MP_OBJ_TO_PTR(self_in);
    return micropy_seq_count_obj(mp_state, self->items, self->len, value);
}
STATIC MP_DEFINE_CONST_FUN_OBJ_2(tuple_count_obj, micropy_tuple_count);

STATIC mp_obj_t micropy_tuple_index(struct _mp_state_ctx_t *mp_state, size_t n_args, const mp_obj_t *args) {
    assert(MP_OBJ_IS_TYPE(args[0], &mp_type_tuple));
    mp_obj_tuple_t *self = MP_OBJ_TO_PTR(args[0]);
    return micropy_seq_index_obj(mp_state, self->items, self->len, n_args, args);
}
STATIC MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(tuple_index_obj, 2, 4, micropy_tuple_index);

STATIC const mp_rom_map_elem_t tuple_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_count), MP_ROM_PTR(&tuple_count_obj) },
    { MP_ROM_QSTR(MP_QSTR_index), MP_ROM_PTR(&tuple_index_obj) },
};

STATIC MP_DEFINE_CONST_DICT(tuple_locals_dict, tuple_locals_dict_table);

const mp_obj_type_t mp_type_tuple = {
    { &mp_type_type },
    .name = MP_QSTR_tuple,
    .print = micropy_obj_tuple_print,
    .make_new = micropy_obj_tuple_make_new,
    .unary_op = micropy_obj_tuple_unary_op,
    .binary_op = micropy_obj_tuple_binary_op,
    .subscr = micropy_obj_tuple_subscr,
    .getiter = micropy_obj_tuple_getiter,
    .locals_dict = (mp_obj_dict_t*)&tuple_locals_dict,
};

// the zero-length tuple
const mp_obj_tuple_t mp_const_empty_tuple_obj = {{&mp_type_tuple}, 0};

mp_obj_t micropy_obj_new_tuple(struct _mp_state_ctx_t *mp_state, mp_uint_t n, const mp_obj_t *items) {
    if (n == 0) {
        return mp_const_empty_tuple;
    }
    mp_obj_tuple_t *o = micropy_m_new_obj_var(mp_state, mp_obj_tuple_t, mp_obj_t, n);
    o->base.type = &mp_type_tuple;
    o->len = n;
    if (items) {
        for (mp_uint_t i = 0; i < n; i++) {
            o->items[i] = items[i];
        }
    }
    return MP_OBJ_FROM_PTR(o);
}

void micropy_obj_tuple_get(struct _mp_state_ctx_t *mp_state, mp_obj_t self_in, mp_uint_t *len, mp_obj_t **items) {
    assert(MP_OBJ_IS_TYPE(self_in, &mp_type_tuple));
    mp_obj_tuple_t *self = MP_OBJ_TO_PTR(self_in);
    *len = self->len;
    *items = &self->items[0];
}

void micropy_obj_tuple_del(struct _mp_state_ctx_t *mp_state, mp_obj_t self_in) {
    assert(MP_OBJ_IS_TYPE(self_in, &mp_type_tuple));
    mp_obj_tuple_t *self = MP_OBJ_TO_PTR(self_in);
    micropy_m_del_var(mp_state, mp_obj_tuple_t, mp_obj_t, self->len, self);
}

/******************************************************************************/
/* tuple iterator                                                             */

typedef struct _mp_obj_tuple_it_t {
    mp_obj_base_t base;
    mp_fun_1_t iternext;
    mp_obj_tuple_t *tuple;
    mp_uint_t cur;
} mp_obj_tuple_it_t;

STATIC mp_obj_t micropy_tuple_it_iternext(struct _mp_state_ctx_t *mp_state, mp_obj_t self_in) {
    mp_obj_tuple_it_t *self = MP_OBJ_TO_PTR(self_in);
    if (self->cur < self->tuple->len) {
        mp_obj_t o_out = self->tuple->items[self->cur];
        self->cur += 1;
        return o_out;
    } else {
        return MP_OBJ_STOP_ITERATION;
    }
}

STATIC mp_obj_t micropy_obj_new_tuple_iterator(struct _mp_state_ctx_t *mp_state, mp_obj_tuple_t *tuple, mp_uint_t cur) {
    mp_obj_tuple_it_t *o = micropy_m_new_obj(mp_state, mp_obj_tuple_it_t);
    o->base.type = &mp_type_polymorph_iter;
    o->iternext = micropy_tuple_it_iternext;
    o->tuple = tuple;
    o->cur = cur;
    return MP_OBJ_FROM_PTR(o);
}
/*
 * This file is part of the Micro Python project, http://micropython.org/
 *
 * The MIT License (MIT)
 *
 * Copyright (c) 2013, 2014 Damien P. George
 * Copyright (c) 2014 Paul Sokolovsky
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

#include <stdio.h>
#include <stddef.h>
#include <string.h>
#include <assert.h>

//#include "py/nlr.h"
//#include "py/objtype.h"
//#include "py/runtime0.h"
//#include "py/runtime.h"

#if 0 // print debugging info
#define DEBUG_PRINT (1)
#define DEBUG_printf DEBUG_printf
#else // don't print debugging info
#define DEBUG_PRINT (0)
#define DEBUG_printf(...) (void)0
#endif

STATIC mp_obj_t micropy_static_class_method_make_new(struct _mp_state_ctx_t *mp_state, const mp_obj_type_t *self_in, size_t n_args, size_t n_kw, const mp_obj_t *args);

/******************************************************************************/
// instance object

STATIC mp_obj_t micropy_obj_new_instance(struct _mp_state_ctx_t *mp_state, const mp_obj_type_t *class, uint subobjs) {
    mp_obj_instance_t *o = micropy_m_new_obj_var(mp_state, mp_obj_instance_t, mp_obj_t, subobjs);
    o->base.type = class;
    micropy_map_init(mp_state, &o->members, 0);
    micropy_seq_clear(mp_state, o->subobj, 0, subobjs, sizeof(*o->subobj));
    return MP_OBJ_FROM_PTR(o);
}

STATIC int micropy_instance_count_native_bases(struct _mp_state_ctx_t *mp_state, const mp_obj_type_t *type, const mp_obj_type_t **last_native_base) {
    mp_uint_t len = type->bases_tuple->len;
    mp_obj_t *items = type->bases_tuple->items;

    int count = 0;
    for (uint i = 0; i < len; i++) {
        assert(MP_OBJ_IS_TYPE(items[i], &mp_type_type));
        const mp_obj_type_t *bt = (const mp_obj_type_t *)MP_OBJ_TO_PTR(items[i]);
        if (bt == &mp_type_object) {
            // Not a "real" type
            continue;
        }
        if (micropy_obj_is_native_type(mp_state, bt)) {
            *last_native_base = bt;
            count++;
        } else {
            count += micropy_instance_count_native_bases(mp_state, bt, last_native_base);
        }
    }

    return count;
}

// TODO
// This implements depth-first left-to-right MRO, which is not compliant with Python3 MRO
// http://python-history.blogspot.com/2010/06/method-resolution-order.html
// https://www.python.org/download/releases/2.3/mro/
//
// will keep lookup->dest[0]'s value (should be MP_OBJ_NULL on invocation) if attribute
// is not found
// will set lookup->dest[0] to MP_OBJ_SENTINEL if special method was found in a native
// type base via slot id (as specified by lookup->meth_offset). As there can be only one
// native base, it's known that it applies to instance->subobj[0]. In most cases, we also
// don't need to know which type it was - because instance->subobj[0] is of that type.
// The only exception is when object is not yet constructed, then we need to know base
// native type to construct its instance->subobj[0] from. But this case is handled via
// instance_count_native_bases(), which returns a native base which it saw.
struct class_lookup_data {
    mp_obj_instance_t *obj;
    qstr attr;
    mp_uint_t meth_offset;
    mp_obj_t *dest;
    bool is_type;
};

STATIC void micropy_obj_class_lookup(struct _mp_state_ctx_t *mp_state, struct class_lookup_data  *lookup, const mp_obj_type_t *type) {
    assert(lookup->dest[0] == MP_OBJ_NULL);
    assert(lookup->dest[1] == MP_OBJ_NULL);
    for (;;) {
        // Optimize special method lookup for native types
        // This avoids extra method_name => slot lookup. On the other hand,
        // this should not be applied to class types, as will result in extra
        // lookup either.
        if (lookup->meth_offset != 0 && micropy_obj_is_native_type(mp_state, type)) {
            if (*(void**)((char*)type + lookup->meth_offset) != NULL) {
                DEBUG_printf("mp_obj_class_lookup: matched special meth slot for %s\n", micropy_qstr_str(mp_state, lookup->attr));
                lookup->dest[0] = MP_OBJ_SENTINEL;
                return;
            }
        }

        if (type->locals_dict != NULL) {
            // search locals_dict (the set of methods/attributes)
            assert(type->locals_dict->base.type == &mp_type_dict); // MicroPython restriction, for now
            mp_map_t *locals_map = &type->locals_dict->map;
            mp_map_elem_t *elem = micropy_map_lookup(mp_state, locals_map, MP_OBJ_NEW_QSTR(lookup->attr), MP_MAP_LOOKUP);
            if (elem != NULL) {
                if (lookup->is_type) {
                    // If we look up a class method, we need to return original type for which we
                    // do a lookup, not a (base) type in which we found the class method.
                    const mp_obj_type_t *org_type = (const mp_obj_type_t*)lookup->obj;
                    micropy_convert_member_lookup(mp_state, MP_OBJ_NULL, org_type, elem->value, lookup->dest);
                } else {
                    mp_obj_instance_t *obj = lookup->obj;
                    mp_obj_t obj_obj;
                    if (obj != NULL && micropy_obj_is_native_type(mp_state, type) && type != &mp_type_object /* object is not a real type */) {
                        // If we're dealing with native base class, then it applies to native sub-object
                        obj_obj = obj->subobj[0];
                    } else {
                        obj_obj = MP_OBJ_FROM_PTR(obj);
                    }
                    micropy_convert_member_lookup(mp_state, obj_obj, type, elem->value, lookup->dest);
                }
#if DEBUG_PRINT
                printf("mp_obj_class_lookup: Returning: ");
                micropy_obj_print(mp_state, lookup->dest[0], PRINT_REPR); printf(" ");
                micropy_obj_print(mp_state, lookup->dest[1], PRINT_REPR); printf("\n");
#endif
                return;
            }
        }

        // Previous code block takes care about attributes defined in .locals_dict,
        // but some attributes of native types may be handled using .load_attr method,
        // so make sure we try to lookup those too.
        if (lookup->obj != NULL && !lookup->is_type && micropy_obj_is_native_type(mp_state, type) && type != &mp_type_object /* object is not a real type */) {
            micropy_load_method_maybe(mp_state, lookup->obj->subobj[0], lookup->attr, lookup->dest);
            if (lookup->dest[0] != MP_OBJ_NULL) {
                return;
            }
        }

        // attribute not found, keep searching base classes

        // for a const struct, this entry might be NULL
        if (type->bases_tuple == NULL) {
            return;
        }

        mp_uint_t len = type->bases_tuple->len;
        mp_obj_t *items = type->bases_tuple->items;
        if (len == 0) {
            return;
        }
        for (uint i = 0; i < len - 1; i++) {
            assert(MP_OBJ_IS_TYPE(items[i], &mp_type_type));
            mp_obj_type_t *bt = (mp_obj_type_t*)MP_OBJ_TO_PTR(items[i]);
            if (bt == &mp_type_object) {
                // Not a "real" type
                continue;
            }
            micropy_obj_class_lookup(mp_state, lookup, bt);
            if (lookup->dest[0] != MP_OBJ_NULL) {
                return;
            }
        }

        // search last base (simple tail recursion elimination)
        assert(MP_OBJ_IS_TYPE(items[len - 1], &mp_type_type));
        type = (mp_obj_type_t*)MP_OBJ_TO_PTR(items[len - 1]);
        if (type == &mp_type_object) {
            // Not a "real" type
            return;
        }
    }
}

STATIC void micropy_instance_print(struct _mp_state_ctx_t *mp_state, const mp_print_t *print, mp_obj_t self_in, mp_print_kind_t kind) {
    mp_obj_instance_t *self = MP_OBJ_TO_PTR(self_in);
    qstr meth = (kind == PRINT_STR) ? MP_QSTR___str__ : MP_QSTR___repr__;
    mp_obj_t member[2] = {MP_OBJ_NULL};
    struct class_lookup_data lookup = {
        .obj = self,
        .attr = meth,
        .meth_offset = offsetof(mp_obj_type_t, print),
        .dest = member,
        .is_type = false,
    };
    micropy_obj_class_lookup(mp_state, &lookup, self->base.type);
    if (member[0] == MP_OBJ_NULL && kind == PRINT_STR) {
        // If there's no __str__, fall back to __repr__
        lookup.attr = MP_QSTR___repr__;
        lookup.meth_offset = 0;
        micropy_obj_class_lookup(mp_state, &lookup, self->base.type);
    }

    if (member[0] == MP_OBJ_SENTINEL) {
        // Handle Exception subclasses specially
        if (micropy_obj_is_native_exception_instance(mp_state, self->subobj[0])) {
            if (kind != PRINT_STR) {
                micropy_print_str(mp_state, print, micropy_qstr_str(mp_state, self->base.type->name));
            }
            micropy_obj_print_helper(mp_state, print, self->subobj[0], kind | PRINT_EXC_SUBCLASS);
        } else {
            micropy_obj_print_helper(mp_state, print, self->subobj[0], kind);
        }
        return;
    }

    if (member[0] != MP_OBJ_NULL) {
        mp_obj_t r = micropy_call_function_1(mp_state, member[0], self_in);
        micropy_obj_print_helper(mp_state, print, r, PRINT_STR);
        return;
    }

    // TODO: CPython prints fully-qualified type name
    micropy_printf(mp_state, print, "<%s object at %p>", micropy_obj_get_type_str(mp_state, self_in), self);
}

mp_obj_t micropy_obj_instance_make_new(struct _mp_state_ctx_t *mp_state, const mp_obj_type_t *self, size_t n_args, size_t n_kw, const mp_obj_t *args) {
    assert(micropy_obj_is_instance_type(mp_state, self));

    const mp_obj_type_t *native_base;
    uint num_native_bases = micropy_instance_count_native_bases(mp_state, self, &native_base);
    assert(num_native_bases < 2);

    mp_obj_instance_t *o = MP_OBJ_TO_PTR(micropy_obj_new_instance(mp_state, self, num_native_bases));

    // This executes only "__new__" part of obejection creation.
    // TODO: This won't work will for classes with native bases.
    // TODO: This is hack, should be resolved along the lines of
    // https://github.com/micropython/micropython/issues/606#issuecomment-43685883
    if (n_args == 1 && *args == MP_OBJ_SENTINEL) {
        return MP_OBJ_FROM_PTR(o);
    }

    // look for __new__ function
    mp_obj_t init_fn[2] = {MP_OBJ_NULL};
    struct class_lookup_data lookup = {
        .obj = NULL,
        .attr = MP_QSTR___new__,
        .meth_offset = offsetof(mp_obj_type_t, make_new),
        .dest = init_fn,
        .is_type = false,
    };
    micropy_obj_class_lookup(mp_state, &lookup, self);

    mp_obj_t new_ret = MP_OBJ_FROM_PTR(o);
    if (init_fn[0] == MP_OBJ_SENTINEL) {
        // Native type's constructor is what wins - it gets all our arguments,
        // and none Python classes are initialized at all.
        o->subobj[0] = native_base->make_new(mp_state, native_base, n_args, n_kw, args);
    } else if (init_fn[0] != MP_OBJ_NULL) {
        // now call Python class __new__ function with all args
        if (n_args == 0 && n_kw == 0) {
            mp_obj_t args2[1] = {MP_OBJ_FROM_PTR(self)};
            new_ret = micropy_call_function_n_kw(mp_state, init_fn[0], 1, 0, args2);
        } else {
            mp_obj_t *args2 = micropy_m_new(mp_state, mp_obj_t, 1 + n_args + 2 * n_kw);
            args2[0] = MP_OBJ_FROM_PTR(self);
            memcpy(args2 + 1, args, (n_args + 2 * n_kw) * sizeof(mp_obj_t));
            new_ret = micropy_call_function_n_kw(mp_state, init_fn[0], n_args + 1, n_kw, args2);
            micropy_m_del(mp_state, mp_obj_t, args2, 1 + n_args + 2 * n_kw);
        }

    }

    // https://docs.python.org/3.4/reference/datamodel.html#object.__new__
    // "If __new__() does not return an instance of cls, then the new instances __init__() method will not be invoked."
    if (micropy_obj_get_type(mp_state, new_ret) != self) {
        return new_ret;
    }

    o = MP_OBJ_TO_PTR(new_ret);

    // now call Python class __init__ function with all args
    init_fn[0] = init_fn[1] = MP_OBJ_NULL;
    lookup.obj = o;
    lookup.attr = MP_QSTR___init__;
    lookup.meth_offset = 0;
    micropy_obj_class_lookup(mp_state, &lookup, self);
    if (init_fn[0] != MP_OBJ_NULL) {
        mp_obj_t init_ret;
        if (n_args == 0 && n_kw == 0) {
            init_ret = micropy_call_method_n_kw(mp_state, 0, 0, init_fn);
        } else {
            mp_obj_t *args2 = micropy_m_new(mp_state, mp_obj_t, 2 + n_args + 2 * n_kw);
            args2[0] = init_fn[0];
            args2[1] = init_fn[1];
            memcpy(args2 + 2, args, (n_args + 2 * n_kw) * sizeof(mp_obj_t));
            init_ret = micropy_call_method_n_kw(mp_state, n_args, n_kw, args2);
            micropy_m_del(mp_state, mp_obj_t, args2, 2 + n_args + 2 * n_kw);
        }
        if (init_ret != mp_const_none) {
            if (MICROPY_ERROR_REPORTING == MICROPY_ERROR_REPORTING_TERSE) {
                micropy_nlr_raise(mp_state, micropy_obj_new_exception_msg(mp_state, &mp_type_TypeError,
                    "__init__() should return None"));
            } else {
                micropy_nlr_raise(mp_state, micropy_obj_new_exception_msg_varg(mp_state, &mp_type_TypeError,
                    "__init__() should return None, not '%s'", micropy_obj_get_type_str(mp_state, init_ret)));
            }
        }

    }

    return MP_OBJ_FROM_PTR(o);
}

const qstr mp_unary_op_method_name[] = {
    [MP_UNARY_OP_BOOL] = MP_QSTR___bool__,
    [MP_UNARY_OP_LEN] = MP_QSTR___len__,
    [MP_UNARY_OP_HASH] = MP_QSTR___hash__,
    #if MICROPY_PY_ALL_SPECIAL_METHODS
    [MP_UNARY_OP_POSITIVE] = MP_QSTR___pos__,
    [MP_UNARY_OP_NEGATIVE] = MP_QSTR___neg__,
    [MP_UNARY_OP_INVERT] = MP_QSTR___invert__,
    #endif
    [MP_UNARY_OP_NOT] = MP_QSTR_, // don't need to implement this, used to make sure array has full size
};

STATIC mp_obj_t micropy_instance_unary_op(struct _mp_state_ctx_t *mp_state, mp_uint_t op, mp_obj_t self_in) {
    mp_obj_instance_t *self = MP_OBJ_TO_PTR(self_in);
    qstr op_name = mp_unary_op_method_name[op];
    /* Still try to lookup native slot
    if (op_name == 0) {
        return MP_OBJ_NULL;
    }
    */
    mp_obj_t member[2] = {MP_OBJ_NULL};
    struct class_lookup_data lookup = {
        .obj = self,
        .attr = op_name,
        .meth_offset = offsetof(mp_obj_type_t, unary_op),
        .dest = member,
        .is_type = false,
    };
    micropy_obj_class_lookup(mp_state, &lookup, self->base.type);
    if (member[0] == MP_OBJ_SENTINEL) {
        return micropy_unary_op(mp_state, op, self->subobj[0]);
    } else if (member[0] != MP_OBJ_NULL) {
        mp_obj_t val = micropy_call_function_1(mp_state, member[0], self_in);
        // __hash__ must return a small int
        if (op == MP_UNARY_OP_HASH) {
            val = MP_OBJ_NEW_SMALL_INT(micropy_obj_get_int_truncated(mp_state, val));
        }
        return val;
    } else {
        if (op == MP_UNARY_OP_HASH) {
            lookup.attr = MP_QSTR___eq__;
            micropy_obj_class_lookup(mp_state, &lookup, self->base.type);
            if (member[0] == MP_OBJ_NULL) {
                // https://docs.python.org/3/reference/datamodel.html#object.__hash__
                // "User-defined classes have __eq__() and __hash__() methods by default;
                // with them, all objects compare unequal (except with themselves) and 
                // x.__hash__() returns an appropriate value such that x == y implies
                // both that x is y and hash(x) == hash(y)."
                return MP_OBJ_NEW_SMALL_INT((mp_uint_t)self_in);
            }
            // "A class that overrides __eq__() and does not define __hash__() will have its __hash__() implicitly set to None.
            // When the __hash__() method of a class is None, instances of the class will raise an appropriate TypeError"
        }

        return MP_OBJ_NULL; // op not supported
    }
}

const qstr mp_binary_op_method_name[] = {
    /*
    MP_BINARY_OP_OR,
    MP_BINARY_OP_XOR,
    MP_BINARY_OP_AND,
    MP_BINARY_OP_LSHIFT,
    MP_BINARY_OP_RSHIFT,
    */
    [MP_BINARY_OP_ADD] = MP_QSTR___add__,
    [MP_BINARY_OP_SUBTRACT] = MP_QSTR___sub__,
    #if MICROPY_PY_ALL_SPECIAL_METHODS
    [MP_BINARY_OP_MULTIPLY] = MP_QSTR___mul__,
    [MP_BINARY_OP_FLOOR_DIVIDE] = MP_QSTR___floordiv__,
    [MP_BINARY_OP_TRUE_DIVIDE] = MP_QSTR___truediv__,
    #endif
    /*
    MP_BINARY_OP_MODULO,
    MP_BINARY_OP_POWER,
    MP_BINARY_OP_DIVMOD,
    MP_BINARY_OP_INPLACE_OR,
    MP_BINARY_OP_INPLACE_XOR,
    MP_BINARY_OP_INPLACE_AND,
    MP_BINARY_OP_INPLACE_LSHIFT,
    MP_BINARY_OP_INPLACE_RSHIFT,*/
    #if MICROPY_PY_ALL_SPECIAL_METHODS
    [MP_BINARY_OP_INPLACE_ADD] = MP_QSTR___iadd__,
    [MP_BINARY_OP_INPLACE_SUBTRACT] = MP_QSTR___isub__,
    #endif
    /*MP_BINARY_OP_INPLACE_MULTIPLY,
    MP_BINARY_OP_INPLACE_FLOOR_DIVIDE,
    MP_BINARY_OP_INPLACE_TRUE_DIVIDE,
    MP_BINARY_OP_INPLACE_MODULO,
    MP_BINARY_OP_INPLACE_POWER,*/
    [MP_BINARY_OP_LESS] = MP_QSTR___lt__,
    [MP_BINARY_OP_MORE] = MP_QSTR___gt__,
    [MP_BINARY_OP_EQUAL] = MP_QSTR___eq__,
    [MP_BINARY_OP_LESS_EQUAL] = MP_QSTR___le__,
    [MP_BINARY_OP_MORE_EQUAL] = MP_QSTR___ge__,
    /*
    MP_BINARY_OP_NOT_EQUAL, // a != b calls a == b and inverts result
    */
    [MP_BINARY_OP_IN] = MP_QSTR___contains__,
    /*
    MP_BINARY_OP_IS,
    */
    [MP_BINARY_OP_EXCEPTION_MATCH] = MP_QSTR_, // not implemented, used to make sure array has full size
};

STATIC mp_obj_t micropy_instance_binary_op(struct _mp_state_ctx_t *mp_state, mp_uint_t op, mp_obj_t lhs_in, mp_obj_t rhs_in) {
    // Note: For ducktyping, CPython does not look in the instance members or use
    // __getattr__ or __getattribute__.  It only looks in the class dictionary.
    mp_obj_instance_t *lhs = MP_OBJ_TO_PTR(lhs_in);
    qstr op_name = mp_binary_op_method_name[op];
    /* Still try to lookup native slot
    if (op_name == 0) {
        return MP_OBJ_NULL;
    }
    */
    mp_obj_t dest[3] = {MP_OBJ_NULL};
    struct class_lookup_data lookup = {
        .obj = lhs,
        .attr = op_name,
        .meth_offset = offsetof(mp_obj_type_t, binary_op),
        .dest = dest,
        .is_type = false,
    };
    micropy_obj_class_lookup(mp_state, &lookup, lhs->base.type);
    if (dest[0] == MP_OBJ_SENTINEL) {
        return micropy_binary_op(mp_state, op, lhs->subobj[0], rhs_in);
    } else if (dest[0] != MP_OBJ_NULL) {
        dest[2] = rhs_in;
        return micropy_call_method_n_kw(mp_state, 1, 0, dest);
    } else {
        return MP_OBJ_NULL; // op not supported
    }
}

STATIC void micropy_obj_instance_load_attr(struct _mp_state_ctx_t *mp_state, mp_obj_t self_in, qstr attr, mp_obj_t *dest) {
    // logic: look in instance members then class locals
    assert(micropy_obj_is_instance_type(mp_state, micropy_obj_get_type(mp_state, self_in)));
    mp_obj_instance_t *self = MP_OBJ_TO_PTR(self_in);

    mp_map_elem_t *elem = micropy_map_lookup(mp_state, &self->members, MP_OBJ_NEW_QSTR(attr), MP_MAP_LOOKUP);
    if (elem != NULL) {
        // object member, always treated as a value
        // TODO should we check for properties?
        dest[0] = elem->value;
        return;
    }
#if MICROPY_CPYTHON_COMPAT
    if (attr == MP_QSTR___dict__) {
        // Create a new dict with a copy of the instance's map items.
        // This creates, unlike CPython, a 'read-only' __dict__: modifying
        // it will not result in modifications to the actual instance members.
        mp_map_t *map = &self->members;
        mp_obj_t attr_dict = micropy_obj_new_dict(mp_state, map->used);
        for (mp_uint_t i = 0; i < map->alloc; ++i) {
            if (MP_MAP_SLOT_IS_FILLED(map, i)) {
                micropy_obj_dict_store(mp_state, attr_dict, map->table[i].key, map->table[i].value);
            }
        }
        dest[0] = attr_dict;
        return;
    }
#endif
    struct class_lookup_data lookup = {
        .obj = self,
        .attr = attr,
        .meth_offset = 0,
        .dest = dest,
        .is_type = false,
    };
    micropy_obj_class_lookup(mp_state, &lookup, self->base.type);
    mp_obj_t member = dest[0];
    if (member != MP_OBJ_NULL) {
        #if MICROPY_PY_BUILTINS_PROPERTY
        if (MP_OBJ_IS_TYPE(member, &mp_type_property)) {
            // object member is a property; delegate the load to the property
            // Note: This is an optimisation for code size and execution time.
            // The proper way to do it is have the functionality just below
            // in a __get__ method of the property object, and then it would
            // be called by the descriptor code down below.  But that way
            // requires overhead for the nested mp_call's and overhead for
            // the code.
            const mp_obj_t *proxy = micropy_obj_property_get(mp_state, member);
            if (proxy[0] == mp_const_none) {
                micropy_nlr_raise(mp_state, micropy_obj_new_exception_msg(mp_state, &mp_type_AttributeError, "unreadable attribute"));
            } else {
                dest[0] = micropy_call_function_n_kw(mp_state, proxy[0], 1, 0, &self_in);
            }
            return;
        }
        #endif

        #if MICROPY_PY_DESCRIPTORS
        // found a class attribute; if it has a __get__ method then call it with the
        // class instance and class as arguments and return the result
        // Note that this is functionally correct but very slow: each load_attr
        // requires an extra mp_load_method_maybe to check for the __get__.
        mp_obj_t attr_get_method[4];
        micropy_load_method_maybe(mp_state, member, MP_QSTR___get__, attr_get_method);
        if (attr_get_method[0] != MP_OBJ_NULL) {
            attr_get_method[2] = self_in;
            attr_get_method[3] = MP_OBJ_FROM_PTR(micropy_obj_get_type(mp_state, self_in));
            dest[0] = micropy_call_method_n_kw(mp_state, 2, 0, attr_get_method);
        }
        #endif
        return;
    }

    // try __getattr__
    if (attr != MP_QSTR___getattr__) {
        mp_obj_t dest2[3];
        micropy_load_method_maybe(mp_state, self_in, MP_QSTR___getattr__, dest2);
        if (dest2[0] != MP_OBJ_NULL) {
            // __getattr__ exists, call it and return its result
            // XXX if this fails to load the requested attr, should we catch the attribute error and return silently?
            dest2[2] = MP_OBJ_NEW_QSTR(attr);
            dest[0] = micropy_call_method_n_kw(mp_state, 1, 0, dest2);
            return;
        }
    }
}

STATIC bool micropy_obj_instance_store_attr(struct _mp_state_ctx_t *mp_state, mp_obj_t self_in, qstr attr, mp_obj_t value) {
    mp_obj_instance_t *self = MP_OBJ_TO_PTR(self_in);

    #if MICROPY_PY_BUILTINS_PROPERTY || MICROPY_PY_DESCRIPTORS
    // With property and/or descriptors enabled we need to do a lookup
    // first in the class dict for the attribute to see if the store should
    // be delegated.
    // Note: this makes all stores slow... how to fix?
    mp_obj_t member[2] = {MP_OBJ_NULL};
    struct class_lookup_data lookup = {
        .obj = self,
        .attr = attr,
        .meth_offset = 0,
        .dest = member,
        .is_type = false,
    };
    micropy_obj_class_lookup(mp_state, &lookup, self->base.type);

    if (member[0] != MP_OBJ_NULL) {
        #if MICROPY_PY_BUILTINS_PROPERTY
        if (MP_OBJ_IS_TYPE(member[0], &mp_type_property)) {
            // attribute exists and is a property; delegate the store/delete
            // Note: This is an optimisation for code size and execution time.
            // The proper way to do it is have the functionality just below in
            // a __set__/__delete__ method of the property object, and then it
            // would be called by the descriptor code down below.  But that way
            // requires overhead for the nested mp_call's and overhead for
            // the code.
            const mp_obj_t *proxy = micropy_obj_property_get(mp_state, member[0]);
            mp_obj_t dest[2] = {self_in, value};
            if (value == MP_OBJ_NULL) {
                // delete attribute
                if (proxy[2] == mp_const_none) {
                    // TODO better error message?
                    return false;
                } else {
                    micropy_call_function_n_kw(mp_state, proxy[2], 1, 0, dest);
                    return true;
                }
            } else {
                // store attribute
                if (proxy[1] == mp_const_none) {
                    // TODO better error message?
                    return false;
                } else {
                    micropy_call_function_n_kw(mp_state, proxy[1], 2, 0, dest);
                    return true;
                }
            }
        }
        #endif

        #if MICROPY_PY_DESCRIPTORS
        // found a class attribute; if it has a __set__/__delete__ method then
        // call it with the class instance (and value) as arguments
        if (value == MP_OBJ_NULL) {
            // delete attribute
            mp_obj_t attr_delete_method[3];
            micropy_load_method_maybe(mp_state, member[0], MP_QSTR___delete__, attr_delete_method);
            if (attr_delete_method[0] != MP_OBJ_NULL) {
                attr_delete_method[2] = self_in;
                micropy_call_method_n_kw(mp_state, 1, 0, attr_delete_method);
                return true;
            }
        } else {
            // store attribute
            mp_obj_t attr_set_method[4];
            micropy_load_method_maybe(mp_state, member[0], MP_QSTR___set__, attr_set_method);
            if (attr_set_method[0] != MP_OBJ_NULL) {
                attr_set_method[2] = self_in;
                attr_set_method[3] = value;
                micropy_call_method_n_kw(mp_state, 2, 0, attr_set_method);
                return true;
            }
        }
        #endif
    }
    #endif

    if (value == MP_OBJ_NULL) {
        // delete attribute
        mp_map_elem_t *elem = micropy_map_lookup(mp_state, &self->members, MP_OBJ_NEW_QSTR(attr), MP_MAP_LOOKUP_REMOVE_IF_FOUND);
        return elem != NULL;
    } else {
        // store attribute
        micropy_map_lookup(mp_state, &self->members, MP_OBJ_NEW_QSTR(attr), MP_MAP_LOOKUP_ADD_IF_NOT_FOUND)->value = value;
        return true;
    }
}

void micropy_obj_instance_attr(struct _mp_state_ctx_t *mp_state, mp_obj_t self_in, qstr attr, mp_obj_t *dest) {
    if (dest[0] == MP_OBJ_NULL) {
        micropy_obj_instance_load_attr(mp_state, self_in, attr, dest);
    } else {
        if (micropy_obj_instance_store_attr(mp_state, self_in, attr, dest[1])) {
            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC mp_obj_t micropy_instance_subscr(struct _mp_state_ctx_t *mp_state, mp_obj_t self_in, mp_obj_t index, mp_obj_t value) {
    mp_obj_instance_t *self = MP_OBJ_TO_PTR(self_in);
    mp_obj_t member[2] = {MP_OBJ_NULL};
    struct class_lookup_data lookup = {
        .obj = self,
        .meth_offset = offsetof(mp_obj_type_t, subscr),
        .dest = member,
        .is_type = false,
    };
    uint meth_args;
    if (value == MP_OBJ_NULL) {
        // delete item
        lookup.attr = MP_QSTR___delitem__;
        micropy_obj_class_lookup(mp_state, &lookup, self->base.type);
        meth_args = 2;
    } else if (value == MP_OBJ_SENTINEL) {
        // load item
        lookup.attr = MP_QSTR___getitem__;
        micropy_obj_class_lookup(mp_state, &lookup, self->base.type);
        meth_args = 2;
    } else {
        // store item
        lookup.attr = MP_QSTR___setitem__;
        micropy_obj_class_lookup(mp_state, &lookup, self->base.type);
        meth_args = 3;
    }
    if (member[0] == MP_OBJ_SENTINEL) {
        return micropy_obj_subscr(mp_state, self->subobj[0], index, value);
    } else if (member[0] != MP_OBJ_NULL) {
        mp_obj_t args[3] = {self_in, index, value};
        // TODO probably need to call mp_convert_member_lookup, and use mp_call_method_n_kw
        mp_obj_t ret = micropy_call_function_n_kw(mp_state, member[0], meth_args, 0, args);
        if (value == MP_OBJ_SENTINEL) {
            return ret;
        } else {
            return mp_const_none;
        }
    } else {
        return MP_OBJ_NULL; // op not supported
    }
}

STATIC mp_obj_t micropy_obj_instance_get_call(struct _mp_state_ctx_t *mp_state, mp_obj_t self_in) {
    mp_obj_instance_t *self = MP_OBJ_TO_PTR(self_in);
    mp_obj_t member[2] = {MP_OBJ_NULL, MP_OBJ_NULL};
    struct class_lookup_data lookup = {
        .obj = self,
        .attr = MP_QSTR___call__,
        .meth_offset = offsetof(mp_obj_type_t, call),
        .dest = member,
        .is_type = false,
    };
    micropy_obj_class_lookup(mp_state, &lookup, self->base.type);
    return member[0];
}

bool micropy_obj_instance_is_callable(struct _mp_state_ctx_t *mp_state, mp_obj_t self_in) {
    return micropy_obj_instance_get_call(mp_state, self_in) != MP_OBJ_NULL;
}

mp_obj_t micropy_obj_instance_call(struct _mp_state_ctx_t *mp_state, mp_obj_t self_in, size_t n_args, size_t n_kw, const mp_obj_t *args) {
    mp_obj_t call = micropy_obj_instance_get_call(mp_state, self_in);
    if (call == MP_OBJ_NULL) {
        if (MICROPY_ERROR_REPORTING == MICROPY_ERROR_REPORTING_TERSE) {
            micropy_nlr_raise(mp_state, micropy_obj_new_exception_msg(mp_state, &mp_type_TypeError,
                "object not callable"));
        } else {
            micropy_nlr_raise(mp_state, micropy_obj_new_exception_msg_varg(mp_state, &mp_type_TypeError,
                "'%s' object is not callable", micropy_obj_get_type_str(mp_state, self_in)));
        }
    }
    mp_obj_instance_t *self = MP_OBJ_TO_PTR(self_in);
    if (call == MP_OBJ_SENTINEL) {
        return micropy_call_function_n_kw(mp_state, self->subobj[0], n_args, n_kw, args);
    }
    mp_obj_t meth = micropy_obj_new_bound_meth(mp_state, call, self_in);
    return micropy_call_function_n_kw(mp_state, meth, n_args, n_kw, args);
}

STATIC mp_obj_t micropy_instance_getiter(struct _mp_state_ctx_t *mp_state, mp_obj_t self_in) {
    mp_obj_instance_t *self = MP_OBJ_TO_PTR(self_in);
    mp_obj_t member[2] = {MP_OBJ_NULL};
    struct class_lookup_data lookup = {
        .obj = self,
        .attr = MP_QSTR___iter__,
        .meth_offset = offsetof(mp_obj_type_t, getiter),
        .dest = member,
        .is_type = false,
    };
    micropy_obj_class_lookup(mp_state, &lookup, self->base.type);
    if (member[0] == MP_OBJ_NULL) {
        return MP_OBJ_NULL;
    } else if (member[0] == MP_OBJ_SENTINEL) {
        mp_obj_type_t *type = micropy_obj_get_type(mp_state, self->subobj[0]);
        return type->getiter(mp_state, self->subobj[0]);
    } else {
        return micropy_call_method_n_kw(mp_state, 0, 0, member);
    }
}

STATIC mp_int_t micropy_instance_get_buffer(struct _mp_state_ctx_t *mp_state, mp_obj_t self_in, mp_buffer_info_t *bufinfo, mp_uint_t flags) {
    mp_obj_instance_t *self = MP_OBJ_TO_PTR(self_in);
    mp_obj_t member[2] = {MP_OBJ_NULL};
    struct class_lookup_data lookup = {
        .obj = self,
        .attr = MP_QSTR_, // don't actually look for a method
        .meth_offset = offsetof(mp_obj_type_t, buffer_p.get_buffer),
        .dest = member,
        .is_type = false,
    };
    micropy_obj_class_lookup(mp_state, &lookup, self->base.type);
    if (member[0] == MP_OBJ_SENTINEL) {
        mp_obj_type_t *type = micropy_obj_get_type(mp_state, self->subobj[0]);
        return type->buffer_p.get_buffer(mp_state, self->subobj[0], bufinfo, flags);
    } else {
        return 1; // object does not support buffer protocol
    }
}

/******************************************************************************/
// type object
//  - the struct is mp_obj_type_t and is defined in obj.h so const types can be made
//  - there is a constant mp_obj_type_t (called mp_type_type) for the 'type' object
//  - creating a new class (a new type) creates a new mp_obj_type_t

STATIC void micropy_type_print(struct _mp_state_ctx_t *mp_state, const mp_print_t *print, mp_obj_t self_in, mp_print_kind_t kind) {
    (void)kind;
    mp_obj_type_t *self = MP_OBJ_TO_PTR(self_in);
    micropy_printf(mp_state, print, "<class '%q'>", self->name);
}

STATIC mp_obj_t micropy_type_make_new(struct _mp_state_ctx_t *mp_state, const mp_obj_type_t *type_in, size_t n_args, size_t n_kw, const mp_obj_t *args) {
    (void)type_in;

    micropy_arg_check_num(mp_state, n_args, n_kw, 1, 3, false);

    switch (n_args) {
        case 1:
            return MP_OBJ_FROM_PTR(micropy_obj_get_type(mp_state, args[0]));

        case 3:
            // args[0] = name
            // args[1] = bases tuple
            // args[2] = locals dict
            return micropy_obj_new_type(mp_state, micropy_obj_str_get_qstr(mp_state, args[0]), args[1], args[2]);

        default:
            micropy_nlr_raise(mp_state, micropy_obj_new_exception_msg(mp_state, &mp_type_TypeError, "type takes 1 or 3 arguments"));
    }
}

STATIC mp_obj_t micropy_type_call(struct _mp_state_ctx_t *mp_state, mp_obj_t self_in, size_t n_args, size_t n_kw, const mp_obj_t *args) {
    // instantiate an instance of a class

    mp_obj_type_t *self = MP_OBJ_TO_PTR(self_in);

    if (self->make_new == NULL) {
        if (MICROPY_ERROR_REPORTING == MICROPY_ERROR_REPORTING_TERSE) {
            micropy_nlr_raise(mp_state, micropy_obj_new_exception_msg(mp_state, &mp_type_TypeError, "cannot create instance"));
        } else {
            micropy_nlr_raise(mp_state, micropy_obj_new_exception_msg_varg(mp_state, &mp_type_TypeError,
                "cannot create '%q' instances", self->name));
        }
    }

    // make new instance
    mp_obj_t o = self->make_new(mp_state, self, n_args, n_kw, args);

    // return new instance
    return o;
}

STATIC void micropy_type_attr(struct _mp_state_ctx_t *mp_state, mp_obj_t self_in, qstr attr, mp_obj_t *dest) {
    assert(MP_OBJ_IS_TYPE(self_in, &mp_type_type));
    mp_obj_type_t *self = MP_OBJ_TO_PTR(self_in);

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        #if MICROPY_CPYTHON_COMPAT
        if (attr == MP_QSTR___name__) {
            dest[0] = MP_OBJ_NEW_QSTR(self->name);
            return;
        }
        #endif
        struct class_lookup_data lookup = {
            .obj = (mp_obj_instance_t*)self,
            .attr = attr,
            .meth_offset = 0,
            .dest = dest,
            .is_type = true,
        };
        micropy_obj_class_lookup(mp_state, &lookup, self);
    } else {
        // delete/store attribute

        // TODO CPython allows STORE_ATTR to a class, but is this the correct implementation?

        if (self->locals_dict != NULL) {
            assert(self->locals_dict->base.type == &mp_type_dict); // MicroPython restriction, for now
            mp_map_t *locals_map = &self->locals_dict->map;
            if (dest[1] == MP_OBJ_NULL) {
                // delete attribute
                mp_map_elem_t *elem = micropy_map_lookup(mp_state, locals_map, MP_OBJ_NEW_QSTR(attr), MP_MAP_LOOKUP_REMOVE_IF_FOUND);
                // note that locals_map may be in ROM, so remove will fail in that case
                if (elem != NULL) {
                    dest[0] = MP_OBJ_NULL; // indicate success
                }
            } else {
                // store attribute
                mp_map_elem_t *elem = micropy_map_lookup(mp_state, locals_map, MP_OBJ_NEW_QSTR(attr), MP_MAP_LOOKUP_ADD_IF_NOT_FOUND);
                // note that locals_map may be in ROM, so add will fail in that case
                if (elem != NULL) {
                    elem->value = dest[1];
                    dest[0] = MP_OBJ_NULL; // indicate success
                }
            }
        }
    }
}

const mp_obj_type_t mp_type_type = {
    { &mp_type_type },
    .name = MP_QSTR_type,
    .print = micropy_type_print,
    .make_new = micropy_type_make_new,
    .call = micropy_type_call,
    .unary_op = micropy_generic_unary_op,
    .attr = micropy_type_attr,
};

mp_obj_t micropy_obj_new_type(struct _mp_state_ctx_t *mp_state, qstr name, mp_obj_t bases_tuple, mp_obj_t locals_dict) {
    assert(MP_OBJ_IS_TYPE(bases_tuple, &mp_type_tuple)); // Micro Python restriction, for now
    assert(MP_OBJ_IS_TYPE(locals_dict, &mp_type_dict)); // Micro Python restriction, for now

    // TODO might need to make a copy of locals_dict; at least that's how CPython does it

    // Basic validation of base classes
    mp_uint_t len;
    mp_obj_t *items;
    micropy_obj_tuple_get(mp_state, bases_tuple, &len, &items);
    for (uint i = 0; i < len; i++) {
        assert(MP_OBJ_IS_TYPE(items[i], &mp_type_type));
        mp_obj_type_t *t = MP_OBJ_TO_PTR(items[i]);
        // TODO: Verify with CPy, tested on function type
        if (t->make_new == NULL) {
            if (MICROPY_ERROR_REPORTING == MICROPY_ERROR_REPORTING_TERSE) {
                micropy_nlr_raise(mp_state, micropy_obj_new_exception_msg(mp_state, &mp_type_TypeError,
                    "type is not an acceptable base type"));
            } else {
                micropy_nlr_raise(mp_state, micropy_obj_new_exception_msg_varg(mp_state, &mp_type_TypeError,
                    "type '%q' is not an acceptable base type", t->name));
            }
        }
    }

    mp_obj_type_t *o = micropy_m_new0(mp_state, mp_obj_type_t, 1);
    o->base.type = &mp_type_type;
    o->name = name;
    o->print = micropy_instance_print;
    o->make_new = micropy_obj_instance_make_new;
    o->call = micropy_obj_instance_call;
    o->unary_op = micropy_instance_unary_op;
    o->binary_op = micropy_instance_binary_op;
    o->attr = micropy_obj_instance_attr;
    o->subscr = micropy_instance_subscr;
    o->getiter = micropy_instance_getiter;
    //o->iternext = ; not implemented
    o->buffer_p.get_buffer = micropy_instance_get_buffer;
    //o->stream_p = ; not implemented
    o->bases_tuple = MP_OBJ_TO_PTR(bases_tuple);
    o->locals_dict = MP_OBJ_TO_PTR(locals_dict);

    const mp_obj_type_t *native_base;
    uint num_native_bases = micropy_instance_count_native_bases(mp_state, o, &native_base);
    if (num_native_bases > 1) {
        micropy_nlr_raise(mp_state, micropy_obj_new_exception_msg(mp_state, &mp_type_TypeError, "multiple bases have instance lay-out conflict"));
    }

    mp_map_t *locals_map = &o->locals_dict->map;
    mp_map_elem_t *elem = micropy_map_lookup(mp_state, locals_map, MP_OBJ_NEW_QSTR(MP_QSTR___new__), MP_MAP_LOOKUP);
    if (elem != NULL) {
        // __new__ slot exists; check if it is a function
        if (MP_OBJ_IS_FUN(elem->value)) {
            // __new__ is a function, wrap it in a staticmethod decorator
            elem->value = micropy_static_class_method_make_new(mp_state, &mp_type_staticmethod, 1, 0, &elem->value);
        }
    }

    return MP_OBJ_FROM_PTR(o);
}

/******************************************************************************/
// super object

typedef struct _mp_obj_super_t {
    mp_obj_base_t base;
    mp_obj_t type;
    mp_obj_t obj;
} mp_obj_super_t;

STATIC void micropy_super_print(struct _mp_state_ctx_t *mp_state, const mp_print_t *print, mp_obj_t self_in, mp_print_kind_t kind) {
    (void)kind;
    mp_obj_super_t *self = MP_OBJ_TO_PTR(self_in);
    micropy_print_str(mp_state, print, "<super: ");
    micropy_obj_print_helper(mp_state, print, self->type, PRINT_STR);
    micropy_print_str(mp_state, print, ", ");
    micropy_obj_print_helper(mp_state, print, self->obj, PRINT_STR);
    micropy_print_str(mp_state, print, ">");
}

STATIC mp_obj_t micropy_super_make_new(struct _mp_state_ctx_t *mp_state, const mp_obj_type_t *type_in, size_t n_args, size_t n_kw, const mp_obj_t *args) {
    (void)type_in;
    // 0 arguments are turned into 2 in the compiler
    // 1 argument is not yet implemented
    micropy_arg_check_num(mp_state, n_args, n_kw, 2, 2, false);
    return micropy_obj_new_super(mp_state, args[0], args[1]);
}

STATIC void micropy_super_attr(struct _mp_state_ctx_t *mp_state, mp_obj_t self_in, qstr attr, mp_obj_t *dest) {
    if (dest[0] != MP_OBJ_NULL) {
        // not load attribute
        return;
    }

    assert(MP_OBJ_IS_TYPE(self_in, &mp_type_super));
    mp_obj_super_t *self = MP_OBJ_TO_PTR(self_in);

    assert(MP_OBJ_IS_TYPE(self->type, &mp_type_type));

    mp_obj_type_t *type = MP_OBJ_TO_PTR(self->type);

    // for a const struct, this entry might be NULL
    if (type->bases_tuple == NULL) {
        return;
    }

    mp_uint_t len = type->bases_tuple->len;
    mp_obj_t *items = type->bases_tuple->items;
    struct class_lookup_data lookup = {
        .obj = MP_OBJ_TO_PTR(self->obj),
        .attr = attr,
        .meth_offset = 0,
        .dest = dest,
        .is_type = false,
    };
    for (uint i = 0; i < len; i++) {
        assert(MP_OBJ_IS_TYPE(items[i], &mp_type_type));
        micropy_obj_class_lookup(mp_state, &lookup, (mp_obj_type_t*)MP_OBJ_TO_PTR(items[i]));
        if (dest[0] != MP_OBJ_NULL) {
            return;
        }
    }
    micropy_obj_class_lookup(mp_state, &lookup, &mp_type_object);
}

const mp_obj_type_t mp_type_super = {
    { &mp_type_type },
    .name = MP_QSTR_super,
    .print = micropy_super_print,
    .make_new = micropy_super_make_new,
    .attr = micropy_super_attr,
};

mp_obj_t micropy_obj_new_super(struct _mp_state_ctx_t *mp_state, mp_obj_t type, mp_obj_t obj) {
    mp_obj_super_t *o = micropy_m_new_obj(mp_state, mp_obj_super_t);
    *o = (mp_obj_super_t){{&mp_type_super}, type, obj};
    return MP_OBJ_FROM_PTR(o);
}

/******************************************************************************/
// subclassing and built-ins specific to types

// object and classinfo should be type objects
// (but the function will fail gracefully if they are not)
bool micropy_obj_is_subclass_fast(struct _mp_state_ctx_t *mp_state, mp_const_obj_t object, mp_const_obj_t classinfo) {
    for (;;) {
        if (object == classinfo) {
            return true;
        }

        // not equivalent classes, keep searching base classes

        // object should always be a type object, but just return false if it's not
        if (!MP_OBJ_IS_TYPE(object, &mp_type_type)) {
            return false;
        }

        const mp_obj_type_t *self = MP_OBJ_TO_PTR(object);

        // for a const struct, this entry might be NULL
        if (self->bases_tuple == NULL) {
            return false;
        }

        // get the base objects (they should be type objects)
        mp_uint_t len = self->bases_tuple->len;
        mp_obj_t *items = self->bases_tuple->items;
        if (len == 0) {
            return false;
        }

        // iterate through the base objects
        for (uint i = 0; i < len - 1; i++) {
            if (micropy_obj_is_subclass_fast(mp_state, items[i], classinfo)) {
                return true;
            }
        }

        // search last base (simple tail recursion elimination)
        object = items[len - 1];
    }
}

STATIC mp_obj_t micropy_obj_is_subclass(struct _mp_state_ctx_t *mp_state, mp_obj_t object, mp_obj_t classinfo) {
    mp_uint_t len;
    mp_obj_t *items;
    if (MP_OBJ_IS_TYPE(classinfo, &mp_type_type)) {
        len = 1;
        items = &classinfo;
    } else if (MP_OBJ_IS_TYPE(classinfo, &mp_type_tuple)) {
        micropy_obj_tuple_get(mp_state, classinfo, &len, &items);
    } else {
        micropy_nlr_raise(mp_state, micropy_obj_new_exception_msg(mp_state, &mp_type_TypeError, "issubclass() arg 2 must be a class or a tuple of classes"));
    }

    for (uint i = 0; i < len; i++) {
        // We explicitly check for 'object' here since no-one explicitly derives from it
        if (items[i] == MP_OBJ_FROM_PTR(&mp_type_object) || micropy_obj_is_subclass_fast(mp_state, object, items[i])) {
            return mp_const_true;
        }
    }
    return mp_const_false;
}

STATIC mp_obj_t micropy_builtin_issubclass(struct _mp_state_ctx_t *mp_state, mp_obj_t object, mp_obj_t classinfo) {
    if (!MP_OBJ_IS_TYPE(object, &mp_type_type)) {
        micropy_nlr_raise(mp_state, micropy_obj_new_exception_msg(mp_state, &mp_type_TypeError, "issubclass() arg 1 must be a class"));
    }
    return micropy_obj_is_subclass(mp_state, object, classinfo);
}

MP_DEFINE_CONST_FUN_OBJ_2(mp_builtin_issubclass_obj, micropy_builtin_issubclass);

STATIC mp_obj_t micropy_builtin_isinstance(struct _mp_state_ctx_t *mp_state, mp_obj_t object, mp_obj_t classinfo) {
    return micropy_obj_is_subclass(mp_state, MP_OBJ_FROM_PTR(micropy_obj_get_type(mp_state, object)), classinfo);
}

MP_DEFINE_CONST_FUN_OBJ_2(mp_builtin_isinstance_obj, micropy_builtin_isinstance);

mp_obj_t micropy_instance_cast_to_native_base(struct _mp_state_ctx_t *mp_state, mp_const_obj_t self_in, mp_const_obj_t native_type) {
    mp_obj_type_t *self_type = micropy_obj_get_type(mp_state, self_in);
    if (!micropy_obj_is_subclass_fast(mp_state, MP_OBJ_FROM_PTR(self_type), native_type)) {
        return MP_OBJ_NULL;
    }
    mp_obj_instance_t *self = (mp_obj_instance_t*)MP_OBJ_TO_PTR(self_in);
    return self->subobj[0];
}

/******************************************************************************/
// staticmethod and classmethod types (probably should go in a different file)

STATIC mp_obj_t micropy_static_class_method_make_new(struct _mp_state_ctx_t *mp_state, const mp_obj_type_t *self, size_t n_args, size_t n_kw, const mp_obj_t *args) {
    assert(self == &mp_type_staticmethod || self == &mp_type_classmethod);

    micropy_arg_check_num(mp_state, n_args, n_kw, 1, 1, false);

    mp_obj_static_class_method_t *o = micropy_m_new_obj(mp_state, mp_obj_static_class_method_t);
    *o = (mp_obj_static_class_method_t){{self}, args[0]};
    return MP_OBJ_FROM_PTR(o);
}

const mp_obj_type_t mp_type_staticmethod = {
    { &mp_type_type },
    .name = MP_QSTR_staticmethod,
    .make_new = micropy_static_class_method_make_new,
};

const mp_obj_type_t mp_type_classmethod = {
    { &mp_type_type },
    .name = MP_QSTR_classmethod,
    .make_new = micropy_static_class_method_make_new,
};
/*
 * This file is part of the Micro Python project, http://micropython.org/
 *
 * The MIT License (MIT)
 *
 * Copyright (c) 2013, 2014 Damien P. George
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

#include <stdlib.h>
#include <assert.h>

//#include "py/objtuple.h"
//#include "py/runtime.h"

typedef struct _mp_obj_zip_t {
    mp_obj_base_t base;
    mp_uint_t n_iters;
    mp_obj_t iters[];
} mp_obj_zip_t;

STATIC mp_obj_t micropy_zip_make_new(struct _mp_state_ctx_t *mp_state, const mp_obj_type_t *type, size_t n_args, size_t n_kw, const mp_obj_t *args) {
    micropy_arg_check_num(mp_state, n_args, n_kw, 0, MP_OBJ_FUN_ARGS_MAX, false);

    mp_obj_zip_t *o = micropy_m_new_obj_var(mp_state, mp_obj_zip_t, mp_obj_t, n_args);
    o->base.type = type;
    o->n_iters = n_args;
    for (mp_uint_t i = 0; i < n_args; i++) {
        o->iters[i] = micropy_getiter(mp_state, args[i]);
    }
    return MP_OBJ_FROM_PTR(o);
}

STATIC mp_obj_t micropy_zip_iternext(struct _mp_state_ctx_t *mp_state, mp_obj_t self_in) {
    assert(MP_OBJ_IS_TYPE(self_in, &mp_type_zip));
    mp_obj_zip_t *self = MP_OBJ_TO_PTR(self_in);
    if (self->n_iters == 0) {
        return MP_OBJ_STOP_ITERATION;
    }
    mp_obj_tuple_t *tuple = MP_OBJ_TO_PTR(micropy_obj_new_tuple(mp_state, self->n_iters, NULL));

    for (mp_uint_t i = 0; i < self->n_iters; i++) {
        mp_obj_t next = micropy_iternext(mp_state, self->iters[i]);
        if (next == MP_OBJ_STOP_ITERATION) {
            micropy_obj_tuple_del(mp_state, MP_OBJ_FROM_PTR(tuple));
            return MP_OBJ_STOP_ITERATION;
        }
        tuple->items[i] = next;
    }
    return MP_OBJ_FROM_PTR(tuple);
}

const mp_obj_type_t mp_type_zip = {
    { &mp_type_type },
    .name = MP_QSTR_zip,
    .make_new = micropy_zip_make_new,
    .getiter = micropy_identity,
    .iternext = micropy_zip_iternext,
};
/*
 * This file is part of the Micro Python project, http://micropython.org/
 *
 * The MIT License (MIT)
 *
 * Copyright (c) 2013, 2014 Damien P. George
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

//#include "py/builtin.h"

#if MICROPY_PY_ARRAY

STATIC const mp_rom_map_elem_t mp_module_array_globals_table[] = {
    { MP_ROM_QSTR(MP_QSTR___name__), MP_ROM_QSTR(MP_QSTR_array) },
    { MP_ROM_QSTR(MP_QSTR_array), MP_ROM_PTR(&mp_type_array) },
};

STATIC MP_DEFINE_CONST_DICT(mp_module_array_globals, mp_module_array_globals_table);

const mp_obj_module_t mp_module_array = {
    .base = { &mp_type_module },
    .name = MP_QSTR_array,
    .globals = (mp_obj_dict_t*)&mp_module_array_globals,
};

#endif
/*
 * This file is part of the Micro Python project, http://micropython.org/
 *
 * The MIT License (MIT)
 *
 * Copyright (c) 2013, 2014 Damien P. George
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

#include <stdio.h>
#include <assert.h>

//#include "py/nlr.h"
//#include "py/smallint.h"
//#include "py/objint.h"
//#include "py/objstr.h"
//#include "py/objtype.h"
//#include "py/runtime0.h"
//#include "py/runtime.h"
//#include "py/builtin.h"
//#include "py/stream.h"

#if MICROPY_PY_BUILTINS_FLOAT
#include <math.h>
#endif

#if MICROPY_PY_IO
extern struct _mp_dummy_t mp_sys_stdout_obj; // type is irrelevant, just need pointer
#endif

// args[0] is function from class body
// args[1] is class name
// args[2:] are base objects
STATIC mp_obj_t micropy_builtin___build_class__(struct _mp_state_ctx_t *mp_state, size_t n_args, const mp_obj_t *args) {
    assert(2 <= n_args);

    // set the new classes __locals__ object
    mp_obj_dict_t *old_locals = mp_state->dict_locals;
    mp_obj_t class_locals = micropy_obj_new_dict(mp_state, 0);
    micropy_locals_set(mp_state, MP_OBJ_TO_PTR(class_locals));

    // call the class code
    mp_obj_t cell = micropy_call_function_0(mp_state, args[0]);

    // restore old __locals__ object
    mp_state->dict_locals = old_locals;

    // get the class type (meta object) from the base objects
    mp_obj_t meta;
    if (n_args == 2) {
        // no explicit bases, so use 'type'
        meta = MP_OBJ_FROM_PTR(&mp_type_type);
    } else {
        // use type of first base object
        meta = MP_OBJ_FROM_PTR(micropy_obj_get_type(mp_state, args[2]));
    }

    // TODO do proper metaclass resolution for multiple base objects

    // create the new class using a call to the meta object
    mp_obj_t meta_args[3];
    meta_args[0] = args[1]; // class name
    meta_args[1] = micropy_obj_new_tuple(mp_state, n_args - 2, args + 2); // tuple of bases
    meta_args[2] = class_locals; // dict of members
    mp_obj_t new_class = micropy_call_function_n_kw(mp_state, meta, 3, 0, meta_args);

    // store into cell if neede
    if (cell != mp_const_none) {
        micropy_obj_cell_set(mp_state, cell, new_class);
    }

    return new_class;
}
MP_DEFINE_CONST_FUN_OBJ_VAR(mp_builtin___build_class___obj, 2, micropy_builtin___build_class__);

STATIC mp_obj_t micropy_builtin_abs(struct _mp_state_ctx_t *mp_state, mp_obj_t o_in) {
    if (0) {
        // dummy
#if MICROPY_PY_BUILTINS_FLOAT
    } else if (micropy_obj_is_float(mp_state, o_in)) {
        mp_float_t value = micropy_obj_float_get(mp_state, o_in);
        // TODO check for NaN etc
        if (value < 0) {
            return micropy_obj_new_float(mp_state, -value);
        } else {
            return o_in;
        }
#if MICROPY_PY_BUILTINS_COMPLEX
    } else if (MP_OBJ_IS_TYPE(o_in, &mp_type_complex)) {
        mp_float_t real, imag;
        micropy_obj_complex_get(mp_state, o_in, &real, &imag);
        return micropy_obj_new_float(mp_state, MICROPY_FLOAT_C_FUN(sqrt)(real*real + imag*imag));
#endif
#endif
    } else {
        // this will raise a TypeError if the argument is not integral
        return micropy_obj_int_abs(mp_state, o_in);
    }
}
MP_DEFINE_CONST_FUN_OBJ_1(mp_builtin_abs_obj, micropy_builtin_abs);

STATIC mp_obj_t micropy_builtin_all(struct _mp_state_ctx_t *mp_state, mp_obj_t o_in) {
    mp_obj_t iterable = micropy_getiter(mp_state, o_in);
    mp_obj_t item;
    while ((item = micropy_iternext(mp_state, iterable)) != MP_OBJ_STOP_ITERATION) {
        if (!micropy_obj_is_true(mp_state, item)) {
            return mp_const_false;
        }
    }
    return mp_const_true;
}
MP_DEFINE_CONST_FUN_OBJ_1(mp_builtin_all_obj, micropy_builtin_all);

STATIC mp_obj_t micropy_builtin_any(struct _mp_state_ctx_t *mp_state, mp_obj_t o_in) {
    mp_obj_t iterable = micropy_getiter(mp_state, o_in);
    mp_obj_t item;
    while ((item = micropy_iternext(mp_state, iterable)) != MP_OBJ_STOP_ITERATION) {
        if (micropy_obj_is_true(mp_state, item)) {
            return mp_const_true;
        }
    }
    return mp_const_false;
}
MP_DEFINE_CONST_FUN_OBJ_1(mp_builtin_any_obj, micropy_builtin_any);

STATIC mp_obj_t micropy_builtin_bin(struct _mp_state_ctx_t *mp_state, mp_obj_t o_in) {
    mp_obj_t args[] = { MP_OBJ_NEW_QSTR(MP_QSTR__brace_open__colon__hash_b_brace_close_), o_in };
    return micropy_obj_str_format(mp_state, MP_ARRAY_SIZE(args), args, NULL);
}
MP_DEFINE_CONST_FUN_OBJ_1(mp_builtin_bin_obj, micropy_builtin_bin);

STATIC mp_obj_t micropy_builtin_callable(struct _mp_state_ctx_t *mp_state, mp_obj_t o_in) {
    if (micropy_obj_is_callable(mp_state, o_in)) {
        return mp_const_true;
    } else {
        return mp_const_false;
    }
}
MP_DEFINE_CONST_FUN_OBJ_1(mp_builtin_callable_obj, micropy_builtin_callable);

STATIC mp_obj_t micropy_builtin_chr(struct _mp_state_ctx_t *mp_state, mp_obj_t o_in) {
    #if MICROPY_PY_BUILTINS_STR_UNICODE
    mp_uint_t c = micropy_obj_get_int(mp_state, o_in);
    char str[4];
    int len = 0;
    if (c < 0x80) {
        *str = c; len = 1;
    } else if (c < 0x800) {
        str[0] = (c >> 6) | 0xC0;
        str[1] = (c & 0x3F) | 0x80;
        len = 2;
    } else if (c < 0x10000) {
        str[0] = (c >> 12) | 0xE0;
        str[1] = ((c >> 6) & 0x3F) | 0x80;
        str[2] = (c & 0x3F) | 0x80;
        len = 3;
    } else if (c < 0x110000) {
        str[0] = (c >> 18) | 0xF0;
        str[1] = ((c >> 12) & 0x3F) | 0x80;
        str[2] = ((c >> 6) & 0x3F) | 0x80;
        str[3] = (c & 0x3F) | 0x80;
        len = 4;
    } else {
        micropy_nlr_raise(mp_state, micropy_obj_new_exception_msg(mp_state, &mp_type_ValueError, "chr() arg not in micropy_range(mp_state, 0x110000)"));
    }
    return micropy_obj_new_str(mp_state, str, len, true);
    #else
    mp_int_t ord = micropy_obj_get_int(mp_state, o_in);
    if (0 <= ord && ord <= 0xff) {
        char str[1] = {ord};
        return micropy_obj_new_str(mp_state, str, 1, true);
    } else {
        micropy_nlr_raise(mp_state, micropy_obj_new_exception_msg(mp_state, &mp_type_ValueError, "chr() arg not in micropy_range(mp_state, 256)"));
    }
    #endif
}
MP_DEFINE_CONST_FUN_OBJ_1(mp_builtin_chr_obj, micropy_builtin_chr);

STATIC mp_obj_t micropy_builtin_dir(struct _mp_state_ctx_t *mp_state, size_t n_args, const mp_obj_t *args) {
    // TODO make this function more general and less of a hack

    mp_obj_dict_t *dict = NULL;
    mp_map_t *members = NULL;
    if (n_args == 0) {
        // make a list of names in the local name space
        dict = mp_state->dict_locals;
    } else { // n_args == 1
        // make a list of names in the given object
        if (MP_OBJ_IS_TYPE(args[0], &mp_type_module)) {
            dict = micropy_obj_module_get_globals(mp_state, args[0]);
        } else {
            mp_obj_type_t *type;
            if (MP_OBJ_IS_TYPE(args[0], &mp_type_type)) {
                type = MP_OBJ_TO_PTR(args[0]);
            } else {
                type = micropy_obj_get_type(mp_state, args[0]);
            }
            if (type->locals_dict != NULL && type->locals_dict->base.type == &mp_type_dict) {
                dict = type->locals_dict;
            }
        }
        if (micropy_obj_is_instance_type(mp_state, micropy_obj_get_type(mp_state, args[0]))) {
            mp_obj_instance_t *inst = MP_OBJ_TO_PTR(args[0]);
            members = &inst->members;
        }
    }

    mp_obj_t dir = micropy_obj_new_list(mp_state, 0, NULL);
    if (dict != NULL) {
        for (mp_uint_t i = 0; i < dict->map.alloc; i++) {
            if (MP_MAP_SLOT_IS_FILLED(&dict->map, i)) {
                micropy_obj_list_append(mp_state, dir, dict->map.table[i].key);
            }
        }
    }
    if (members != NULL) {
        for (mp_uint_t i = 0; i < members->alloc; i++) {
            if (MP_MAP_SLOT_IS_FILLED(members, i)) {
                micropy_obj_list_append(mp_state, dir, members->table[i].key);
            }
        }
    }
    return dir;
}
MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(mp_builtin_dir_obj, 0, 1, micropy_builtin_dir);

STATIC mp_obj_t micropy_builtin_divmod(struct _mp_state_ctx_t *mp_state, mp_obj_t o1_in, mp_obj_t o2_in) {
    return micropy_binary_op(mp_state, MP_BINARY_OP_DIVMOD, o1_in, o2_in);
}
MP_DEFINE_CONST_FUN_OBJ_2(mp_builtin_divmod_obj, micropy_builtin_divmod);

STATIC mp_obj_t micropy_builtin_hash(struct _mp_state_ctx_t *mp_state, mp_obj_t o_in) {
    // result is guaranteed to be a (small) int
    return micropy_unary_op(mp_state, MP_UNARY_OP_HASH, o_in);
}
MP_DEFINE_CONST_FUN_OBJ_1(mp_builtin_hash_obj, micropy_builtin_hash);

STATIC mp_obj_t micropy_builtin_hex(struct _mp_state_ctx_t *mp_state, mp_obj_t o_in) {
    return micropy_binary_op(mp_state, MP_BINARY_OP_MODULO, MP_OBJ_NEW_QSTR(MP_QSTR__percent__hash_x), o_in);
}
MP_DEFINE_CONST_FUN_OBJ_1(mp_builtin_hex_obj, micropy_builtin_hex);

STATIC mp_obj_t micropy_builtin_iter(struct _mp_state_ctx_t *mp_state, mp_obj_t o_in) {
    return micropy_getiter(mp_state, o_in);
}
MP_DEFINE_CONST_FUN_OBJ_1(mp_builtin_iter_obj, micropy_builtin_iter);

#if MICROPY_PY_BUILTINS_MIN_MAX

STATIC mp_obj_t micropy_builtin_min_max(struct _mp_state_ctx_t *mp_state, size_t n_args, const mp_obj_t *args, mp_map_t *kwargs, mp_uint_t op) {
    mp_map_elem_t *key_elem = micropy_map_lookup(mp_state, kwargs, MP_OBJ_NEW_QSTR(MP_QSTR_key), MP_MAP_LOOKUP);
    mp_map_elem_t *default_elem;
    mp_obj_t key_fn = key_elem == NULL ? MP_OBJ_NULL : key_elem->value;
    if (n_args == 1) {
        // given an iterable
        mp_obj_t iterable = micropy_getiter(mp_state, args[0]);
        mp_obj_t best_key = MP_OBJ_NULL;
        mp_obj_t best_obj = MP_OBJ_NULL;
        mp_obj_t item;
        while ((item = micropy_iternext(mp_state, iterable)) != MP_OBJ_STOP_ITERATION) {
            mp_obj_t key = key_fn == MP_OBJ_NULL ? item : micropy_call_function_1(mp_state, key_fn, item);
            if (best_obj == MP_OBJ_NULL || (micropy_binary_op(mp_state, op, key, best_key) == mp_const_true)) {
                best_key = key;
                best_obj = item;
            }
        }
        if (best_obj == MP_OBJ_NULL) {
            default_elem = micropy_map_lookup(mp_state, kwargs, MP_OBJ_NEW_QSTR(MP_QSTR_default), MP_MAP_LOOKUP);
            if (default_elem != NULL) {
                best_obj = default_elem->value;
            } else {
                micropy_nlr_raise(mp_state, micropy_obj_new_exception_msg(mp_state, &mp_type_ValueError, "arg is an empty sequence"));
            }
        }
        return best_obj;
    } else {
        // given many args
        mp_obj_t best_key = MP_OBJ_NULL;
        mp_obj_t best_obj = MP_OBJ_NULL;
        for (mp_uint_t i = 0; i < n_args; i++) {
            mp_obj_t key = key_fn == MP_OBJ_NULL ? args[i] : micropy_call_function_1(mp_state, key_fn, args[i]);
            if (best_obj == MP_OBJ_NULL || (micropy_binary_op(mp_state, op, key, best_key) == mp_const_true)) {
                best_key = key;
                best_obj = args[i];
            }
        }
        return best_obj;
    }
}

STATIC mp_obj_t micropy_builtin_max(struct _mp_state_ctx_t *mp_state, size_t n_args, const mp_obj_t *args, mp_map_t *kwargs) {
    return micropy_builtin_min_max(mp_state, n_args, args, kwargs, MP_BINARY_OP_MORE);
}
MP_DEFINE_CONST_FUN_OBJ_KW(mp_builtin_max_obj, 1, micropy_builtin_max);

STATIC mp_obj_t micropy_builtin_min(struct _mp_state_ctx_t *mp_state, size_t n_args, const mp_obj_t *args, mp_map_t *kwargs) {
    return micropy_builtin_min_max(mp_state, n_args, args, kwargs, MP_BINARY_OP_LESS);
}
MP_DEFINE_CONST_FUN_OBJ_KW(mp_builtin_min_obj, 1, micropy_builtin_min);

#endif

STATIC mp_obj_t micropy_builtin_next(struct _mp_state_ctx_t *mp_state, mp_obj_t o) {
    mp_obj_t ret = micropy_iternext_allow_raise(mp_state, o);
    if (ret == MP_OBJ_STOP_ITERATION) {
        micropy_nlr_raise(mp_state, micropy_obj_new_exception(mp_state, &mp_type_StopIteration));
    } else {
        return ret;
    }
}
MP_DEFINE_CONST_FUN_OBJ_1(mp_builtin_next_obj, micropy_builtin_next);

STATIC mp_obj_t micropy_builtin_oct(struct _mp_state_ctx_t *mp_state, mp_obj_t o_in) {
    return micropy_binary_op(mp_state, MP_BINARY_OP_MODULO, MP_OBJ_NEW_QSTR(MP_QSTR__percent__hash_o), o_in);
}
MP_DEFINE_CONST_FUN_OBJ_1(mp_builtin_oct_obj, micropy_builtin_oct);

STATIC mp_obj_t micropy_builtin_ord(struct _mp_state_ctx_t *mp_state, mp_obj_t o_in) {
    mp_uint_t len;
    const char *str = micropy_obj_str_get_data(mp_state, o_in, &len);
    #if MICROPY_PY_BUILTINS_STR_UNICODE
    if (MP_OBJ_IS_STR(o_in)) {
        len = unichar_charlen(str, len);
        if (len == 1) {
            if (!UTF8_IS_NONASCII(*str)) {
                goto return_first_byte;
            }
            mp_int_t ord = *str++ & 0x7F;
            for (mp_int_t mask = 0x40; ord & mask; mask >>= 1) {
                ord &= ~mask;
            }
            while (UTF8_IS_CONT(*str)) {
                ord = (ord << 6) | (*str++ & 0x3F);
            }
            return micropy_obj_new_int(mp_state, ord);
        }
    } else {
        // a bytes object
        if (len == 1) {
        return_first_byte:
            return MP_OBJ_NEW_SMALL_INT(((const byte*)str)[0]);
        }
    }
    #else
    if (len == 1) {
        // don't sign extend when converting to ord
        return micropy_obj_new_int(mp_state, ((const byte*)str)[0]);
    }
    #endif

    if (MICROPY_ERROR_REPORTING == MICROPY_ERROR_REPORTING_TERSE) {
        micropy_nlr_raise(mp_state, micropy_obj_new_exception_msg_varg(mp_state, &mp_type_TypeError,
            "ord expects a character"));
    } else {
        micropy_nlr_raise(mp_state, micropy_obj_new_exception_msg_varg(mp_state, &mp_type_TypeError,
            "ord() expected a character, but string of length %d found", (int)len));
    }
}
MP_DEFINE_CONST_FUN_OBJ_1(mp_builtin_ord_obj, micropy_builtin_ord);

STATIC mp_obj_t micropy_builtin_pow(struct _mp_state_ctx_t *mp_state, size_t n_args, const mp_obj_t *args) {
    assert(2 <= n_args && n_args <= 3);
    switch (n_args) {
        case 2: return micropy_binary_op(mp_state, MP_BINARY_OP_POWER, args[0], args[1]);
        default: return micropy_binary_op(mp_state, MP_BINARY_OP_MODULO, micropy_binary_op(mp_state, MP_BINARY_OP_POWER, args[0], args[1]), args[2]); // TODO optimise...
    }
}
MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(mp_builtin_pow_obj, 2, 3, micropy_builtin_pow);

STATIC mp_obj_t micropy_builtin_print(struct _mp_state_ctx_t *mp_state, size_t n_args, const mp_obj_t *args, mp_map_t *kwargs) {
    mp_map_elem_t *sep_elem = micropy_map_lookup(mp_state, kwargs, MP_OBJ_NEW_QSTR(MP_QSTR_sep), MP_MAP_LOOKUP);
    mp_map_elem_t *end_elem = micropy_map_lookup(mp_state, kwargs, MP_OBJ_NEW_QSTR(MP_QSTR_end), MP_MAP_LOOKUP);
    const char *sep_data = " ";
    mp_uint_t sep_len = 1;
    const char *end_data = "\n";
    mp_uint_t end_len = 1;
    if (sep_elem != NULL && sep_elem->value != mp_const_none) {
        sep_data = micropy_obj_str_get_data(mp_state, sep_elem->value, &sep_len);
    }
    if (end_elem != NULL && end_elem->value != mp_const_none) {
        end_data = micropy_obj_str_get_data(mp_state, end_elem->value, &end_len);
    }
    #if MICROPY_PY_IO
    void *stream_obj = &mp_sys_stdout_obj;
    mp_map_elem_t *file_elem = micropy_map_lookup(mp_state, kwargs, MP_OBJ_NEW_QSTR(MP_QSTR_file), MP_MAP_LOOKUP);
    if (file_elem != NULL && file_elem->value != mp_const_none) {
        stream_obj = MP_OBJ_TO_PTR(file_elem->value); // XXX may not be a concrete object
    }

    mp_print_t print = {stream_obj, micropy_stream_write_adaptor};
    #endif
    for (mp_uint_t i = 0; i < n_args; i++) {
        if (i > 0) {
            #if MICROPY_PY_IO
            micropy_stream_write_adaptor(mp_state, stream_obj, sep_data, sep_len);
            #else
            micropy_print_strn(mp_state, &mp_plat_print, sep_data, sep_len, 0, 0, 0);
            #endif
        }
        #if MICROPY_PY_IO
        micropy_obj_print_helper(mp_state, &print, args[i], PRINT_STR);
        #else
        micropy_obj_print_helper(mp_state, &mp_plat_print, args[i], PRINT_STR);
        #endif
    }
    #if MICROPY_PY_IO
    micropy_stream_write_adaptor(mp_state, stream_obj, end_data, end_len);
    #else
    micropy_print_strn(mp_state, &mp_plat_print, end_data, end_len, 0, 0, 0);
    #endif
    return mp_const_none;
}
MP_DEFINE_CONST_FUN_OBJ_KW(mp_builtin_print_obj, 0, micropy_builtin_print);

STATIC mp_obj_t micropy_builtin___repl_print__(struct _mp_state_ctx_t *mp_state, mp_obj_t o) {
    if (o != mp_const_none) {
        #if MICROPY_PY_IO
        micropy_obj_print_helper(mp_state, &mp_sys_stdout_print, o, PRINT_REPR);
        micropy_print_str(mp_state, &mp_sys_stdout_print, "\n");
        #else
        micropy_obj_print_helper(mp_state, &mp_plat_print, o, PRINT_REPR);
        micropy_print_str(mp_state, &mp_plat_print, "\n");
        #endif
        #if MICROPY_CAN_OVERRIDE_BUILTINS
        // Set "_" special variable
        mp_obj_t dest[2] = {MP_OBJ_SENTINEL, o};
        mp_type_module.attr(mp_state, MP_OBJ_FROM_PTR(&mp_module_builtins), MP_QSTR__, dest);
        #endif
    }
    return mp_const_none;
}
MP_DEFINE_CONST_FUN_OBJ_1(mp_builtin___repl_print___obj, micropy_builtin___repl_print__);

STATIC mp_obj_t micropy_builtin_repr(struct _mp_state_ctx_t *mp_state, mp_obj_t o_in) {
    vstr_t vstr;
    mp_print_t print;
    micropy_vstr_init_print(mp_state, &vstr, 16, &print);
    micropy_obj_print_helper(mp_state, &print, o_in, PRINT_REPR);
    return micropy_obj_new_str_from_vstr(mp_state, &mp_type_str, &vstr);
}
MP_DEFINE_CONST_FUN_OBJ_1(mp_builtin_repr_obj, micropy_builtin_repr);

STATIC mp_obj_t micropy_builtin_round(struct _mp_state_ctx_t *mp_state, size_t n_args, const mp_obj_t *args) {
    mp_obj_t o_in = args[0];
    if (MP_OBJ_IS_INT(o_in)) {
        return o_in;
    }
#if MICROPY_PY_BUILTINS_FLOAT
    mp_int_t num_dig = 0;
    if (n_args > 1) {
        num_dig = micropy_obj_get_int(mp_state, args[1]);
        mp_float_t val = micropy_obj_get_float(mp_state, o_in);
        mp_float_t mult = MICROPY_FLOAT_C_FUN(pow)(10, num_dig);
        // TODO may lead to overflow
        mp_float_t rounded = MICROPY_FLOAT_C_FUN(round)(val * mult) / mult;
        return micropy_obj_new_float(mp_state, rounded);
    }
    mp_float_t val = micropy_obj_get_float(mp_state, o_in);
    mp_float_t rounded = MICROPY_FLOAT_C_FUN(round)(val);
    mp_int_t r = rounded;
    // make rounded value even if it was halfway between ints
    if (val - rounded == 0.5) {
        r = (r + 1) & (~1);
    } else if (val - rounded == -0.5) {
        r &= ~1;
    }
    if (n_args > 1) {
        return micropy_obj_new_float(mp_state, r);
    }
#else
    mp_int_t r = micropy_obj_get_int(mp_state, o_in);
#endif
    return micropy_obj_new_int(mp_state, r);
}
MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(mp_builtin_round_obj, 1, 2, micropy_builtin_round);

STATIC mp_obj_t micropy_builtin_sum(struct _mp_state_ctx_t *mp_state, size_t n_args, const mp_obj_t *args) {
    assert(1 <= n_args && n_args <= 2);
    mp_obj_t value;
    switch (n_args) {
        case 1: value = MP_OBJ_NEW_SMALL_INT(0); break;
        default: value = args[1]; break;
    }
    mp_obj_t iterable = micropy_getiter(mp_state, args[0]);
    mp_obj_t item;
    while ((item = micropy_iternext(mp_state, iterable)) != MP_OBJ_STOP_ITERATION) {
        value = micropy_binary_op(mp_state, MP_BINARY_OP_ADD, value, item);
    }
    return value;
}
MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(mp_builtin_sum_obj, 1, 2, micropy_builtin_sum);

STATIC mp_obj_t micropy_builtin_sorted(struct _mp_state_ctx_t *mp_state, size_t n_args, const mp_obj_t *args, mp_map_t *kwargs) {
    assert(n_args >= 1);
    if (n_args > 1) {
        micropy_nlr_raise(mp_state, micropy_obj_new_exception_msg(mp_state, &mp_type_TypeError,
                                          "must use keyword argument for key function"));
    }
    mp_obj_t self = mp_type_list.make_new(mp_state, &mp_type_list, 1, 0, args);
    micropy_obj_list_sort(mp_state, 1, &self, kwargs);

    return self;
}
MP_DEFINE_CONST_FUN_OBJ_KW(mp_builtin_sorted_obj, 1, micropy_builtin_sorted);

// See mp_load_attr() if making any changes
STATIC inline mp_obj_t micropy_load_attr_default(struct _mp_state_ctx_t *mp_state, mp_obj_t base, qstr attr, mp_obj_t defval) {
    mp_obj_t dest[2];
    // use load_method, raising or not raising exception
    ((defval == MP_OBJ_NULL) ? micropy_load_method : micropy_load_method_maybe)(mp_state, base, attr, dest);
    if (dest[0] == MP_OBJ_NULL) {
        return defval;
    } else if (dest[1] == MP_OBJ_NULL) {
        // load_method returned just a normal attribute
        return dest[0];
    } else {
        // load_method returned a method, so build a bound method object
        return micropy_obj_new_bound_meth(mp_state, dest[0], dest[1]);
    }
}

STATIC mp_obj_t micropy_builtin_getattr(struct _mp_state_ctx_t *mp_state, size_t n_args, const mp_obj_t *args) {
    mp_obj_t defval = MP_OBJ_NULL;
    if (n_args > 2) {
        defval = args[2];
    }
    return micropy_load_attr_default(mp_state, args[0], micropy_obj_str_get_qstr(mp_state, args[1]), defval);
}
MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(mp_builtin_getattr_obj, 2, 3, micropy_builtin_getattr);

STATIC mp_obj_t micropy_builtin_setattr(struct _mp_state_ctx_t *mp_state, mp_obj_t base, mp_obj_t attr, mp_obj_t value) {
    micropy_store_attr(mp_state, base, micropy_obj_str_get_qstr(mp_state, attr), value);
    return mp_const_none;
}
MP_DEFINE_CONST_FUN_OBJ_3(mp_builtin_setattr_obj, micropy_builtin_setattr);

STATIC mp_obj_t micropy_builtin_hasattr(struct _mp_state_ctx_t *mp_state, mp_obj_t object_in, mp_obj_t attr_in) {
    qstr attr = micropy_obj_str_get_qstr(mp_state, attr_in);

    mp_obj_t dest[2];
    // TODO: https://docs.python.org/3/library/functions.html?highlight=hasattr#hasattr
    // explicitly says "This is implemented by calling getattr(object, name) and seeing
    // whether it raises an AttributeError or not.", so we should explicitly wrap this
    // in nlr_push and handle exception.
    micropy_load_method_maybe(mp_state, object_in, attr, dest);

    return micropy_obj_new_bool(mp_state, dest[0] != MP_OBJ_NULL);
}
MP_DEFINE_CONST_FUN_OBJ_2(mp_builtin_hasattr_obj, micropy_builtin_hasattr);

STATIC mp_obj_t micropy_builtin_globals(struct _mp_state_ctx_t *mp_state) {
    return MP_OBJ_FROM_PTR(mp_state->dict_globals);
}
MP_DEFINE_CONST_FUN_OBJ_0(mp_builtin_globals_obj, micropy_builtin_globals);

STATIC mp_obj_t micropy_builtin_locals(struct _mp_state_ctx_t *mp_state) {
    return MP_OBJ_FROM_PTR(mp_state->dict_locals);
}
MP_DEFINE_CONST_FUN_OBJ_0(mp_builtin_locals_obj, micropy_builtin_locals);

// These are defined in terms of MicroPython API functions right away
MP_DEFINE_CONST_FUN_OBJ_1(mp_builtin_id_obj, micropy_obj_id);
MP_DEFINE_CONST_FUN_OBJ_1(mp_builtin_len_obj, micropy_obj_len);

STATIC const mp_rom_map_elem_t mp_module_builtins_globals_table[] = {
    // built-in core functions
    { MP_ROM_QSTR(MP_QSTR___build_class__), MP_ROM_PTR(&mp_builtin___build_class___obj) },
    { MP_ROM_QSTR(MP_QSTR___import__), MP_ROM_PTR(&mp_builtin___import___obj) },
    { MP_ROM_QSTR(MP_QSTR___repl_print__), MP_ROM_PTR(&mp_builtin___repl_print___obj) },

    // built-in types
    { MP_ROM_QSTR(MP_QSTR_bool), MP_ROM_PTR(&mp_type_bool) },
    { MP_ROM_QSTR(MP_QSTR_bytes), MP_ROM_PTR(&mp_type_bytes) },
    #if MICROPY_PY_BUILTINS_BYTEARRAY
    { MP_ROM_QSTR(MP_QSTR_bytearray), MP_ROM_PTR(&mp_type_bytearray) },
    #endif
    #if MICROPY_PY_BUILTINS_COMPLEX
    { MP_ROM_QSTR(MP_QSTR_complex), MP_ROM_PTR(&mp_type_complex) },
    #endif
    { MP_ROM_QSTR(MP_QSTR_dict), MP_ROM_PTR(&mp_type_dict) },
    #if MICROPY_PY_BUILTINS_ENUMERATE
    { MP_ROM_QSTR(MP_QSTR_enumerate), MP_ROM_PTR(&mp_type_enumerate) },
    #endif
    #if MICROPY_PY_BUILTINS_FILTER
    { MP_ROM_QSTR(MP_QSTR_filter), MP_ROM_PTR(&mp_type_filter) },
    #endif
    #if MICROPY_PY_BUILTINS_FLOAT
    { MP_ROM_QSTR(MP_QSTR_float), MP_ROM_PTR(&mp_type_float) },
    #endif
    #if MICROPY_PY_BUILTINS_SET && MICROPY_PY_BUILTINS_FROZENSET
    { MP_ROM_QSTR(MP_QSTR_frozenset), MP_ROM_PTR(&mp_type_frozenset) },
    #endif
    { MP_ROM_QSTR(MP_QSTR_int), MP_ROM_PTR(&mp_type_int) },
    { MP_ROM_QSTR(MP_QSTR_list), MP_ROM_PTR(&mp_type_list) },
    { MP_ROM_QSTR(MP_QSTR_map), MP_ROM_PTR(&mp_type_map) },
    #if MICROPY_PY_BUILTINS_MEMORYVIEW
    { MP_ROM_QSTR(MP_QSTR_memoryview), MP_ROM_PTR(&mp_type_memoryview) },
    #endif
    { MP_ROM_QSTR(MP_QSTR_object), MP_ROM_PTR(&mp_type_object) },
    #if MICROPY_PY_BUILTINS_PROPERTY
    { MP_ROM_QSTR(MP_QSTR_property), MP_ROM_PTR(&mp_type_property) },
    #endif
    { MP_ROM_QSTR(MP_QSTR_range), MP_ROM_PTR(&mp_type_range) },
    #if MICROPY_PY_BUILTINS_REVERSED
    { MP_ROM_QSTR(MP_QSTR_reversed), MP_ROM_PTR(&mp_type_reversed) },
    #endif
    #if MICROPY_PY_BUILTINS_SET
    { MP_ROM_QSTR(MP_QSTR_set), MP_ROM_PTR(&mp_type_set) },
    #endif
    { MP_ROM_QSTR(MP_QSTR_str), MP_ROM_PTR(&mp_type_str) },
    { MP_ROM_QSTR(MP_QSTR_super), MP_ROM_PTR(&mp_type_super) },
    { MP_ROM_QSTR(MP_QSTR_tuple), MP_ROM_PTR(&mp_type_tuple) },
    { MP_ROM_QSTR(MP_QSTR_type), MP_ROM_PTR(&mp_type_type) },
    { MP_ROM_QSTR(MP_QSTR_zip), MP_ROM_PTR(&mp_type_zip) },

    { MP_ROM_QSTR(MP_QSTR_classmethod), MP_ROM_PTR(&mp_type_classmethod) },
    { MP_ROM_QSTR(MP_QSTR_staticmethod), MP_ROM_PTR(&mp_type_staticmethod) },

    // built-in objects
    { MP_ROM_QSTR(MP_QSTR_Ellipsis), MP_ROM_PTR(&mp_const_ellipsis_obj) },
    #if MICROPY_PY_BUILTINS_NOTIMPLEMENTED
    { MP_ROM_QSTR(MP_QSTR_NotImplemented), MP_ROM_PTR(&mp_const_notimplemented_obj) },
    #endif

    // built-in user functions
    { MP_ROM_QSTR(MP_QSTR_abs), MP_ROM_PTR(&mp_builtin_abs_obj) },
    { MP_ROM_QSTR(MP_QSTR_all), MP_ROM_PTR(&mp_builtin_all_obj) },
    { MP_ROM_QSTR(MP_QSTR_any), MP_ROM_PTR(&mp_builtin_any_obj) },
    { MP_ROM_QSTR(MP_QSTR_bin), MP_ROM_PTR(&mp_builtin_bin_obj) },
    { MP_ROM_QSTR(MP_QSTR_callable), MP_ROM_PTR(&mp_builtin_callable_obj) },
    #if MICROPY_PY_BUILTINS_COMPILE
    { MP_ROM_QSTR(MP_QSTR_compile), MP_ROM_PTR(&mp_builtin_compile_obj) },
    #endif
    { MP_ROM_QSTR(MP_QSTR_chr), MP_ROM_PTR(&mp_builtin_chr_obj) },
    { MP_ROM_QSTR(MP_QSTR_dir), MP_ROM_PTR(&mp_builtin_dir_obj) },
    { MP_ROM_QSTR(MP_QSTR_divmod), MP_ROM_PTR(&mp_builtin_divmod_obj) },
    #if MICROPY_PY_BUILTINS_EVAL_EXEC
    { MP_ROM_QSTR(MP_QSTR_eval), MP_ROM_PTR(&mp_builtin_eval_obj) },
    { MP_ROM_QSTR(MP_QSTR_exec), MP_ROM_PTR(&mp_builtin_exec_obj) },
    #endif
    #if MICROPY_PY_BUILTINS_EXECFILE
    { MP_ROM_QSTR(MP_QSTR_execfile), MP_ROM_PTR(&mp_builtin_execfile_obj) },
    #endif
    { MP_ROM_QSTR(MP_QSTR_getattr), MP_ROM_PTR(&mp_builtin_getattr_obj) },
    { MP_ROM_QSTR(MP_QSTR_setattr), MP_ROM_PTR(&mp_builtin_setattr_obj) },
    { MP_ROM_QSTR(MP_QSTR_globals), MP_ROM_PTR(&mp_builtin_globals_obj) },
    { MP_ROM_QSTR(MP_QSTR_hasattr), MP_ROM_PTR(&mp_builtin_hasattr_obj) },
    { MP_ROM_QSTR(MP_QSTR_hash), MP_ROM_PTR(&mp_builtin_hash_obj) },
    { MP_ROM_QSTR(MP_QSTR_hex), MP_ROM_PTR(&mp_builtin_hex_obj) },
    { MP_ROM_QSTR(MP_QSTR_id), MP_ROM_PTR(&mp_builtin_id_obj) },
    { MP_ROM_QSTR(MP_QSTR_isinstance), MP_ROM_PTR(&mp_builtin_isinstance_obj) },
    { MP_ROM_QSTR(MP_QSTR_issubclass), MP_ROM_PTR(&mp_builtin_issubclass_obj) },
    { MP_ROM_QSTR(MP_QSTR_iter), MP_ROM_PTR(&mp_builtin_iter_obj) },
    { MP_ROM_QSTR(MP_QSTR_len), MP_ROM_PTR(&mp_builtin_len_obj) },
    { MP_ROM_QSTR(MP_QSTR_locals), MP_ROM_PTR(&mp_builtin_locals_obj) },
    #if MICROPY_PY_BUILTINS_MIN_MAX
    { MP_ROM_QSTR(MP_QSTR_max), MP_ROM_PTR(&mp_builtin_max_obj) },
    { MP_ROM_QSTR(MP_QSTR_min), MP_ROM_PTR(&mp_builtin_min_obj) },
    #endif
    { MP_ROM_QSTR(MP_QSTR_next), MP_ROM_PTR(&mp_builtin_next_obj) },
    { MP_ROM_QSTR(MP_QSTR_oct), MP_ROM_PTR(&mp_builtin_oct_obj) },
    { MP_ROM_QSTR(MP_QSTR_ord), MP_ROM_PTR(&mp_builtin_ord_obj) },
    { MP_ROM_QSTR(MP_QSTR_pow), MP_ROM_PTR(&mp_builtin_pow_obj) },
    { MP_ROM_QSTR(MP_QSTR_print), MP_ROM_PTR(&mp_builtin_print_obj) },
    { MP_ROM_QSTR(MP_QSTR_repr), MP_ROM_PTR(&mp_builtin_repr_obj) },
    { MP_ROM_QSTR(MP_QSTR_round), MP_ROM_PTR(&mp_builtin_round_obj) },
    { MP_ROM_QSTR(MP_QSTR_sorted), MP_ROM_PTR(&mp_builtin_sorted_obj) },
    { MP_ROM_QSTR(MP_QSTR_sum), MP_ROM_PTR(&mp_builtin_sum_obj) },

    // built-in exceptions
    { MP_ROM_QSTR(MP_QSTR_BaseException), MP_ROM_PTR(&mp_type_BaseException) },
    { MP_ROM_QSTR(MP_QSTR_ArithmeticError), MP_ROM_PTR(&mp_type_ArithmeticError) },
    { MP_ROM_QSTR(MP_QSTR_AssertionError), MP_ROM_PTR(&mp_type_AssertionError) },
    { MP_ROM_QSTR(MP_QSTR_AttributeError), MP_ROM_PTR(&mp_type_AttributeError) },
    { MP_ROM_QSTR(MP_QSTR_EOFError), MP_ROM_PTR(&mp_type_EOFError) },
    { MP_ROM_QSTR(MP_QSTR_Exception), MP_ROM_PTR(&mp_type_Exception) },
    { MP_ROM_QSTR(MP_QSTR_GeneratorExit), MP_ROM_PTR(&mp_type_GeneratorExit) },
    { MP_ROM_QSTR(MP_QSTR_ImportError), MP_ROM_PTR(&mp_type_ImportError) },
    { MP_ROM_QSTR(MP_QSTR_IndentationError), MP_ROM_PTR(&mp_type_IndentationError) },
    { MP_ROM_QSTR(MP_QSTR_IndexError), MP_ROM_PTR(&mp_type_IndexError) },
    { MP_ROM_QSTR(MP_QSTR_KeyboardInterrupt), MP_ROM_PTR(&mp_type_KeyboardInterrupt) },
    { MP_ROM_QSTR(MP_QSTR_KeyError), MP_ROM_PTR(&mp_type_KeyError) },
    { MP_ROM_QSTR(MP_QSTR_LookupError), MP_ROM_PTR(&mp_type_LookupError) },
    { MP_ROM_QSTR(MP_QSTR_MemoryError), MP_ROM_PTR(&mp_type_MemoryError) },
    { MP_ROM_QSTR(MP_QSTR_NameError), MP_ROM_PTR(&mp_type_NameError) },
    { MP_ROM_QSTR(MP_QSTR_NotImplementedError), MP_ROM_PTR(&mp_type_NotImplementedError) },
    { MP_ROM_QSTR(MP_QSTR_OSError), MP_ROM_PTR(&mp_type_OSError) },
    { MP_ROM_QSTR(MP_QSTR_OverflowError), MP_ROM_PTR(&mp_type_OverflowError) },
    { MP_ROM_QSTR(MP_QSTR_RuntimeError), MP_ROM_PTR(&mp_type_RuntimeError) },
    #if MICROPY_PY_ASYNC_AWAIT
    { MP_ROM_QSTR(MP_QSTR_StopAsyncIteration), MP_ROM_PTR(&mp_type_StopAsyncIteration) },
    #endif
    { MP_ROM_QSTR(MP_QSTR_StopIteration), MP_ROM_PTR(&mp_type_StopIteration) },
    { MP_ROM_QSTR(MP_QSTR_SyntaxError), MP_ROM_PTR(&mp_type_SyntaxError) },
    { MP_ROM_QSTR(MP_QSTR_SystemExit), MP_ROM_PTR(&mp_type_SystemExit) },
    { MP_ROM_QSTR(MP_QSTR_TypeError), MP_ROM_PTR(&mp_type_TypeError) },
    #if MICROPY_PY_BUILTINS_STR_UNICODE
    { MP_ROM_QSTR(MP_QSTR_UnicodeError), MP_ROM_PTR(&mp_type_UnicodeError) },
    #endif
    { MP_ROM_QSTR(MP_QSTR_ValueError), MP_ROM_PTR(&mp_type_ValueError) },
    #if MICROPY_EMIT_NATIVE
    { MP_ROM_QSTR(MP_QSTR_ViperTypeError), MP_ROM_PTR(&mp_type_ViperTypeError) },
    #endif
    { MP_ROM_QSTR(MP_QSTR_ZeroDivisionError), MP_ROM_PTR(&mp_type_ZeroDivisionError) },
    // Somehow CPython managed to have OverflowError not inherit from ValueError ;-/
    // TODO: For MICROPY_CPYTHON_COMPAT==0 use ValueError to avoid exc proliferation

    // Extra builtins as defined by a port
    MICROPY_PORT_BUILTINS
};

MP_DEFINE_CONST_DICT(mp_module_builtins_globals, mp_module_builtins_globals_table);

const mp_obj_module_t mp_module_builtins = {
    .base = { &mp_type_module },
    .name = MP_QSTR_builtins,
    .globals = (mp_obj_dict_t*)&mp_module_builtins_globals,
};
/*
 * This file is part of the Micro Python project, http://micropython.org/
 *
 * The MIT License (MIT)
 *
 * Copyright (c) 2013, 2014 Damien P. George
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

//#include "py/builtin.h"

#if MICROPY_PY_COLLECTIONS

STATIC const mp_rom_map_elem_t mp_module_collections_globals_table[] = {
    { MP_ROM_QSTR(MP_QSTR___name__), MP_ROM_QSTR(MP_QSTR_ucollections) },
    { MP_ROM_QSTR(MP_QSTR_namedtuple), MP_ROM_PTR(&mp_namedtuple_obj) },
    #if MICROPY_PY_COLLECTIONS_ORDEREDDICT
    { MP_ROM_QSTR(MP_QSTR_OrderedDict), MP_ROM_PTR(&mp_type_ordereddict) },
    #endif
};

STATIC MP_DEFINE_CONST_DICT(mp_module_collections_globals, mp_module_collections_globals_table);

const mp_obj_module_t mp_module_collections = {
    .base = { &mp_type_module },
    .name = MP_QSTR_ucollections,
    .globals = (mp_obj_dict_t*)&mp_module_collections_globals,
};

#endif // MICROPY_PY_COLLECTIONS
/*
 * This file is part of the Micro Python project, http://micropython.org/
 *
 * The MIT License (MIT)
 *
 * Copyright (c) 2013, 2014 Damien P. George
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

//#include "py/mpstate.h"
//#include "py/obj.h"
//#include "py/gc.h"

#if MICROPY_PY_GC && MICROPY_ENABLE_GC

/// \module gc - control the garbage collector

/// \function collect()
/// Run a garbage collection.
STATIC mp_obj_t micropy_py_gc_collect(struct _mp_state_ctx_t *mp_state) {
    micropy_gc_collect(mp_state);
#if MICROPY_PY_GC_COLLECT_RETVAL
    return MP_OBJ_NEW_SMALL_INT((mp_state)->mem.gc_collected);
#else
    return mp_const_none;
#endif
}
MP_DEFINE_CONST_FUN_OBJ_0(gc_collect_obj, micropy_py_gc_collect);

/// \function disable()
/// Disable the garbage collector.
STATIC mp_obj_t micropy_gc_disable(struct _mp_state_ctx_t *mp_state) {
    (mp_state)->mem.gc_auto_collect_enabled = 0;
    return mp_const_none;
}
MP_DEFINE_CONST_FUN_OBJ_0(gc_disable_obj, micropy_gc_disable);

/// \function enable()
/// Enable the garbage collector.
STATIC mp_obj_t micropy_gc_enable(struct _mp_state_ctx_t *mp_state) {
    (mp_state)->mem.gc_auto_collect_enabled = 1;
    return mp_const_none;
}
MP_DEFINE_CONST_FUN_OBJ_0(gc_enable_obj, micropy_gc_enable);

STATIC mp_obj_t micropy_gc_isenabled(struct _mp_state_ctx_t *mp_state) {
    return micropy_obj_new_bool(mp_state, (mp_state)->mem.gc_auto_collect_enabled);
}
MP_DEFINE_CONST_FUN_OBJ_0(gc_isenabled_obj, micropy_gc_isenabled);

/// \function mem_free()
/// Return the number of bytes of available heap RAM.
STATIC mp_obj_t micropy_gc_mem_free(struct _mp_state_ctx_t *mp_state) {
    gc_info_t info;
    micropy_gc_info(mp_state, &info);
    return MP_OBJ_NEW_SMALL_INT(info.free);
}
MP_DEFINE_CONST_FUN_OBJ_0(gc_mem_free_obj, micropy_gc_mem_free);

/// \function mem_alloc()
/// Return the number of bytes of heap RAM that are allocated.
STATIC mp_obj_t micropy_gc_mem_alloc(struct _mp_state_ctx_t *mp_state) {
    gc_info_t info;
    micropy_gc_info(mp_state, &info);
    return MP_OBJ_NEW_SMALL_INT(info.used);
}
MP_DEFINE_CONST_FUN_OBJ_0(gc_mem_alloc_obj, micropy_gc_mem_alloc);

STATIC const mp_rom_map_elem_t mp_module_gc_globals_table[] = {
    { MP_ROM_QSTR(MP_QSTR___name__), MP_ROM_QSTR(MP_QSTR_gc) },
    { MP_ROM_QSTR(MP_QSTR_collect), MP_ROM_PTR(&gc_collect_obj) },
    { MP_ROM_QSTR(MP_QSTR_disable), MP_ROM_PTR(&gc_disable_obj) },
    { MP_ROM_QSTR(MP_QSTR_enable), MP_ROM_PTR(&gc_enable_obj) },
    { MP_ROM_QSTR(MP_QSTR_isenabled), MP_ROM_PTR(&gc_isenabled_obj) },
    { MP_ROM_QSTR(MP_QSTR_mem_free), MP_ROM_PTR(&gc_mem_free_obj) },
    { MP_ROM_QSTR(MP_QSTR_mem_alloc), MP_ROM_PTR(&gc_mem_alloc_obj) },
};

STATIC MP_DEFINE_CONST_DICT(mp_module_gc_globals, mp_module_gc_globals_table);

const mp_obj_module_t mp_module_gc = {
    .base = { &mp_type_module },
    .name = MP_QSTR_gc,
    .globals = (mp_obj_dict_t*)&mp_module_gc_globals,
};

#endif
/*
 * This file is part of the Micro Python project, http://micropython.org/
 *
 * The MIT License (MIT)
 *
 * Copyright (c) 2013, 2014 Damien P. George
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

#include <assert.h>
#include <string.h>

//#include "py/runtime.h"
//#include "py/builtin.h"
//#include "py/stream.h"

#if MICROPY_PY_IO

extern const mp_obj_type_t mp_type_fileio;
extern const mp_obj_type_t mp_type_textio;

#if MICROPY_PY_IO_BUFFEREDWRITER
typedef struct _mp_obj_bufwriter_t {
    mp_obj_base_t base;
    mp_obj_t stream;
    size_t alloc;
    size_t len;
    byte buf[0];
} mp_obj_bufwriter_t;

STATIC mp_obj_t micropy_bufwriter_make_new(struct _mp_state_ctx_t *mp_state, const mp_obj_type_t *type, size_t n_args, size_t n_kw, const mp_obj_t *args) {
    micropy_arg_check_num(mp_state, n_args, n_kw, 2, 2, false);
    size_t alloc = micropy_obj_get_int(mp_state, args[1]);
    mp_obj_bufwriter_t *o = micropy_m_new_obj_var(mp_state, mp_obj_bufwriter_t, byte, alloc);
    o->base.type = type;
    o->stream = args[0];
    o->alloc = alloc;
    o->len = 0;
    return o;
}

STATIC mp_uint_t micropy_bufwriter_write(struct _mp_state_ctx_t *mp_state, mp_obj_t self_in, const void *buf, mp_uint_t size, int *errcode) {
    mp_obj_bufwriter_t *self = MP_OBJ_TO_PTR(self_in);

    mp_uint_t org_size = size;

    while (size > 0) {
        mp_uint_t rem = self->alloc - self->len;
        if (size < rem) {
            memcpy(self->buf + self->len, buf, size);
            self->len += size;
            return org_size;
        }

        // Buffer flushing policy here is to flush entire buffer all the time.
        // This allows e.g. to have a block device as backing storage and write
        // entire block to it. memcpy below is not ideal and could be optimized
        // in some cases. But the way it is now it at least ensures that buffer
        // is word-aligned, to guard against obscure cases when it matters, e.g.
        // https://github.com/micropython/micropython/issues/1863
        memcpy(self->buf + self->len, buf, rem);
        buf = (byte*)buf + rem;
        size -= rem;
        mp_uint_t out_sz = micropy_stream_write_exactly(mp_state, self->stream, self->buf, self->alloc, errcode);
        if (*errcode != 0) {
            return MP_STREAM_ERROR;
        }
        // TODO: try to recover from a case of non-blocking stream, e.g. move
        // remaining chunk to the beginning of buffer.
        assert(out_sz == self->alloc);
        self->len = 0;
    }

    return org_size;
}

STATIC mp_obj_t micropy_bufwriter_flush(struct _mp_state_ctx_t *mp_state, mp_obj_t self_in) {
    mp_obj_bufwriter_t *self = MP_OBJ_TO_PTR(self_in);

    if (self->len != 0) {
        int err;
        mp_uint_t out_sz = micropy_stream_write_exactly(mp_state, self->stream, self->buf, self->len, &err);
        // TODO: try to recover from a case of non-blocking stream, e.g. move
        // remaining chunk to the beginning of buffer.
        assert(out_sz == self->len);
        self->len = 0;
        if (err != 0) {
            micropy_nlr_raise(mp_state, micropy_obj_new_exception_arg1(mp_state, &mp_type_OSError, MP_OBJ_NEW_SMALL_INT(err)));
        }
    }

    return mp_const_none;
}
STATIC MP_DEFINE_CONST_FUN_OBJ_1(bufwriter_flush_obj, micropy_bufwriter_flush);

STATIC const mp_map_elem_t bufwriter_locals_dict_table[] = {
    { MP_OBJ_NEW_QSTR(MP_QSTR_write), (mp_obj_t)&mp_stream_write_obj },
    { MP_OBJ_NEW_QSTR(MP_QSTR_flush), (mp_obj_t)&bufwriter_flush_obj },
};
STATIC MP_DEFINE_CONST_DICT(bufwriter_locals_dict, bufwriter_locals_dict_table);

STATIC const mp_stream_p_t bufwriter_stream_p = {
    .write = micropy_bufwriter_write,
};

STATIC const mp_obj_type_t bufwriter_type = {
    { &mp_type_type },
    .name = MP_QSTR_BufferedWriter,
    .make_new = micropy_bufwriter_make_new,
    .stream_p = &bufwriter_stream_p,
    .locals_dict = (mp_obj_t)&bufwriter_locals_dict,
};
#endif // MICROPY_PY_IO_BUFFEREDWRITER

STATIC const mp_rom_map_elem_t mp_module_io_globals_table[] = {
    { MP_ROM_QSTR(MP_QSTR___name__), MP_ROM_QSTR(MP_QSTR_uio) },
    // Note: mp_builtin_open_obj should be defined by port, it's not
    // part of the core.
    { MP_ROM_QSTR(MP_QSTR_open), MP_ROM_PTR(&mp_builtin_open_obj) },
    #if MICROPY_PY_IO_FILEIO
    { MP_ROM_QSTR(MP_QSTR_FileIO), MP_ROM_PTR(&mp_type_fileio) },
    #if MICROPY_CPYTHON_COMPAT
    { MP_ROM_QSTR(MP_QSTR_TextIOWrapper), MP_ROM_PTR(&mp_type_textio) },
    #endif
    #endif
    { MP_ROM_QSTR(MP_QSTR_StringIO), MP_ROM_PTR(&mp_type_stringio) },
    #if MICROPY_PY_IO_BYTESIO
    { MP_ROM_QSTR(MP_QSTR_BytesIO), MP_ROM_PTR(&mp_type_bytesio) },
    #endif
    #if MICROPY_PY_IO_BUFFEREDWRITER
    { MP_ROM_QSTR(MP_QSTR_BufferedWriter), MP_ROM_PTR(&bufwriter_type) },
    #endif
};

STATIC MP_DEFINE_CONST_DICT(mp_module_io_globals, mp_module_io_globals_table);

const mp_obj_module_t mp_module_io = {
    .base = { &mp_type_module },
    .name = MP_QSTR_uio,
    .globals = (mp_obj_dict_t*)&mp_module_io_globals,
};

#endif
/*
 * This file is part of the Micro Python project, http://micropython.org/
 *
 * The MIT License (MIT)
 *
 * Copyright (c) 2013, 2014 Damien P. George
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

//#include "py/builtin.h"
//#include "py/nlr.h"

#if MICROPY_PY_BUILTINS_FLOAT && MICROPY_PY_MATH

#include <math.h>

// M_PI is not part of the math.h standard and may not be defined
#ifndef M_PI
#define M_PI (3.14159265358979323846)
#endif

/// \module math - mathematical functions
///
/// The `math` module provides some basic mathematical funtions for
/// working with floating-point numbers.

STATIC NORETURN void micropy_math_error(struct _mp_state_ctx_t *mp_state) {
    micropy_nlr_raise(mp_state, micropy_obj_new_exception_msg_varg(mp_state, &mp_type_ValueError, "math domain error"));
}

#define MATH_FUN_1(py_name, c_name) \
    STATIC mp_obj_t mp_math_ ## micropy_py_name(mp_state, mp_obj_t x_obj) { return micropy_obj_new_float(mp_state, MICROPY_FLOAT_C_FUN(c_name)(micropy_obj_get_float(mp_state, x_obj))); } \
    STATIC MP_DEFINE_CONST_FUN_OBJ_1(mp_math_## py_name ## _obj, mp_math_ ## py_name);

#define MATH_FUN_2(py_name, c_name) \
    STATIC mp_obj_t mp_math_ ## micropy_py_name(mp_state, mp_obj_t x_obj, mp_obj_t y_obj) { return micropy_obj_new_float(mp_state, MICROPY_FLOAT_C_FUN(c_name)(micropy_obj_get_float(mp_state, x_obj), micropy_obj_get_float(mp_state, y_obj))); } \
    STATIC MP_DEFINE_CONST_FUN_OBJ_2(mp_math_## py_name ## _obj, mp_math_ ## py_name);

#define MATH_FUN_1_TO_BOOL(py_name, c_name) \
    STATIC mp_obj_t mp_math_ ## micropy_py_name(mp_state, mp_obj_t x_obj) { return micropy_obj_new_bool(mp_state, micropy_c_name(mp_state, micropy_obj_get_float(mp_state, x_obj))); } \
    STATIC MP_DEFINE_CONST_FUN_OBJ_1(mp_math_## py_name ## _obj, mp_math_ ## py_name);

#define MATH_FUN_1_TO_INT(py_name, c_name) \
    STATIC mp_obj_t mp_math_ ## micropy_py_name(mp_state, mp_obj_t x_obj) { mp_int_t x = MICROPY_FLOAT_C_FUN(c_name)(micropy_obj_get_float(mp_state, x_obj)); return micropy_obj_new_int(mp_state, x); } \
    STATIC MP_DEFINE_CONST_FUN_OBJ_1(mp_math_## py_name ## _obj, mp_math_ ## py_name);

#define MATH_FUN_1_ERRCOND(py_name, c_name, error_condition) \
    STATIC mp_obj_t mp_math_ ## micropy_py_name(mp_state, mp_obj_t x_obj) { \
        mp_float_t x = micropy_obj_get_float(mp_state, x_obj); \
        if (error_condition) { \
            micropy_math_error(mp_state); \
        } \
        return micropy_obj_new_float(mp_state, MICROPY_FLOAT_C_FUN(c_name)(x)); \
    } \
    STATIC MP_DEFINE_CONST_FUN_OBJ_1(mp_math_## py_name ## _obj, mp_math_ ## py_name);

#if MP_NEED_LOG2
// 1.442695040888963407354163704 is 1/_M_LN2
#define micropy_log2(mp_state, x) (micropy_log(mp_state, x) * 1.442695040888963407354163704)
#endif

/// \function sqrt(x)
/// Returns the square root of `x`.
MATH_FUN_1_ERRCOND(sqrt, sqrt, (x < (mp_float_t)0.0))
/// \function pow(x, y)
/// Returns `x` to the power of `y`.
MATH_FUN_2(pow, pow)
/// \function exp(x)
MATH_FUN_1(exp, exp)
#if MICROPY_PY_MATH_SPECIAL_FUNCTIONS
/// \function expm1(x)
MATH_FUN_1(expm1, expm1)
/// \function log2(x)
MATH_FUN_1_ERRCOND(log2, log2, (x <= (mp_float_t)0.0))
/// \function log10(x)
MATH_FUN_1_ERRCOND(log10, log10, (x <= (mp_float_t)0.0))
/// \function cosh(x)
MATH_FUN_1(cosh, cosh)
/// \function sinh(x)
MATH_FUN_1(sinh, sinh)
/// \function tanh(x)
MATH_FUN_1(tanh, tanh)
/// \function acosh(x)
MATH_FUN_1(acosh, acosh)
/// \function asinh(x)
MATH_FUN_1(asinh, asinh)
/// \function atanh(x)
MATH_FUN_1(atanh, atanh)
#endif
/// \function cos(x)
MATH_FUN_1(cos, cos)
/// \function sin(x)
MATH_FUN_1(sin, sin)
/// \function tan(x)
MATH_FUN_1(tan, tan)
/// \function acos(x)
MATH_FUN_1(acos, acos)
/// \function asin(x)
MATH_FUN_1(asin, asin)
/// \function atan(x)
MATH_FUN_1(atan, atan)
/// \function atan2(y, x)
MATH_FUN_2(atan2, atan2)
/// \function ceil(x)
MATH_FUN_1_TO_INT(ceil, ceil)
/// \function copysign(x, y)
MATH_FUN_2(copysign, copysign)
/// \function fabs(x)
MATH_FUN_1(fabs, fabs)
/// \function floor(x)
MATH_FUN_1_TO_INT(floor, floor) //TODO: delegate to x.__floor__() if x is not a float
/// \function fmod(x, y)
MATH_FUN_2(fmod, fmod)
/// \function isfinite(x)
MATH_FUN_1_TO_BOOL(isfinite, isfinite)
/// \function isinf(x)
MATH_FUN_1_TO_BOOL(isinf, isinf)
/// \function isnan(x)
MATH_FUN_1_TO_BOOL(isnan, isnan)
/// \function trunc(x)
MATH_FUN_1_TO_INT(trunc, trunc)
/// \function ldexp(x, exp)
MATH_FUN_2(ldexp, ldexp)
#if MICROPY_PY_MATH_SPECIAL_FUNCTIONS
/// \function erf(x)
/// Return the error function of `x`.
MATH_FUN_1(erf, erf)
/// \function erfc(x)
/// Return the complementary error function of `x`.
MATH_FUN_1(erfc, erfc)
/// \function gamma(x)
/// Return the gamma function of `x`.
MATH_FUN_1(gamma, tgamma)
/// \function lgamma(x)
/// return the natural logarithm of the gamma function of `x`.
MATH_FUN_1(lgamma, lgamma)
#endif
//TODO: factorial, fsum

// Function that takes a variable number of arguments

// log(x[, base])
STATIC mp_obj_t micropy_math_log(struct _mp_state_ctx_t *mp_state, size_t n_args, const mp_obj_t *args) {
    mp_float_t x = micropy_obj_get_float(mp_state, args[0]);
    if (x <= (mp_float_t)0.0) {
        micropy_math_error(mp_state);
    }
    mp_float_t l = MICROPY_FLOAT_C_FUN(log)(x);
    if (n_args == 1) {
        return micropy_obj_new_float(mp_state, l);
    } else {
        mp_float_t base = micropy_obj_get_float(mp_state, args[1]);
        if (base <= (mp_float_t)0.0) {
            micropy_math_error(mp_state);
        }
        return micropy_obj_new_float(mp_state, l / MICROPY_FLOAT_C_FUN(log)(base));
    }
}
STATIC MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(mp_math_log_obj, 1, 2, micropy_math_log);

// Functions that return a tuple

/// \function frexp(x)
/// Converts a floating-point number to fractional and integral components.
STATIC mp_obj_t micropy_math_frexp(struct _mp_state_ctx_t *mp_state, mp_obj_t x_obj) {
    int int_exponent = 0;
    mp_float_t significand = MICROPY_FLOAT_C_FUN(frexp)(micropy_obj_get_float(mp_state, x_obj), &int_exponent);
    mp_obj_t tuple[2];
    tuple[0] = micropy_obj_new_float(mp_state, significand);
    tuple[1] = micropy_obj_new_int(mp_state, int_exponent);
    return micropy_obj_new_tuple(mp_state, 2, tuple);
}
STATIC MP_DEFINE_CONST_FUN_OBJ_1(mp_math_frexp_obj, micropy_math_frexp);

/// \function modf(x)
STATIC mp_obj_t micropy_math_modf(struct _mp_state_ctx_t *mp_state, mp_obj_t x_obj) {
    mp_float_t int_part = 0.0;
    mp_float_t fractional_part = MICROPY_FLOAT_C_FUN(modf)(micropy_obj_get_float(mp_state, x_obj), &int_part);
    mp_obj_t tuple[2];
    tuple[0] = micropy_obj_new_float(mp_state, fractional_part);
    tuple[1] = micropy_obj_new_float(mp_state, int_part);
    return micropy_obj_new_tuple(mp_state, 2, tuple);
}
STATIC MP_DEFINE_CONST_FUN_OBJ_1(mp_math_modf_obj, micropy_math_modf);

// Angular conversions

/// \function radians(x)
STATIC mp_obj_t micropy_math_radians(struct _mp_state_ctx_t *mp_state, mp_obj_t x_obj) {
    return micropy_obj_new_float(mp_state, micropy_obj_get_float(mp_state, x_obj) * M_PI / 180.0);
}
STATIC MP_DEFINE_CONST_FUN_OBJ_1(mp_math_radians_obj, micropy_math_radians);

/// \function degrees(x)
STATIC mp_obj_t micropy_math_degrees(struct _mp_state_ctx_t *mp_state, mp_obj_t x_obj) {
    return micropy_obj_new_float(mp_state, micropy_obj_get_float(mp_state, x_obj) * 180.0 / M_PI);
}
STATIC MP_DEFINE_CONST_FUN_OBJ_1(mp_math_degrees_obj, micropy_math_degrees);

STATIC const mp_rom_map_elem_t mp_module_math_globals_table[] = {
    { MP_ROM_QSTR(MP_QSTR___name__), MP_ROM_QSTR(MP_QSTR_math) },
    { MP_ROM_QSTR(MP_QSTR_e), mp_const_float_e },
    { MP_ROM_QSTR(MP_QSTR_pi), mp_const_float_pi },
    { MP_ROM_QSTR(MP_QSTR_sqrt), MP_ROM_PTR(&mp_math_sqrt_obj) },
    { MP_ROM_QSTR(MP_QSTR_pow), MP_ROM_PTR(&mp_math_pow_obj) },
    { MP_ROM_QSTR(MP_QSTR_exp), MP_ROM_PTR(&mp_math_exp_obj) },
    #if MICROPY_PY_MATH_SPECIAL_FUNCTIONS
    { MP_ROM_QSTR(MP_QSTR_expm1), MP_ROM_PTR(&mp_math_expm1_obj) },
    #endif
    { MP_ROM_QSTR(MP_QSTR_log), MP_ROM_PTR(&mp_math_log_obj) },
    #if MICROPY_PY_MATH_SPECIAL_FUNCTIONS
    { MP_ROM_QSTR(MP_QSTR_log2), MP_ROM_PTR(&mp_math_log2_obj) },
    { MP_ROM_QSTR(MP_QSTR_log10), MP_ROM_PTR(&mp_math_log10_obj) },
    { MP_ROM_QSTR(MP_QSTR_cosh), MP_ROM_PTR(&mp_math_cosh_obj) },
    { MP_ROM_QSTR(MP_QSTR_sinh), MP_ROM_PTR(&mp_math_sinh_obj) },
    { MP_ROM_QSTR(MP_QSTR_tanh), MP_ROM_PTR(&mp_math_tanh_obj) },
    { MP_ROM_QSTR(MP_QSTR_acosh), MP_ROM_PTR(&mp_math_acosh_obj) },
    { MP_ROM_QSTR(MP_QSTR_asinh), MP_ROM_PTR(&mp_math_asinh_obj) },
    { MP_ROM_QSTR(MP_QSTR_atanh), MP_ROM_PTR(&mp_math_atanh_obj) },
    #endif
    { MP_ROM_QSTR(MP_QSTR_cos), MP_ROM_PTR(&mp_math_cos_obj) },
    { MP_ROM_QSTR(MP_QSTR_sin), MP_ROM_PTR(&mp_math_sin_obj) },
    { MP_ROM_QSTR(MP_QSTR_tan), MP_ROM_PTR(&mp_math_tan_obj) },
    { MP_ROM_QSTR(MP_QSTR_acos), MP_ROM_PTR(&mp_math_acos_obj) },
    { MP_ROM_QSTR(MP_QSTR_asin), MP_ROM_PTR(&mp_math_asin_obj) },
    { MP_ROM_QSTR(MP_QSTR_atan), MP_ROM_PTR(&mp_math_atan_obj) },
    { MP_ROM_QSTR(MP_QSTR_atan2), MP_ROM_PTR(&mp_math_atan2_obj) },
    { MP_ROM_QSTR(MP_QSTR_ceil), MP_ROM_PTR(&mp_math_ceil_obj) },
    { MP_ROM_QSTR(MP_QSTR_copysign), MP_ROM_PTR(&mp_math_copysign_obj) },
    { MP_ROM_QSTR(MP_QSTR_fabs), MP_ROM_PTR(&mp_math_fabs_obj) },
    { MP_ROM_QSTR(MP_QSTR_floor), MP_ROM_PTR(&mp_math_floor_obj) },
    { MP_ROM_QSTR(MP_QSTR_fmod), MP_ROM_PTR(&mp_math_fmod_obj) },
    { MP_ROM_QSTR(MP_QSTR_frexp), MP_ROM_PTR(&mp_math_frexp_obj) },
    { MP_ROM_QSTR(MP_QSTR_ldexp), MP_ROM_PTR(&mp_math_ldexp_obj) },
    { MP_ROM_QSTR(MP_QSTR_modf), MP_ROM_PTR(&mp_math_modf_obj) },
    { MP_ROM_QSTR(MP_QSTR_isfinite), MP_ROM_PTR(&mp_math_isfinite_obj) },
    { MP_ROM_QSTR(MP_QSTR_isinf), MP_ROM_PTR(&mp_math_isinf_obj) },
    { MP_ROM_QSTR(MP_QSTR_isnan), MP_ROM_PTR(&mp_math_isnan_obj) },
    { MP_ROM_QSTR(MP_QSTR_trunc), MP_ROM_PTR(&mp_math_trunc_obj) },
    { MP_ROM_QSTR(MP_QSTR_radians), MP_ROM_PTR(&mp_math_radians_obj) },
    { MP_ROM_QSTR(MP_QSTR_degrees), MP_ROM_PTR(&mp_math_degrees_obj) },
    #if MICROPY_PY_MATH_SPECIAL_FUNCTIONS
    { MP_ROM_QSTR(MP_QSTR_erf), MP_ROM_PTR(&mp_math_erf_obj) },
    { MP_ROM_QSTR(MP_QSTR_erfc), MP_ROM_PTR(&mp_math_erfc_obj) },
    { MP_ROM_QSTR(MP_QSTR_gamma), MP_ROM_PTR(&mp_math_gamma_obj) },
    { MP_ROM_QSTR(MP_QSTR_lgamma), MP_ROM_PTR(&mp_math_lgamma_obj) },
    #endif
};

STATIC MP_DEFINE_CONST_DICT(mp_module_math_globals, mp_module_math_globals_table);

const mp_obj_module_t mp_module_math = {
    .base = { &mp_type_module },
    .name = MP_QSTR_math,
    .globals = (mp_obj_dict_t*)&mp_module_math_globals,
};

#endif // MICROPY_PY_BUILTINS_FLOAT && MICROPY_PY_MATH
/*
 * This file is part of the Micro Python project, http://micropython.org/
 *
 * The MIT License (MIT)
 *
 * Copyright (c) 2013, 2014 Damien P. George
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

//#include "py/builtin.h"

#if MICROPY_PY_BUILTINS_FLOAT && MICROPY_PY_BUILTINS_COMPLEX && MICROPY_PY_CMATH

#include <math.h>

/// \module cmath - mathematical functions for complex numbers
///
/// The `cmath` module provides some basic mathematical funtions for
/// working with complex numbers.

/// \function phase(z)
/// Returns the phase of the number `z`, in the range (-pi, +pi].
STATIC mp_obj_t micropy_cmath_phase(struct _mp_state_ctx_t *mp_state, mp_obj_t z_obj) {
    mp_float_t real, imag;
    micropy_obj_get_complex(mp_state, z_obj, &real, &imag);
    return micropy_obj_new_float(mp_state, MICROPY_FLOAT_C_FUN(atan2)(imag, real));
}
STATIC MP_DEFINE_CONST_FUN_OBJ_1(mp_cmath_phase_obj, micropy_cmath_phase);

/// \function polar(z)
/// Returns, as a tuple, the polar form of `z`.
STATIC mp_obj_t micropy_cmath_polar(struct _mp_state_ctx_t *mp_state, mp_obj_t z_obj) {
    mp_float_t real, imag;
    micropy_obj_get_complex(mp_state, z_obj, &real, &imag);
    mp_obj_t tuple[2] = {
        micropy_obj_new_float(mp_state, MICROPY_FLOAT_C_FUN(sqrt)(real*real + imag*imag)),
        micropy_obj_new_float(mp_state, MICROPY_FLOAT_C_FUN(atan2)(imag, real)),
    };
    return micropy_obj_new_tuple(mp_state, 2, tuple);
}
STATIC MP_DEFINE_CONST_FUN_OBJ_1(mp_cmath_polar_obj, micropy_cmath_polar);

/// \function rect(r, phi)
/// Returns the complex number with modulus `r` and phase `phi`.
STATIC mp_obj_t micropy_cmath_rect(struct _mp_state_ctx_t *mp_state, mp_obj_t r_obj, mp_obj_t phi_obj) {
    mp_float_t r = micropy_obj_get_float(mp_state, r_obj);
    mp_float_t phi = micropy_obj_get_float(mp_state, phi_obj);
    return micropy_obj_new_complex(mp_state, r * MICROPY_FLOAT_C_FUN(cos)(phi), r * MICROPY_FLOAT_C_FUN(sin)(phi));
}
STATIC MP_DEFINE_CONST_FUN_OBJ_2(mp_cmath_rect_obj, micropy_cmath_rect);

/// \function exp(z)
/// Return the exponential of `z`.
STATIC mp_obj_t micropy_cmath_exp(struct _mp_state_ctx_t *mp_state, mp_obj_t z_obj) {
    mp_float_t real, imag;
    micropy_obj_get_complex(mp_state, z_obj, &real, &imag);
    mp_float_t exp_real = MICROPY_FLOAT_C_FUN(exp)(real);
    return micropy_obj_new_complex(mp_state, exp_real * MICROPY_FLOAT_C_FUN(cos)(imag), exp_real * MICROPY_FLOAT_C_FUN(sin)(imag));
}
STATIC MP_DEFINE_CONST_FUN_OBJ_1(mp_cmath_exp_obj, micropy_cmath_exp);

/// \function log(z)
/// Return the natural logarithm of `z`.  The branch cut is along the negative real axis.
// TODO can take second argument, being the base
STATIC mp_obj_t micropy_cmath_log(struct _mp_state_ctx_t *mp_state, mp_obj_t z_obj) {
    mp_float_t real, imag;
    micropy_obj_get_complex(mp_state, z_obj, &real, &imag);
    return micropy_obj_new_complex(mp_state, 0.5 * MICROPY_FLOAT_C_FUN(log)(real*real + imag*imag), MICROPY_FLOAT_C_FUN(atan2)(imag, real));
}
STATIC MP_DEFINE_CONST_FUN_OBJ_1(mp_cmath_log_obj, micropy_cmath_log);

#if MICROPY_PY_MATH_SPECIAL_FUNCTIONS
/// \function log10(z)
/// Return the base-10 logarithm of `z`.  The branch cut is along the negative real axis.
STATIC mp_obj_t micropy_cmath_log10(struct _mp_state_ctx_t *mp_state, mp_obj_t z_obj) {
    mp_float_t real, imag;
    micropy_obj_get_complex(mp_state, z_obj, &real, &imag);
    return micropy_obj_new_complex(mp_state, 0.5 * MICROPY_FLOAT_C_FUN(log10)(real*real + imag*imag), 0.4342944819032518 * MICROPY_FLOAT_C_FUN(atan2)(imag, real));
}
STATIC MP_DEFINE_CONST_FUN_OBJ_1(mp_cmath_log10_obj, micropy_cmath_log10);
#endif

/// \function sqrt(z)
/// Return the square-root of `z`.
STATIC mp_obj_t micropy_cmath_sqrt(struct _mp_state_ctx_t *mp_state, mp_obj_t z_obj) {
    mp_float_t real, imag;
    micropy_obj_get_complex(mp_state, z_obj, &real, &imag);
    mp_float_t sqrt_abs = MICROPY_FLOAT_C_FUN(pow)(real*real + imag*imag, 0.25);
    mp_float_t theta = 0.5 * MICROPY_FLOAT_C_FUN(atan2)(imag, real);
    return micropy_obj_new_complex(mp_state, sqrt_abs * MICROPY_FLOAT_C_FUN(cos)(theta), sqrt_abs * MICROPY_FLOAT_C_FUN(sin)(theta));
}
STATIC MP_DEFINE_CONST_FUN_OBJ_1(mp_cmath_sqrt_obj, micropy_cmath_sqrt);

/// \function cos(z)
/// Return the cosine of `z`.
STATIC mp_obj_t micropy_cmath_cos(struct _mp_state_ctx_t *mp_state, mp_obj_t z_obj) {
    mp_float_t real, imag;
    micropy_obj_get_complex(mp_state, z_obj, &real, &imag);
    return micropy_obj_new_complex(mp_state, MICROPY_FLOAT_C_FUN(cos)(real) * MICROPY_FLOAT_C_FUN(cosh)(imag), -MICROPY_FLOAT_C_FUN(sin)(real) * MICROPY_FLOAT_C_FUN(sinh)(imag));
}
STATIC MP_DEFINE_CONST_FUN_OBJ_1(mp_cmath_cos_obj, micropy_cmath_cos);

/// \function sin(z)
/// Return the sine of `z`.
STATIC mp_obj_t micropy_cmath_sin(struct _mp_state_ctx_t *mp_state, mp_obj_t z_obj) {
    mp_float_t real, imag;
    micropy_obj_get_complex(mp_state, z_obj, &real, &imag);
    return micropy_obj_new_complex(mp_state, MICROPY_FLOAT_C_FUN(sin)(real) * MICROPY_FLOAT_C_FUN(cosh)(imag), MICROPY_FLOAT_C_FUN(cos)(real) * MICROPY_FLOAT_C_FUN(sinh)(imag));
}
STATIC MP_DEFINE_CONST_FUN_OBJ_1(mp_cmath_sin_obj, micropy_cmath_sin);

STATIC const mp_rom_map_elem_t mp_module_cmath_globals_table[] = {
    { MP_ROM_QSTR(MP_QSTR___name__), MP_ROM_QSTR(MP_QSTR_cmath) },
    { MP_ROM_QSTR(MP_QSTR_e), mp_const_float_e },
    { MP_ROM_QSTR(MP_QSTR_pi), mp_const_float_pi },
    { MP_ROM_QSTR(MP_QSTR_phase), MP_ROM_PTR(&mp_cmath_phase_obj) },
    { MP_ROM_QSTR(MP_QSTR_polar), MP_ROM_PTR(&mp_cmath_polar_obj) },
    { MP_ROM_QSTR(MP_QSTR_rect), MP_ROM_PTR(&mp_cmath_rect_obj) },
    { MP_ROM_QSTR(MP_QSTR_exp), MP_ROM_PTR(&mp_cmath_exp_obj) },
    { MP_ROM_QSTR(MP_QSTR_log), MP_ROM_PTR(&mp_cmath_log_obj) },
    #if MICROPY_PY_MATH_SPECIAL_FUNCTIONS
    { MP_ROM_QSTR(MP_QSTR_log10), MP_ROM_PTR(&mp_cmath_log10_obj) },
    #endif
    { MP_ROM_QSTR(MP_QSTR_sqrt), MP_ROM_PTR(&mp_cmath_sqrt_obj) },
    //{ MP_ROM_QSTR(MP_QSTR_acos), MP_ROM_PTR(&mp_cmath_acos_obj) },
    //{ MP_ROM_QSTR(MP_QSTR_asin), MP_ROM_PTR(&mp_cmath_asin_obj) },
    //{ MP_ROM_QSTR(MP_QSTR_atan), MP_ROM_PTR(&mp_cmath_atan_obj) },
    { MP_ROM_QSTR(MP_QSTR_cos), MP_ROM_PTR(&mp_cmath_cos_obj) },
    { MP_ROM_QSTR(MP_QSTR_sin), MP_ROM_PTR(&mp_cmath_sin_obj) },
    //{ MP_ROM_QSTR(MP_QSTR_tan), MP_ROM_PTR(&mp_cmath_tan_obj) },
    //{ MP_ROM_QSTR(MP_QSTR_acosh), MP_ROM_PTR(&mp_cmath_acosh_obj) },
    //{ MP_ROM_QSTR(MP_QSTR_asinh), MP_ROM_PTR(&mp_cmath_asinh_obj) },
    //{ MP_ROM_QSTR(MP_QSTR_atanh), MP_ROM_PTR(&mp_cmath_atanh_obj) },
    //{ MP_ROM_QSTR(MP_QSTR_cosh), MP_ROM_PTR(&mp_cmath_cosh_obj) },
    //{ MP_ROM_QSTR(MP_QSTR_sinh), MP_ROM_PTR(&mp_cmath_sinh_obj) },
    //{ MP_ROM_QSTR(MP_QSTR_tanh), MP_ROM_PTR(&mp_cmath_tanh_obj) },
    //{ MP_ROM_QSTR(MP_QSTR_isfinite), MP_ROM_PTR(&mp_cmath_isfinite_obj) },
    //{ MP_ROM_QSTR(MP_QSTR_isinf), MP_ROM_PTR(&mp_cmath_isinf_obj) },
    //{ MP_ROM_QSTR(MP_QSTR_isnan), MP_ROM_PTR(&mp_cmath_isnan_obj) },
};

STATIC MP_DEFINE_CONST_DICT(mp_module_cmath_globals, mp_module_cmath_globals_table);

const mp_obj_module_t mp_module_cmath = {
    .base = { &mp_type_module },
    .name = MP_QSTR_cmath,
    .globals = (mp_obj_dict_t*)&mp_module_cmath_globals,
};

#endif // MICROPY_PY_BUILTINS_FLOAT && MICROPY_PY_CMATH
/*
 * This file is part of the Micro Python project, http://micropython.org/
 *
 * The MIT License (MIT)
 *
 * Copyright (c) 2013, 2014 Damien P. George
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

#include <stdio.h>

//#include "py/mpstate.h"
//#include "py/builtin.h"
//#include "py/stackctrl.h"
//#include "py/gc.h"

// Various builtins specific to MicroPython runtime,
// living in micropython module

#if MICROPY_PY_MICROPYTHON_MEM_INFO

#if MICROPY_MEM_STATS
STATIC mp_obj_t micropy_micropython_mem_total(struct _mp_state_ctx_t *mp_state) {
    return MP_OBJ_NEW_SMALL_INT(micropy_m_get_total_bytes_allocated(mp_state));
}
STATIC MP_DEFINE_CONST_FUN_OBJ_0(mp_micropython_mem_total_obj, micropy_micropython_mem_total);

STATIC mp_obj_t micropy_micropython_mem_current(struct _mp_state_ctx_t *mp_state) {
    return MP_OBJ_NEW_SMALL_INT(micropy_m_get_current_bytes_allocated(mp_state));
}
STATIC MP_DEFINE_CONST_FUN_OBJ_0(mp_micropython_mem_current_obj, micropy_micropython_mem_current);

STATIC mp_obj_t micropy_micropython_mem_peak(struct _mp_state_ctx_t *mp_state) {
    return MP_OBJ_NEW_SMALL_INT(micropy_m_get_peak_bytes_allocated(mp_state));
}
STATIC MP_DEFINE_CONST_FUN_OBJ_0(mp_micropython_mem_peak_obj, micropy_micropython_mem_peak);
#endif

mp_obj_t micropy_micropython_mem_info(struct _mp_state_ctx_t *mp_state, size_t n_args, const mp_obj_t *args) {
    (void)args;
#if MICROPY_MEM_STATS
    micropy_printf(mp_state, &mp_plat_print, "mem: total=" UINT_FMT ", current=" UINT_FMT ", peak=" UINT_FMT "\n",
        (mp_uint_t)micropy_m_get_total_bytes_allocated(mp_state), (mp_uint_t)micropy_m_get_current_bytes_allocated(mp_state), (mp_uint_t)micropy_m_get_peak_bytes_allocated(mp_state));
#endif
#if MICROPY_STACK_CHECK
    micropy_printf(mp_state, &mp_plat_print, "stack: " UINT_FMT " out of " INT_FMT "\n", micropy_stack_usage(mp_state), (mp_state)->vm.stack_limit);
#else
    micropy_printf(mp_state, &mp_plat_print, "stack: " UINT_FMT "\n", micropy_stack_usage(mp_state));
#endif
#if MICROPY_ENABLE_GC
    micropy_gc_dump_info(mp_state);
    if (n_args == 1) {
        // arg given means dump gc allocation table
        micropy_gc_dump_alloc_table(mp_state);
    }
#else
    (void)n_args;
#endif
    return mp_const_none;
}
STATIC MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(mp_micropython_mem_info_obj, 0, 1, micropy_micropython_mem_info);

STATIC mp_obj_t micropy_micropython_qstr_info(struct _mp_state_ctx_t *mp_state, size_t n_args, const mp_obj_t *args) {
    (void)args;
    size_t n_pool, n_qstr, n_str_data_bytes, n_total_bytes;
    micropy_qstr_pool_info(mp_state, &n_pool, &n_qstr, &n_str_data_bytes, &n_total_bytes);
    micropy_printf(mp_state, &mp_plat_print, "qstr pool: n_pool=%u, n_qstr=%u, n_str_data_bytes=%u, n_total_bytes=%u\n",
        n_pool, n_qstr, n_str_data_bytes, n_total_bytes);
    if (n_args == 1) {
        // arg given means dump qstr data
        micropy_qstr_dump_data(mp_state);
    }
    return mp_const_none;
}
STATIC MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(mp_micropython_qstr_info_obj, 0, 1, micropy_micropython_qstr_info);

#if MICROPY_STACK_CHECK
STATIC mp_obj_t micropy_micropython_stack_use(struct _mp_state_ctx_t *mp_state) {
    return MP_OBJ_NEW_SMALL_INT(micropy_stack_usage(mp_state));
}
STATIC MP_DEFINE_CONST_FUN_OBJ_0(mp_micropython_stack_use_obj, micropy_micropython_stack_use);
#endif

#endif // MICROPY_PY_MICROPYTHON_MEM_INFO

#if MICROPY_ENABLE_GC
STATIC mp_obj_t micropy_micropython_heap_lock(struct _mp_state_ctx_t *mp_state) {
    micropy_gc_lock(mp_state);
    return mp_const_none;
}
STATIC MP_DEFINE_CONST_FUN_OBJ_0(mp_micropython_heap_lock_obj, micropy_micropython_heap_lock);

STATIC mp_obj_t micropy_micropython_heap_unlock(struct _mp_state_ctx_t *mp_state) {
    micropy_gc_unlock(mp_state);
    return mp_const_none;
}
STATIC MP_DEFINE_CONST_FUN_OBJ_0(mp_micropython_heap_unlock_obj, micropy_micropython_heap_unlock);
#endif

#if MICROPY_ENABLE_EMERGENCY_EXCEPTION_BUF && (MICROPY_EMERGENCY_EXCEPTION_BUF_SIZE == 0)
STATIC MP_DEFINE_CONST_FUN_OBJ_1(mp_alloc_emergency_exception_buf_obj, micropy_alloc_emergency_exception_buf);
#endif

STATIC const mp_rom_map_elem_t mp_module_micropython_globals_table[] = {
    { MP_ROM_QSTR(MP_QSTR___name__), MP_ROM_QSTR(MP_QSTR_micropython) },
#if MICROPY_PY_MICROPYTHON_MEM_INFO
#if MICROPY_MEM_STATS
    { MP_ROM_QSTR(MP_QSTR_mem_total), MP_ROM_PTR(&mp_micropython_mem_total_obj) },
    { MP_ROM_QSTR(MP_QSTR_mem_current), MP_ROM_PTR(&mp_micropython_mem_current_obj) },
    { MP_ROM_QSTR(MP_QSTR_mem_peak), MP_ROM_PTR(&mp_micropython_mem_peak_obj) },
#endif
    { MP_ROM_QSTR(MP_QSTR_mem_info), MP_ROM_PTR(&mp_micropython_mem_info_obj) },
    { MP_ROM_QSTR(MP_QSTR_qstr_info), MP_ROM_PTR(&mp_micropython_qstr_info_obj) },
    #if MICROPY_STACK_CHECK
    { MP_ROM_QSTR(MP_QSTR_stack_use), MP_ROM_PTR(&mp_micropython_stack_use_obj) },
    #endif
#endif
#if MICROPY_ENABLE_EMERGENCY_EXCEPTION_BUF && (MICROPY_EMERGENCY_EXCEPTION_BUF_SIZE == 0)
    { MP_ROM_QSTR(MP_QSTR_alloc_emergency_exception_buf), MP_ROM_PTR(&mp_alloc_emergency_exception_buf_obj) },
#endif
    #if MICROPY_ENABLE_GC
    { MP_ROM_QSTR(MP_QSTR_heap_lock), MP_ROM_PTR(&mp_micropython_heap_lock_obj) },
    { MP_ROM_QSTR(MP_QSTR_heap_unlock), MP_ROM_PTR(&mp_micropython_heap_unlock_obj) },
    #endif
};

STATIC MP_DEFINE_CONST_DICT(mp_module_micropython_globals, mp_module_micropython_globals_table);

const mp_obj_module_t mp_module_micropython = {
    .base = { &mp_type_module },
    .name = MP_QSTR_micropython,
    .globals = (mp_obj_dict_t*)&mp_module_micropython_globals,
};
/*
 * This file is part of the Micro Python project, http://micropython.org/
 *
 * The MIT License (MIT)
 *
 * Copyright (c) 2013, 2014 Damien P. George
 * Copyright (c) 2014 Paul Sokolovsky
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

#include <assert.h>
#include <string.h>

//#include "py/runtime.h"
//#include "py/builtin.h"
//#include "py/objtuple.h"
//#include "py/binary.h"
//#include "py/parsenum.h"

#if MICROPY_PY_STRUCT

/*
    This module implements most of character typecodes from CPython, with
    some extensions:

    O - (Pointer to) an arbitrary Python object. This is useful for callback
        data, etc. Note that you must keep reference to passed object in
        your Python application, otherwise it may be garbage-collected,
        and then when you get back this value from callback it may be
        invalid (and lead to crash).
    S - Pointer to a string (returned as a Python string). Note the
        difference from "Ns", - the latter says "in this place of structure
        is character data of up to N bytes length", while "S" means
        "in this place of a structure is a pointer to zero-terminated
        character data".
 */

STATIC char micropy_get_fmt_type(struct _mp_state_ctx_t *mp_state, const char **fmt) {
    char t = **fmt;
    switch (t) {
        case '!':
            t = '>';
            break;
        case '@':
        case '=':
        case '<':
        case '>':
            break;
        default:
            return '@';
    }
    // Skip type char
    (*fmt)++;
    return t;
}

STATIC mp_uint_t micropy_get_fmt_num(struct _mp_state_ctx_t *mp_state, const char **p) {
    const char *num = *p;
    uint len = 1;
    while (unichar_isdigit(*++num)) {
        len++;
    }
    mp_uint_t val = (mp_uint_t)MP_OBJ_SMALL_INT_VALUE(micropy_parse_num_integer(mp_state, *p, len, 10, NULL));
    *p = num;
    return val;
}

STATIC uint micropy_calcsize_items(struct _mp_state_ctx_t *mp_state, const char *fmt) {
    uint cnt = 0;
    while (*fmt) {
        int num = 1;
        if (unichar_isdigit(*fmt)) {
            num = micropy_get_fmt_num(mp_state, &fmt);
            if (*fmt == 's') {
                num = 1;
            }
        }
        cnt += num;
        fmt++;
    }
    return cnt;
}

STATIC mp_obj_t micropy_struct_calcsize(struct _mp_state_ctx_t *mp_state, mp_obj_t fmt_in) {
    const char *fmt = micropy_obj_str_get_str(mp_state, fmt_in);
    char fmt_type = micropy_get_fmt_type(mp_state, &fmt);
    mp_uint_t size;
    for (size = 0; *fmt; fmt++) {
        mp_uint_t cnt = 1;
        if (unichar_isdigit(*fmt)) {
            cnt = micropy_get_fmt_num(mp_state, &fmt);
        }

        if (*fmt == 's') {
            size += cnt;
        } else {
            mp_uint_t align;
            size_t sz = micropy_binary_get_size(mp_state, fmt_type, *fmt, &align);
            if (sz == 0) {
                micropy_nlr_raise(mp_state, micropy_obj_new_exception_msg(mp_state, &mp_type_ValueError, "unsupported format"));
            }
            while (cnt--) {
                // Apply alignment
                size = (size + align - 1) & ~(align - 1);
                size += sz;
            }
        }
    }
    return MP_OBJ_NEW_SMALL_INT(size);
}
MP_DEFINE_CONST_FUN_OBJ_1(struct_calcsize_obj, micropy_struct_calcsize);

STATIC mp_obj_t micropy_struct_unpack_from(struct _mp_state_ctx_t *mp_state, size_t n_args, const mp_obj_t *args) {
    // unpack requires that the buffer be exactly the right size.
    // unpack_from requires that the buffer be "big enough".
    // Since we implement unpack and unpack_from using the same function
    // we relax the "exact" requirement, and only implement "big enough".
    const char *fmt = micropy_obj_str_get_str(mp_state, args[0]);
    char fmt_type = micropy_get_fmt_type(mp_state, &fmt);
    uint num_items = micropy_calcsize_items(mp_state, fmt);
    mp_obj_tuple_t *res = MP_OBJ_TO_PTR(micropy_obj_new_tuple(mp_state, num_items, NULL));
    mp_buffer_info_t bufinfo;
    micropy_get_buffer_raise(mp_state, args[1], &bufinfo, MP_BUFFER_READ);
    byte *p = bufinfo.buf;
    byte *end_p = &p[bufinfo.len];
    mp_int_t offset = 0;

    if (n_args > 2) {
        // offset arg provided
        offset = micropy_obj_get_int(mp_state, args[2]);
        if (offset < 0) {
            // negative offsets are relative to the end of the buffer
            offset = bufinfo.len + offset;
            if (offset < 0) {
                micropy_nlr_raise(mp_state, micropy_obj_new_exception_msg(mp_state, &mp_type_ValueError, "buffer too small"));
            }
        }
        p += offset;
    }

    for (uint i = 0; i < num_items;) {
        if (*fmt == '\0') {
            break;
        }
        mp_uint_t sz = 1;
        if (unichar_isdigit(*fmt)) {
            sz = micropy_get_fmt_num(mp_state, &fmt);
        }
        if (p + sz > end_p) {
            micropy_nlr_raise(mp_state, micropy_obj_new_exception_msg(mp_state, &mp_type_ValueError, "buffer too small"));
        }
        mp_obj_t item;
        if (*fmt == 's') {
            item = micropy_obj_new_bytes(mp_state, p, sz);
            p += sz;
            res->items[i++] = item;
        } else {
            while (sz--) {
                item = micropy_binary_get_val(mp_state, fmt_type, *fmt, &p);
                res->items[i++] = item;
            }
        }
        fmt++;
    }
    return MP_OBJ_FROM_PTR(res);
}
MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(struct_unpack_from_obj, 2, 3, micropy_struct_unpack_from);

STATIC void micropy_struct_pack_into_internal(struct _mp_state_ctx_t *mp_state, mp_obj_t fmt_in, byte *p, byte* end_p, size_t n_args, const mp_obj_t *args) {
    const char *fmt = micropy_obj_str_get_str(mp_state, fmt_in);
    char fmt_type = micropy_get_fmt_type(mp_state, &fmt);

    size_t i;
    for (i = 0; i < n_args;) {
        mp_uint_t sz = 1;
        if (*fmt == '\0') {
            break;
        }
        if (unichar_isdigit(*fmt)) {
            sz = micropy_get_fmt_num(mp_state, &fmt);
        }
        if (p + sz > end_p) {
            micropy_nlr_raise(mp_state, micropy_obj_new_exception_msg(mp_state, &mp_type_ValueError, "buffer too small"));
        }

        if (*fmt == 's') {
            mp_buffer_info_t bufinfo;
            micropy_get_buffer_raise(mp_state, args[i++], &bufinfo, MP_BUFFER_READ);
            mp_uint_t to_copy = sz;
            if (bufinfo.len < to_copy) {
                to_copy = bufinfo.len;
            }
            memcpy(p, bufinfo.buf, to_copy);
            memset(p + to_copy, 0, sz - to_copy);
            p += sz;
        } else {
            while (sz--) {
                micropy_binary_set_val(mp_state, fmt_type, *fmt, args[i++], &p);
            }
        }
        fmt++;
    }
}

STATIC mp_obj_t micropy_struct_pack(struct _mp_state_ctx_t *mp_state, size_t n_args, const mp_obj_t *args) {
    // TODO: "The arguments must match the values required by the format exactly."
    mp_int_t size = MP_OBJ_SMALL_INT_VALUE(micropy_struct_calcsize(mp_state, args[0]));
    vstr_t vstr;
    micropy_vstr_init_len(mp_state, &vstr, size);
    byte *p = (byte*)vstr.buf;
    memset(p, 0, size);
    byte *end_p = &p[size];
    micropy_struct_pack_into_internal(mp_state, args[0], p, end_p, n_args - 1, &args[1]);
    return micropy_obj_new_str_from_vstr(mp_state, &mp_type_bytes, &vstr);
}
MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(struct_pack_obj, 1, MP_OBJ_FUN_ARGS_MAX, micropy_struct_pack);

STATIC mp_obj_t micropy_struct_pack_into(struct _mp_state_ctx_t *mp_state, size_t n_args, const mp_obj_t *args) {
    mp_buffer_info_t bufinfo;
    micropy_get_buffer_raise(mp_state, args[1], &bufinfo, MP_BUFFER_WRITE);
    mp_int_t offset = micropy_obj_get_int(mp_state, args[2]);
    if (offset < 0) {
        // negative offsets are relative to the end of the buffer
        offset = (mp_int_t)bufinfo.len + offset;
        if (offset < 0) {
            micropy_nlr_raise(mp_state, micropy_obj_new_exception_msg(mp_state, &mp_type_ValueError, "buffer too small"));
        }
    }
    byte *p = (byte *)bufinfo.buf;
    byte *end_p = &p[bufinfo.len];
    p += offset;

    micropy_struct_pack_into_internal(mp_state, args[0], p, end_p, n_args - 3, &args[3]);
    return mp_const_none;
}
MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(struct_pack_into_obj, 3, MP_OBJ_FUN_ARGS_MAX, micropy_struct_pack_into);

STATIC const mp_rom_map_elem_t mp_module_struct_globals_table[] = {
    { MP_ROM_QSTR(MP_QSTR___name__), MP_ROM_QSTR(MP_QSTR_ustruct) },
    { MP_ROM_QSTR(MP_QSTR_calcsize), MP_ROM_PTR(&struct_calcsize_obj) },
    { MP_ROM_QSTR(MP_QSTR_pack), MP_ROM_PTR(&struct_pack_obj) },
    { MP_ROM_QSTR(MP_QSTR_pack_into), MP_ROM_PTR(&struct_pack_into_obj) },
    { MP_ROM_QSTR(MP_QSTR_unpack), MP_ROM_PTR(&struct_unpack_from_obj) },
    { MP_ROM_QSTR(MP_QSTR_unpack_from), MP_ROM_PTR(&struct_unpack_from_obj) },
};

STATIC MP_DEFINE_CONST_DICT(mp_module_struct_globals, mp_module_struct_globals_table);

const mp_obj_module_t mp_module_ustruct = {
    .base = { &mp_type_module },
    .name = MP_QSTR_ustruct,
    .globals = (mp_obj_dict_t*)&mp_module_struct_globals,
};

#endif
/*
 * This file is part of the Micro Python project, http://micropython.org/
 *
 * The MIT License (MIT)
 *
 * Copyright (c) 2013, 2014 Damien P. George
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

//#include "py/mpstate.h"
//#include "py/nlr.h"
//#include "py/builtin.h"
//#include "py/objlist.h"
//#include "py/objtuple.h"
//#include "py/objstr.h"
//#include "py/objint.h"
//#include "py/stream.h"

#if MICROPY_PY_SYS

// This file was generated by py/makeversionhdr.py
#define MICROPY_GIT_TAG "v1.8.1-8-g2b97dfb03b-dirty"
#define MICROPY_GIT_HASH "2b97dfb03-dirty"
#define MICROPY_BUILD_DATE "2025-12-29"
#define MICROPY_VERSION_MAJOR (1)
#define MICROPY_VERSION_MINOR (8)
#define MICROPY_VERSION_MICRO (1)
#define MICROPY_VERSION_STRING "1.8.1"

/// \module sys - system specific functions

// defined per port; type of these is irrelevant, just need pointer
extern struct _mp_dummy_t mp_sys_stdin_obj;
extern struct _mp_dummy_t mp_sys_stdout_obj;
extern struct _mp_dummy_t mp_sys_stderr_obj;

#if MICROPY_PY_IO
const mp_print_t mp_sys_stdout_print = {&mp_sys_stdout_obj, micropy_stream_write_adaptor};
#endif

/// \constant version - Python language version that this implementation conforms to, as a string
STATIC const MP_DEFINE_STR_OBJ(version_obj, "3.4.0");

/// \constant version_info - Python language version that this implementation conforms to, as a tuple of ints
#define I(n) MP_OBJ_NEW_SMALL_INT(n)
// TODO: CPython is now at 5-element array, but save 2 els so far...
STATIC const mp_obj_tuple_t mp_sys_version_info_obj = {{&mp_type_tuple}, 3, {I(3), I(4), I(0)}};

// sys.implementation object
// this holds the MicroPython version
STATIC const mp_obj_tuple_t mp_sys_implementation_version_info_obj = {
    {&mp_type_tuple},
    3,
    { I(MICROPY_VERSION_MAJOR), I(MICROPY_VERSION_MINOR), I(MICROPY_VERSION_MICRO) }
};
#if MICROPY_PY_ATTRTUPLE
STATIC const qstr impl_fields[] = { MP_QSTR_name, MP_QSTR_version };
STATIC MP_DEFINE_ATTRTUPLE(
    mp_sys_implementation_obj,
    impl_fields,
    2,
        MP_ROM_QSTR(MP_QSTR_micropython),
        MP_ROM_PTR(&mp_sys_implementation_version_info_obj)
);
#else
STATIC const mp_obj_tuple_t mp_sys_implementation_obj = {
    {&mp_type_tuple},
    2,
    {
        MP_OBJ_NEW_QSTR(MP_QSTR_micropython),
        (mp_obj_t)&mp_sys_implementation_version_info_obj,
    }
};
#endif

#undef I

#ifdef MICROPY_PY_SYS_PLATFORM
/// \constant platform - the platform that Micro Python is running on
STATIC const MP_DEFINE_STR_OBJ(platform_obj, MICROPY_PY_SYS_PLATFORM);
#endif

/// \function exit([retval])
/// Raise a `SystemExit` exception.  If an argument is given, it is the
/// value given to `SystemExit`.
STATIC mp_obj_t micropy_sys_exit(struct _mp_state_ctx_t *mp_state, size_t n_args, const mp_obj_t *args) {
    mp_obj_t exc;
    if (n_args == 0) {
        exc = micropy_obj_new_exception(mp_state, &mp_type_SystemExit);
    } else {
        exc = micropy_obj_new_exception_arg1(mp_state, &mp_type_SystemExit, args[0]);
    }
    micropy_nlr_raise(mp_state, exc);
}
MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(mp_sys_exit_obj, 0, 1, micropy_sys_exit);

STATIC mp_obj_t micropy_sys_print_exception(struct _mp_state_ctx_t *mp_state, size_t n_args, const mp_obj_t *args) {
    #if MICROPY_PY_IO
    void *stream_obj = &mp_sys_stdout_obj;
    if (n_args > 1) {
        stream_obj = MP_OBJ_TO_PTR(args[1]); // XXX may fail
    }

    mp_print_t print = {stream_obj, micropy_stream_write_adaptor};
    micropy_obj_print_exception(mp_state, &print, args[0]);
    #else
    (void)n_args;
    micropy_obj_print_exception(mp_state, &mp_plat_print, args[0]);
    #endif

    return mp_const_none;
}
MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(mp_sys_print_exception_obj, 1, 2, micropy_sys_print_exception);

#if MICROPY_PY_SYS_EXC_INFO
STATIC mp_obj_t micropy_sys_exc_info(struct _mp_state_ctx_t *mp_state) {
    mp_obj_t cur_exc = MP_OBJ_FROM_PTR((mp_state)->vm.cur_exception);
    mp_obj_tuple_t *t = MP_OBJ_TO_PTR(micropy_obj_new_tuple(mp_state, 3, NULL));

    if (cur_exc == MP_OBJ_NULL) {
        t->items[0] = mp_const_none;
        t->items[1] = mp_const_none;
        t->items[2] = mp_const_none;
        return MP_OBJ_FROM_PTR(t);
    }

    t->items[0] = MP_OBJ_FROM_PTR(micropy_obj_get_type(mp_state, cur_exc));
    t->items[1] = cur_exc;
    t->items[2] = mp_const_none;
    return MP_OBJ_FROM_PTR(t);
}
MP_DEFINE_CONST_FUN_OBJ_0(mp_sys_exc_info_obj, micropy_sys_exc_info);
#endif

STATIC const mp_rom_map_elem_t mp_module_sys_globals_table[] = {
    { MP_ROM_QSTR(MP_QSTR___name__), MP_ROM_QSTR(MP_QSTR_sys) },



    { MP_ROM_QSTR(MP_QSTR_version), MP_ROM_PTR(&version_obj) },
    { MP_ROM_QSTR(MP_QSTR_version_info), MP_ROM_PTR(&mp_sys_version_info_obj) },
    { MP_ROM_QSTR(MP_QSTR_implementation), MP_ROM_PTR(&mp_sys_implementation_obj) },
    #ifdef MICROPY_PY_SYS_PLATFORM
    { MP_ROM_QSTR(MP_QSTR_platform), MP_ROM_PTR(&platform_obj) },
    #endif
    /// \constant byteorder - the byte order of the system ("little" or "big")
    #if MP_ENDIANNESS_LITTLE
    { MP_ROM_QSTR(MP_QSTR_byteorder), MP_ROM_QSTR(MP_QSTR_little) },
    #else
    { MP_ROM_QSTR(MP_QSTR_byteorder), MP_ROM_QSTR(MP_QSTR_big) },
    #endif

    #if MICROPY_PY_SYS_MAXSIZE
    #if MICROPY_LONGINT_IMPL == MICROPY_LONGINT_IMPL_NONE
    // INT_MAX is not representable as small int, as we know that small int
    // takes one bit for tag. So, we have little choice but to provide this
    // value. Apps also should be careful to not try to compare sys.maxsize
    // with some number (which may not fit in available int size), but instead
    // count number of significant bits in sys.maxsize.
    { MP_ROM_QSTR(MP_QSTR_maxsize), MP_OBJ_NEW_SMALL_INT(INT_MAX >> 1) },
    #else
    { MP_ROM_QSTR(MP_QSTR_maxsize), MP_ROM_PTR(&mp_maxsize_obj) },
    #endif
    #endif

    #if MICROPY_PY_SYS_EXIT
    // documented per-port
    { MP_ROM_QSTR(MP_QSTR_exit), MP_ROM_PTR(&mp_sys_exit_obj) },
    #endif

    #if MICROPY_PY_SYS_STDFILES
    // documented per-port
    { MP_ROM_QSTR(MP_QSTR_stdin), MP_ROM_PTR(&mp_sys_stdin_obj) },
    { MP_ROM_QSTR(MP_QSTR_stdout), MP_ROM_PTR(&mp_sys_stdout_obj) },
    { MP_ROM_QSTR(MP_QSTR_stderr), MP_ROM_PTR(&mp_sys_stderr_obj) },
    #endif

    #if MICROPY_PY_SYS_MODULES

    #endif
    #if MICROPY_PY_SYS_EXC_INFO
    { MP_ROM_QSTR(MP_QSTR_exc_info), MP_ROM_PTR(&mp_sys_exc_info_obj) },
    #endif

    /*
     * Extensions to CPython
     */

    { MP_ROM_QSTR(MP_QSTR_print_exception), MP_ROM_PTR(&mp_sys_print_exception_obj) },
};

STATIC MP_DEFINE_CONST_DICT(mp_module_sys_globals, mp_module_sys_globals_table);

const mp_obj_module_t mp_module_sys = {
    .base = { &mp_type_module },
    .name = MP_QSTR_sys,
    .globals = (mp_obj_dict_t*)&mp_module_sys_globals,
};

#endif
/*
 * This file is part of the Micro Python project, http://micropython.org/
 *
 * The MIT License (MIT)
 *
 * Copyright (c) 2014 Damien P. George
 * Copyright (c) 2014 Paul Sokolovsky
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

#include <stdbool.h>
#include <string.h>
#include <assert.h>

//#include "py/nlr.h"
//#include "py/objfun.h"
//#include "py/runtime0.h"
//#include "py/bc0.h"
//#include "py/bc.h"

#if 0 // print debugging info
#define DEBUG_PRINT (1)
#else // don't print debugging info
#define DEBUG_PRINT (0)
#define DEBUG_printf(...) (void)0
#endif

mp_uint_t micropy_decode_uint(struct _mp_state_ctx_t *mp_state, const byte **ptr) {
    mp_uint_t unum = 0;
    byte val;
    const byte *p = *ptr;
    do {
        val = *p++;
        unum = (unum << 7) | (val & 0x7f);
    } while ((val & 0x80) != 0);
    *ptr = p;
    return unum;
}

STATIC NORETURN void micropy_fun_pos_args_mismatch(struct _mp_state_ctx_t *mp_state, mp_obj_fun_bc_t *f, size_t expected, size_t given) {
#if MICROPY_ERROR_REPORTING == MICROPY_ERROR_REPORTING_TERSE
    // generic message, used also for other argument issues
    (void)f;
    (void)expected;
    (void)given;
    micropy_arg_error_terse_mismatch(mp_state);
#elif MICROPY_ERROR_REPORTING == MICROPY_ERROR_REPORTING_NORMAL
    (void)f;
    micropy_nlr_raise(mp_state, micropy_obj_new_exception_msg_varg(mp_state, &mp_type_TypeError,
        "function takes %d positional arguments but %d were given", expected, given));
#elif MICROPY_ERROR_REPORTING == MICROPY_ERROR_REPORTING_DETAILED
    micropy_nlr_raise(mp_state, micropy_obj_new_exception_msg_varg(mp_state, &mp_type_TypeError,
        "%q() takes %d positional arguments but %d were given",
        micropy_obj_fun_get_name(mp_state, MP_OBJ_FROM_PTR(f)), expected, given));
#endif
}

#if DEBUG_PRINT
STATIC void micropy_dump_args(struct _mp_state_ctx_t *mp_state, const mp_obj_t *a, size_t sz) {
    DEBUG_printf("%p: ", a);
    for (size_t i = 0; i < sz; i++) {
        DEBUG_printf("%p ", a[i]);
    }
    DEBUG_printf("\n");
}
#else
#define micropy_dump_args(mp_state, ...) (void)0
#endif

// On entry code_state should be allocated somewhere (stack/heap) and
// contain the following valid entries:
//    - code_state->ip should contain the offset in bytes from the start of
//      the bytecode chunk to just after n_state and n_exc_stack
//    - code_state->n_state should be set to the state size (locals plus stack)
void micropy_setup_code_state(struct _mp_state_ctx_t *mp_state, mp_code_state *code_state, mp_obj_fun_bc_t *self, size_t n_args, size_t n_kw, const mp_obj_t *args) {
    // This function is pretty complicated.  It's main aim is to be efficient in speed and RAM
    // usage for the common case of positional only args.
    size_t n_state = code_state->n_state;

    // ip comes in as an offset into bytecode, so turn it into a true pointer
    code_state->ip = self->bytecode + (size_t)code_state->ip;

    // store pointer to constant table
    code_state->const_table = self->const_table;

    #if MICROPY_STACKLESS
    code_state->prev = NULL;
    #endif

    // get params
    size_t scope_flags = *code_state->ip++;
    size_t n_pos_args = *code_state->ip++;
    size_t n_kwonly_args = *code_state->ip++;
    size_t n_def_pos_args = *code_state->ip++;

    code_state->sp = &code_state->state[0] - 1;
    code_state->exc_sp = (mp_exc_stack_t*)(code_state->state + n_state) - 1;

    // zero out the local stack to begin with
    memset(code_state->state, 0, n_state * sizeof(*code_state->state));

    const mp_obj_t *kwargs = args + n_args;

    // var_pos_kw_args points to the stack where the var-args tuple, and var-kw dict, should go (if they are needed)
    mp_obj_t *var_pos_kw_args = &code_state->state[n_state - 1 - n_pos_args - n_kwonly_args];

    // check positional arguments

    if (n_args > n_pos_args) {
        // given more than enough arguments
        if ((scope_flags & MP_SCOPE_FLAG_VARARGS) == 0) {
            micropy_fun_pos_args_mismatch(mp_state, self, n_pos_args, n_args);
        }
        // put extra arguments in varargs tuple
        *var_pos_kw_args-- = micropy_obj_new_tuple(mp_state, n_args - n_pos_args, args + n_pos_args);
        n_args = n_pos_args;
    } else {
        if ((scope_flags & MP_SCOPE_FLAG_VARARGS) != 0) {
            DEBUG_printf("passing empty tuple as *args\n");
            *var_pos_kw_args-- = mp_const_empty_tuple;
        }
        // Apply processing and check below only if we don't have kwargs,
        // otherwise, kw handling code below has own extensive checks.
        if (n_kw == 0 && (scope_flags & MP_SCOPE_FLAG_DEFKWARGS) == 0) {
            if (n_args >= (size_t)(n_pos_args - n_def_pos_args)) {
                // given enough arguments, but may need to use some default arguments
                for (size_t i = n_args; i < n_pos_args; i++) {
                    code_state->state[n_state - 1 - i] = self->extra_args[i - (n_pos_args - n_def_pos_args)];
                }
            } else {
                micropy_fun_pos_args_mismatch(mp_state, self, n_pos_args - n_def_pos_args, n_args);
            }
        }
    }

    // copy positional args into state
    for (size_t i = 0; i < n_args; i++) {
        code_state->state[n_state - 1 - i] = args[i];
    }

    // check keyword arguments

    if (n_kw != 0 || (scope_flags & MP_SCOPE_FLAG_DEFKWARGS) != 0) {
        DEBUG_printf("Initial args: ");
        micropy_dump_args(mp_state, code_state->state + n_state - n_pos_args - n_kwonly_args, n_pos_args + n_kwonly_args);

        mp_obj_t dict = MP_OBJ_NULL;
        if ((scope_flags & MP_SCOPE_FLAG_VARKEYWORDS) != 0) {
            dict = micropy_obj_new_dict(mp_state, n_kw); // TODO: better go conservative with 0?
            *var_pos_kw_args = dict;
        }

        // get pointer to arg_names array
        const mp_obj_t *arg_names = (const mp_obj_t*)code_state->const_table;

        for (size_t i = 0; i < n_kw; i++) {
            // the keys in kwargs are expected to be qstr objects
            mp_obj_t wanted_arg_name = kwargs[2 * i];
            for (size_t j = 0; j < n_pos_args + n_kwonly_args; j++) {
                if (wanted_arg_name == arg_names[j]) {
                    if (code_state->state[n_state - 1 - j] != MP_OBJ_NULL) {
                        micropy_nlr_raise(mp_state, micropy_obj_new_exception_msg_varg(mp_state, &mp_type_TypeError,
                            "function got multiple values for argument '%q'", MP_OBJ_QSTR_VALUE(wanted_arg_name)));
                    }
                    code_state->state[n_state - 1 - j] = kwargs[2 * i + 1];
                    goto continue2;
                }
            }
            // Didn't find name match with positional args
            if ((scope_flags & MP_SCOPE_FLAG_VARKEYWORDS) == 0) {
                micropy_nlr_raise(mp_state, micropy_obj_new_exception_msg(mp_state, &mp_type_TypeError, "function does not take keyword arguments"));
            }
            micropy_obj_dict_store(mp_state, dict, kwargs[2 * i], kwargs[2 * i + 1]);
continue2:;
        }

        DEBUG_printf("Args with kws flattened: ");
        micropy_dump_args(mp_state, code_state->state + n_state - n_pos_args - n_kwonly_args, n_pos_args + n_kwonly_args);

        // fill in defaults for positional args
        mp_obj_t *d = &code_state->state[n_state - n_pos_args];
        mp_obj_t *s = &self->extra_args[n_def_pos_args - 1];
        for (size_t i = n_def_pos_args; i > 0; i--, d++, s--) {
            if (*d == MP_OBJ_NULL) {
                *d = *s;
            }
        }

        DEBUG_printf("Args after filling default positional: ");
        micropy_dump_args(mp_state, code_state->state + n_state - n_pos_args - n_kwonly_args, n_pos_args + n_kwonly_args);

        // Check that all mandatory positional args are specified
        while (d < &code_state->state[n_state]) {
            if (*d++ == MP_OBJ_NULL) {
                micropy_nlr_raise(mp_state, micropy_obj_new_exception_msg_varg(mp_state, &mp_type_TypeError,
                    "function missing required positional argument #%d", &code_state->state[n_state] - d));
            }
        }

        // Check that all mandatory keyword args are specified
        // Fill in default kw args if we have them
        for (size_t i = 0; i < n_kwonly_args; i++) {
            if (code_state->state[n_state - 1 - n_pos_args - i] == MP_OBJ_NULL) {
                mp_map_elem_t *elem = NULL;
                if ((scope_flags & MP_SCOPE_FLAG_DEFKWARGS) != 0) {
                    elem = micropy_map_lookup(mp_state, &((mp_obj_dict_t*)MP_OBJ_TO_PTR(self->extra_args[n_def_pos_args]))->map, arg_names[n_pos_args + i], MP_MAP_LOOKUP);
                }
                if (elem != NULL) {
                    code_state->state[n_state - 1 - n_pos_args - i] = elem->value;
                } else {
                    micropy_nlr_raise(mp_state, micropy_obj_new_exception_msg_varg(mp_state, &mp_type_TypeError,
                        "function missing required keyword argument '%q'", MP_OBJ_QSTR_VALUE(arg_names[n_pos_args + i])));
                }
            }
        }

    } else {
        // no keyword arguments given
        if (n_kwonly_args != 0) {
            micropy_nlr_raise(mp_state, micropy_obj_new_exception_msg(mp_state, &mp_type_TypeError,
                "function missing keyword-only argument"));
        }
        if ((scope_flags & MP_SCOPE_FLAG_VARKEYWORDS) != 0) {
            *var_pos_kw_args = micropy_obj_new_dict(mp_state, 0);
        }
    }

    // get the ip and skip argument names
    const byte *ip = code_state->ip;

    // store pointer to code_info and jump over it
    {
        code_state->code_info = ip;
        const byte *ip2 = ip;
        size_t code_info_size = micropy_decode_uint(mp_state, &ip2);
        ip += code_info_size;
    }

    // bytecode prelude: initialise closed over variables
    size_t local_num;
    while ((local_num = *ip++) != 255) {
        code_state->state[n_state - 1 - local_num] =
            micropy_obj_new_cell(mp_state, code_state->state[n_state - 1 - local_num]);
    }

    // now that we skipped over the prelude, set the ip for the VM
    code_state->ip = ip;

    DEBUG_printf("Calling: n_pos_args=%d, n_kwonly_args=%d\n", n_pos_args, n_kwonly_args);
    micropy_dump_args(mp_state, code_state->state + n_state - n_pos_args - n_kwonly_args, n_pos_args + n_kwonly_args);
    micropy_dump_args(mp_state, code_state->state, n_state);
}

#if MICROPY_PERSISTENT_CODE_LOAD || MICROPY_PERSISTENT_CODE_SAVE

// The following table encodes the number of bytes that a specific opcode
// takes up.  There are 3 special opcodes that always have an extra byte:
//     MP_BC_MAKE_CLOSURE
//     MP_BC_MAKE_CLOSURE_DEFARGS
//     MP_BC_RAISE_VARARGS
// There are 4 special opcodes that have an extra byte only when
// MICROPY_OPT_CACHE_MAP_LOOKUP_IN_BYTECODE is enabled:
//     MP_BC_LOAD_NAME
//     MP_BC_LOAD_GLOBAL
//     MP_BC_LOAD_ATTR
//     MP_BC_STORE_ATTR
#define OC4(a, b, c, d) (a | (b << 2) | (c << 4) | (d << 6))
#define U (0) // undefined opcode
#define B (MP_OPCODE_BYTE) // single byte
#define Q (MP_OPCODE_QSTR) // single byte plus 2-byte qstr
#define V (MP_OPCODE_VAR_UINT) // single byte plus variable encoded unsigned int
#define O (MP_OPCODE_OFFSET) // single byte plus 2-byte bytecode offset
STATIC const byte opcode_format_table[64] = {
    OC4(U, U, U, U), // 0x00-0x03
    OC4(U, U, U, U), // 0x04-0x07
    OC4(U, U, U, U), // 0x08-0x0b
    OC4(U, U, U, U), // 0x0c-0x0f
    OC4(B, B, B, U), // 0x10-0x13
    OC4(V, U, Q, V), // 0x14-0x17
    OC4(B, U, V, V), // 0x18-0x1b
    OC4(Q, Q, Q, Q), // 0x1c-0x1f
    OC4(B, B, V, V), // 0x20-0x23
    OC4(Q, Q, Q, B), // 0x24-0x27
    OC4(V, V, Q, Q), // 0x28-0x2b
    OC4(U, U, U, U), // 0x2c-0x2f
    OC4(B, B, B, B), // 0x30-0x33
    OC4(B, O, O, O), // 0x34-0x37
    OC4(O, O, U, U), // 0x38-0x3b
    OC4(U, O, B, O), // 0x3c-0x3f
    OC4(O, B, B, O), // 0x40-0x43
    OC4(B, B, O, U), // 0x44-0x47
    OC4(U, U, U, U), // 0x48-0x4b
    OC4(U, U, U, U), // 0x4c-0x4f
    OC4(V, V, V, V), // 0x50-0x53
    OC4(B, V, V, V), // 0x54-0x57
    OC4(V, V, V, B), // 0x58-0x5b
    OC4(B, B, B, U), // 0x5c-0x5f
    OC4(V, V, V, V), // 0x60-0x63
    OC4(V, V, V, V), // 0x64-0x67
    OC4(Q, Q, B, U), // 0x68-0x6b
    OC4(U, U, U, U), // 0x6c-0x6f

    OC4(B, B, B, B), // 0x70-0x73
    OC4(B, B, B, B), // 0x74-0x77
    OC4(B, B, B, B), // 0x78-0x7b
    OC4(B, B, B, B), // 0x7c-0x7f
    OC4(B, B, B, B), // 0x80-0x83
    OC4(B, B, B, B), // 0x84-0x87
    OC4(B, B, B, B), // 0x88-0x8b
    OC4(B, B, B, B), // 0x8c-0x8f
    OC4(B, B, B, B), // 0x90-0x93
    OC4(B, B, B, B), // 0x94-0x97
    OC4(B, B, B, B), // 0x98-0x9b
    OC4(B, B, B, B), // 0x9c-0x9f
    OC4(B, B, B, B), // 0xa0-0xa3
    OC4(B, B, B, B), // 0xa4-0xa7
    OC4(B, B, B, B), // 0xa8-0xab
    OC4(B, B, B, B), // 0xac-0xaf

    OC4(B, B, B, B), // 0xb0-0xb3
    OC4(B, B, B, B), // 0xb4-0xb7
    OC4(B, B, B, B), // 0xb8-0xbb
    OC4(B, B, B, B), // 0xbc-0xbf

    OC4(B, B, B, B), // 0xc0-0xc3
    OC4(B, B, B, B), // 0xc4-0xc7
    OC4(B, B, B, B), // 0xc8-0xcb
    OC4(B, B, B, B), // 0xcc-0xcf

    OC4(B, B, B, B), // 0xd0-0xd3
    OC4(B, B, B, B), // 0xd4-0xd7
    OC4(B, B, B, B), // 0xd8-0xdb
    OC4(B, B, B, B), // 0xdc-0xdf

    OC4(B, B, B, B), // 0xe0-0xe3
    OC4(B, B, B, B), // 0xe4-0xe7
    OC4(B, B, B, B), // 0xe8-0xeb
    OC4(B, B, B, B), // 0xec-0xef

    OC4(B, B, B, B), // 0xf0-0xf3
    OC4(B, B, B, B), // 0xf4-0xf7
    OC4(B, B, B, U), // 0xf8-0xfb
    OC4(U, U, U, U), // 0xfc-0xff
};
#undef OC4
#undef U
#undef B
#undef Q
#undef V
#undef O

uint micropy_opcode_format(struct _mp_state_ctx_t *mp_state, const byte *ip, size_t *opcode_size) {
    uint f = (opcode_format_table[*ip >> 2] >> (2 * (*ip & 3))) & 3;
    const byte *ip_start = ip;
    if (f == MP_OPCODE_QSTR) {
        ip += 3;
    } else {
        int extra_byte = (
            *ip == MP_BC_RAISE_VARARGS
            || *ip == MP_BC_MAKE_CLOSURE
            || *ip == MP_BC_MAKE_CLOSURE_DEFARGS
            #if MICROPY_OPT_CACHE_MAP_LOOKUP_IN_BYTECODE
            || *ip == MP_BC_LOAD_NAME
            || *ip == MP_BC_LOAD_GLOBAL
            || *ip == MP_BC_LOAD_ATTR
            || *ip == MP_BC_STORE_ATTR
            #endif
        );
        ip += 1;
        if (f == MP_OPCODE_VAR_UINT) {
            while ((*ip++ & 0x80) != 0) {
            }
        } else if (f == MP_OPCODE_OFFSET) {
            ip += 2;
        }
        ip += extra_byte;
    }
    *opcode_size = ip - ip_start;
    return f;
}

#endif // MICROPY_PERSISTENT_CODE_LOAD || MICROPY_PERSISTENT_CODE_SAVE
/*
 * This file is part of the Micro Python project, http://micropython.org/
 *
 * The MIT License (MIT)
 *
 * Copyright (c) 2013, 2014 Damien P. George
 * Copyright (c) 2014 Paul Sokolovsky
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

#include <stdio.h>
#include <string.h>
#include <assert.h>

//#include "py/mpstate.h"
//#include "py/nlr.h"
//#include "py/emitglue.h"
//#include "py/objtype.h"
//#include "py/runtime.h"
//#include "py/bc0.h"
//#include "py/bc.h"

#if 0
//#define TRACE(ip) printf("sp=" INT_FMT " ", sp - code_state->sp); mp_bytecode_print2(ip, 1);
#define TRACE(ip) printf("sp=%d ", sp - code_state->sp); micropy_bytecode_print2(mp_state, ip, 1);
#else
#define TRACE(ip)
#endif

// Value stack grows up (this makes it incompatible with native C stack, but
// makes sure that arguments to functions are in natural order arg1..argN
// (Python semantics mandates left-to-right evaluation order, including for
// function arguments). Stack pointer is pre-incremented and points at the
// top element.
// Exception stack also grows up, top element is also pointed at.

// Exception stack unwind reasons (WHY_* in CPython-speak)
// TODO perhaps compress this to RETURN=0, JUMP>0, with number of unwinds
// left to do encoded in the JUMP number
typedef enum {
    UNWIND_RETURN = 1,
    UNWIND_JUMP,
} mp_unwind_reason_t;

#define DECODE_UINT \
    mp_uint_t unum = 0; \
    do { \
        unum = (unum << 7) + (*ip & 0x7f); \
    } while ((*ip++ & 0x80) != 0)
#define DECODE_ULABEL mp_uint_t ulab = (ip[0] | (ip[1] << 8)); ip += 2
#define DECODE_SLABEL mp_uint_t slab = (ip[0] | (ip[1] << 8)) - 0x8000; ip += 2

#if MICROPY_PERSISTENT_CODE

#define DECODE_QSTR \
    qstr qst = ip[0] | ip[1] << 8; \
    ip += 2;
#define DECODE_PTR \
    DECODE_UINT; \
    void *ptr = (void*)(uintptr_t)code_state->const_table[unum]
#define DECODE_OBJ \
    DECODE_UINT; \
    mp_obj_t obj = (mp_obj_t)code_state->const_table[unum]

#else

#define DECODE_QSTR qstr qst = 0; \
    do { \
        qst = (qst << 7) + (*ip & 0x7f); \
    } while ((*ip++ & 0x80) != 0)
#define DECODE_PTR \
    ip = (byte*)MP_ALIGN(ip, sizeof(void*)); \
    void *ptr = *(void**)ip; \
    ip += sizeof(void*)
#define DECODE_OBJ \
    ip = (byte*)MP_ALIGN(ip, sizeof(mp_obj_t)); \
    mp_obj_t obj = *(mp_obj_t*)ip; \
    ip += sizeof(mp_obj_t)

#endif

#define PUSH(val) *++sp = (val)
#define POP() (*sp--)
#define TOP() (*sp)
#define SET_TOP(val) *sp = (val)

#if MICROPY_PY_SYS_EXC_INFO
#define CLEAR_SYS_EXC_INFO() (mp_state)->vm.cur_exception = NULL;
#else
#define CLEAR_SYS_EXC_INFO()
#endif

#define PUSH_EXC_BLOCK(with_or_finally) do { \
    DECODE_ULABEL; /* except labels are always forward */ \
    ++exc_sp; \
    exc_sp->handler = ip + ulab; \
    exc_sp->val_sp = MP_TAGPTR_MAKE(sp, ((with_or_finally) << 1) | currently_in_except_block); \
    exc_sp->prev_exc = NULL; \
    currently_in_except_block = 0; /* in a try block now */ \
} while (0)

#define POP_EXC_BLOCK() \
    currently_in_except_block = MP_TAGPTR_TAG0(exc_sp->val_sp); /* restore previous state */ \
    exc_sp--; /* pop back to previous exception handler */ \
    CLEAR_SYS_EXC_INFO() /* just clear sys.exc_info(), not compliant, but it shouldn't be used in 1st place */

// fastn has items in reverse order (fastn[0] is local[0], fastn[-1] is local[1], etc)
// sp points to bottom of stack which grows up
// returns:
//  MP_VM_RETURN_NORMAL, sp valid, return value in *sp
//  MP_VM_RETURN_YIELD, ip, sp valid, yielded value in *sp
//  MP_VM_RETURN_EXCEPTION, exception in fastn[0]
mp_vm_return_kind_t micropy_execute_bytecode(struct _mp_state_ctx_t *mp_state, mp_code_state *code_state, volatile mp_obj_t inject_exc) {
#define SELECTIVE_EXC_IP (0)
#if SELECTIVE_EXC_IP
#define MARK_EXC_IP_SELECTIVE() { code_state->ip = ip; } /* stores ip 1 byte past last opcode */
#define MARK_EXC_IP_GLOBAL()
#else
#define MARK_EXC_IP_SELECTIVE()
#define MARK_EXC_IP_GLOBAL() { code_state->ip = ip; } /* stores ip pointing to last opcode */
#endif
#if MICROPY_OPT_COMPUTED_GOTO
/*
 * This file is part of the Micro Python project, http://micropython.org/
 *
 * The MIT License (MIT)
 *
 * Copyright (c) 2013, 2014 Damien P. George
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

#if __clang__
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Winitializer-overrides"
#endif // __clang__

static const void *const entry_table[256] = {
    [0 ... 255] = &&entry_default,
    [MP_BC_LOAD_CONST_FALSE] = &&entry_MP_BC_LOAD_CONST_FALSE,
    [MP_BC_LOAD_CONST_NONE] = &&entry_MP_BC_LOAD_CONST_NONE,
    [MP_BC_LOAD_CONST_TRUE] = &&entry_MP_BC_LOAD_CONST_TRUE,
    [MP_BC_LOAD_CONST_SMALL_INT] = &&entry_MP_BC_LOAD_CONST_SMALL_INT,
    [MP_BC_LOAD_CONST_STRING] = &&entry_MP_BC_LOAD_CONST_STRING,
    [MP_BC_LOAD_CONST_OBJ] = &&entry_MP_BC_LOAD_CONST_OBJ,
    [MP_BC_LOAD_NULL] = &&entry_MP_BC_LOAD_NULL,
    [MP_BC_LOAD_FAST_N] = &&entry_MP_BC_LOAD_FAST_N,
    [MP_BC_LOAD_DEREF] = &&entry_MP_BC_LOAD_DEREF,
    [MP_BC_LOAD_NAME] = &&entry_MP_BC_LOAD_NAME,
    [MP_BC_LOAD_GLOBAL] = &&entry_MP_BC_LOAD_GLOBAL,
    [MP_BC_LOAD_ATTR] = &&entry_MP_BC_LOAD_ATTR,
    [MP_BC_LOAD_METHOD] = &&entry_MP_BC_LOAD_METHOD,
    [MP_BC_LOAD_BUILD_CLASS] = &&entry_MP_BC_LOAD_BUILD_CLASS,
    [MP_BC_LOAD_SUBSCR] = &&entry_MP_BC_LOAD_SUBSCR,
    [MP_BC_STORE_FAST_N] = &&entry_MP_BC_STORE_FAST_N,
    [MP_BC_STORE_DEREF] = &&entry_MP_BC_STORE_DEREF,
    [MP_BC_STORE_NAME] = &&entry_MP_BC_STORE_NAME,
    [MP_BC_STORE_GLOBAL] = &&entry_MP_BC_STORE_GLOBAL,
    [MP_BC_STORE_ATTR] = &&entry_MP_BC_STORE_ATTR,
    [MP_BC_STORE_SUBSCR] = &&entry_MP_BC_STORE_SUBSCR,
    [MP_BC_DELETE_FAST] = &&entry_MP_BC_DELETE_FAST,
    [MP_BC_DELETE_DEREF] = &&entry_MP_BC_DELETE_DEREF,
    [MP_BC_DELETE_NAME] = &&entry_MP_BC_DELETE_NAME,
    [MP_BC_DELETE_GLOBAL] = &&entry_MP_BC_DELETE_GLOBAL,
    [MP_BC_DUP_TOP] = &&entry_MP_BC_DUP_TOP,
    [MP_BC_DUP_TOP_TWO] = &&entry_MP_BC_DUP_TOP_TWO,
    [MP_BC_POP_TOP] = &&entry_MP_BC_POP_TOP,
    [MP_BC_ROT_TWO] = &&entry_MP_BC_ROT_TWO,
    [MP_BC_ROT_THREE] = &&entry_MP_BC_ROT_THREE,
    [MP_BC_JUMP] = &&entry_MP_BC_JUMP,
    [MP_BC_POP_JUMP_IF_TRUE] = &&entry_MP_BC_POP_JUMP_IF_TRUE,
    [MP_BC_POP_JUMP_IF_FALSE] = &&entry_MP_BC_POP_JUMP_IF_FALSE,
    [MP_BC_JUMP_IF_TRUE_OR_POP] = &&entry_MP_BC_JUMP_IF_TRUE_OR_POP,
    [MP_BC_JUMP_IF_FALSE_OR_POP] = &&entry_MP_BC_JUMP_IF_FALSE_OR_POP,
    [MP_BC_SETUP_WITH] = &&entry_MP_BC_SETUP_WITH,
    [MP_BC_WITH_CLEANUP] = &&entry_MP_BC_WITH_CLEANUP,
    [MP_BC_UNWIND_JUMP] = &&entry_MP_BC_UNWIND_JUMP,
    [MP_BC_SETUP_EXCEPT] = &&entry_MP_BC_SETUP_EXCEPT,
    [MP_BC_SETUP_FINALLY] = &&entry_MP_BC_SETUP_FINALLY,
    [MP_BC_END_FINALLY] = &&entry_MP_BC_END_FINALLY,
    [MP_BC_GET_ITER] = &&entry_MP_BC_GET_ITER,
    [MP_BC_FOR_ITER] = &&entry_MP_BC_FOR_ITER,
    [MP_BC_POP_BLOCK] = &&entry_MP_BC_POP_BLOCK,
    [MP_BC_POP_EXCEPT] = &&entry_MP_BC_POP_EXCEPT,
    [MP_BC_BUILD_TUPLE] = &&entry_MP_BC_BUILD_TUPLE,
    [MP_BC_BUILD_LIST] = &&entry_MP_BC_BUILD_LIST,
    [MP_BC_LIST_APPEND] = &&entry_MP_BC_LIST_APPEND,
    [MP_BC_BUILD_MAP] = &&entry_MP_BC_BUILD_MAP,
    [MP_BC_STORE_MAP] = &&entry_MP_BC_STORE_MAP,
    [MP_BC_MAP_ADD] = &&entry_MP_BC_MAP_ADD,
    #if MICROPY_PY_BUILTINS_SET
    [MP_BC_BUILD_SET] = &&entry_MP_BC_BUILD_SET,
    [MP_BC_SET_ADD] = &&entry_MP_BC_SET_ADD,
    #endif
    #if MICROPY_PY_BUILTINS_SLICE
    [MP_BC_BUILD_SLICE] = &&entry_MP_BC_BUILD_SLICE,
    #endif
    [MP_BC_UNPACK_SEQUENCE] = &&entry_MP_BC_UNPACK_SEQUENCE,
    [MP_BC_UNPACK_EX] = &&entry_MP_BC_UNPACK_EX,
    [MP_BC_MAKE_FUNCTION] = &&entry_MP_BC_MAKE_FUNCTION,
    [MP_BC_MAKE_FUNCTION_DEFARGS] = &&entry_MP_BC_MAKE_FUNCTION_DEFARGS,
    [MP_BC_MAKE_CLOSURE] = &&entry_MP_BC_MAKE_CLOSURE,
    [MP_BC_MAKE_CLOSURE_DEFARGS] = &&entry_MP_BC_MAKE_CLOSURE_DEFARGS,
    [MP_BC_CALL_FUNCTION] = &&entry_MP_BC_CALL_FUNCTION,
    [MP_BC_CALL_FUNCTION_VAR_KW] = &&entry_MP_BC_CALL_FUNCTION_VAR_KW,
    [MP_BC_CALL_METHOD] = &&entry_MP_BC_CALL_METHOD,
    [MP_BC_CALL_METHOD_VAR_KW] = &&entry_MP_BC_CALL_METHOD_VAR_KW,
    [MP_BC_RETURN_VALUE] = &&entry_MP_BC_RETURN_VALUE,
    [MP_BC_RAISE_VARARGS] = &&entry_MP_BC_RAISE_VARARGS,
    [MP_BC_YIELD_VALUE] = &&entry_MP_BC_YIELD_VALUE,
    [MP_BC_YIELD_FROM] = &&entry_MP_BC_YIELD_FROM,
    [MP_BC_IMPORT_NAME] = &&entry_MP_BC_IMPORT_NAME,
    [MP_BC_IMPORT_FROM] = &&entry_MP_BC_IMPORT_FROM,
    [MP_BC_IMPORT_STAR] = &&entry_MP_BC_IMPORT_STAR,
    [MP_BC_LOAD_CONST_SMALL_INT_MULTI ... MP_BC_LOAD_CONST_SMALL_INT_MULTI + 63] = &&entry_MP_BC_LOAD_CONST_SMALL_INT_MULTI,
    [MP_BC_LOAD_FAST_MULTI ... MP_BC_LOAD_FAST_MULTI + 15] = &&entry_MP_BC_LOAD_FAST_MULTI,
    [MP_BC_STORE_FAST_MULTI ... MP_BC_STORE_FAST_MULTI + 15] = &&entry_MP_BC_STORE_FAST_MULTI,
    [MP_BC_UNARY_OP_MULTI ... MP_BC_UNARY_OP_MULTI + 6] = &&entry_MP_BC_UNARY_OP_MULTI,
    [MP_BC_BINARY_OP_MULTI ... MP_BC_BINARY_OP_MULTI + 35] = &&entry_MP_BC_BINARY_OP_MULTI,
};

#if __clang__
#pragma clang diagnostic pop
#endif // __clang__
    #define DISPATCH() do { \
        TRACE(ip); \
        MARK_EXC_IP_GLOBAL(); \
        goto *entry_table[*ip++]; \
    } while (0)
    #define DISPATCH_WITH_PEND_EXC_CHECK() goto pending_exception_check
    #define ENTRY(op) entry_##op
    #define ENTRY_DEFAULT entry_default
#else
    #define DISPATCH() break
    #define DISPATCH_WITH_PEND_EXC_CHECK() goto pending_exception_check
    #define ENTRY(op) case op
    #define ENTRY_DEFAULT default
#endif

    // nlr_raise needs to be implemented as a goto, so that the C compiler's flow analyser
    // sees that it's possible for us to jump from the dispatch loop to the exception
    // handler.  Without this, the code may have a different stack layout in the dispatch
    // loop and the exception handler, leading to very obscure bugs.
    #define RAISE(o) do { micropy_nlr_pop(mp_state); nlr.ret_val = MP_OBJ_TO_PTR(o); goto exception_handler; } while (0)

#if MICROPY_STACKLESS
run_code_state: ;
#endif
    // Pointers which are constant for particular invocation of mp_execute_bytecode()
    mp_obj_t * /*const*/ fastn = &code_state->state[code_state->n_state - 1];
    mp_exc_stack_t * /*const*/ exc_stack = (mp_exc_stack_t*)(code_state->state + code_state->n_state);

    // variables that are visible to the exception handler (declared volatile)
    volatile bool currently_in_except_block = MP_TAGPTR_TAG0(code_state->exc_sp); // 0 or 1, to detect nested exceptions
    mp_exc_stack_t *volatile exc_sp = MP_TAGPTR_PTR(code_state->exc_sp); // stack grows up, exc_sp points to top of stack

    // outer exception handling loop
    for (;;) {
        nlr_buf_t nlr;
outer_dispatch_loop:
        if (micropy_nlr_push(mp_state, &nlr) == 0) {
            // local variables that are not visible to the exception handler
            const byte *ip = code_state->ip;
            mp_obj_t *sp = code_state->sp;
            mp_obj_t obj_shared;
            MICROPY_VM_HOOK_INIT

            // If we have exception to inject, now that we finish setting up
            // execution context, raise it. This works as if RAISE_VARARGS
            // bytecode was executed.
            // Injecting exc into yield from generator is a special case,
            // handled by MP_BC_YIELD_FROM itself
            if (inject_exc != MP_OBJ_NULL && *ip != MP_BC_YIELD_FROM) {
                mp_obj_t exc = inject_exc;
                inject_exc = MP_OBJ_NULL;
                exc = micropy_make_raise_obj(mp_state, exc);
                RAISE(exc);
            }

            // loop to execute byte code
            for (;;) {
dispatch_loop:
#if MICROPY_OPT_COMPUTED_GOTO
                DISPATCH();
#else
                TRACE(ip);
                MARK_EXC_IP_GLOBAL();
                switch (*ip++) {
#endif

                ENTRY(MP_BC_LOAD_CONST_FALSE):
                    PUSH(mp_const_false);
                    DISPATCH();

                ENTRY(MP_BC_LOAD_CONST_NONE):
                    PUSH(mp_const_none);
                    DISPATCH();

                ENTRY(MP_BC_LOAD_CONST_TRUE):
                    PUSH(mp_const_true);
                    DISPATCH();

                ENTRY(MP_BC_LOAD_CONST_SMALL_INT): {
                    mp_int_t num = 0;
                    if ((ip[0] & 0x40) != 0) {
                        // Number is negative
                        num--;
                    }
                    do {
                        num = (num << 7) | (*ip & 0x7f);
                    } while ((*ip++ & 0x80) != 0);
                    PUSH(MP_OBJ_NEW_SMALL_INT(num));
                    DISPATCH();
                }

                ENTRY(MP_BC_LOAD_CONST_STRING): {
                    DECODE_QSTR;
                    PUSH(MP_OBJ_NEW_QSTR(qst));
                    DISPATCH();
                }

                ENTRY(MP_BC_LOAD_CONST_OBJ): {
                    DECODE_OBJ;
                    PUSH(obj);
                    DISPATCH();
                }

                ENTRY(MP_BC_LOAD_NULL):
                    PUSH(MP_OBJ_NULL);
                    DISPATCH();

                ENTRY(MP_BC_LOAD_FAST_N): {
                    DECODE_UINT;
                    obj_shared = fastn[-unum];
                    load_check:
                    if (obj_shared == MP_OBJ_NULL) {
                        local_name_error: {
                            MARK_EXC_IP_SELECTIVE();
                            mp_obj_t obj = micropy_obj_new_exception_msg(mp_state, &mp_type_NameError, "local variable referenced before assignment");
                            RAISE(obj);
                        }
                    }
                    PUSH(obj_shared);
                    DISPATCH();
                }

                ENTRY(MP_BC_LOAD_DEREF): {
                    DECODE_UINT;
                    obj_shared = micropy_obj_cell_get(mp_state, fastn[-unum]);
                    goto load_check;
                }

                #if !MICROPY_OPT_CACHE_MAP_LOOKUP_IN_BYTECODE
                ENTRY(MP_BC_LOAD_NAME): {
                    MARK_EXC_IP_SELECTIVE();
                    DECODE_QSTR;
                    PUSH(micropy_load_name(mp_state, qst));
                    DISPATCH();
                }
                #else
                ENTRY(MP_BC_LOAD_NAME): {
                    MARK_EXC_IP_SELECTIVE();
                    DECODE_QSTR;
                    mp_obj_t key = MP_OBJ_NEW_QSTR(qst);
                    mp_uint_t x = *ip;
                    if (x < (mp_state)->dict_locals->map.alloc && (mp_state)->dict_locals->map.table[x].key == key) {
                        PUSH((mp_state)->dict_locals->map.table[x].value);
                    } else {
                        mp_map_elem_t *elem = micropy_map_lookup(mp_state, &(mp_state)->dict_locals->map, MP_OBJ_NEW_QSTR(qst), MP_MAP_LOOKUP);
                        if (elem != NULL) {
                            *(byte*)ip = (elem - &(mp_state)->dict_locals->map.table[0]) & 0xff;
                            PUSH(elem->value);
                        } else {
                            PUSH(micropy_load_name(mp_state, MP_OBJ_QSTR_VALUE(key)));
                        }
                    }
                    ip++;
                    DISPATCH();
                }
                #endif

                #if !MICROPY_OPT_CACHE_MAP_LOOKUP_IN_BYTECODE
                ENTRY(MP_BC_LOAD_GLOBAL): {
                    MARK_EXC_IP_SELECTIVE();
                    DECODE_QSTR;
                    PUSH(micropy_load_global(mp_state, qst));
                    DISPATCH();
                }
                #else
                ENTRY(MP_BC_LOAD_GLOBAL): {
                    MARK_EXC_IP_SELECTIVE();
                    DECODE_QSTR;
                    mp_obj_t key = MP_OBJ_NEW_QSTR(qst);
                    mp_uint_t x = *ip;
                    if (x < (mp_state)->dict_globals->map.alloc && (mp_state)->dict_globals->map.table[x].key == key) {
                        PUSH((mp_state)->dict_globals->map.table[x].value);
                    } else {
                        mp_map_elem_t *elem = micropy_map_lookup(mp_state, &(mp_state)->dict_globals->map, MP_OBJ_NEW_QSTR(qst), MP_MAP_LOOKUP);
                        if (elem != NULL) {
                            *(byte*)ip = (elem - &(mp_state)->dict_globals->map.table[0]) & 0xff;
                            PUSH(elem->value);
                        } else {
                            PUSH(micropy_load_global(mp_state, MP_OBJ_QSTR_VALUE(key)));
                        }
                    }
                    ip++;
                    DISPATCH();
                }
                #endif

                #if !MICROPY_OPT_CACHE_MAP_LOOKUP_IN_BYTECODE
                ENTRY(MP_BC_LOAD_ATTR): {
                    MARK_EXC_IP_SELECTIVE();
                    DECODE_QSTR;
                    SET_TOP(micropy_load_attr(mp_state, TOP(), qst));
                    DISPATCH();
                }
                #else
                ENTRY(MP_BC_LOAD_ATTR): {
                    MARK_EXC_IP_SELECTIVE();
                    DECODE_QSTR;
                    mp_obj_t top = TOP();
                    if (micropy_obj_get_type(mp_state, top)->attr == micropy_obj_instance_attr) {
                        mp_obj_instance_t *self = MP_OBJ_TO_PTR(top);
                        mp_uint_t x = *ip;
                        mp_obj_t key = MP_OBJ_NEW_QSTR(qst);
                        mp_map_elem_t *elem;
                        if (x < self->members.alloc && self->members.table[x].key == key) {
                            elem = &self->members.table[x];
                        } else {
                            elem = micropy_map_lookup(mp_state, &self->members, key, MP_MAP_LOOKUP);
                            if (elem != NULL) {
                                *(byte*)ip = elem - &self->members.table[0];
                            } else {
                                goto load_attr_cache_fail;
                            }
                        }
                        SET_TOP(elem->value);
                        ip++;
                        DISPATCH();
                    }
                load_attr_cache_fail:
                    SET_TOP(micropy_load_attr(mp_state, top, qst));
                    ip++;
                    DISPATCH();
                }
                #endif

                ENTRY(MP_BC_LOAD_METHOD): {
                    MARK_EXC_IP_SELECTIVE();
                    DECODE_QSTR;
                    micropy_load_method(mp_state, *sp, qst, sp);
                    sp += 1;
                    DISPATCH();
                }

                ENTRY(MP_BC_LOAD_BUILD_CLASS):
                    MARK_EXC_IP_SELECTIVE();
                    PUSH(micropy_load_build_class(mp_state));
                    DISPATCH();

                ENTRY(MP_BC_LOAD_SUBSCR): {
                    MARK_EXC_IP_SELECTIVE();
                    mp_obj_t index = POP();
                    SET_TOP(micropy_obj_subscr(mp_state, TOP(), index, MP_OBJ_SENTINEL));
                    DISPATCH();
                }

                ENTRY(MP_BC_STORE_FAST_N): {
                    DECODE_UINT;
                    fastn[-unum] = POP();
                    DISPATCH();
                }

                ENTRY(MP_BC_STORE_DEREF): {
                    DECODE_UINT;
                    micropy_obj_cell_set(mp_state, fastn[-unum], POP());
                    DISPATCH();
                }

                ENTRY(MP_BC_STORE_NAME): {
                    MARK_EXC_IP_SELECTIVE();
                    DECODE_QSTR;
                    micropy_store_name(mp_state, qst, POP());
                    DISPATCH();
                }

                ENTRY(MP_BC_STORE_GLOBAL): {
                    MARK_EXC_IP_SELECTIVE();
                    DECODE_QSTR;
                    micropy_store_global(mp_state, qst, POP());
                    DISPATCH();
                }

                #if !MICROPY_OPT_CACHE_MAP_LOOKUP_IN_BYTECODE
                ENTRY(MP_BC_STORE_ATTR): {
                    MARK_EXC_IP_SELECTIVE();
                    DECODE_QSTR;
                    micropy_store_attr(mp_state, sp[0], qst, sp[-1]);
                    sp -= 2;
                    DISPATCH();
                }
                #else
                // This caching code works with MICROPY_PY_BUILTINS_PROPERTY and/or
                // MICROPY_PY_DESCRIPTORS enabled because if the attr exists in
                // self->members then it can't be a property or have descriptors.  A
                // consequence of this is that we can't use MP_MAP_LOOKUP_ADD_IF_NOT_FOUND
                // in the fast-path below, because that store could override a property.
                ENTRY(MP_BC_STORE_ATTR): {
                    MARK_EXC_IP_SELECTIVE();
                    DECODE_QSTR;
                    mp_obj_t top = TOP();
                    if (micropy_obj_get_type(mp_state, top)->attr == micropy_obj_instance_attr && sp[-1] != MP_OBJ_NULL) {
                        mp_obj_instance_t *self = MP_OBJ_TO_PTR(top);
                        mp_uint_t x = *ip;
                        mp_obj_t key = MP_OBJ_NEW_QSTR(qst);
                        mp_map_elem_t *elem;
                        if (x < self->members.alloc && self->members.table[x].key == key) {
                            elem = &self->members.table[x];
                        } else {
                            elem = micropy_map_lookup(mp_state, &self->members, key, MP_MAP_LOOKUP);
                            if (elem != NULL) {
                                *(byte*)ip = elem - &self->members.table[0];
                            } else {
                                goto store_attr_cache_fail;
                            }
                        }
                        elem->value = sp[-1];
                        sp -= 2;
                        ip++;
                        DISPATCH();
                    }
                store_attr_cache_fail:
                    micropy_store_attr(mp_state, sp[0], qst, sp[-1]);
                    sp -= 2;
                    ip++;
                    DISPATCH();
                }
                #endif

                ENTRY(MP_BC_STORE_SUBSCR):
                    MARK_EXC_IP_SELECTIVE();
                    micropy_obj_subscr(mp_state, sp[-1], sp[0], sp[-2]);
                    sp -= 3;
                    DISPATCH();

                ENTRY(MP_BC_DELETE_FAST): {
                    MARK_EXC_IP_SELECTIVE();
                    DECODE_UINT;
                    if (fastn[-unum] == MP_OBJ_NULL) {
                        goto local_name_error;
                    }
                    fastn[-unum] = MP_OBJ_NULL;
                    DISPATCH();
                }

                ENTRY(MP_BC_DELETE_DEREF): {
                    MARK_EXC_IP_SELECTIVE();
                    DECODE_UINT;
                    if (micropy_obj_cell_get(mp_state, fastn[-unum]) == MP_OBJ_NULL) {
                        goto local_name_error;
                    }
                    micropy_obj_cell_set(mp_state, fastn[-unum], MP_OBJ_NULL);
                    DISPATCH();
                }

                ENTRY(MP_BC_DELETE_NAME): {
                    MARK_EXC_IP_SELECTIVE();
                    DECODE_QSTR;
                    micropy_delete_name(mp_state, qst);
                    DISPATCH();
                }

                ENTRY(MP_BC_DELETE_GLOBAL): {
                    MARK_EXC_IP_SELECTIVE();
                    DECODE_QSTR;
                    micropy_delete_global(mp_state, qst);
                    DISPATCH();
                }

                ENTRY(MP_BC_DUP_TOP): {
                    mp_obj_t top = TOP();
                    PUSH(top);
                    DISPATCH();
                }

                ENTRY(MP_BC_DUP_TOP_TWO):
                    sp += 2;
                    sp[0] = sp[-2];
                    sp[-1] = sp[-3];
                    DISPATCH();

                ENTRY(MP_BC_POP_TOP):
                    sp -= 1;
                    DISPATCH();

                ENTRY(MP_BC_ROT_TWO): {
                    mp_obj_t top = sp[0];
                    sp[0] = sp[-1];
                    sp[-1] = top;
                    DISPATCH();
                }

                ENTRY(MP_BC_ROT_THREE): {
                    mp_obj_t top = sp[0];
                    sp[0] = sp[-1];
                    sp[-1] = sp[-2];
                    sp[-2] = top;
                    DISPATCH();
                }

                ENTRY(MP_BC_JUMP): {
                    DECODE_SLABEL;
                    ip += slab;
                    DISPATCH_WITH_PEND_EXC_CHECK();
                }

                ENTRY(MP_BC_POP_JUMP_IF_TRUE): {
                    DECODE_SLABEL;
                    if (micropy_obj_is_true(mp_state, POP())) {
                        ip += slab;
                    }
                    DISPATCH_WITH_PEND_EXC_CHECK();
                }

                ENTRY(MP_BC_POP_JUMP_IF_FALSE): {
                    DECODE_SLABEL;
                    if (!micropy_obj_is_true(mp_state, POP())) {
                        ip += slab;
                    }
                    DISPATCH_WITH_PEND_EXC_CHECK();
                }

                ENTRY(MP_BC_JUMP_IF_TRUE_OR_POP): {
                    DECODE_SLABEL;
                    if (micropy_obj_is_true(mp_state, TOP())) {
                        ip += slab;
                    } else {
                        sp--;
                    }
                    DISPATCH_WITH_PEND_EXC_CHECK();
                }

                ENTRY(MP_BC_JUMP_IF_FALSE_OR_POP): {
                    DECODE_SLABEL;
                    if (micropy_obj_is_true(mp_state, TOP())) {
                        sp--;
                    } else {
                        ip += slab;
                    }
                    DISPATCH_WITH_PEND_EXC_CHECK();
                }

                ENTRY(MP_BC_SETUP_WITH): {
                    MARK_EXC_IP_SELECTIVE();
                    // stack: (..., ctx_mgr)
                    mp_obj_t obj = TOP();
                    micropy_load_method(mp_state, obj, MP_QSTR___exit__, sp);
                    micropy_load_method(mp_state, obj, MP_QSTR___enter__, sp + 2);
                    mp_obj_t ret = micropy_call_method_n_kw(mp_state, 0, 0, sp + 2);
                    sp += 1;
                    PUSH_EXC_BLOCK(1);
                    PUSH(ret);
                    // stack: (..., __exit__, ctx_mgr, as_value)
                    DISPATCH();
                }

                ENTRY(MP_BC_WITH_CLEANUP): {
                    MARK_EXC_IP_SELECTIVE();
                    // Arriving here, there's "exception control block" on top of stack,
                    // and __exit__ method (with self) underneath it. Bytecode calls __exit__,
                    // and "deletes" it off stack, shifting "exception control block"
                    // to its place.
                    if (TOP() == mp_const_none) {
                        // stack: (..., __exit__, ctx_mgr, None)
                        sp[1] = mp_const_none;
                        sp[2] = mp_const_none;
                        sp -= 2;
                        micropy_call_method_n_kw(mp_state, 3, 0, sp);
                        SET_TOP(mp_const_none);
                    } else if (MP_OBJ_IS_SMALL_INT(TOP())) {
                        mp_int_t cause_val = MP_OBJ_SMALL_INT_VALUE(TOP());
                        if (cause_val == UNWIND_RETURN) {
                            // stack: (..., __exit__, ctx_mgr, ret_val, UNWIND_RETURN)
                            mp_obj_t ret_val = sp[-1];
                            sp[-1] = mp_const_none;
                            sp[0] = mp_const_none;
                            sp[1] = mp_const_none;
                            micropy_call_method_n_kw(mp_state, 3, 0, sp - 3);
                            sp[-3] = ret_val;
                            sp[-2] = MP_OBJ_NEW_SMALL_INT(UNWIND_RETURN);
                        } else {
                            assert(cause_val == UNWIND_JUMP);
                            // stack: (..., __exit__, ctx_mgr, dest_ip, num_exc, UNWIND_JUMP)
                            mp_obj_t dest_ip = sp[-2];
                            mp_obj_t num_exc = sp[-1];
                            sp[-2] = mp_const_none;
                            sp[-1] = mp_const_none;
                            sp[0] = mp_const_none;
                            micropy_call_method_n_kw(mp_state, 3, 0, sp - 4);
                            sp[-4] = dest_ip;
                            sp[-3] = num_exc;
                            sp[-2] = MP_OBJ_NEW_SMALL_INT(UNWIND_JUMP);
                        }
                        sp -= 2; // we removed (__exit__, ctx_mgr)
                    } else {
                        assert(micropy_obj_is_exception_type(mp_state, TOP()));
                        // stack: (..., __exit__, ctx_mgr, traceback, exc_val, exc_type)
                        // Need to pass (sp[0], sp[-1], sp[-2]) as arguments so must reverse the
                        // order of these on the value stack (don't want to create a temporary
                        // array because it increases stack footprint of the VM).
                        mp_obj_t obj = sp[-2];
                        sp[-2] = sp[0];
                        sp[0] = obj;
                        mp_obj_t ret_value = micropy_call_method_n_kw(mp_state, 3, 0, sp - 4);
                        if (micropy_obj_is_true(mp_state, ret_value)) {
                            // We need to silence/swallow the exception.  This is done
                            // by popping the exception and the __exit__ handler and
                            // replacing it with None, which signals END_FINALLY to just
                            // execute the finally handler normally.
                            sp -= 4;
                            SET_TOP(mp_const_none);
                            assert(exc_sp >= exc_stack);
                            POP_EXC_BLOCK();
                        } else {
                            // We need to re-raise the exception.  We pop __exit__ handler
                            // and copy the 3 exception values down (remembering that they
                            // are reversed due to above code).
                            sp[-4] = sp[0];
                            sp[-3] = sp[-1];
                            sp -= 2;
                        }
                    }
                    DISPATCH();
                }

                ENTRY(MP_BC_UNWIND_JUMP): {
                    MARK_EXC_IP_SELECTIVE();
                    DECODE_SLABEL;
                    PUSH((mp_obj_t)(mp_uint_t)(uintptr_t)(ip + slab)); // push destination ip for jump
                    PUSH((mp_obj_t)(mp_uint_t)(*ip)); // push number of exception handlers to unwind (0x80 bit set if we also need to pop stack)
unwind_jump:;
                    mp_uint_t unum = (mp_uint_t)POP(); // get number of exception handlers to unwind
                    while ((unum & 0x7f) > 0) {
                        unum -= 1;
                        assert(exc_sp >= exc_stack);
                        if (MP_TAGPTR_TAG1(exc_sp->val_sp)) {
                            // Getting here the stack looks like:
                            //     (..., X, dest_ip)
                            // where X is pointed to by exc_sp->val_sp and in the case
                            // of a "with" block contains the context manager info.
                            // We're going to run "finally" code as a coroutine
                            // (not calling it recursively). Set up a sentinel
                            // on a stack so it can return back to us when it is
                            // done (when WITH_CLEANUP or END_FINALLY reached).
                            PUSH((mp_obj_t)unum); // push number of exception handlers left to unwind
                            PUSH(MP_OBJ_NEW_SMALL_INT(UNWIND_JUMP)); // push sentinel
                            ip = exc_sp->handler; // get exception handler byte code address
                            exc_sp--; // pop exception handler
                            goto dispatch_loop; // run the exception handler
                        }
                        POP_EXC_BLOCK();
                    }
                    ip = (const byte*)MP_OBJ_TO_PTR(POP()); // pop destination ip for jump
                    if (unum != 0) {
                        sp--;
                    }
                    DISPATCH_WITH_PEND_EXC_CHECK();
                }

                // matched against: POP_BLOCK or POP_EXCEPT (anything else?)
                ENTRY(MP_BC_SETUP_EXCEPT):
                ENTRY(MP_BC_SETUP_FINALLY): {
                    MARK_EXC_IP_SELECTIVE();
                    #if SELECTIVE_EXC_IP
                    PUSH_EXC_BLOCK((code_state->ip[-1] == MP_BC_SETUP_FINALLY) ? 1 : 0);
                    #else
                    PUSH_EXC_BLOCK((code_state->ip[0] == MP_BC_SETUP_FINALLY) ? 1 : 0);
                    #endif
                    DISPATCH();
                }

                ENTRY(MP_BC_END_FINALLY):
                    MARK_EXC_IP_SELECTIVE();
                    // not fully implemented
                    // if TOS is an exception, reraises the exception (3 values on TOS)
                    // if TOS is None, just pops it and continues
                    // if TOS is an integer, does something else
                    // else error
                    if (micropy_obj_is_exception_type(mp_state, TOP())) {
                        RAISE(sp[-1]);
                    }
                    if (TOP() == mp_const_none) {
                        sp--;
                    } else {
                        assert(MP_OBJ_IS_SMALL_INT(TOP()));
                        // We finished "finally" coroutine and now dispatch back
                        // to our caller, based on TOS value
                        mp_unwind_reason_t reason = MP_OBJ_SMALL_INT_VALUE(POP());
                        if (reason == UNWIND_RETURN) {
                            goto unwind_return;
                        } else {
                            assert(reason == UNWIND_JUMP);
                            goto unwind_jump;
                        }
                    }
                    DISPATCH();

                ENTRY(MP_BC_GET_ITER):
                    MARK_EXC_IP_SELECTIVE();
                    SET_TOP(micropy_getiter(mp_state, TOP()));
                    DISPATCH();

                ENTRY(MP_BC_FOR_ITER): {
                    MARK_EXC_IP_SELECTIVE();
                    DECODE_ULABEL; // the jump offset if iteration finishes; for labels are always forward
                    code_state->sp = sp;
                    assert(TOP());
                    mp_obj_t value = micropy_iternext_allow_raise(mp_state, TOP());
                    if (value == MP_OBJ_STOP_ITERATION) {
                        --sp; // pop the exhausted iterator
                        ip += ulab; // jump to after for-block
                    } else {
                        PUSH(value); // push the next iteration value
                    }
                    DISPATCH();
                }

                // matched against: SETUP_EXCEPT, SETUP_FINALLY, SETUP_WITH
                ENTRY(MP_BC_POP_BLOCK):
                    // we are exiting an exception handler, so pop the last one of the exception-stack
                    assert(exc_sp >= exc_stack);
                    POP_EXC_BLOCK();
                    DISPATCH();

                // matched against: SETUP_EXCEPT
                ENTRY(MP_BC_POP_EXCEPT):
                    // TODO need to work out how blocks work etc
                    // pops block, checks it's an exception block, and restores the stack, saving the 3 exception values to local threadstate
                    assert(exc_sp >= exc_stack);
                    assert(currently_in_except_block);
                    //sp = (mp_obj_t*)(*exc_sp--);
                    //exc_sp--; // discard ip
                    POP_EXC_BLOCK();
                    //sp -= 3; // pop 3 exception values
                    DISPATCH();

                ENTRY(MP_BC_BUILD_TUPLE): {
                    MARK_EXC_IP_SELECTIVE();
                    DECODE_UINT;
                    sp -= unum - 1;
                    SET_TOP(micropy_obj_new_tuple(mp_state, unum, sp));
                    DISPATCH();
                }

                ENTRY(MP_BC_BUILD_LIST): {
                    MARK_EXC_IP_SELECTIVE();
                    DECODE_UINT;
                    sp -= unum - 1;
                    SET_TOP(micropy_obj_new_list(mp_state, unum, sp));
                    DISPATCH();
                }

                ENTRY(MP_BC_LIST_APPEND): {
                    MARK_EXC_IP_SELECTIVE();
                    DECODE_UINT;
                    // I think it's guaranteed by the compiler that sp[unum] is a list
                    micropy_obj_list_append(mp_state, sp[-unum], sp[0]);
                    sp--;
                    DISPATCH();
                }

                ENTRY(MP_BC_BUILD_MAP): {
                    MARK_EXC_IP_SELECTIVE();
                    DECODE_UINT;
                    PUSH(micropy_obj_new_dict(mp_state, unum));
                    DISPATCH();
                }

                ENTRY(MP_BC_STORE_MAP):
                    MARK_EXC_IP_SELECTIVE();
                    sp -= 2;
                    micropy_obj_dict_store(mp_state, sp[0], sp[2], sp[1]);
                    DISPATCH();

                ENTRY(MP_BC_MAP_ADD): {
                    MARK_EXC_IP_SELECTIVE();
                    DECODE_UINT;
                    // I think it's guaranteed by the compiler that sp[-unum - 1] is a map
                    micropy_obj_dict_store(mp_state, sp[-unum - 1], sp[0], sp[-1]);
                    sp -= 2;
                    DISPATCH();
                }

#if MICROPY_PY_BUILTINS_SET
                ENTRY(MP_BC_BUILD_SET): {
                    MARK_EXC_IP_SELECTIVE();
                    DECODE_UINT;
                    sp -= unum - 1;
                    SET_TOP(micropy_obj_new_set(mp_state, unum, sp));
                    DISPATCH();
                }

                ENTRY(MP_BC_SET_ADD): {
                    MARK_EXC_IP_SELECTIVE();
                    DECODE_UINT;
                    // I think it's guaranteed by the compiler that sp[-unum] is a set
                    micropy_obj_set_store(mp_state, sp[-unum], sp[0]);
                    sp--;
                    DISPATCH();
                }
#endif

#if MICROPY_PY_BUILTINS_SLICE
                ENTRY(MP_BC_BUILD_SLICE): {
                    MARK_EXC_IP_SELECTIVE();
                    DECODE_UINT;
                    if (unum == 2) {
                        mp_obj_t stop = POP();
                        mp_obj_t start = TOP();
                        SET_TOP(micropy_obj_new_slice(mp_state, start, stop, mp_const_none));
                    } else {
                        mp_obj_t step = POP();
                        mp_obj_t stop = POP();
                        mp_obj_t start = TOP();
                        SET_TOP(micropy_obj_new_slice(mp_state, start, stop, step));
                    }
                    DISPATCH();
                }
#endif

                ENTRY(MP_BC_UNPACK_SEQUENCE): {
                    MARK_EXC_IP_SELECTIVE();
                    DECODE_UINT;
                    micropy_unpack_sequence(mp_state, sp[0], unum, sp);
                    sp += unum - 1;
                    DISPATCH();
                }

                ENTRY(MP_BC_UNPACK_EX): {
                    MARK_EXC_IP_SELECTIVE();
                    DECODE_UINT;
                    micropy_unpack_ex(mp_state, sp[0], unum, sp);
                    sp += (unum & 0xff) + ((unum >> 8) & 0xff);
                    DISPATCH();
                }

                ENTRY(MP_BC_MAKE_FUNCTION): {
                    DECODE_PTR;
                    PUSH(micropy_make_function_from_raw_code(mp_state, ptr, MP_OBJ_NULL, MP_OBJ_NULL));
                    DISPATCH();
                }

                ENTRY(MP_BC_MAKE_FUNCTION_DEFARGS): {
                    DECODE_PTR;
                    // Stack layout: def_tuple def_dict <- TOS
                    mp_obj_t def_dict = POP();
                    SET_TOP(micropy_make_function_from_raw_code(mp_state, ptr, TOP(), def_dict));
                    DISPATCH();
                }

                ENTRY(MP_BC_MAKE_CLOSURE): {
                    DECODE_PTR;
                    mp_uint_t n_closed_over = *ip++;
                    // Stack layout: closed_overs <- TOS
                    sp -= n_closed_over - 1;
                    SET_TOP(micropy_make_closure_from_raw_code(mp_state, ptr, n_closed_over, sp));
                    DISPATCH();
                }

                ENTRY(MP_BC_MAKE_CLOSURE_DEFARGS): {
                    DECODE_PTR;
                    mp_uint_t n_closed_over = *ip++;
                    // Stack layout: def_tuple def_dict closed_overs <- TOS
                    sp -= 2 + n_closed_over - 1;
                    SET_TOP(micropy_make_closure_from_raw_code(mp_state, ptr, 0x100 | n_closed_over, sp));
                    DISPATCH();
                }

                ENTRY(MP_BC_CALL_FUNCTION): {
                    MARK_EXC_IP_SELECTIVE();
                    DECODE_UINT;
                    // unum & 0xff == n_positional
                    // (unum >> 8) & 0xff == n_keyword
                    sp -= (unum & 0xff) + ((unum >> 7) & 0x1fe);
                    #if MICROPY_STACKLESS
                    if (micropy_obj_get_type(mp_state, *sp) == &mp_type_fun_bc) {
                        code_state->ip = ip;
                        code_state->sp = sp;
                        code_state->exc_sp = MP_TAGPTR_MAKE(exc_sp, currently_in_except_block);
                        mp_code_state *new_state = micropy_obj_fun_bc_prepare_codestate(mp_state, *sp, unum & 0xff, (unum >> 8) & 0xff, sp + 1);
                        if (new_state) {
                            new_state->prev = code_state;
                            code_state = new_state;
                            micropy_nlr_pop(mp_state);
                            goto run_code_state;
                        }
                        #if MICROPY_STACKLESS_STRICT
                        else {
                        deep_recursion_error:
                            micropy_exc_recursion_depth(mp_state);
                        }
                        #endif
                    }
                    #endif
                    SET_TOP(micropy_call_function_n_kw(mp_state, *sp, unum & 0xff, (unum >> 8) & 0xff, sp + 1));
                    DISPATCH();
                }

                ENTRY(MP_BC_CALL_FUNCTION_VAR_KW): {
                    MARK_EXC_IP_SELECTIVE();
                    DECODE_UINT;
                    // unum & 0xff == n_positional
                    // (unum >> 8) & 0xff == n_keyword
                    // We have folowing stack layout here:
                    // fun arg0 arg1 ... kw0 val0 kw1 val1 ... seq dict <- TOS
                    sp -= (unum & 0xff) + ((unum >> 7) & 0x1fe) + 2;
                    #if MICROPY_STACKLESS
                    if (micropy_obj_get_type(mp_state, *sp) == &mp_type_fun_bc) {
                        code_state->ip = ip;
                        code_state->sp = sp;
                        code_state->exc_sp = MP_TAGPTR_MAKE(exc_sp, currently_in_except_block);

                        mp_call_args_t out_args;
                        micropy_call_prepare_args_n_kw_var(mp_state, false, unum, sp, &out_args);

                        mp_code_state *new_state = micropy_obj_fun_bc_prepare_codestate(mp_state, out_args.fun,
                            out_args.n_args, out_args.n_kw, out_args.args);
                        micropy_m_del(mp_state, mp_obj_t, out_args.args, out_args.n_alloc);
                        if (new_state) {
                            new_state->prev = code_state;
                            code_state = new_state;
                            micropy_nlr_pop(mp_state);
                            goto run_code_state;
                        }
                        #if MICROPY_STACKLESS_STRICT
                        else {
                            goto deep_recursion_error;
                        }
                        #endif
                    }
                    #endif
                    SET_TOP(micropy_call_method_n_kw_var(mp_state, false, unum, sp));
                    DISPATCH();
                }

                ENTRY(MP_BC_CALL_METHOD): {
                    MARK_EXC_IP_SELECTIVE();
                    DECODE_UINT;
                    // unum & 0xff == n_positional
                    // (unum >> 8) & 0xff == n_keyword
                    sp -= (unum & 0xff) + ((unum >> 7) & 0x1fe) + 1;
                    #if MICROPY_STACKLESS
                    if (micropy_obj_get_type(mp_state, *sp) == &mp_type_fun_bc) {
                        code_state->ip = ip;
                        code_state->sp = sp;
                        code_state->exc_sp = MP_TAGPTR_MAKE(exc_sp, currently_in_except_block);

                        mp_uint_t n_args = unum & 0xff;
                        mp_uint_t n_kw = (unum >> 8) & 0xff;
                        int adjust = (sp[1] == MP_OBJ_NULL) ? 0 : 1;

                        mp_code_state *new_state = micropy_obj_fun_bc_prepare_codestate(mp_state, *sp, n_args + adjust, n_kw, sp + 2 - adjust);
                        if (new_state) {
                            new_state->prev = code_state;
                            code_state = new_state;
                            micropy_nlr_pop(mp_state);
                            goto run_code_state;
                        }
                        #if MICROPY_STACKLESS_STRICT
                        else {
                            goto deep_recursion_error;
                        }
                        #endif
                    }
                    #endif
                    SET_TOP(micropy_call_method_n_kw(mp_state, unum & 0xff, (unum >> 8) & 0xff, sp));
                    DISPATCH();
                }

                ENTRY(MP_BC_CALL_METHOD_VAR_KW): {
                    MARK_EXC_IP_SELECTIVE();
                    DECODE_UINT;
                    // unum & 0xff == n_positional
                    // (unum >> 8) & 0xff == n_keyword
                    // We have folowing stack layout here:
                    // fun self arg0 arg1 ... kw0 val0 kw1 val1 ... seq dict <- TOS
                    sp -= (unum & 0xff) + ((unum >> 7) & 0x1fe) + 3;
                    #if MICROPY_STACKLESS
                    if (micropy_obj_get_type(mp_state, *sp) == &mp_type_fun_bc) {
                        code_state->ip = ip;
                        code_state->sp = sp;
                        code_state->exc_sp = MP_TAGPTR_MAKE(exc_sp, currently_in_except_block);

                        mp_call_args_t out_args;
                        micropy_call_prepare_args_n_kw_var(mp_state, true, unum, sp, &out_args);

                        mp_code_state *new_state = micropy_obj_fun_bc_prepare_codestate(mp_state, out_args.fun,
                            out_args.n_args, out_args.n_kw, out_args.args);
                        micropy_m_del(mp_state, mp_obj_t, out_args.args, out_args.n_alloc);
                        if (new_state) {
                            new_state->prev = code_state;
                            code_state = new_state;
                            micropy_nlr_pop(mp_state);
                            goto run_code_state;
                        }
                        #if MICROPY_STACKLESS_STRICT
                        else {
                            goto deep_recursion_error;
                        }
                        #endif
                    }
                    #endif
                    SET_TOP(micropy_call_method_n_kw_var(mp_state, true, unum, sp));
                    DISPATCH();
                }

                ENTRY(MP_BC_RETURN_VALUE):
                    MARK_EXC_IP_SELECTIVE();
                    // These next 3 lines pop a try-finally exception handler, if one
                    // is there on the exception stack.  Without this the finally block
                    // is executed a second time when the return is executed, because
                    // the try-finally exception handler is still on the stack.
                    // TODO Possibly find a better way to handle this case.
                    if (currently_in_except_block) {
                        POP_EXC_BLOCK();
                    }
unwind_return:
                    while (exc_sp >= exc_stack) {
                        if (MP_TAGPTR_TAG1(exc_sp->val_sp)) {
                            // Getting here the stack looks like:
                            //     (..., X, [iter0, iter1, ...,] ret_val)
                            // where X is pointed to by exc_sp->val_sp and in the case
                            // of a "with" block contains the context manager info.
                            // There may be 0 or more for-iterators between X and the
                            // return value, and these must be removed before control can
                            // pass to the finally code.  We simply copy the ret_value down
                            // over these iterators, if they exist.  If they don't then the
                            // following is a null operation.
                            mp_obj_t *finally_sp = MP_TAGPTR_PTR(exc_sp->val_sp);
                            finally_sp[1] = sp[0];
                            sp = &finally_sp[1];
                            // We're going to run "finally" code as a coroutine
                            // (not calling it recursively). Set up a sentinel
                            // on a stack so it can return back to us when it is
                            // done (when WITH_CLEANUP or END_FINALLY reached).
                            PUSH(MP_OBJ_NEW_SMALL_INT(UNWIND_RETURN));
                            ip = exc_sp->handler;
                            exc_sp--;
                            goto dispatch_loop;
                        }
                        exc_sp--;
                    }
                    micropy_nlr_pop(mp_state);
                    code_state->sp = sp;
                    assert(exc_sp == exc_stack - 1);
                    MICROPY_VM_HOOK_RETURN
                    #if MICROPY_STACKLESS
                    if (code_state->prev != NULL) {
                        mp_obj_t res = *sp;
                        mp_state->dict_globals = code_state->old_globals;
                        code_state = code_state->prev;
                        *code_state->sp = res;
                        goto run_code_state;
                    }
                    #endif
                    return MP_VM_RETURN_NORMAL;

                ENTRY(MP_BC_RAISE_VARARGS): {
                    MARK_EXC_IP_SELECTIVE();
                    mp_uint_t unum = *ip++;
                    mp_obj_t obj;
                    if (unum == 2) {
                        micropy_warning(mp_state, "exception chaining not supported");
                        // ignore (pop) "from" argument
                        sp--;
                    }
                    if (unum == 0) {
                        // search for the inner-most previous exception, to reraise it
                        obj = MP_OBJ_NULL;
                        for (mp_exc_stack_t *e = exc_sp; e >= exc_stack; e--) {
                            if (e->prev_exc != NULL) {
                                obj = MP_OBJ_FROM_PTR(e->prev_exc);
                                break;
                            }
                        }
                        if (obj == MP_OBJ_NULL) {
                            obj = micropy_obj_new_exception_msg(mp_state, &mp_type_RuntimeError, "No active exception to reraise");
                            RAISE(obj);
                        }
                    } else {
                        obj = POP();
                    }
                    obj = micropy_make_raise_obj(mp_state, obj);
                    RAISE(obj);
                }

                ENTRY(MP_BC_YIELD_VALUE):
yield:
                    micropy_nlr_pop(mp_state);
                    code_state->ip = ip;
                    code_state->sp = sp;
                    code_state->exc_sp = MP_TAGPTR_MAKE(exc_sp, currently_in_except_block);
                    return MP_VM_RETURN_YIELD;

                ENTRY(MP_BC_YIELD_FROM): {
                    MARK_EXC_IP_SELECTIVE();
//#define EXC_MATCH(exc, type) MP_OBJ_IS_TYPE(exc, type)
#define EXC_MATCH(exc, type) micropy_obj_exception_match(mp_state, exc, type)
#define GENERATOR_EXIT_IF_NEEDED(t) if (t != MP_OBJ_NULL && EXC_MATCH(t, MP_OBJ_FROM_PTR(&mp_type_GeneratorExit))) { RAISE(t); }
                    mp_vm_return_kind_t ret_kind;
                    mp_obj_t send_value = POP();
                    mp_obj_t t_exc = MP_OBJ_NULL;
                    mp_obj_t ret_value;
                    if (inject_exc != MP_OBJ_NULL) {
                        t_exc = inject_exc;
                        inject_exc = MP_OBJ_NULL;
                        ret_kind = micropy_resume(mp_state, TOP(), MP_OBJ_NULL, t_exc, &ret_value);
                    } else {
                        ret_kind = micropy_resume(mp_state, TOP(), send_value, MP_OBJ_NULL, &ret_value);
                    }

                    if (ret_kind == MP_VM_RETURN_YIELD) {
                        ip--;
                        PUSH(ret_value);
                        goto yield;
                    }
                    if (ret_kind == MP_VM_RETURN_NORMAL) {
                        // Pop exhausted gen
                        sp--;
                        // TODO: When ret_value can be MP_OBJ_NULL here??
                        if (ret_value == MP_OBJ_NULL || ret_value == MP_OBJ_STOP_ITERATION) {
                            // Optimize StopIteration
                            // TODO: get StopIteration's value
                            PUSH(mp_const_none);
                        } else {
                            PUSH(ret_value);
                        }

                        // If we injected GeneratorExit downstream, then even
                        // if it was swallowed, we re-raise GeneratorExit
                        GENERATOR_EXIT_IF_NEEDED(t_exc);
                        DISPATCH();
                    }
                    if (ret_kind == MP_VM_RETURN_EXCEPTION) {
                        // Pop exhausted gen
                        sp--;
                        if (EXC_MATCH(ret_value, MP_OBJ_FROM_PTR(&mp_type_StopIteration))) {
                            PUSH(micropy_obj_exception_get_value(mp_state, ret_value));
                            // If we injected GeneratorExit downstream, then even
                            // if it was swallowed, we re-raise GeneratorExit
                            GENERATOR_EXIT_IF_NEEDED(t_exc);
                            DISPATCH();
                        } else {
                            RAISE(ret_value);
                        }
                    }
                }

                ENTRY(MP_BC_IMPORT_NAME): {
                    MARK_EXC_IP_SELECTIVE();
                    DECODE_QSTR;
                    mp_obj_t obj = POP();
                    SET_TOP(micropy_import_name(mp_state, qst, obj, TOP()));
                    DISPATCH();
                }

                ENTRY(MP_BC_IMPORT_FROM): {
                    MARK_EXC_IP_SELECTIVE();
                    DECODE_QSTR;
                    mp_obj_t obj = micropy_import_from(mp_state, TOP(), qst);
                    PUSH(obj);
                    DISPATCH();
                }

                ENTRY(MP_BC_IMPORT_STAR):
                    MARK_EXC_IP_SELECTIVE();
                    micropy_import_all(mp_state, POP());
                    DISPATCH();

#if MICROPY_OPT_COMPUTED_GOTO
                ENTRY(MP_BC_LOAD_CONST_SMALL_INT_MULTI):
                    PUSH(MP_OBJ_NEW_SMALL_INT((mp_int_t)ip[-1] - MP_BC_LOAD_CONST_SMALL_INT_MULTI - 16));
                    DISPATCH();

                ENTRY(MP_BC_LOAD_FAST_MULTI):
                    obj_shared = fastn[MP_BC_LOAD_FAST_MULTI - (mp_int_t)ip[-1]];
                    goto load_check;

                ENTRY(MP_BC_STORE_FAST_MULTI):
                    fastn[MP_BC_STORE_FAST_MULTI - (mp_int_t)ip[-1]] = POP();
                    DISPATCH();

                ENTRY(MP_BC_UNARY_OP_MULTI):
                    MARK_EXC_IP_SELECTIVE();
                    SET_TOP(micropy_unary_op(mp_state, ip[-1] - MP_BC_UNARY_OP_MULTI, TOP()));
                    DISPATCH();

                ENTRY(MP_BC_BINARY_OP_MULTI): {
                    MARK_EXC_IP_SELECTIVE();
                    mp_obj_t rhs = POP();
                    mp_obj_t lhs = TOP();
                    SET_TOP(micropy_binary_op(mp_state, ip[-1] - MP_BC_BINARY_OP_MULTI, lhs, rhs));
                    DISPATCH();
                }

                ENTRY_DEFAULT:
                    MARK_EXC_IP_SELECTIVE();
#else
                ENTRY_DEFAULT:
                    if (ip[-1] < MP_BC_LOAD_CONST_SMALL_INT_MULTI + 64) {
                        PUSH(MP_OBJ_NEW_SMALL_INT((mp_int_t)ip[-1] - MP_BC_LOAD_CONST_SMALL_INT_MULTI - 16));
                        DISPATCH();
                    } else if (ip[-1] < MP_BC_LOAD_FAST_MULTI + 16) {
                        obj_shared = fastn[MP_BC_LOAD_FAST_MULTI - (mp_int_t)ip[-1]];
                        goto load_check;
                    } else if (ip[-1] < MP_BC_STORE_FAST_MULTI + 16) {
                        fastn[MP_BC_STORE_FAST_MULTI - (mp_int_t)ip[-1]] = POP();
                        DISPATCH();
                    } else if (ip[-1] < MP_BC_UNARY_OP_MULTI + 7) {
                        SET_TOP(micropy_unary_op(mp_state, ip[-1] - MP_BC_UNARY_OP_MULTI, TOP()));
                        DISPATCH();
                    } else if (ip[-1] < MP_BC_BINARY_OP_MULTI + 36) {
                        mp_obj_t rhs = POP();
                        mp_obj_t lhs = TOP();
                        SET_TOP(micropy_binary_op(mp_state, ip[-1] - MP_BC_BINARY_OP_MULTI, lhs, rhs));
                        DISPATCH();
                    } else
#endif
                {
                    mp_obj_t obj = micropy_obj_new_exception_msg(mp_state, &mp_type_NotImplementedError, "byte code not implemented");
                    micropy_nlr_pop(mp_state);
                    fastn[0] = obj;
                    return MP_VM_RETURN_EXCEPTION;
                }

#if !MICROPY_OPT_COMPUTED_GOTO
                } // switch
#endif

pending_exception_check:
                MICROPY_VM_HOOK_LOOP
                if ((mp_state)->vm.mp_pending_exception != MP_OBJ_NULL) {
                    MARK_EXC_IP_SELECTIVE();
                    mp_obj_t obj = (mp_state)->vm.mp_pending_exception;
                    (mp_state)->vm.mp_pending_exception = MP_OBJ_NULL;
                    RAISE(obj);
                }

            } // for loop

        } else {
exception_handler:
            // exception occurred

            #if MICROPY_PY_SYS_EXC_INFO
            (mp_state)->vm.cur_exception = nlr.ret_val;
            #endif

            #if SELECTIVE_EXC_IP
            // with selective ip, we store the ip 1 byte past the opcode, so move ptr back
            code_state->ip -= 1;
            #endif

            if (micropy_obj_is_subclass_fast(mp_state, MP_OBJ_FROM_PTR(((mp_obj_base_t*)nlr.ret_val)->type), MP_OBJ_FROM_PTR(&mp_type_StopIteration))) {
                if (code_state->ip) {
                    // check if it's a StopIteration within a for block
                    if (*code_state->ip == MP_BC_FOR_ITER) {
                        const byte *ip = code_state->ip + 1;
                        DECODE_ULABEL; // the jump offset if iteration finishes; for labels are always forward
                        code_state->ip = ip + ulab; // jump to after for-block
                        code_state->sp -= 1; // pop the exhausted iterator
                        goto outer_dispatch_loop; // continue with dispatch loop
                    } else if (*code_state->ip == MP_BC_YIELD_FROM) {
                        // StopIteration inside yield from call means return a value of
                        // yield from, so inject exception's value as yield from's result
                        *++code_state->sp = micropy_obj_exception_get_value(mp_state, MP_OBJ_FROM_PTR(nlr.ret_val));
                        code_state->ip++; // yield from is over, move to next instruction
                        goto outer_dispatch_loop; // continue with dispatch loop
                    }
                }
            }

#if MICROPY_STACKLESS
unwind_loop:
#endif
            // set file and line number that the exception occurred at
            // TODO: don't set traceback for exceptions re-raised by END_FINALLY.
            // But consider how to handle nested exceptions.
            // TODO need a better way of not adding traceback to constant objects (right now, just GeneratorExit_obj and MemoryError_obj)
            if (nlr.ret_val != &mp_const_GeneratorExit_obj && nlr.ret_val != &mp_const_MemoryError_obj) {
                const byte *ip = code_state->code_info;
                mp_uint_t code_info_size = micropy_decode_uint(mp_state, &ip);
                #if MICROPY_PERSISTENT_CODE
                qstr block_name = ip[0] | (ip[1] << 8);
                qstr source_file = ip[2] | (ip[3] << 8);
                ip += 4;
                #else
                qstr block_name = micropy_decode_uint(mp_state, &ip);
                qstr source_file = micropy_decode_uint(mp_state, &ip);
                #endif
                size_t bc = code_state->ip - code_state->code_info - code_info_size;
                size_t source_line = 1;
                size_t c;
                while ((c = *ip)) {
                    mp_uint_t b, l;
                    if ((c & 0x80) == 0) {
                        // 0b0LLBBBBB encoding
                        b = c & 0x1f;
                        l = c >> 5;
                        ip += 1;
                    } else {
                        // 0b1LLLBBBB 0bLLLLLLLL encoding (l's LSB in second byte)
                        b = c & 0xf;
                        l = ((c << 4) & 0x700) | ip[1];
                        ip += 2;
                    }
                    if (bc >= b) {
                        bc -= b;
                        source_line += l;
                    } else {
                        // found source line corresponding to bytecode offset
                        break;
                    }
                }
                micropy_obj_exception_add_traceback(mp_state, MP_OBJ_FROM_PTR(nlr.ret_val), source_file, source_line, block_name);
            }

            while (currently_in_except_block) {
                // nested exception

                assert(exc_sp >= exc_stack);

                // TODO make a proper message for nested exception
                // at the moment we are just raising the very last exception (the one that caused the nested exception)

                // move up to previous exception handler
                POP_EXC_BLOCK();
            }

            if (exc_sp >= exc_stack) {
                // set flag to indicate that we are now handling an exception
                currently_in_except_block = 1;

                // catch exception and pass to byte code
                code_state->ip = exc_sp->handler;
                mp_obj_t *sp = MP_TAGPTR_PTR(exc_sp->val_sp);
                // save this exception in the stack so it can be used in a reraise, if needed
                exc_sp->prev_exc = nlr.ret_val;
                // push(traceback, exc-val, exc-type)
                PUSH(mp_const_none);
                PUSH(MP_OBJ_FROM_PTR(nlr.ret_val));
                PUSH(MP_OBJ_FROM_PTR(((mp_obj_base_t*)nlr.ret_val)->type));
                code_state->sp = sp;

            #if MICROPY_STACKLESS
            } else if (code_state->prev != NULL) {
                mp_state->dict_globals = code_state->old_globals;
                code_state = code_state->prev;
                fastn = &code_state->state[code_state->n_state - 1];
                exc_stack = (mp_exc_stack_t*)(code_state->state + code_state->n_state);
                // variables that are visible to the exception handler (declared volatile)
                currently_in_except_block = MP_TAGPTR_TAG0(code_state->exc_sp); // 0 or 1, to detect nested exceptions
                exc_sp = MP_TAGPTR_PTR(code_state->exc_sp); // stack grows up, exc_sp points to top of stack
                goto unwind_loop;

            #endif
            } else {
                // propagate exception to higher level
                // TODO what to do about ip and sp? they don't really make sense at this point
                fastn[0] = MP_OBJ_FROM_PTR(nlr.ret_val); // must put exception here because sp is invalid
                return MP_VM_RETURN_EXCEPTION;
            }
        }
    }
}
/*
 * This file is part of the Micro Python project, http://micropython.org/
 *
 * The MIT License (MIT)
 *
 * Copyright (c) 2013, 2014 Damien P. George
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

#include <stdio.h>
#include <assert.h>

//#include "py/bc0.h"
//#include "py/bc.h"

#if MICROPY_DEBUG_PRINTERS

#define DECODE_UINT { \
    unum = 0; \
    do { \
        unum = (unum << 7) + (*ip & 0x7f); \
    } while ((*ip++ & 0x80) != 0); \
}
#define DECODE_ULABEL do { unum = (ip[0] | (ip[1] << 8)); ip += 2; } while (0)
#define DECODE_SLABEL do { unum = (ip[0] | (ip[1] << 8)) - 0x8000; ip += 2; } while (0)

#if MICROPY_PERSISTENT_CODE

#define DECODE_QSTR \
    qst = ip[0] | ip[1] << 8; \
    ip += 2;
#define DECODE_PTR \
    DECODE_UINT; \
    unum = mp_showbc_const_table[unum]
#define DECODE_OBJ \
    DECODE_UINT; \
    unum = mp_showbc_const_table[unum]

#else

#define DECODE_QSTR { \
    qst = 0; \
    do { \
        qst = (qst << 7) + (*ip & 0x7f); \
    } while ((*ip++ & 0x80) != 0); \
}
#define DECODE_PTR do { \
    ip = (byte*)MP_ALIGN(ip, sizeof(void*)); \
    unum = (uintptr_t)*(void**)ip; \
    ip += sizeof(void*); \
} while (0)
#define DECODE_OBJ do { \
    ip = (byte*)MP_ALIGN(ip, sizeof(mp_obj_t)); \
    unum = (mp_uint_t)*(mp_obj_t*)ip; \
    ip += sizeof(mp_obj_t); \
} while (0)

#endif

const byte *mp_showbc_code_start;
const mp_uint_t *mp_showbc_const_table;

void micropy_bytecode_print(struct _mp_state_ctx_t *mp_state, const void *descr, const byte *ip, mp_uint_t len, const mp_uint_t *const_table) {
    mp_showbc_code_start = ip;
    mp_showbc_const_table = const_table;

    // get bytecode parameters
    mp_uint_t n_state = micropy_decode_uint(mp_state, &ip);
    mp_uint_t n_exc_stack = micropy_decode_uint(mp_state, &ip);
    /*mp_uint_t scope_flags =*/ ip++;
    mp_uint_t n_pos_args = *ip++;
    mp_uint_t n_kwonly_args = *ip++;
    /*mp_uint_t n_def_pos_args =*/ ip++;

    const byte *code_info = ip;
    mp_uint_t code_info_size = micropy_decode_uint(mp_state, &code_info);
    ip += code_info_size;

    #if MICROPY_PERSISTENT_CODE
    qstr block_name = code_info[0] | (code_info[1] << 8);
    qstr source_file = code_info[2] | (code_info[3] << 8);
    #else
    qstr block_name = micropy_decode_uint(mp_state, &code_info);
    qstr source_file = micropy_decode_uint(mp_state, &code_info);
    #endif
    printf("File %s, code block '%s' (descriptor: %p, bytecode @%p " UINT_FMT " bytes)\n",
        micropy_qstr_str(mp_state, source_file), micropy_qstr_str(mp_state, block_name), descr, mp_showbc_code_start, len);

    // raw bytecode dump
    printf("Raw bytecode (code_info_size=" UINT_FMT ", bytecode_size=" UINT_FMT "):\n", code_info_size, len - code_info_size);
    for (mp_uint_t i = 0; i < len; i++) {
        if (i > 0 && i % 16 == 0) {
            printf("\n");
        }
        printf(" %02x", mp_showbc_code_start[i]);
    }
    printf("\n");

    // bytecode prelude: arg names (as qstr objects)
    printf("arg names:");
    for (mp_uint_t i = 0; i < n_pos_args + n_kwonly_args; i++) {
        printf(" %s", micropy_qstr_str(mp_state, MP_OBJ_QSTR_VALUE(const_table[i])));
    }
    printf("\n");

    printf("(N_STATE " UINT_FMT ")\n", n_state);
    printf("(N_EXC_STACK " UINT_FMT ")\n", n_exc_stack);

    // for printing line number info
    const byte *bytecode_start = ip;

    // bytecode prelude: initialise closed over variables
    {
        uint local_num;
        while ((local_num = *ip++) != 255) {
            printf("(INIT_CELL %u)\n", local_num);
        }
        len -= ip - mp_showbc_code_start;
    }

    // print out line number info
    {
        mp_int_t bc = bytecode_start - ip;
        mp_uint_t source_line = 1;
        printf("  bc=" INT_FMT " line=" UINT_FMT "\n", bc, source_line);
        for (const byte* ci = code_info; *ci;) {
            if ((ci[0] & 0x80) == 0) {
                // 0b0LLBBBBB encoding
                bc += ci[0] & 0x1f;
                source_line += ci[0] >> 5;
                ci += 1;
            } else {
                // 0b1LLLBBBB 0bLLLLLLLL encoding (l's LSB in second byte)
                bc += ci[0] & 0xf;
                source_line += ((ci[0] << 4) & 0x700) | ci[1];
                ci += 2;
            }
            printf("  bc=" INT_FMT " line=" UINT_FMT "\n", bc, source_line);
        }
    }
    micropy_bytecode_print2(mp_state, ip, len - 0);
}

const byte *micropy_bytecode_print_str(struct _mp_state_ctx_t *mp_state, const byte *ip) {
    mp_uint_t unum;
    qstr qst;

    switch (*ip++) {
        case MP_BC_LOAD_CONST_FALSE:
            printf("LOAD_CONST_FALSE");
            break;

        case MP_BC_LOAD_CONST_NONE:
            printf("LOAD_CONST_NONE");
            break;

        case MP_BC_LOAD_CONST_TRUE:
            printf("LOAD_CONST_TRUE");
            break;

        case MP_BC_LOAD_CONST_SMALL_INT: {
            mp_int_t num = 0;
            if ((ip[0] & 0x40) != 0) {
                // Number is negative
                num--;
            }
            do {
                num = (num << 7) | (*ip & 0x7f);
            } while ((*ip++ & 0x80) != 0);
            printf("LOAD_CONST_SMALL_INT " INT_FMT, num);
            break;
        }

        case MP_BC_LOAD_CONST_STRING:
            DECODE_QSTR;
            printf("LOAD_CONST_STRING '%s'", micropy_qstr_str(mp_state, qst));
            break;

        case MP_BC_LOAD_CONST_OBJ:
            DECODE_OBJ;
            printf("LOAD_CONST_OBJ %p=", MP_OBJ_TO_PTR(unum));
            micropy_obj_print_helper(mp_state, &mp_plat_print, (mp_obj_t)unum, PRINT_REPR);
            break;

        case MP_BC_LOAD_NULL:
            printf("LOAD_NULL");
            break;

        case MP_BC_LOAD_FAST_N:
            DECODE_UINT;
            printf("LOAD_FAST_N " UINT_FMT, unum);
            break;

        case MP_BC_LOAD_DEREF:
            DECODE_UINT;
            printf("LOAD_DEREF " UINT_FMT, unum);
            break;

        case MP_BC_LOAD_NAME:
            DECODE_QSTR;
            printf("LOAD_NAME %s", micropy_qstr_str(mp_state, qst));
            if (MICROPY_OPT_CACHE_MAP_LOOKUP_IN_BYTECODE) {
                printf(" (cache=%u)", *ip++);
            }
            break;

        case MP_BC_LOAD_GLOBAL:
            DECODE_QSTR;
            printf("LOAD_GLOBAL %s", micropy_qstr_str(mp_state, qst));
            if (MICROPY_OPT_CACHE_MAP_LOOKUP_IN_BYTECODE) {
                printf(" (cache=%u)", *ip++);
            }
            break;

        case MP_BC_LOAD_ATTR:
            DECODE_QSTR;
            printf("LOAD_ATTR %s", micropy_qstr_str(mp_state, qst));
            if (MICROPY_OPT_CACHE_MAP_LOOKUP_IN_BYTECODE) {
                printf(" (cache=%u)", *ip++);
            }
            break;

        case MP_BC_LOAD_METHOD:
            DECODE_QSTR;
            printf("LOAD_METHOD %s", micropy_qstr_str(mp_state, qst));
            break;

        case MP_BC_LOAD_BUILD_CLASS:
            printf("LOAD_BUILD_CLASS");
            break;

        case MP_BC_LOAD_SUBSCR:
            printf("LOAD_SUBSCR");
            break;

        case MP_BC_STORE_FAST_N:
            DECODE_UINT;
            printf("STORE_FAST_N " UINT_FMT, unum);
            break;

        case MP_BC_STORE_DEREF:
            DECODE_UINT;
            printf("STORE_DEREF " UINT_FMT, unum);
            break;

        case MP_BC_STORE_NAME:
            DECODE_QSTR;
            printf("STORE_NAME %s", micropy_qstr_str(mp_state, qst));
            break;

        case MP_BC_STORE_GLOBAL:
            DECODE_QSTR;
            printf("STORE_GLOBAL %s", micropy_qstr_str(mp_state, qst));
            break;

        case MP_BC_STORE_ATTR:
            DECODE_QSTR;
            printf("STORE_ATTR %s", micropy_qstr_str(mp_state, qst));
            if (MICROPY_OPT_CACHE_MAP_LOOKUP_IN_BYTECODE) {
                printf(" (cache=%u)", *ip++);
            }
            break;

        case MP_BC_STORE_SUBSCR:
            printf("STORE_SUBSCR");
            break;

        case MP_BC_DELETE_FAST:
            DECODE_UINT;
            printf("DELETE_FAST " UINT_FMT, unum);
            break;

        case MP_BC_DELETE_DEREF:
            DECODE_UINT;
            printf("DELETE_DEREF " UINT_FMT, unum);
            break;

        case MP_BC_DELETE_NAME:
            DECODE_QSTR;
            printf("DELETE_NAME %s", micropy_qstr_str(mp_state, qst));
            break;

        case MP_BC_DELETE_GLOBAL:
            DECODE_QSTR;
            printf("DELETE_GLOBAL %s", micropy_qstr_str(mp_state, qst));
            break;

        case MP_BC_DUP_TOP:
            printf("DUP_TOP");
            break;

        case MP_BC_DUP_TOP_TWO:
            printf("DUP_TOP_TWO");
            break;

        case MP_BC_POP_TOP:
            printf("POP_TOP");
            break;

        case MP_BC_ROT_TWO:
            printf("ROT_TWO");
            break;

        case MP_BC_ROT_THREE:
            printf("ROT_THREE");
            break;

        case MP_BC_JUMP:
            DECODE_SLABEL;
            printf("JUMP " UINT_FMT, (mp_uint_t)(ip + unum - mp_showbc_code_start));
            break;

        case MP_BC_POP_JUMP_IF_TRUE:
            DECODE_SLABEL;
            printf("POP_JUMP_IF_TRUE " UINT_FMT, (mp_uint_t)(ip + unum - mp_showbc_code_start));
            break;

        case MP_BC_POP_JUMP_IF_FALSE:
            DECODE_SLABEL;
            printf("POP_JUMP_IF_FALSE " UINT_FMT, (mp_uint_t)(ip + unum - mp_showbc_code_start));
            break;

        case MP_BC_JUMP_IF_TRUE_OR_POP:
            DECODE_SLABEL;
            printf("JUMP_IF_TRUE_OR_POP " UINT_FMT, (mp_uint_t)(ip + unum - mp_showbc_code_start));
            break;

        case MP_BC_JUMP_IF_FALSE_OR_POP:
            DECODE_SLABEL;
            printf("JUMP_IF_FALSE_OR_POP " UINT_FMT, (mp_uint_t)(ip + unum - mp_showbc_code_start));
            break;

        case MP_BC_SETUP_WITH:
            DECODE_ULABEL; // loop-like labels are always forward
            printf("SETUP_WITH " UINT_FMT, (mp_uint_t)(ip + unum - mp_showbc_code_start));
            break;

        case MP_BC_WITH_CLEANUP:
            printf("WITH_CLEANUP");
            break;

        case MP_BC_UNWIND_JUMP:
            DECODE_SLABEL;
            printf("UNWIND_JUMP " UINT_FMT " %d", (mp_uint_t)(ip + unum - mp_showbc_code_start), *ip);
            ip += 1;
            break;

        case MP_BC_SETUP_EXCEPT:
            DECODE_ULABEL; // except labels are always forward
            printf("SETUP_EXCEPT " UINT_FMT, (mp_uint_t)(ip + unum - mp_showbc_code_start));
            break;

        case MP_BC_SETUP_FINALLY:
            DECODE_ULABEL; // except labels are always forward
            printf("SETUP_FINALLY " UINT_FMT, (mp_uint_t)(ip + unum - mp_showbc_code_start));
            break;

        case MP_BC_END_FINALLY:
            // if TOS is an exception, reraises the exception (3 values on TOS)
            // if TOS is an integer, does something else
            // if TOS is None, just pops it and continues
            // else error
            printf("END_FINALLY");
            break;

        case MP_BC_GET_ITER:
            printf("GET_ITER");
            break;

        case MP_BC_FOR_ITER:
            DECODE_ULABEL; // the jump offset if iteration finishes; for labels are always forward
            printf("FOR_ITER " UINT_FMT, (mp_uint_t)(ip + unum - mp_showbc_code_start));
            break;

        case MP_BC_POP_BLOCK:
            // pops block and restores the stack
            printf("POP_BLOCK");
            break;

        case MP_BC_POP_EXCEPT:
            // pops block, checks it's an exception block, and restores the stack, saving the 3 exception values to local threadstate
            printf("POP_EXCEPT");
            break;

        case MP_BC_BUILD_TUPLE:
            DECODE_UINT;
            printf("BUILD_TUPLE " UINT_FMT, unum);
            break;

        case MP_BC_BUILD_LIST:
            DECODE_UINT;
            printf("BUILD_LIST " UINT_FMT, unum);
            break;

        case MP_BC_LIST_APPEND:
            DECODE_UINT;
            printf("LIST_APPEND " UINT_FMT, unum);
            break;

        case MP_BC_BUILD_MAP:
            DECODE_UINT;
            printf("BUILD_MAP " UINT_FMT, unum);
            break;

        case MP_BC_STORE_MAP:
            printf("STORE_MAP");
            break;

        case MP_BC_MAP_ADD:
            DECODE_UINT;
            printf("MAP_ADD " UINT_FMT, unum);
            break;

        case MP_BC_BUILD_SET:
            DECODE_UINT;
            printf("BUILD_SET " UINT_FMT, unum);
            break;

        case MP_BC_SET_ADD:
            DECODE_UINT;
            printf("SET_ADD " UINT_FMT, unum);
            break;

#if MICROPY_PY_BUILTINS_SLICE
        case MP_BC_BUILD_SLICE:
            DECODE_UINT;
            printf("BUILD_SLICE " UINT_FMT, unum);
            break;
#endif

        case MP_BC_UNPACK_SEQUENCE:
            DECODE_UINT;
            printf("UNPACK_SEQUENCE " UINT_FMT, unum);
            break;

        case MP_BC_UNPACK_EX:
            DECODE_UINT;
            printf("UNPACK_EX " UINT_FMT, unum);
            break;

        case MP_BC_MAKE_FUNCTION:
            DECODE_PTR;
            printf("MAKE_FUNCTION %p", (void*)(uintptr_t)unum);
            break;

        case MP_BC_MAKE_FUNCTION_DEFARGS:
            DECODE_PTR;
            printf("MAKE_FUNCTION_DEFARGS %p", (void*)(uintptr_t)unum);
            break;

        case MP_BC_MAKE_CLOSURE: {
            DECODE_PTR;
            mp_uint_t n_closed_over = *ip++;
            printf("MAKE_CLOSURE %p " UINT_FMT, (void*)(uintptr_t)unum, n_closed_over);
            break;
        }

        case MP_BC_MAKE_CLOSURE_DEFARGS: {
            DECODE_PTR;
            mp_uint_t n_closed_over = *ip++;
            printf("MAKE_CLOSURE_DEFARGS %p " UINT_FMT, (void*)(uintptr_t)unum, n_closed_over);
            break;
        }

        case MP_BC_CALL_FUNCTION:
            DECODE_UINT;
            printf("CALL_FUNCTION n=" UINT_FMT " nkw=" UINT_FMT, unum & 0xff, (unum >> 8) & 0xff);
            break;

        case MP_BC_CALL_FUNCTION_VAR_KW:
            DECODE_UINT;
            printf("CALL_FUNCTION_VAR_KW n=" UINT_FMT " nkw=" UINT_FMT, unum & 0xff, (unum >> 8) & 0xff);
            break;

        case MP_BC_CALL_METHOD:
            DECODE_UINT;
            printf("CALL_METHOD n=" UINT_FMT " nkw=" UINT_FMT, unum & 0xff, (unum >> 8) & 0xff);
            break;

        case MP_BC_CALL_METHOD_VAR_KW:
            DECODE_UINT;
            printf("CALL_METHOD_VAR_KW n=" UINT_FMT " nkw=" UINT_FMT, unum & 0xff, (unum >> 8) & 0xff);
            break;

        case MP_BC_RETURN_VALUE:
            printf("RETURN_VALUE");
            break;

        case MP_BC_RAISE_VARARGS:
            unum = *ip++;
            printf("RAISE_VARARGS " UINT_FMT, unum);
            break;

        case MP_BC_YIELD_VALUE:
            printf("YIELD_VALUE");
            break;

        case MP_BC_YIELD_FROM:
            printf("YIELD_FROM");
            break;

        case MP_BC_IMPORT_NAME:
            DECODE_QSTR;
            printf("IMPORT_NAME '%s'", micropy_qstr_str(mp_state, qst));
            break;

        case MP_BC_IMPORT_FROM:
            DECODE_QSTR;
            printf("IMPORT_FROM '%s'", micropy_qstr_str(mp_state, qst));
            break;

        case MP_BC_IMPORT_STAR:
            printf("IMPORT_STAR");
            break;

        default:
            if (ip[-1] < MP_BC_LOAD_CONST_SMALL_INT_MULTI + 64) {
                printf("LOAD_CONST_SMALL_INT " INT_FMT, (mp_int_t)ip[-1] - MP_BC_LOAD_CONST_SMALL_INT_MULTI - 16);
            } else if (ip[-1] < MP_BC_LOAD_FAST_MULTI + 16) {
                printf("LOAD_FAST " UINT_FMT, (mp_uint_t)ip[-1] - MP_BC_LOAD_FAST_MULTI);
            } else if (ip[-1] < MP_BC_STORE_FAST_MULTI + 16) {
                printf("STORE_FAST " UINT_FMT, (mp_uint_t)ip[-1] - MP_BC_STORE_FAST_MULTI);
            } else if (ip[-1] < MP_BC_UNARY_OP_MULTI + 7) {
                printf("UNARY_OP " UINT_FMT, (mp_uint_t)ip[-1] - MP_BC_UNARY_OP_MULTI);
            } else if (ip[-1] < MP_BC_BINARY_OP_MULTI + 36) {
                mp_uint_t op = ip[-1] - MP_BC_BINARY_OP_MULTI;
                printf("BINARY_OP " UINT_FMT " %s", op, micropy_qstr_str(mp_state, mp_binary_op_method_name[op]));
            } else {
                printf("code %p, byte code 0x%02x not implemented\n", ip, ip[-1]);
                assert(0);
                return ip;
            }
            break;
    }

    return ip;
}

void micropy_bytecode_print2(struct _mp_state_ctx_t *mp_state, const byte *ip, mp_uint_t len) {
    mp_showbc_code_start = ip;
    while (ip < len + mp_showbc_code_start) {
        printf("%02u ", (uint)(ip - mp_showbc_code_start));
        ip = micropy_bytecode_print_str(mp_state, ip);
        printf("\n");
    }
}

#endif // MICROPY_DEBUG_PRINTERS
/*
 * This file is part of the Micro Python project, http://micropython.org/
 *
 * The MIT License (MIT)
 *
 * Copyright (c) 2013-2015 Damien P. George
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

#include <string.h>
//#include "py/obj.h"
//#include "py/runtime.h"
//#include "py/repl.h"

#if MICROPY_HELPER_REPL

STATIC bool micropy_str_startswith_word(struct _mp_state_ctx_t *mp_state, const char *str, const char *head) {
    mp_uint_t i;
    for (i = 0; str[i] && head[i]; i++) {
        if (str[i] != head[i]) {
            return false;
        }
    }
    return head[i] == '\0' && (str[i] == '\0' || !unichar_isident(str[i]));
}

bool micropy_repl_continue_with_input(struct _mp_state_ctx_t *mp_state, const char *input) {
    // check for blank input
    if (input[0] == '\0') {
        return false;
    }

    // check if input starts with a certain keyword
    bool starts_with_compound_keyword =
           input[0] == '@'
        || micropy_str_startswith_word(mp_state, input, "if")
        || micropy_str_startswith_word(mp_state, input, "while")
        || micropy_str_startswith_word(mp_state, input, "for")
        || micropy_str_startswith_word(mp_state, input, "try")
        || micropy_str_startswith_word(mp_state, input, "with")
        || micropy_str_startswith_word(mp_state, input, "def")
        || micropy_str_startswith_word(mp_state, input, "class")
        #if MICROPY_PY_ASYNC_AWAIT
        || micropy_str_startswith_word(mp_state, input, "async")
        #endif
        ;

    // check for unmatched open bracket, quote or escape quote
    #define Q_NONE (0)
    #define Q_1_SINGLE (1)
    #define Q_1_DOUBLE (2)
    #define Q_3_SINGLE (3)
    #define Q_3_DOUBLE (4)
    int n_paren = 0;
    int n_brack = 0;
    int n_brace = 0;
    int in_quote = Q_NONE;
    const char *i;
    for (i = input; *i; i++) {
        if (*i == '\'') {
            if ((in_quote == Q_NONE || in_quote == Q_3_SINGLE) && i[1] == '\'' && i[2] == '\'') {
                i += 2;
                in_quote = Q_3_SINGLE - in_quote;
            } else if (in_quote == Q_NONE || in_quote == Q_1_SINGLE) {
                in_quote = Q_1_SINGLE - in_quote;
            }
        } else if (*i == '"') {
            if ((in_quote == Q_NONE || in_quote == Q_3_DOUBLE) && i[1] == '"' && i[2] == '"') {
                i += 2;
                in_quote = Q_3_DOUBLE - in_quote;
            } else if (in_quote == Q_NONE || in_quote == Q_1_DOUBLE) {
                in_quote = Q_1_DOUBLE - in_quote;
            }
        } else if (*i == '\\' && (i[1] == '\'' || i[1] == '"' || i[1] == '\\')) {
            if (in_quote != Q_NONE) {
                i++;
            }
        } else if (in_quote == Q_NONE) {
            switch (*i) {
                case '(': n_paren += 1; break;
                case ')': n_paren -= 1; break;
                case '[': n_brack += 1; break;
                case ']': n_brack -= 1; break;
                case '{': n_brace += 1; break;
                case '}': n_brace -= 1; break;
                default: break;
            }
        }
    }

    // continue if unmatched brackets or quotes
    if (n_paren > 0 || n_brack > 0 || n_brace > 0 || in_quote == Q_3_SINGLE || in_quote == Q_3_DOUBLE) {
        return true;
    }

    // continue if last character was backslash (for line continuation)
    if (i[-1] == '\\') {
        return true;
    }

    // continue if compound keyword and last line was not empty
    if (starts_with_compound_keyword && i[-1] != '\n') {
        return true;
    }

    // otherwise, don't continue
    return false;
}

mp_uint_t micropy_repl_autocomplete(struct _mp_state_ctx_t *mp_state, const char *str, mp_uint_t len, const mp_print_t *print, const char **compl_str) {
    // scan backwards to find start of "a.b.c" chain
    const char *org_str = str;
    const char *top = str + len;
    for (const char *s = top; --s >= str;) {
        if (!(unichar_isalpha(*s) || unichar_isdigit(*s) || *s == '_' || *s == '.')) {
            ++s;
            str = s;
            break;
        }
    }

    // begin search in locals dict
    mp_obj_dict_t *dict = mp_state->dict_locals;

    for (;;) {
        // get next word in string to complete
        const char *s_start = str;
        while (str < top && *str != '.') {
            ++str;
        }
        mp_uint_t s_len = str - s_start;

        if (str < top) {
            // a complete word, lookup in current dict

            mp_obj_t obj = MP_OBJ_NULL;
            for (mp_uint_t i = 0; i < dict->map.alloc; i++) {
                if (MP_MAP_SLOT_IS_FILLED(&dict->map, i)) {
                    mp_uint_t d_len;
                    const char *d_str = micropy_obj_str_get_data(mp_state, dict->map.table[i].key, &d_len);
                    if (s_len == d_len && strncmp(s_start, d_str, d_len) == 0) {
                        obj = dict->map.table[i].value;
                        break;
                    }
                }
            }

            if (obj == MP_OBJ_NULL) {
                // lookup failed
                return 0;
            }

            // found an object of this name; try to get its dict
            if (MP_OBJ_IS_TYPE(obj, &mp_type_module)) {
                dict = micropy_obj_module_get_globals(mp_state, obj);
            } else {
                mp_obj_type_t *type;
                if (MP_OBJ_IS_TYPE(obj, &mp_type_type)) {
                    type = MP_OBJ_TO_PTR(obj);
                } else {
                    type = micropy_obj_get_type(mp_state, obj);
                }
                if (type->locals_dict != NULL && type->locals_dict->base.type == &mp_type_dict) {
                    dict = type->locals_dict;
                } else {
                    // obj has no dict
                    return 0;
                }
            }

            // skip '.' to move to next word
            ++str;

        } else {
            // end of string, do completion on this partial name

            // look for matches
            int n_found = 0;
            const char *match_str = NULL;
            mp_uint_t match_len = 0;
            for (mp_uint_t i = 0; i < dict->map.alloc; i++) {
                if (MP_MAP_SLOT_IS_FILLED(&dict->map, i)) {
                    mp_uint_t d_len;
                    const char *d_str = micropy_obj_str_get_data(mp_state, dict->map.table[i].key, &d_len);
                    if (s_len <= d_len && strncmp(s_start, d_str, s_len) == 0) {
                        if (match_str == NULL) {
                            match_str = d_str;
                            match_len = d_len;
                        } else {
                            // search for longest common prefix of match_str and d_str
                            // (assumes these strings are null-terminated)
                            for (mp_uint_t j = s_len; j <= match_len && j <= d_len; ++j) {
                                if (match_str[j] != d_str[j]) {
                                    match_len = j;
                                    break;
                                }
                            }
                        }
                        ++n_found;
                    }
                }
            }

            // nothing found
            if (n_found == 0) {
                // If there're no better alternatives, and if it's first word
                // in the line, try to complete "import".
                if (s_start == org_str) {
                    static const char import_str[] = "import ";
                    if (memcmp(s_start, import_str, s_len) == 0) {
                        *compl_str = import_str + s_len;
                        return sizeof(import_str) - 1 - s_len;
                    }
                }

                return 0;
            }

            // 1 match found, or multiple matches with a common prefix
            if (n_found == 1 || match_len > s_len) {
                *compl_str = match_str + s_len;
                return match_len - s_len;
            }

            // multiple matches found, print them out

            #define WORD_SLOT_LEN (16)
            #define MAX_LINE_LEN  (4 * WORD_SLOT_LEN)

            int line_len = MAX_LINE_LEN; // force a newline for first word
            for (mp_uint_t i = 0; i < dict->map.alloc; i++) {
                if (MP_MAP_SLOT_IS_FILLED(&dict->map, i)) {
                    mp_uint_t d_len;
                    const char *d_str = micropy_obj_str_get_data(mp_state, dict->map.table[i].key, &d_len);
                    if (s_len <= d_len && strncmp(s_start, d_str, s_len) == 0) {
                        int gap = (line_len + WORD_SLOT_LEN - 1) / WORD_SLOT_LEN * WORD_SLOT_LEN - line_len;
                        if (gap < 2) {
                            gap += WORD_SLOT_LEN;
                        }
                        if (line_len + gap + d_len <= MAX_LINE_LEN) {
                            // TODO optimise printing of gap?
                            for (int j = 0; j < gap; ++j) {
                                micropy_print_str(mp_state, print, " ");
                            }
                            micropy_print_str(mp_state, print, d_str);
                            line_len += gap + d_len;
                        } else {
                            micropy_printf(mp_state, print, "\n%s", d_str);
                            line_len = d_len;
                        }
                    }
                }
            }
            micropy_print_str(mp_state, print, "\n");

            return (mp_uint_t)(-1); // indicate many matches
        }
    }
}

#endif // MICROPY_HELPER_REPL
/*
 * This file is part of the Micro Python project, http://micropython.org/
 *
 * The MIT License (MIT)
 *
 * Copyright (c) 2013, 2014 Damien P. George
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

//#include "py/smallint.h"

bool micropy_small_int_mul_overflow(struct _mp_state_ctx_t *mp_state, mp_int_t x, mp_int_t y) {
    // Check for multiply overflow; see CERT INT32-C
    if (x > 0) { // x is positive
        if (y > 0) { // x and y are positive
            if (x > (MP_SMALL_INT_MAX / y)) {
                return true;
            }
        } else { // x positive, y nonpositive
            if (y < (MP_SMALL_INT_MIN / x)) {
                return true;
            }
        } // x positive, y nonpositive
    } else { // x is nonpositive
        if (y > 0) { // x is nonpositive, y is positive
            if (x < (MP_SMALL_INT_MIN / y)) {
                return true;
            }
        } else { // x and y are nonpositive
            if (x != 0 && y < (MP_SMALL_INT_MAX / x)) {
                return true;
            }
        } // End if x and y are nonpositive
    } // End if x is nonpositive
    return false;
}

mp_int_t micropy_small_int_modulo(struct _mp_state_ctx_t *mp_state, mp_int_t dividend, mp_int_t divisor) {
    // Python specs require that mod has same sign as second operand
    dividend %= divisor;
    if ((dividend < 0 && divisor > 0) || (dividend > 0 && divisor < 0)) {
        dividend += divisor;
    }
    return dividend;
}

mp_int_t micropy_small_int_floor_divide(struct _mp_state_ctx_t *mp_state, mp_int_t num, mp_int_t denom) {
    if (num >= 0) {
        if (denom < 0) {
            num += -denom - 1;
        }
    } else {
        if (denom >= 0) {
            num += -denom + 1;
        }
    }
    return num / denom;
}
/*
 * This file is part of the Micro Python project, http://micropython.org/
 *
 * The MIT License (MIT)
 *
 * Copyright (c) 2015 Paul Sokolovsky
 * Copyright (c) 2016 Damien P. George
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

#include <string.h>
#include <stdint.h>

//#include "py/lexer.h"
//#include "py/frozenmod.h"

#if MICROPY_MODULE_FROZEN_STR

#ifndef MICROPY_MODULE_FROZEN_LEXER
#define MICROPY_MODULE_FROZEN_LEXER mp_lexer_new_from_str_len
#else
mp_lexer_t *micropy_MICROPY_MODULE_FROZEN_LEXER(struct _mp_state_ctx_t *mp_state, qstr src_name, const char *str, mp_uint_t len, mp_uint_t free_len);
#endif

extern const char mp_frozen_str_names[];
extern const uint32_t mp_frozen_str_sizes[];
extern const char mp_frozen_str_content[];

STATIC mp_lexer_t *micropy_find_frozen_str(struct _mp_state_ctx_t *mp_state, const char *str, size_t len) {
    const char *name = mp_frozen_str_names;

    size_t offset = 0;
    for (int i = 0; *name != 0; i++) {
        size_t l = strlen(name);
        if (l == len && !memcmp(str, name, l)) {
            qstr source = micropy_qstr_from_strn(mp_state, name, l);
            mp_lexer_t *lex = MICROPY_MODULE_FROZEN_LEXER(source, mp_frozen_str_content + offset, mp_frozen_str_sizes[i], 0);
            return lex;
        }
        name += l + 1;
        offset += mp_frozen_str_sizes[i] + 1;
    }
    return NULL;
}

#endif

#if MICROPY_MODULE_FROZEN_MPY

//#include "py/emitglue.h"

extern const char mp_frozen_mpy_names[];
extern const mp_raw_code_t *const mp_frozen_mpy_content[];

STATIC const mp_raw_code_t *micropy_find_frozen_mpy(struct _mp_state_ctx_t *mp_state, const char *str, size_t len) {
    const char *name = mp_frozen_mpy_names;
    for (size_t i = 0; *name != 0; i++) {
        size_t l = strlen(name);
        if (l == len && !memcmp(str, name, l)) {
            return mp_frozen_mpy_content[i];
        }
        name += l + 1;
    }
    return NULL;
}

#endif

#if MICROPY_MODULE_FROZEN

STATIC mp_import_stat_t micropy_frozen_stat_helper(struct _mp_state_ctx_t *mp_state, const char *name, const char *str) {
    size_t len = strlen(str);

    for (int i = 0; *name != 0; i++) {
        size_t l = strlen(name);
        if (l >= len && !memcmp(str, name, len)) {
            if (name[len] == 0) {
                return MP_IMPORT_STAT_FILE;
            } else if (name[len] == '/') {
                return MP_IMPORT_STAT_DIR;
            }
        }
        name += l + 1;
    }
    return MP_IMPORT_STAT_NO_EXIST;
}

mp_import_stat_t micropy_frozen_stat(struct _mp_state_ctx_t *mp_state, const char *str) {
    mp_import_stat_t stat;

    #if MICROPY_MODULE_FROZEN_STR
    stat = micropy_frozen_stat_helper(mp_state, mp_frozen_str_names, str);
    if (stat != MP_IMPORT_STAT_NO_EXIST) {
        return stat;
    }
    #endif

    #if MICROPY_MODULE_FROZEN_MPY
    stat = micropy_frozen_stat_helper(mp_state, mp_frozen_mpy_names, str);
    if (stat != MP_IMPORT_STAT_NO_EXIST) {
        return stat;
    }
    #endif

    return MP_IMPORT_STAT_NO_EXIST;
}

int micropy_find_frozen_module(struct _mp_state_ctx_t *mp_state, const char *str, size_t len, void **data) {
    #if MICROPY_MODULE_FROZEN_STR
    mp_lexer_t *lex = micropy_find_frozen_str(mp_state, str, len);
    if (lex != NULL) {
        *data = lex;
        return MP_FROZEN_STR;
    }
    #endif
    #if MICROPY_MODULE_FROZEN_MPY
    const mp_raw_code_t *rc = micropy_find_frozen_mpy(mp_state, str, len);
    if (rc != NULL) {
        *data = (void*)rc;
        return MP_FROZEN_MPY;
    }
    #endif
    return MP_FROZEN_NONE;
}

#endif
/*
 * This file is part of the Micro Python project, http://micropython.org/
 *
 * The MIT License (MIT)
 *
 * Copyright (c) 2014 Paul Sokolovsky
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

#include <assert.h>
#include <string.h>
#include <stdint.h>

//#include "py/nlr.h"
//#include "py/runtime.h"
//#include "py/objtuple.h"
//#include "py/binary.h"

#if MICROPY_PY_UCTYPES

/// \module uctypes - Access data structures in memory
///
/// The module allows to define layout of raw data structure (using terms
/// of C language), and then access memory buffers using this definition.
/// The module also provides convenience functions to access memory buffers
/// contained in Python objects or wrap memory buffers in Python objects.
/// \constant UINT8_1 - uint8_t value type

/// \class struct - C-like structure
///
/// Encapsulalation of in-memory data structure. This class doesn't define
/// any methods, only attribute access (for structure fields) and
/// indexing (for pointer and array fields).
///
/// Usage:
///
///     # Define layout of a structure with 2 fields
///     # 0 and 4 are byte offsets of fields from the beginning of struct
///     # they are logically ORed with field type
///     FOO_STRUCT = {"a": 0 | uctypes.UINT32, "b": 4 | uctypes.UINT8}
///
///     # Example memory buffer to access (contained in bytes object)
///     buf = b"\x64\0\0\0\0x14"
///
///     # Create structure object referring to address of
///     # the data in the buffer above
///     s = uctypes.struct(FOO_STRUCT, uctypes.addressof(buf))
///
///     # Access fields
///     print(s.a, s.b)
///     # Result:
///     # 100, 20

#define LAYOUT_LITTLE_ENDIAN (0)
#define LAYOUT_BIG_ENDIAN    (1)
#define LAYOUT_NATIVE        (2)

#define VAL_TYPE_BITS 4
#define BITF_LEN_BITS 5
#define BITF_OFF_BITS 5
#define OFFSET_BITS 17
#if VAL_TYPE_BITS + BITF_LEN_BITS + BITF_OFF_BITS + OFFSET_BITS != 31
#error Invalid encoding field length
#endif

enum {
    UINT8, INT8, UINT16, INT16,
    UINT32, INT32, UINT64, INT64,

    BFUINT8, BFINT8, BFUINT16, BFINT16,
    BFUINT32, BFINT32,

    FLOAT32, FLOAT64,
};

#define AGG_TYPE_BITS 2

enum {
    STRUCT, PTR, ARRAY, BITFIELD,
};

// Here we need to set sign bit right
#define TYPE2SMALLINT(x, nbits) ((((int)x) << (32 - nbits)) >> 1)
#define GET_TYPE(x, nbits) (((x) >> (31 - nbits)) & ((1 << nbits) - 1))
// Bit 0 is "is_signed"
#define GET_SCALAR_SIZE(val_type) (1 << ((val_type) >> 1))
#define VALUE_MASK(type_nbits) ~((int)0x80000000 >> type_nbits)

#define IS_SCALAR_ARRAY(tuple_desc) ((tuple_desc)->len == 2)
// We cannot apply the below to INT8, as their range [-128, 127]
#define IS_SCALAR_ARRAY_OF_BYTES(tuple_desc) (GET_TYPE(MP_OBJ_SMALL_INT_VALUE((tuple_desc)->items[1]), VAL_TYPE_BITS) == UINT8)

// "struct" in uctypes context means "structural", i.e. aggregate, type.
STATIC const mp_obj_type_t uctypes_struct_type;

typedef struct _mp_obj_uctypes_struct_t {
    mp_obj_base_t base;
    mp_obj_t desc;
    byte *addr;
    uint32_t flags;
} mp_obj_uctypes_struct_t;

STATIC NORETURN void micropy_syntax_error(struct _mp_state_ctx_t *mp_state) {
    micropy_nlr_raise(mp_state, micropy_obj_new_exception_msg(mp_state, &mp_type_TypeError, "syntax error in uctypes descriptor"));
}

STATIC mp_obj_t micropy_uctypes_struct_make_new(struct _mp_state_ctx_t *mp_state, const mp_obj_type_t *type, size_t n_args, size_t n_kw, const mp_obj_t *args) {
    micropy_arg_check_num(mp_state, n_args, n_kw, 2, 3, false);
    mp_obj_uctypes_struct_t *o = micropy_m_new_obj(mp_state, mp_obj_uctypes_struct_t);
    o->base.type = type;
    o->addr = (void*)(uintptr_t)micropy_obj_get_int(mp_state, args[0]);
    o->desc = args[1];
    o->flags = LAYOUT_NATIVE;
    if (n_args == 3) {
        o->flags = micropy_obj_get_int(mp_state, args[2]);
    }
    return MP_OBJ_FROM_PTR(o);
}

STATIC void micropy_uctypes_struct_print(struct _mp_state_ctx_t *mp_state, const mp_print_t *print, mp_obj_t self_in, mp_print_kind_t kind) {
    (void)kind;
    mp_obj_uctypes_struct_t *self = MP_OBJ_TO_PTR(self_in);
    const char *typen = "unk";
    if (MP_OBJ_IS_TYPE(self->desc, &mp_type_dict)) {
        typen = "STRUCT";
    } else if (MP_OBJ_IS_TYPE(self->desc, &mp_type_tuple)) {
        mp_obj_tuple_t *t = MP_OBJ_TO_PTR(self->desc);
        mp_int_t offset = MP_OBJ_SMALL_INT_VALUE(t->items[0]);
        uint agg_type = GET_TYPE(offset, AGG_TYPE_BITS);
        switch (agg_type) {
            case PTR: typen = "PTR"; break;
            case ARRAY: typen = "ARRAY"; break;
        }
    } else {
        typen = "ERROR";
    }
    micropy_printf(mp_state, print, "<struct %s %p>", typen, self->addr);
}

// Get size of any type descriptor
STATIC mp_uint_t micropy_uctypes_struct_size(struct _mp_state_ctx_t *mp_state, mp_obj_t desc_in, int layout_type, mp_uint_t *max_field_size);

// Get size of scalar type descriptor
static inline mp_uint_t micropy_uctypes_struct_scalar_size(struct _mp_state_ctx_t *mp_state, int val_type) {
    if (val_type == FLOAT32) {
        return 4;
    } else {
        return GET_SCALAR_SIZE(val_type & 7);
    }
}

// Get size of aggregate type descriptor
STATIC mp_uint_t micropy_uctypes_struct_agg_size(struct _mp_state_ctx_t *mp_state, mp_obj_tuple_t *t, int layout_type, mp_uint_t *max_field_size) {
    mp_uint_t total_size = 0;

    mp_int_t offset_ = MP_OBJ_SMALL_INT_VALUE(t->items[0]);
    mp_uint_t agg_type = GET_TYPE(offset_, AGG_TYPE_BITS);

    switch (agg_type) {
        case STRUCT:
            return micropy_uctypes_struct_size(mp_state, t->items[1], layout_type, max_field_size);
        case PTR:
            if (sizeof(void*) > *max_field_size) {
                *max_field_size = sizeof(void*);
            }
            return sizeof(void*);
        case ARRAY: {
            mp_int_t arr_sz = MP_OBJ_SMALL_INT_VALUE(t->items[1]);
            uint val_type = GET_TYPE(arr_sz, VAL_TYPE_BITS);
            arr_sz &= VALUE_MASK(VAL_TYPE_BITS);
            mp_uint_t item_s;
            if (t->len == 2) {
                // Elements of array are scalar
                item_s = GET_SCALAR_SIZE(val_type);
                if (item_s > *max_field_size) {
                    *max_field_size = item_s;
                }
            } else {
                // Elements of array are aggregates
                item_s = micropy_uctypes_struct_size(mp_state, t->items[2], layout_type, max_field_size);
            }

            return item_s * arr_sz;
        }
        default:
            assert(0);
    }

    return total_size;
}

STATIC mp_uint_t micropy_uctypes_struct_size(struct _mp_state_ctx_t *mp_state, mp_obj_t desc_in, int layout_type, mp_uint_t *max_field_size) {
    if (!MP_OBJ_IS_TYPE(desc_in, &mp_type_dict)) {
        if (MP_OBJ_IS_TYPE(desc_in, &mp_type_tuple)) {
            return micropy_uctypes_struct_agg_size(mp_state, (mp_obj_tuple_t*)MP_OBJ_TO_PTR(desc_in), layout_type, max_field_size);
        } else if (MP_OBJ_IS_SMALL_INT(desc_in)) {
            // We allow sizeof on both type definitions and structures/structure fields,
            // but scalar structure field is lowered into native Python int, so all
            // type info is lost. So, we cannot say if it's scalar type description,
            // or such lowered scalar.
            micropy_nlr_raise(mp_state, micropy_obj_new_exception_msg(mp_state, &mp_type_TypeError, "Cannot unambiguously get sizeof scalar"));
        }
        micropy_syntax_error(mp_state);
    }

    mp_obj_dict_t *d = MP_OBJ_TO_PTR(desc_in);
    mp_uint_t total_size = 0;

    for (mp_uint_t i = 0; i < d->map.alloc; i++) {
        if (MP_MAP_SLOT_IS_FILLED(&d->map, i)) {
            mp_obj_t v = d->map.table[i].value;
            if (MP_OBJ_IS_SMALL_INT(v)) {
                mp_uint_t offset = MP_OBJ_SMALL_INT_VALUE(v);
                mp_uint_t val_type = GET_TYPE(offset, VAL_TYPE_BITS);
                offset &= VALUE_MASK(VAL_TYPE_BITS);
                if (val_type >= BFUINT8 && val_type <= BFINT32) {
                    offset &= (1 << OFFSET_BITS) - 1;
                }
                mp_uint_t s = micropy_uctypes_struct_scalar_size(mp_state, val_type);
                if (s > *max_field_size) {
                    *max_field_size = s;
                }
                if (offset + s > total_size) {
                    total_size = offset + s;
                }
            } else {
                if (!MP_OBJ_IS_TYPE(v, &mp_type_tuple)) {
                    micropy_syntax_error(mp_state);
                }
                mp_obj_tuple_t *t = MP_OBJ_TO_PTR(v);
                mp_int_t offset = MP_OBJ_SMALL_INT_VALUE(t->items[0]);
                offset &= VALUE_MASK(AGG_TYPE_BITS);
                mp_uint_t s = micropy_uctypes_struct_agg_size(mp_state, t, layout_type, max_field_size);
                if (offset + s > total_size) {
                    total_size = offset + s;
                }
            }
        }
    }

    // Round size up to alignment of biggest field
    if (layout_type == LAYOUT_NATIVE) {
        total_size = (total_size + *max_field_size - 1) & ~(*max_field_size - 1);
    }
    return total_size;
}

STATIC mp_obj_t micropy_uctypes_struct_sizeof(struct _mp_state_ctx_t *mp_state, mp_obj_t obj_in) {
    mp_uint_t max_field_size = 0;
    if (MP_OBJ_IS_TYPE(obj_in, &mp_type_bytearray)) {
        return micropy_obj_len(mp_state, obj_in);
    }
    int layout_type = LAYOUT_NATIVE;
    // We can apply sizeof either to structure definition (a dict)
    // or to instantiated structure
    if (MP_OBJ_IS_TYPE(obj_in, &uctypes_struct_type)) {
        // Extract structure definition
        mp_obj_uctypes_struct_t *obj = MP_OBJ_TO_PTR(obj_in);
        obj_in = obj->desc;
        layout_type = obj->flags;
    }
    mp_uint_t size = micropy_uctypes_struct_size(mp_state, obj_in, layout_type, &max_field_size);
    return MP_OBJ_NEW_SMALL_INT(size);
}
STATIC MP_DEFINE_CONST_FUN_OBJ_1(uctypes_struct_sizeof_obj, micropy_uctypes_struct_sizeof);

STATIC inline mp_obj_t micropy_get_unaligned(struct _mp_state_ctx_t *mp_state, uint val_type, byte *p, int big_endian) {
    char struct_type = big_endian ? '>' : '<';
    static const char type2char[16] = "BbHhIiQq------fd";
    return micropy_binary_get_val(mp_state, struct_type, type2char[val_type], &p);
}

STATIC inline void micropy_set_unaligned(struct _mp_state_ctx_t *mp_state, uint val_type, byte *p, int big_endian, mp_obj_t val) {
    char struct_type = big_endian ? '>' : '<';
    static const char type2char[16] = "BbHhIiQq------fd";
    micropy_binary_set_val(mp_state, struct_type, type2char[val_type], val, &p);
}

static inline mp_uint_t micropy_get_aligned_basic(struct _mp_state_ctx_t *mp_state, uint val_type, void *p) {
    switch (val_type) {
        case UINT8:
            return *(uint8_t*)p;
        case UINT16:
            return *(uint16_t*)p;
        case UINT32:
            return *(uint32_t*)p;
    }
    assert(0);
    return 0;
}

static inline void micropy_set_aligned_basic(struct _mp_state_ctx_t *mp_state, uint val_type, void *p, mp_uint_t v) {
    switch (val_type) {
        case UINT8:
            *(uint8_t*)p = (uint8_t)v; return;
        case UINT16:
            *(uint16_t*)p = (uint16_t)v; return;
        case UINT32:
            *(uint32_t*)p = (uint32_t)v; return;
    }
    assert(0);
}

STATIC mp_obj_t micropy_get_aligned(struct _mp_state_ctx_t *mp_state, uint val_type, void *p, mp_int_t index) {
    switch (val_type) {
        case UINT8:
            return MP_OBJ_NEW_SMALL_INT(((uint8_t*)p)[index]);
        case INT8:
            return MP_OBJ_NEW_SMALL_INT(((int8_t*)p)[index]);
        case UINT16:
            return MP_OBJ_NEW_SMALL_INT(((uint16_t*)p)[index]);
        case INT16:
            return MP_OBJ_NEW_SMALL_INT(((int16_t*)p)[index]);
        case UINT32:
            return micropy_obj_new_int_from_uint(mp_state, ((uint32_t*)p)[index]);
        case INT32:
            return micropy_obj_new_int(mp_state, ((int32_t*)p)[index]);
        case UINT64:
            return micropy_obj_new_int_from_ull(mp_state, ((uint64_t*)p)[index]);
        case INT64:
            return micropy_obj_new_int_from_ll(mp_state, ((int64_t*)p)[index]);
        #if MICROPY_PY_BUILTINS_FLOAT
        case FLOAT32:
            return micropy_obj_new_float(mp_state, ((float*)p)[index]);
        case FLOAT64:
            return micropy_obj_new_float(mp_state, ((double*)p)[index]);
        #endif
        default:
            assert(0);
            return MP_OBJ_NULL;
    }
}

STATIC void micropy_set_aligned(struct _mp_state_ctx_t *mp_state, uint val_type, void *p, mp_int_t index, mp_obj_t val) {
    #if MICROPY_PY_BUILTINS_FLOAT
    if (val_type == FLOAT32 || val_type == FLOAT64) {
        mp_float_t v = micropy_obj_get_float(mp_state, val);
        if (val_type == FLOAT32) {
            ((float*)p)[index] = v;
        } else {
            ((double*)p)[index] = v;
        }
        return;
    }
    #endif
    mp_int_t v = micropy_obj_get_int(mp_state, val);
    switch (val_type) {
        case UINT8:
            ((uint8_t*)p)[index] = (uint8_t)v; return;
        case INT8:
            ((int8_t*)p)[index] = (int8_t)v; return;
        case UINT16:
            ((uint16_t*)p)[index] = (uint16_t)v; return;
        case INT16:
            ((int16_t*)p)[index] = (int16_t)v; return;
        case UINT32:
            ((uint32_t*)p)[index] = (uint32_t)v; return;
        case INT32:
            ((int32_t*)p)[index] = (int32_t)v; return;
        case INT64:
        case UINT64:
            if (sizeof(mp_int_t) == 8) {
                ((uint64_t*)p)[index] = (uint64_t)v;
            } else {
                // TODO: Doesn't offer atomic store semantics, but should at least try
                micropy_set_unaligned(mp_state, val_type, p, MP_ENDIANNESS_BIG, val);
            }
            return;
        default:
            assert(0);
    }
}

STATIC mp_obj_t micropy_uctypes_struct_attr_op(struct _mp_state_ctx_t *mp_state, mp_obj_t self_in, qstr attr, mp_obj_t set_val) {
    mp_obj_uctypes_struct_t *self = MP_OBJ_TO_PTR(self_in);

    // TODO: Support at least OrderedDict in addition
    if (!MP_OBJ_IS_TYPE(self->desc, &mp_type_dict)) {
            micropy_nlr_raise(mp_state, micropy_obj_new_exception_msg(mp_state, &mp_type_TypeError, "struct: no fields"));
    }

    mp_obj_t deref = micropy_obj_dict_get(mp_state, self->desc, MP_OBJ_NEW_QSTR(attr));
    if (MP_OBJ_IS_SMALL_INT(deref)) {
        mp_int_t offset = MP_OBJ_SMALL_INT_VALUE(deref);
        mp_uint_t val_type = GET_TYPE(offset, VAL_TYPE_BITS);
        offset &= VALUE_MASK(VAL_TYPE_BITS);
//printf("scalar type=%d offset=%x\n", val_type, offset);

        if (val_type <= INT64 || val_type == FLOAT32 || val_type == FLOAT64) {
//            printf("size=%d\n", GET_SCALAR_SIZE(val_type));
            if (self->flags == LAYOUT_NATIVE) {
                if (set_val == MP_OBJ_NULL) {
                    return micropy_get_aligned(mp_state, val_type, self->addr + offset, 0);
                } else {
                    micropy_set_aligned(mp_state, val_type, self->addr + offset, 0, set_val);
                    return set_val; // just !MP_OBJ_NULL
                }
            } else {
                if (set_val == MP_OBJ_NULL) {
                    return micropy_get_unaligned(mp_state, val_type, self->addr + offset, self->flags);
                } else {
                    micropy_set_unaligned(mp_state, val_type, self->addr + offset, self->flags, set_val);
                    return set_val; // just !MP_OBJ_NULL
                }
            }
        } else if (val_type >= BFUINT8 && val_type <= BFINT32) {
            uint bit_offset = (offset >> 17) & 31;
            uint bit_len = (offset >> 22) & 31;
            offset &= (1 << 17) - 1;
            mp_uint_t val;
            if (self->flags == LAYOUT_NATIVE) {
                val = micropy_get_aligned_basic(mp_state, val_type & 6, self->addr + offset);
            } else {
                val = micropy_binary_get_int(mp_state, GET_SCALAR_SIZE(val_type & 7), val_type & 1, self->flags, self->addr + offset);
            }
            if (set_val == MP_OBJ_NULL) {
                val >>= bit_offset;
                val &= (1 << bit_len) - 1;
                // TODO: signed
                assert((val_type & 1) == 0);
                return micropy_obj_new_int(mp_state, val);
            } else {
                mp_uint_t set_val_int = (mp_uint_t)micropy_obj_get_int(mp_state, set_val);
                mp_uint_t mask = (1 << bit_len) - 1;
                set_val_int &= mask;
                set_val_int <<= bit_offset;
                mask <<= bit_offset;
                val = (val & ~mask) | set_val_int;

                if (self->flags == LAYOUT_NATIVE) {
                    micropy_set_aligned_basic(mp_state, val_type & 6, self->addr + offset, val);
                } else {
                    micropy_binary_set_int(mp_state, GET_SCALAR_SIZE(val_type & 7), self->flags == LAYOUT_BIG_ENDIAN,
                        self->addr + offset, val);
                }
                return set_val; // just !MP_OBJ_NULL
            }
        }

        assert(0);
        return MP_OBJ_NULL;
    }

    if (!MP_OBJ_IS_TYPE(deref, &mp_type_tuple)) {
        micropy_syntax_error(mp_state);
    }

    if (set_val != MP_OBJ_NULL) {
        // Cannot assign to aggregate
        micropy_syntax_error(mp_state);
    }

    mp_obj_tuple_t *sub = MP_OBJ_TO_PTR(deref);
    mp_int_t offset = MP_OBJ_SMALL_INT_VALUE(sub->items[0]);
    mp_uint_t agg_type = GET_TYPE(offset, AGG_TYPE_BITS);
    offset &= VALUE_MASK(AGG_TYPE_BITS);
//printf("agg type=%d offset=%x\n", agg_type, offset);

    switch (agg_type) {
        case STRUCT: {
            mp_obj_uctypes_struct_t *o = micropy_m_new_obj(mp_state, mp_obj_uctypes_struct_t);
            o->base.type = &uctypes_struct_type;
            o->desc = sub->items[1];
            o->addr = self->addr + offset;
            o->flags = self->flags;
            return MP_OBJ_FROM_PTR(o);
        }
        case ARRAY: {
            mp_uint_t dummy;
            if (IS_SCALAR_ARRAY(sub) && IS_SCALAR_ARRAY_OF_BYTES(sub)) {
                return micropy_obj_new_bytearray_by_ref(mp_state, micropy_uctypes_struct_agg_size(mp_state, sub, self->flags, &dummy), self->addr + offset);
            }
            // Fall thru to return uctypes struct object
        }
        case PTR: {
            mp_obj_uctypes_struct_t *o = micropy_m_new_obj(mp_state, mp_obj_uctypes_struct_t);
            o->base.type = &uctypes_struct_type;
            o->desc = MP_OBJ_FROM_PTR(sub);
            o->addr = self->addr + offset;
            o->flags = self->flags;
//printf("PTR/ARR base addr=%p\n", o->addr);
            return MP_OBJ_FROM_PTR(o);
        }
    }

    // Should be unreachable once all cases are handled
    return MP_OBJ_NULL;
}

STATIC void micropy_uctypes_struct_attr(struct _mp_state_ctx_t *mp_state, mp_obj_t self_in, qstr attr, mp_obj_t *dest) {
    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        mp_obj_t val = micropy_uctypes_struct_attr_op(mp_state, self_in, attr, MP_OBJ_NULL);
        dest[0] = val;
    } else {
        // delete/store attribute
        if (micropy_uctypes_struct_attr_op(mp_state, self_in, attr, dest[1]) != MP_OBJ_NULL) {
            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC mp_obj_t micropy_uctypes_struct_subscr(struct _mp_state_ctx_t *mp_state, mp_obj_t self_in, mp_obj_t index_in, mp_obj_t value) {
    mp_obj_uctypes_struct_t *self = MP_OBJ_TO_PTR(self_in);

    if (value == MP_OBJ_NULL) {
        // delete
        return MP_OBJ_NULL; // op not supported
    } else {
        // load / store
        if (!MP_OBJ_IS_TYPE(self->desc, &mp_type_tuple)) {
            micropy_nlr_raise(mp_state, micropy_obj_new_exception_msg(mp_state, &mp_type_TypeError, "struct: cannot index"));
        }

        mp_obj_tuple_t *t = MP_OBJ_TO_PTR(self->desc);
        mp_int_t offset = MP_OBJ_SMALL_INT_VALUE(t->items[0]);
        uint agg_type = GET_TYPE(offset, AGG_TYPE_BITS);

        mp_int_t index = MP_OBJ_SMALL_INT_VALUE(index_in);

        if (agg_type == ARRAY) {
            mp_int_t arr_sz = MP_OBJ_SMALL_INT_VALUE(t->items[1]);
            uint val_type = GET_TYPE(arr_sz, VAL_TYPE_BITS);
            arr_sz &= VALUE_MASK(VAL_TYPE_BITS);
            if (index >= arr_sz) {
                micropy_nlr_raise(mp_state, micropy_obj_new_exception_msg(mp_state, &mp_type_IndexError, "struct: index out of range"));
            }

            if (t->len == 2) {
                // array of scalars
                if (self->flags == LAYOUT_NATIVE) {
                    if (value == MP_OBJ_SENTINEL) {
                        return micropy_get_aligned(mp_state, val_type, self->addr, index);
                    } else {
                        micropy_set_aligned(mp_state, val_type, self->addr, index, value);
                        return value; // just !MP_OBJ_NULL
                    }
                } else {
                    byte *p = self->addr + GET_SCALAR_SIZE(val_type) * index;
                    if (value == MP_OBJ_SENTINEL) {
                        return micropy_get_unaligned(mp_state, val_type, p, self->flags);
                    } else {
                        micropy_set_unaligned(mp_state, val_type, p, self->flags, value);
                        return value; // just !MP_OBJ_NULL
                    }
                }
            } else if (value == MP_OBJ_SENTINEL) {
                mp_uint_t dummy = 0;
                mp_uint_t size = micropy_uctypes_struct_size(mp_state, t->items[2], self->flags, &dummy);
                mp_obj_uctypes_struct_t *o = micropy_m_new_obj(mp_state, mp_obj_uctypes_struct_t);
                o->base.type = &uctypes_struct_type;
                o->desc = t->items[2];
                o->addr = self->addr + size * index;
                o->flags = self->flags;
                return MP_OBJ_FROM_PTR(o);
            } else {
                return MP_OBJ_NULL; // op not supported
            }

        } else if (agg_type == PTR) {
            byte *p = *(void**)self->addr;
            if (MP_OBJ_IS_SMALL_INT(t->items[1])) {
                uint val_type = GET_TYPE(MP_OBJ_SMALL_INT_VALUE(t->items[1]), VAL_TYPE_BITS);
                return micropy_get_aligned(mp_state, val_type, p, index);
            } else {
                mp_uint_t dummy = 0;
                mp_uint_t size = micropy_uctypes_struct_size(mp_state, t->items[1], self->flags, &dummy);
                mp_obj_uctypes_struct_t *o = micropy_m_new_obj(mp_state, mp_obj_uctypes_struct_t);
                o->base.type = &uctypes_struct_type;
                o->desc = t->items[1];
                o->addr = p + size * index;
                o->flags = self->flags;
                return MP_OBJ_FROM_PTR(o);
            }
        }

        assert(0);
        return MP_OBJ_NULL;
    }
}

STATIC mp_int_t micropy_uctypes_get_buffer(struct _mp_state_ctx_t *mp_state, mp_obj_t self_in, mp_buffer_info_t *bufinfo, mp_uint_t flags) {
    (void)flags;
    mp_obj_uctypes_struct_t *self = MP_OBJ_TO_PTR(self_in);
    mp_uint_t max_field_size = 0;
    mp_uint_t size = micropy_uctypes_struct_size(mp_state, self->desc, self->flags, &max_field_size);

    bufinfo->buf = self->addr;
    bufinfo->len = size;
    bufinfo->typecode = BYTEARRAY_TYPECODE;
    return 0;
}

/// \function addressof()
/// Return address of object's data (applies to object providing buffer
/// interface).
STATIC mp_obj_t micropy_uctypes_struct_addressof(struct _mp_state_ctx_t *mp_state, mp_obj_t buf) {
    mp_buffer_info_t bufinfo;
    micropy_get_buffer_raise(mp_state, buf, &bufinfo, MP_BUFFER_READ);
    return micropy_obj_new_int(mp_state, (mp_int_t)(uintptr_t)bufinfo.buf);
}
MP_DEFINE_CONST_FUN_OBJ_1(uctypes_struct_addressof_obj, micropy_uctypes_struct_addressof);

/// \function bytearray_at()
/// Capture memory at given address of given size as bytearray. Memory is
/// captured by reference (and thus memory pointed by bytearray may change
/// or become invalid at later time). Use bytes_at() to capture by value.
STATIC mp_obj_t micropy_uctypes_struct_bytearray_at(struct _mp_state_ctx_t *mp_state, mp_obj_t ptr, mp_obj_t size) {
    return micropy_obj_new_bytearray_by_ref(mp_state, micropy_obj_int_get_truncated(mp_state, size), (void*)(uintptr_t)micropy_obj_int_get_truncated(mp_state, ptr));
}
MP_DEFINE_CONST_FUN_OBJ_2(uctypes_struct_bytearray_at_obj, micropy_uctypes_struct_bytearray_at);

/// \function bytes_at()
/// Capture memory at given address of given size as bytes. Memory is
/// captured by value, i.e. copied. Use bytearray_at() to capture by reference
/// ("zero copy").
STATIC mp_obj_t micropy_uctypes_struct_bytes_at(struct _mp_state_ctx_t *mp_state, mp_obj_t ptr, mp_obj_t size) {
    return micropy_obj_new_bytes(mp_state, (void*)(uintptr_t)micropy_obj_int_get_truncated(mp_state, ptr), micropy_obj_int_get_truncated(mp_state, size));
}
MP_DEFINE_CONST_FUN_OBJ_2(uctypes_struct_bytes_at_obj, micropy_uctypes_struct_bytes_at);


STATIC const mp_obj_type_t uctypes_struct_type = {
    { &mp_type_type },
    .name = MP_QSTR_struct,
    .print = micropy_uctypes_struct_print,
    .make_new = micropy_uctypes_struct_make_new,
    .attr = micropy_uctypes_struct_attr,
    .subscr = micropy_uctypes_struct_subscr,
    .buffer_p = { .get_buffer = micropy_uctypes_get_buffer, },
};

STATIC const mp_rom_map_elem_t mp_module_uctypes_globals_table[] = {
    { MP_ROM_QSTR(MP_QSTR___name__), MP_ROM_QSTR(MP_QSTR_uctypes) },
    { MP_ROM_QSTR(MP_QSTR_struct), MP_ROM_PTR(&uctypes_struct_type) },
    { MP_ROM_QSTR(MP_QSTR_sizeof), MP_ROM_PTR(&uctypes_struct_sizeof_obj) },
    { MP_ROM_QSTR(MP_QSTR_addressof), MP_ROM_PTR(&uctypes_struct_addressof_obj) },
    { MP_ROM_QSTR(MP_QSTR_bytes_at), MP_ROM_PTR(&uctypes_struct_bytes_at_obj) },
    { MP_ROM_QSTR(MP_QSTR_bytearray_at), MP_ROM_PTR(&uctypes_struct_bytearray_at_obj) },

    /// \moduleref uctypes

    /// \constant NATIVE - Native structure layout - native endianness,
    /// platform-specific field alignment
    { MP_ROM_QSTR(MP_QSTR_NATIVE), MP_ROM_INT(LAYOUT_NATIVE) },
    /// \constant LITTLE_ENDIAN - Little-endian structure layout, tightly packed
    /// (no alignment constraints)
    { MP_ROM_QSTR(MP_QSTR_LITTLE_ENDIAN), MP_ROM_INT(LAYOUT_LITTLE_ENDIAN) },
    /// \constant BIG_ENDIAN - Big-endian structure layout, tightly packed
    /// (no alignment constraints)
    { MP_ROM_QSTR(MP_QSTR_BIG_ENDIAN), MP_ROM_INT(LAYOUT_BIG_ENDIAN) },

    /// \constant VOID - void value type, may be used only as pointer target type.
    { MP_ROM_QSTR(MP_QSTR_VOID), MP_ROM_INT(TYPE2SMALLINT(UINT8, VAL_TYPE_BITS)) },

    /// \constant UINT8 - uint8_t value type
    { MP_ROM_QSTR(MP_QSTR_UINT8), MP_ROM_INT(TYPE2SMALLINT(UINT8, 4)) },
    /// \constant INT8 - int8_t value type
    { MP_ROM_QSTR(MP_QSTR_INT8), MP_ROM_INT(TYPE2SMALLINT(INT8, 4)) },
    /// \constant UINT16 - uint16_t value type
    { MP_ROM_QSTR(MP_QSTR_UINT16), MP_ROM_INT(TYPE2SMALLINT(UINT16, 4)) },
    /// \constant INT16 - int16_t value type
    { MP_ROM_QSTR(MP_QSTR_INT16), MP_ROM_INT(TYPE2SMALLINT(INT16, 4)) },
    /// \constant UINT32 - uint32_t value type
    { MP_ROM_QSTR(MP_QSTR_UINT32), MP_ROM_INT(TYPE2SMALLINT(UINT32, 4)) },
    /// \constant INT32 - int32_t value type
    { MP_ROM_QSTR(MP_QSTR_INT32), MP_ROM_INT(TYPE2SMALLINT(INT32, 4)) },
    /// \constant UINT64 - uint64_t value type
    { MP_ROM_QSTR(MP_QSTR_UINT64), MP_ROM_INT(TYPE2SMALLINT(UINT64, 4)) },
    /// \constant INT64 - int64_t value type
    { MP_ROM_QSTR(MP_QSTR_INT64), MP_ROM_INT(TYPE2SMALLINT(INT64, 4)) },

    { MP_ROM_QSTR(MP_QSTR_BFUINT8), MP_ROM_INT(TYPE2SMALLINT(BFUINT8, 4)) },
    { MP_ROM_QSTR(MP_QSTR_BFINT8), MP_ROM_INT(TYPE2SMALLINT(BFINT8, 4)) },
    { MP_ROM_QSTR(MP_QSTR_BFUINT16), MP_ROM_INT(TYPE2SMALLINT(BFUINT16, 4)) },
    { MP_ROM_QSTR(MP_QSTR_BFINT16), MP_ROM_INT(TYPE2SMALLINT(BFINT16, 4)) },
    { MP_ROM_QSTR(MP_QSTR_BFUINT32), MP_ROM_INT(TYPE2SMALLINT(BFUINT32, 4)) },
    { MP_ROM_QSTR(MP_QSTR_BFINT32), MP_ROM_INT(TYPE2SMALLINT(BFINT32, 4)) },

    { MP_ROM_QSTR(MP_QSTR_BF_POS), MP_ROM_INT(17) },
    { MP_ROM_QSTR(MP_QSTR_BF_LEN), MP_ROM_INT(22) },

    #if MICROPY_PY_BUILTINS_FLOAT
    { MP_ROM_QSTR(MP_QSTR_FLOAT32), MP_ROM_INT(TYPE2SMALLINT(FLOAT32, 4)) },
    { MP_ROM_QSTR(MP_QSTR_FLOAT64), MP_ROM_INT(TYPE2SMALLINT(FLOAT64, 4)) },
    #endif

    { MP_ROM_QSTR(MP_QSTR_PTR), MP_ROM_INT(TYPE2SMALLINT(PTR, AGG_TYPE_BITS)) },
    { MP_ROM_QSTR(MP_QSTR_ARRAY), MP_ROM_INT(TYPE2SMALLINT(ARRAY, AGG_TYPE_BITS)) },
};

STATIC MP_DEFINE_CONST_DICT(mp_module_uctypes_globals, mp_module_uctypes_globals_table);

const mp_obj_module_t mp_module_uctypes = {
    .base = { &mp_type_module },
    .name = MP_QSTR_uctypes,
    .globals = (mp_obj_dict_t*)&mp_module_uctypes_globals,
};

#endif
/*
 * This file is part of the Micro Python project, http://micropython.org/
 *
 * The MIT License (MIT)
 *
 * Copyright (c) 2014 Damien P. George
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

#include <stdio.h>

//#include "py/nlr.h"
//#include "py/objlist.h"
//#include "py/parsenum.h"
//#include "py/runtime.h"

#if MICROPY_PY_UJSON

STATIC mp_obj_t micropy_mod_ujson_dumps(struct _mp_state_ctx_t *mp_state, mp_obj_t obj) {
    vstr_t vstr;
    mp_print_t print;
    micropy_vstr_init_print(mp_state, &vstr, 8, &print);
    micropy_obj_print_helper(mp_state, &print, obj, PRINT_JSON);
    return micropy_obj_new_str_from_vstr(mp_state, &mp_type_str, &vstr);
}
STATIC MP_DEFINE_CONST_FUN_OBJ_1(mod_ujson_dumps_obj, micropy_mod_ujson_dumps);

// This function implements a simple non-recursive JSON parser.
//
// The JSON specification is at http://www.ietf.org/rfc/rfc4627.txt
// The parser here will parse any valid JSON and return the correct
// corresponding Python object.  It allows through a superset of JSON, since
// it treats commas and colons as "whitespace", and doesn't care if
// brackets/braces are correctly paired.  It will raise a ValueError if the
// input is outside it's specs.
//
// Most of the work is parsing the primitives (null, false, true, numbers,
// strings).  It does 1 pass over the input string and so is easily extended to
// being able to parse from a non-seekable stream.  It tries to be fast and
// small in code size, while not using more RAM than necessary.
STATIC mp_obj_t micropy_mod_ujson_loads(struct _mp_state_ctx_t *mp_state, mp_obj_t obj) {
    mp_uint_t len;
    const char *s = micropy_obj_str_get_data(mp_state, obj, &len);
    const char *top = s + len;
    vstr_t vstr;
    micropy_vstr_init(mp_state, &vstr, 8);
    mp_obj_list_t stack; // we use a list as a simple stack for nested JSON
    stack.len = 0;
    stack.items = NULL;
    mp_obj_t stack_top = MP_OBJ_NULL;
    mp_obj_type_t *stack_top_type = NULL;
    mp_obj_t stack_key = MP_OBJ_NULL;
    for (;;) {
        cont:
        if (s == top) {
            break;
        }
        mp_obj_t next = MP_OBJ_NULL;
        bool enter = false;
        switch (*s) {
            case ',':
            case ':':
            case ' ':
            case '\t':
            case '\n':
            case '\r':
                s += 1;
                goto cont;
            case 'n':
                if (s + 3 < top && s[1] == 'u' && s[2] == 'l' && s[3] == 'l') {
                    s += 4;
                    next = mp_const_none;
                } else {
                    goto fail;
                }
                break;
            case 'f':
                if (s + 4 < top && s[1] == 'a' && s[2] == 'l' && s[3] == 's' && s[4] == 'e') {
                    s += 5;
                    next = mp_const_false;
                } else {
                    goto fail;
                }
                break;
            case 't':
                if (s + 3 < top && s[1] == 'r' && s[2] == 'u' && s[3] == 'e') {
                    s += 4;
                    next = mp_const_true;
                } else {
                    goto fail;
                }
                break;
            case '"':
                micropy_vstr_reset(mp_state, &vstr);
                for (s++; s < top && *s != '"';) {
                    byte c = *s;
                    if (c == '\\') {
                        s++;
                        c = *s;
                        switch (c) {
                            case 'b': c = 0x08; break;
                            case 'f': c = 0x0c; break;
                            case 'n': c = 0x0a; break;
                            case 'r': c = 0x0d; break;
                            case 't': c = 0x09; break;
                            case 'u': {
                                if (s + 4 >= top) { goto fail; }
                                mp_uint_t num = 0;
                                for (int i = 0; i < 4; i++) {
                                    c = (*++s | 0x20) - '0';
                                    if (c > 9) {
                                        c -= ('a' - ('9' + 1));
                                    }
                                    num = (num << 4) | c;
                                }
                                micropy_vstr_add_char(mp_state, &vstr, num);
                                goto str_cont;
                            }
                        }
                    }
                    micropy_vstr_add_byte(mp_state, &vstr, c);
                str_cont:
                    s++;
                }
                if (s == top) {
                    goto fail;
                }
                s++;
                next = micropy_obj_new_str(mp_state, vstr.buf, vstr.len, false);
                break;
            case '-':
            case '0': case '1': case '2': case '3': case '4': case '5': case '6': case '7': case '8': case '9': {
                bool flt = false;
                micropy_vstr_reset(mp_state, &vstr);
                for (; s < top; s++) {
                    if (*s == '.' || *s == 'E' || *s == 'e') {
                        flt = true;
                    } else if (*s == '-' || unichar_isdigit(*s)) {
                        // pass
                    } else {
                        break;
                    }
                    micropy_vstr_add_byte(mp_state, &vstr, *s);
                }
                if (flt) {
                    next = micropy_parse_num_decimal(mp_state, vstr.buf, vstr.len, false, false, NULL);
                } else {
                    next = micropy_parse_num_integer(mp_state, vstr.buf, vstr.len, 10, NULL);
                }
                break;
            }
            case '[':
                next = micropy_obj_new_list(mp_state, 0, NULL);
                enter = true;
                s += 1;
                break;
            case '{':
                next = micropy_obj_new_dict(mp_state, 0);
                enter = true;
                s += 1;
                break;
            case '}':
            case ']': {
                s += 1;
                if (stack_top == MP_OBJ_NULL) {
                    // no object at all
                    goto fail;
                }
                if (stack.len == 0) {
                    // finished; compound object
                    goto success;
                }
                stack.len -= 1;
                stack_top = stack.items[stack.len];
                stack_top_type = micropy_obj_get_type(mp_state, stack_top);
                goto cont;
            }
            default:
                goto fail;
        }
        if (stack_top == MP_OBJ_NULL) {
            stack_top = next;
            stack_top_type = micropy_obj_get_type(mp_state, stack_top);
            if (!enter) {
                // finished; single primitive only
                goto success;
            }
        } else {
            // append to list or dict
            if (stack_top_type == &mp_type_list) {
                micropy_obj_list_append(mp_state, stack_top, next);
            } else {
                if (stack_key == MP_OBJ_NULL) {
                    stack_key = next;
                    if (enter) {
                        goto fail;
                    }
                } else {
                    micropy_obj_dict_store(mp_state, stack_top, stack_key, next);
                    stack_key = MP_OBJ_NULL;
                }
            }
            if (enter) {
                if (stack.items == NULL) {
                    micropy_obj_list_init(mp_state, &stack, 1);
                    stack.items[0] = stack_top;
                } else {
                    micropy_obj_list_append(mp_state, MP_OBJ_FROM_PTR(&stack), stack_top);
                }
                stack_top = next;
                stack_top_type = micropy_obj_get_type(mp_state, stack_top);
            }
        }
    }
    success:
    // eat trailing whitespace
    while (s < top && unichar_isspace(*s)) {
        s++;
    }
    if (s < top) {
        // unexpected chars
        goto fail;
    }
    if (stack_top == MP_OBJ_NULL || stack.len != 0) {
        // not exactly 1 object
        goto fail;
    }
    micropy_vstr_clear(mp_state, &vstr);
    return stack_top;

    fail:
    micropy_nlr_raise(mp_state, micropy_obj_new_exception_msg(mp_state, &mp_type_ValueError, "syntax error in JSON"));
}
STATIC MP_DEFINE_CONST_FUN_OBJ_1(mod_ujson_loads_obj, micropy_mod_ujson_loads);

STATIC const mp_rom_map_elem_t mp_module_ujson_globals_table[] = {
    { MP_ROM_QSTR(MP_QSTR___name__), MP_ROM_QSTR(MP_QSTR_ujson) },
    { MP_ROM_QSTR(MP_QSTR_dumps), MP_ROM_PTR(&mod_ujson_dumps_obj) },
    { MP_ROM_QSTR(MP_QSTR_loads), MP_ROM_PTR(&mod_ujson_loads_obj) },
};

STATIC MP_DEFINE_CONST_DICT(mp_module_ujson_globals, mp_module_ujson_globals_table);

const mp_obj_module_t mp_module_ujson = {
    .base = { &mp_type_module },
    .name = MP_QSTR_ujson,
    .globals = (mp_obj_dict_t*)&mp_module_ujson_globals,
};

#endif //MICROPY_PY_UJSON
/*
 * This file is part of the Micro Python project, http://micropython.org/
 *
 * The MIT License (MIT)
 *
 * Copyright (c) 2014 Paul Sokolovsky
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

#include <stdio.h>
#include <assert.h>
#include <string.h>

//#include "py/nlr.h"
//#include "py/runtime.h"
//#include "py/binary.h"

#if MICROPY_PY_URE

// Copyright 2007-2009 Russ Cox.  All Rights Reserved.
// Copyright 2014 Paul Sokolovsky.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

#ifndef _RE1_5_REGEXP__H
#define _RE1_5_REGEXP__H


#define nil ((void*)0)
#define nelem(x) (sizeof(x)/sizeof((x)[0]))

typedef struct Regexp Regexp;
typedef struct Prog Prog;
typedef struct ByteProg ByteProg;
typedef struct Inst Inst;
typedef struct Subject Subject;

struct Regexp
{
	int type;
	int n;
	int ch;
	Regexp *left;
	Regexp *right;
};

enum	/* Regexp.type */
{
	Alt = 1,
	Cat,
	Lit,
	Dot,
	Paren,
	Quest,
	Star,
	Plus,
};

Regexp *parse(char*);
Regexp *reg(int type, Regexp *left, Regexp *right);
void printre(Regexp*);
#ifndef re1_5_fatal
void re1_5_fatal(char*);
#endif
void *mal(int);

struct Prog
{
	Inst *start;
	int len;
};

struct ByteProg
{
	int bytelen;
	int len;
	int sub;
	char insts[0];
};

struct Inst
{
	int opcode;
	int c;
	int n;
	Inst *x;
	Inst *y;
	int gen;	// global state, oooh!
};

enum	/* Inst.opcode */
{
	// Instructions which consume input bytes (and thus fail if none left)
	CONSUMERS = 1,
	Char = CONSUMERS,
	Any,
	Class,
	ClassNot,
	NamedClass,

	ASSERTS = 0x50,
	Bol = ASSERTS,
	Eol,

	// Instructions which take relative offset as arg
	JUMPS = 0x60,
	Jmp = JUMPS,
	Split,
	RSplit,

	// Other (special) instructions
	Save = 0x7e,
	Match = 0x7f,
};

#define inst_is_consumer(inst) ((inst) < ASSERTS)
#define inst_is_jump(inst) ((inst) & 0x70 == JUMPS)

Prog *compile(Regexp*);
void printprog(Prog*);

extern int gen;

enum {
	MAXSUB = 20
};

typedef struct Sub Sub;

struct Sub
{
	int ref;
	int nsub;
	const char *sub[MAXSUB];
};

Sub *newsub(int n);
Sub *incref(Sub*);
Sub *copy(Sub*);
Sub *update(Sub*, int, const char*);
void decref(Sub*);

struct Subject {
	const char *begin;
	const char *end;
};


#define NON_ANCHORED_PREFIX 5
#define HANDLE_ANCHORED(bytecode, is_anchored) ((is_anchored) ? (bytecode) + NON_ANCHORED_PREFIX : (bytecode))

int re1_5_backtrack(ByteProg*, Subject*, const char**, int, int);
int re1_5_pikevm(ByteProg*, Subject*, const char**, int, int);
int re1_5_recursiveloopprog(ByteProg*, Subject*, const char**, int, int);
int re1_5_recursiveprog(ByteProg*, Subject*, const char**, int, int);
int re1_5_thompsonvm(ByteProg*, Subject*, const char**, int, int);

int re1_5_sizecode(const char *re);
int re1_5_compilecode(ByteProg *prog, const char *re);
void re1_5_dumpcode(ByteProg *prog);
void cleanmarks(ByteProg *prog);
int _re1_5_classmatch(const char *pc, const char *sp);
int _re1_5_namedclassmatch(const char *pc, const char *sp);

#endif /*_RE1_5_REGEXP__H*/

#define FLAG_DEBUG 0x1000

typedef struct _mp_obj_re_t {
    mp_obj_base_t base;
    ByteProg re;
} mp_obj_re_t;

typedef struct _mp_obj_match_t {
    mp_obj_base_t base;
    int num_matches;
    mp_obj_t str;
    const char *caps[0];
} mp_obj_match_t;


STATIC void micropy_match_print(struct _mp_state_ctx_t *mp_state, const mp_print_t *print, mp_obj_t self_in, mp_print_kind_t kind) {
    (void)kind;
    mp_obj_match_t *self = MP_OBJ_TO_PTR(self_in);
    micropy_printf(mp_state, print, "<match num=%d>", self->num_matches);
}

STATIC mp_obj_t micropy_match_group(struct _mp_state_ctx_t *mp_state, mp_obj_t self_in, mp_obj_t no_in) {
    mp_obj_match_t *self = MP_OBJ_TO_PTR(self_in);
    mp_int_t no = micropy_obj_get_int(mp_state, no_in);
    if (no < 0 || no >= self->num_matches) {
        micropy_nlr_raise(mp_state, micropy_obj_new_exception_arg1(mp_state, &mp_type_IndexError, no_in));
    }

    const char *start = self->caps[no * 2];
    if (start == NULL) {
        // no match for this group
        return mp_const_none;
    }
    return micropy_obj_new_str(mp_state, start, self->caps[no * 2 + 1] - start, false);
}
MP_DEFINE_CONST_FUN_OBJ_2(match_group_obj, micropy_match_group);

STATIC const mp_rom_map_elem_t match_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_group), MP_ROM_PTR(&match_group_obj) },
};

STATIC MP_DEFINE_CONST_DICT(match_locals_dict, match_locals_dict_table);

STATIC const mp_obj_type_t match_type = {
    { &mp_type_type },
    .name = MP_QSTR_match,
    .print = micropy_match_print,
    .locals_dict = (void*)&match_locals_dict,
};

STATIC void micropy_re_print(struct _mp_state_ctx_t *mp_state, const mp_print_t *print, mp_obj_t self_in, mp_print_kind_t kind) {
    (void)kind;
    mp_obj_re_t *self = MP_OBJ_TO_PTR(self_in);
    micropy_printf(mp_state, print, "<re %p>", self);
}

STATIC mp_obj_t micropy_ure_exec(struct _mp_state_ctx_t *mp_state, bool is_anchored, uint n_args, const mp_obj_t *args) {
    (void)n_args;
    mp_obj_re_t *self = MP_OBJ_TO_PTR(args[0]);
    Subject subj;
    mp_uint_t len;
    subj.begin = micropy_obj_str_get_data(mp_state, args[1], &len);
    subj.end = subj.begin + len;
    int caps_num = (self->re.sub + 1) * 2;
    mp_obj_match_t *match = micropy_m_new_obj_var(mp_state, mp_obj_match_t, char*, caps_num);
    // cast is a workaround for a bug in msvc: it treats const char** as a const pointer instead of a pointer to pointer to const char
    memset((char*)match->caps, 0, caps_num * sizeof(char*));
    int res = re1_5_recursiveloopprog(&self->re, &subj, match->caps, caps_num, is_anchored);
    if (res == 0) {
        micropy_m_del_var(mp_state, mp_obj_match_t, char*, caps_num, match);
        return mp_const_none;
    }

    match->base.type = &match_type;
    match->num_matches = caps_num / 2; // caps_num counts start and end pointers
    match->str = args[1];
    return MP_OBJ_FROM_PTR(match);
}

STATIC mp_obj_t micropy_re_match(struct _mp_state_ctx_t *mp_state, size_t n_args, const mp_obj_t *args) {
    return micropy_ure_exec(mp_state, true, n_args, args);
}
MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(re_match_obj, 2, 4, micropy_re_match);

STATIC mp_obj_t micropy_re_search(struct _mp_state_ctx_t *mp_state, size_t n_args, const mp_obj_t *args) {
    return micropy_ure_exec(mp_state, false, n_args, args);
}
MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(re_search_obj, 2, 4, micropy_re_search);

STATIC mp_obj_t micropy_re_split(struct _mp_state_ctx_t *mp_state, size_t n_args, const mp_obj_t *args) {
    mp_obj_re_t *self = MP_OBJ_TO_PTR(args[0]);
    Subject subj;
    mp_uint_t len;
    subj.begin = micropy_obj_str_get_data(mp_state, args[1], &len);
    subj.end = subj.begin + len;
    int caps_num = (self->re.sub + 1) * 2;

    int maxsplit = 0;
    if (n_args > 2) {
        maxsplit = micropy_obj_get_int(mp_state, args[2]);
    }

    mp_obj_t retval = micropy_obj_new_list(mp_state, 0, NULL);
    const char **caps = alloca(caps_num * sizeof(char*));
    while (true) {
        // cast is a workaround for a bug in msvc: it treats const char** as a const pointer instead of a pointer to pointer to const char
        memset((char**)caps, 0, caps_num * sizeof(char*));
        int res = re1_5_recursiveloopprog(&self->re, &subj, caps, caps_num, false);

        // if we didn't have a match, or had an empty match, it's time to stop
        if (!res || caps[0] == caps[1]) {
            break;
        }

        mp_obj_t s = micropy_obj_new_str(mp_state, subj.begin, caps[0] - subj.begin, false);
        micropy_obj_list_append(mp_state, retval, s);
        if (self->re.sub > 0) {
            micropy_not_implemented(mp_state, "Splitting with sub-captures");
        }
        subj.begin = caps[1];
        if (maxsplit > 0 && --maxsplit == 0) {
            break;
        }
    }

    mp_obj_t s = micropy_obj_new_str(mp_state, subj.begin, subj.end - subj.begin, false);
    micropy_obj_list_append(mp_state, retval, s);
    return retval;
}
MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(re_split_obj, 2, 3, micropy_re_split);

STATIC const mp_rom_map_elem_t re_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_match), MP_ROM_PTR(&re_match_obj) },
    { MP_ROM_QSTR(MP_QSTR_search), MP_ROM_PTR(&re_search_obj) },
    { MP_ROM_QSTR(MP_QSTR_split), MP_ROM_PTR(&re_split_obj) },
};

STATIC MP_DEFINE_CONST_DICT(re_locals_dict, re_locals_dict_table);

STATIC const mp_obj_type_t re_type = {
    { &mp_type_type },
    .name = MP_QSTR_ure,
    .print = micropy_re_print,
    .locals_dict = (void*)&re_locals_dict,
};

STATIC mp_obj_t micropy_mod_re_compile(struct _mp_state_ctx_t *mp_state, size_t n_args, const mp_obj_t *args) {
    const char *re_str = micropy_obj_str_get_str(mp_state, args[0]);
    int size = re1_5_sizecode(re_str);
    if (size == -1) {
        goto error;
    }
    mp_obj_re_t *o = micropy_m_new_obj_var(mp_state, mp_obj_re_t, char, size);
    o->base.type = &re_type;
    int flags = 0;
    if (n_args > 1) {
        flags = micropy_obj_get_int(mp_state, args[1]);
    }
    int error = re1_5_compilecode(&o->re, re_str);
    if (error != 0) {
error:
        micropy_nlr_raise(mp_state, micropy_obj_new_exception_msg(mp_state, &mp_type_ValueError, "Error in regex"));
    }
    if (flags & FLAG_DEBUG) {
        re1_5_dumpcode(&o->re);
    }
    return MP_OBJ_FROM_PTR(o);
}
MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(mod_re_compile_obj, 1, 2, micropy_mod_re_compile);

STATIC mp_obj_t micropy_mod_re_exec(struct _mp_state_ctx_t *mp_state, bool is_anchored, uint n_args, const mp_obj_t *args) {
    (void)n_args;
    mp_obj_t self = micropy_mod_re_compile(mp_state, 1, args);

    const mp_obj_t args2[] = {self, args[1]};
    mp_obj_t match = micropy_ure_exec(mp_state, is_anchored, 2, args2);
    return match;
}

STATIC mp_obj_t micropy_mod_re_match(struct _mp_state_ctx_t *mp_state, size_t n_args, const mp_obj_t *args) {
    return micropy_mod_re_exec(mp_state, true, n_args, args);
}
MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(mod_re_match_obj, 2, 4, micropy_mod_re_match);

STATIC mp_obj_t micropy_mod_re_search(struct _mp_state_ctx_t *mp_state, size_t n_args, const mp_obj_t *args) {
    return micropy_mod_re_exec(mp_state, false, n_args, args);
}
MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(mod_re_search_obj, 2, 4, micropy_mod_re_search);

STATIC const mp_rom_map_elem_t mp_module_re_globals_table[] = {
    { MP_ROM_QSTR(MP_QSTR___name__), MP_ROM_QSTR(MP_QSTR_ure) },
    { MP_ROM_QSTR(MP_QSTR_compile), MP_ROM_PTR(&mod_re_compile_obj) },
    { MP_ROM_QSTR(MP_QSTR_match), MP_ROM_PTR(&mod_re_match_obj) },
    { MP_ROM_QSTR(MP_QSTR_search), MP_ROM_PTR(&mod_re_search_obj) },
    { MP_ROM_QSTR(MP_QSTR_DEBUG), MP_ROM_INT(FLAG_DEBUG) },
};

STATIC MP_DEFINE_CONST_DICT(mp_module_re_globals, mp_module_re_globals_table);

const mp_obj_module_t mp_module_ure = {
    .base = { &mp_type_module },
    .name = MP_QSTR_ure,
    .globals = (mp_obj_dict_t*)&mp_module_re_globals,
};

// Source files #include'd here to make sure they're compiled in
// only if module is enabled by config setting.

#define re1_5_fatal(x) assert(!x)
// Copyright 2014 Paul Sokolovsky.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.


#define INSERT_CODE(at, num, pc) \
    ((code ? memmove(code + at + num, code + at, pc - at) : (void)0), pc += num)
#define REL(at, to) (to - at - 2)
#undef EMIT
#define EMIT(at, byte) (code ? (code[at] = byte) : (void)(at))
#define PC (prog->bytelen)

static const char *_compilecode(const char *re, ByteProg *prog, int sizecode)
{
    char *code = sizecode ? NULL : prog->insts;
    int start = PC;
    int term = PC;
    int alt_label = 0;

    for (; *re && *re != ')'; re++) {
        switch (*re) {
        case '\\':
            re++;
            if (!*re) return NULL; // Trailing backslash
            if ((*re | 0x20) == 'd' || (*re | 0x20) == 's' || (*re | 0x20) == 'w') {
                term = PC;
                EMIT(PC++, NamedClass);
                EMIT(PC++, *re);
                prog->len++;
                break;
            }
        default:
            term = PC;
            EMIT(PC++, Char);
            EMIT(PC++, *re);
            prog->len++;
            break;
        case '.':
            term = PC;
            EMIT(PC++, Any);
            prog->len++;
            break;
        case '[': {
            int cnt;
            term = PC;
            re++;
            if (*re == '^') {
                EMIT(PC++, ClassNot);
                re++;
            } else {
                EMIT(PC++, Class);
            }
            PC++; // Skip # of pair byte
            prog->len++;
            for (cnt = 0; *re != ']'; re++, cnt++) {
                if (!*re) return NULL;
                EMIT(PC++, *re);
                if (re[1] == '-') {
                    re += 2;
                }
                EMIT(PC++, *re);
            }
            EMIT(term + 1, cnt);
            break;
        }
        case '(': {
            term = PC;
            int sub = 0;
            int capture = re[1] != '?' || re[2] != ':';

            if (capture) {
                sub = ++prog->sub;
                EMIT(PC++, Save);
                EMIT(PC++, 2 * sub);
                prog->len++;
            } else {
                    re += 2;
            }

            re = _compilecode(re + 1, prog, sizecode);
            if (re == NULL || *re != ')') return NULL; // error, or no matching paren

            if (capture) {
                EMIT(PC++, Save);
                EMIT(PC++, 2 * sub + 1);
                prog->len++;
            }

            break;
        }
        case '?':
            if (PC == term) return NULL; // nothing to repeat
            INSERT_CODE(term, 2, PC);
            if (re[1] == '?') {
                EMIT(term, RSplit);
                re++;
            } else {
                EMIT(term, Split);
            }
            EMIT(term + 1, REL(term, PC));
            prog->len++;
            term = PC;
            break;
        case '*':
            if (PC == term) return NULL; // nothing to repeat
            INSERT_CODE(term, 2, PC);
            EMIT(PC, Jmp);
            EMIT(PC + 1, REL(PC, term));
            PC += 2;
            if (re[1] == '?') {
                EMIT(term, RSplit);
                re++;
            } else {
                EMIT(term, Split);
            }
            EMIT(term + 1, REL(term, PC));
            prog->len += 2;
            term = PC;
            break;
        case '+':
            if (PC == term) return NULL; // nothing to repeat
            if (re[1] == '?') {
                EMIT(PC, Split);
                re++;
            } else {
                EMIT(PC, RSplit);
            }
            EMIT(PC + 1, REL(PC, term));
            PC += 2;
            prog->len++;
            term = PC;
            break;
        case '|':
            if (alt_label) {
                EMIT(alt_label, REL(alt_label, PC) + 1);
            }
            INSERT_CODE(start, 2, PC);
            EMIT(PC++, Jmp);
            alt_label = PC++;
            EMIT(start, Split);
            EMIT(start + 1, REL(start, PC));
            prog->len += 2;
            term = PC;
            break;
        case '^':
            EMIT(PC++, Bol);
            prog->len++;
            term = PC;
            break;
        case '$':
            EMIT(PC++, Eol);
            prog->len++;
            term = PC;
            break;
        }
    }

    if (alt_label) {
        EMIT(alt_label, REL(alt_label, PC) + 1);
    }
    return re;
}

int re1_5_sizecode(const char *re)
{
    ByteProg dummyprog = {
         // Save 0, Save 1, Match; more bytes for "search" (vs "match") prefix code
        .bytelen = 5 + NON_ANCHORED_PREFIX
    };

    if (_compilecode(re, &dummyprog, /*sizecode*/1) == NULL) return -1;

    return dummyprog.bytelen;
}

int re1_5_compilecode(ByteProg *prog, const char *re)
{
    prog->len = 0;
    prog->bytelen = 0;
    prog->sub = 0;

    // Add code to implement non-anchored operation ("search"),
    // for anchored operation ("match"), this code will be just skipped.
    // TODO: Implement search in much more efficient manner
    prog->insts[prog->bytelen++] = RSplit;
    prog->insts[prog->bytelen++] = 3;
    prog->insts[prog->bytelen++] = Any;
    prog->insts[prog->bytelen++] = Jmp;
    prog->insts[prog->bytelen++] = -5;
    prog->len += 3;

    prog->insts[prog->bytelen++] = Save;
    prog->insts[prog->bytelen++] = 0;
    prog->len++;

    re = _compilecode(re, prog, /*sizecode*/0);
    if (re == NULL || *re) return 1;

    prog->insts[prog->bytelen++] = Save;
    prog->insts[prog->bytelen++] = 1;
    prog->len++;

    prog->insts[prog->bytelen++] = Match;
    prog->len++;

    return 0;
}

#if 0
int main(int argc, char *argv[])
{
    int pc = 0;
    ByteProg *code = re1_5_compilecode(argv[1]);
    re1_5_dumpcode(code);
}
#endif
// Copyright 2014 Paul Sokolovsky.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.


void re1_5_dumpcode(ByteProg *prog)
{
    int pc = 0;
    char *code = prog->insts;
    while (pc < prog->bytelen) {
                printf("%2d: ", pc);
                switch(code[pc++]) {
                default:
                        assert(0);
//                        re1_5_fatal("printprog");
                case Split:
                        printf("split %d (%d)\n", pc + (signed char)code[pc] + 1, (signed char)code[pc]);
                        pc++;
                        break;
                case RSplit:
                        printf("rsplit %d (%d)\n", pc + (signed char)code[pc] + 1, (signed char)code[pc]);
                        pc++;
                        break;
                case Jmp:
                        printf("jmp %d (%d)\n", pc + (signed char)code[pc] + 1, (signed char)code[pc]);
                        pc++;
                        break;
                case Char:
                        printf("char %c\n", code[pc++]);
                        break;
                case Any:
                        printf("any\n");
                        break;
                case Class:
                case ClassNot: {
                        int num = code[pc];
                        printf("class%s %d", (code[pc - 1] == ClassNot ? "not" : ""), num);
                        pc++;
                        while (num--) {
                            printf(" 0x%02x-0x%02x", code[pc], code[pc + 1]);
                            pc += 2;
                        }
                        printf("\n");
                        break;
                }
                case NamedClass:
                        printf("namedclass %c\n", code[pc++]);
                        break;
                case Match:
                        printf("match\n");
                        break;
                case Save:
                        printf("save %d\n", (unsigned char)code[pc++]);
                        break;
                case Bol:
                        printf("assert bol\n");
                        break;
                case Eol:
                        printf("assert eol\n");
                        break;
                }
    }
    printf("Bytes: %d, insts: %d\n", prog->bytelen, prog->len);
}
// Copyright 2007-2009 Russ Cox.  All Rights Reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.


static int
recursiveloop(char *pc, const char *sp, Subject *input, const char **subp, int nsubp)
{
	const char *old;
	int off;
	
	for(;;) {
		if(inst_is_consumer(*pc)) {
			// If we need to match a character, but there's none left, it's fail
			if(sp >= input->end)
				return 0;
		}
		switch(*pc++) {
		case Char:
			if(*sp != *pc++)
				return 0;
		case Any:
			sp++;
			continue;
		case Class:
		case ClassNot:
			if (!_re1_5_classmatch(pc, sp))
				return 0;
			pc += *(unsigned char*)pc * 2 + 1;
			sp++;
			continue;
                case NamedClass:
			if (!_re1_5_namedclassmatch(pc, sp))
				return 0;
			pc++;
			sp++;
			continue;
		case Match:
			return 1;
		case Jmp:
			off = (signed char)*pc++;
			pc = pc + off;
			continue;
		case Split:
			off = (signed char)*pc++;
			if(recursiveloop(pc, sp, input, subp, nsubp))
				return 1;
			pc = pc + off;
			continue;
		case RSplit:
			off = (signed char)*pc++;
			if(recursiveloop(pc + off, sp, input, subp, nsubp))
				return 1;
			continue;
		case Save:
			off = (unsigned char)*pc++;
			if(off >= nsubp) {
				continue;
			}
			old = subp[off];
			subp[off] = sp;
			if(recursiveloop(pc, sp, input, subp, nsubp))
				return 1;
			subp[off] = old;
			return 0;
		case Bol:
			if(sp != input->begin)
				return 0;
			continue;
		case Eol:
			if(sp != input->end)
				return 0;
			continue;
		}
		re1_5_fatal("recursiveloop");
	}
}

int
re1_5_recursiveloopprog(ByteProg *prog, Subject *input, const char **subp, int nsubp, int is_anchored)
{
	return recursiveloop(HANDLE_ANCHORED(prog->insts, is_anchored), input->begin, input, subp, nsubp);
}

int _re1_5_classmatch(const char *pc, const char *sp)
{
    // pc points to "cnt" byte after opcode
    int is_positive = (pc[-1] == Class);
    int cnt = *pc++;
    while (cnt--) {
        if (*sp >= *pc && *sp <= pc[1]) return is_positive;
        pc += 2;
    }
    return !is_positive;
}

int _re1_5_namedclassmatch(const char *pc, const char *sp)
{
    // pc points to name of class
    int off = (*pc >> 5) & 1;
    if ((*pc | 0x20) == 'd') {
        if (!(*sp >= '0' && *sp <= '9')) {
            off ^= 1;
        }
    } else if ((*pc | 0x20) == 's') {
        if (!(*sp == ' ' || (*sp >= '\t' && *sp <= '\r'))) {
            off ^= 1;
        }
    } else { // w
        if (!((*sp >= 'A' && *sp <= 'Z') || (*sp >= 'a' && *sp <= 'z') || (*sp >= '0' && *sp <= '9') || *sp == '_')) {
            off ^= 1;
        }
    }
    return off;
}

#endif //MICROPY_PY_URE
/*
 * This file is part of the Micro Python project, http://micropython.org/
 *
 * The MIT License (MIT)
 *
 * Copyright (c) 2014 Damien P. George
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

//#include "py/nlr.h"
//#include "py/objlist.h"
//#include "py/runtime0.h"
//#include "py/runtime.h"

#if MICROPY_PY_UHEAPQ

// the algorithm here is modelled on CPython's heapq.py

STATIC mp_obj_list_t *micropy_get_heap(struct _mp_state_ctx_t *mp_state, mp_obj_t heap_in) {
    if (!MP_OBJ_IS_TYPE(heap_in, &mp_type_list)) {
        micropy_nlr_raise(mp_state, micropy_obj_new_exception_msg(mp_state, &mp_type_TypeError, "heap must be a list"));
    }
    return MP_OBJ_TO_PTR(heap_in);
}

STATIC void micropy_heap_siftdown(struct _mp_state_ctx_t *mp_state, mp_obj_list_t *heap, mp_uint_t start_pos, mp_uint_t pos) {
    mp_obj_t item = heap->items[pos];
    while (pos > start_pos) {
        mp_uint_t parent_pos = (pos - 1) >> 1;
        mp_obj_t parent = heap->items[parent_pos];
        if (micropy_binary_op(mp_state, MP_BINARY_OP_LESS, item, parent) == mp_const_true) {
            heap->items[pos] = parent;
            pos = parent_pos;
        } else {
            break;
        }
    }
    heap->items[pos] = item;
}

STATIC void micropy_heap_siftup(struct _mp_state_ctx_t *mp_state, mp_obj_list_t *heap, mp_uint_t pos) {
    mp_uint_t start_pos = pos;
    mp_uint_t end_pos = heap->len;
    mp_obj_t item = heap->items[pos];
    for (mp_uint_t child_pos = 2 * pos + 1; child_pos < end_pos; child_pos = 2 * pos + 1) {
        // choose right child if it's <= left child
        if (child_pos + 1 < end_pos && micropy_binary_op(mp_state, MP_BINARY_OP_LESS, heap->items[child_pos], heap->items[child_pos + 1]) == mp_const_false) {
            child_pos += 1;
        }
        // bubble up the smaller child
        heap->items[pos] = heap->items[child_pos];
        pos = child_pos;
    }
    heap->items[pos] = item;
    micropy_heap_siftdown(mp_state, heap, start_pos, pos);
}

STATIC mp_obj_t micropy_mod_uheapq_heappush(struct _mp_state_ctx_t *mp_state, mp_obj_t heap_in, mp_obj_t item) {
    mp_obj_list_t *heap = micropy_get_heap(mp_state, heap_in);
    micropy_obj_list_append(mp_state, heap_in, item);
    micropy_heap_siftdown(mp_state, heap, 0, heap->len - 1);
    return mp_const_none;
}
STATIC MP_DEFINE_CONST_FUN_OBJ_2(mod_uheapq_heappush_obj, micropy_mod_uheapq_heappush);

STATIC mp_obj_t micropy_mod_uheapq_heappop(struct _mp_state_ctx_t *mp_state, mp_obj_t heap_in) {
    mp_obj_list_t *heap = micropy_get_heap(mp_state, heap_in);
    if (heap->len == 0) {
        micropy_nlr_raise(mp_state, micropy_obj_new_exception_msg(mp_state, &mp_type_IndexError, "empty heap"));
    }
    mp_obj_t item = heap->items[0];
    heap->len -= 1;
    heap->items[0] = heap->items[heap->len];
    heap->items[heap->len] = MP_OBJ_NULL; // so we don't retain a pointer
    if (heap->len) {
        micropy_heap_siftup(mp_state, heap, 0);
    }
    return item;
}
STATIC MP_DEFINE_CONST_FUN_OBJ_1(mod_uheapq_heappop_obj, micropy_mod_uheapq_heappop);

STATIC mp_obj_t micropy_mod_uheapq_heapify(struct _mp_state_ctx_t *mp_state, mp_obj_t heap_in) {
    mp_obj_list_t *heap = micropy_get_heap(mp_state, heap_in);
    for (mp_uint_t i = heap->len / 2; i > 0;) {
        micropy_heap_siftup(mp_state, heap, --i);
    }
    return mp_const_none;
}
STATIC MP_DEFINE_CONST_FUN_OBJ_1(mod_uheapq_heapify_obj, micropy_mod_uheapq_heapify);

STATIC const mp_rom_map_elem_t mp_module_uheapq_globals_table[] = {
    { MP_ROM_QSTR(MP_QSTR___name__), MP_ROM_QSTR(MP_QSTR_uheapq) },
    { MP_ROM_QSTR(MP_QSTR_heappush), MP_ROM_PTR(&mod_uheapq_heappush_obj) },
    { MP_ROM_QSTR(MP_QSTR_heappop), MP_ROM_PTR(&mod_uheapq_heappop_obj) },
    { MP_ROM_QSTR(MP_QSTR_heapify), MP_ROM_PTR(&mod_uheapq_heapify_obj) },
};

STATIC MP_DEFINE_CONST_DICT(mp_module_uheapq_globals, mp_module_uheapq_globals_table);

const mp_obj_module_t mp_module_uheapq = {
    .base = { &mp_type_module },
    .name = MP_QSTR_uheapq,
    .globals = (mp_obj_dict_t*)&mp_module_uheapq_globals,
};

#endif //MICROPY_PY_UHEAPQ
/*
 *
 * Copyright (c) 2025 Damian Parrino
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

#include <stdio.h>
#include <zlib.h>

//#include "py/nlr.h"
//#include "py/runtime.h"

#if 0 // print debugging info
#define DEBUG_printf DEBUG_printf
#else // don't print debugging info
#define DEBUG_printf(...) (void)0
#endif

#define CHUNK_SIZE 16384  // Initial chunk size for output buffer

extern int offzip_init(int wbits);
extern int offzip_search(FILE *fd);
extern int offzip_verify(FILE *fd, uint32_t *offset, uint32_t *inlen, uint32_t *outlen);
extern void offzip_free(void);

/**
 * @brief Decompress data from input buffer to dynamically allocated output buffer
 * 
 * @param compressed_data Pointer to compressed data buffer
 * @param compressed_size Size of compressed data in bytes
 * @param decompressed Pointer to dynamically allocated decompressed buffer
 * @param window_bits Window size for decompression (use 15+16 for gzip format)
 * @return True on success, False on failure
 */

 bool micropy_decompress_buffer_dynamic(struct _mp_state_ctx_t *mp_state, 
    const unsigned char* compressed_data, size_t compressed_size,
    vstr_t* decompressed,
    int window_bits)
{
    z_stream stream;
    unsigned char* out_buffer = NULL;
    int ret;

    // Initialize zlib stream
    memset(&stream, 0, sizeof(stream));
    stream.zalloc = Z_NULL;
    stream.zfree = Z_NULL;
    stream.opaque = Z_NULL;
    stream.avail_in = compressed_size;
    stream.next_in = (Bytef*)compressed_data;

    // Initialize decompression with specified window bits
    if (inflateInit2(&stream, window_bits) != Z_OK) {
        DEBUG_printf("inflateInit2 failed\n");
        return false;
    }

    // Start with a reasonable initial buffer size
    out_buffer = (unsigned char*)malloc(CHUNK_SIZE);
    if (!out_buffer) {
        DEBUG_printf("Memory allocation failed\n");
        inflateEnd(&stream);
        return false;
    }
    
    // Decompress loop
    do {
        // Set output buffer position and available space
        stream.avail_out = CHUNK_SIZE;
        stream.next_out = out_buffer;
        
        // Decompress chunk
        ret = inflate(&stream, Z_NO_FLUSH);
        
        switch (ret) {
            case Z_NEED_DICT:
            case Z_DATA_ERROR:
            case Z_MEM_ERROR:
                DEBUG_printf("Decompression error: %s\n", stream.msg);
                free(out_buffer);
                inflateEnd(&stream);
                return false;
        }
        
        // Update total output size
        size_t bytes_produced = CHUNK_SIZE - stream.avail_out;

        micropy_vstr_add_strn(mp_state, decompressed, (const char*)out_buffer, bytes_produced);
        DEBUG_printf("Decompressed chunk: %zu bytes, total: %zu bytes\n", bytes_produced, stream.total_out);
    } while (ret != Z_STREAM_END);
    
    // Finish decompression
    inflateEnd(&stream);
    free(out_buffer);

    return true;
}

/**
 * @brief Helper function to compress data
 */
bool micropy_compress_buffer(struct _mp_state_ctx_t *mp_state, 
    const unsigned char* data, size_t data_size,
    vstr_t* compressed_out,
    int wbits, int level)
{
    z_stream stream;
    unsigned char* compressed = NULL;
    size_t max_compressed_size;
    int ret;

    // Calculate maximum possible compressed size
    max_compressed_size = compressBound(data_size);
    compressed = (unsigned char*)malloc(max_compressed_size);

    if (!compressed) {
        return false;
    }
    
    // Initialize zlib stream for compression
    memset(&stream, 0, sizeof(stream));
    stream.zalloc = Z_NULL;
    stream.zfree = Z_NULL;
    stream.opaque = Z_NULL;

    if (deflateInit2(&stream, level, Z_DEFLATED, wbits, 9, Z_DEFAULT_STRATEGY)) {
        DEBUG_printf("Error: zlib initialization error");
        free(compressed);
        return false;
    }

    stream.avail_in = data_size;
    stream.next_in = (Bytef*)data;
    stream.avail_out = max_compressed_size;
    stream.next_out = compressed;
    
    ret = deflate(&stream, Z_FINISH);
    
    if (ret != Z_STREAM_END) {
        free(compressed);
        deflateEnd(&stream);
        return false;
    }
    
    micropy_vstr_add_strn(mp_state, compressed_out, (const char*)compressed, max_compressed_size - stream.avail_out);
    deflateEnd(&stream);
    free(compressed);
    
    return true;
}

STATIC mp_obj_t micropy_mod_uzlib_decompress(struct _mp_state_ctx_t *mp_state, size_t n_args, const mp_obj_t *args) {
    mp_buffer_info_t bufinfo;
    vstr_t out;
    bool ret;

    micropy_get_buffer_raise(mp_state, args[0], &bufinfo, MP_BUFFER_READ);
    micropy_vstr_init(mp_state, &out, 0x10);
 
    int wbits = MAX_WBITS;
    if (n_args > 1) {
        // custom window value
        wbits = micropy_obj_int_get_truncated(mp_state, args[1]);
    }

    ret = micropy_decompress_buffer_dynamic(mp_state, bufinfo.buf, bufinfo.len, &out, wbits);

    if (!ret || out.had_error) {
        micropy_nlr_raise(mp_state, micropy_obj_new_exception_msg_varg(mp_state, &mp_type_ValueError, "Zlib decompression error"));
    }

    return micropy_obj_new_str_from_vstr(mp_state, &mp_type_bytes, &out);
}
STATIC MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(mod_uzlib_decompress_obj, 1, 2, micropy_mod_uzlib_decompress);

STATIC mp_obj_t micropy_mod_uzlib_compress(struct _mp_state_ctx_t *mp_state, size_t n_args, const mp_obj_t *args) {
    mp_buffer_info_t bufinfo;
    vstr_t out;
    bool ret;

    micropy_get_buffer_raise(mp_state, args[0], &bufinfo, MP_BUFFER_READ);
    micropy_vstr_init(mp_state, &out, 0x10);

    int wbits = MAX_WBITS;
    if (n_args > 1) {
        // custom window value
        wbits = micropy_obj_int_get_truncated(mp_state, args[1]);
    }

    int level = Z_BEST_COMPRESSION;
    if (n_args > 2) {
        // custom level value
        level = micropy_obj_int_get_truncated(mp_state, args[2]);
    }

    ret = micropy_compress_buffer(mp_state, bufinfo.buf, bufinfo.len, &out, wbits, level);

    if (!ret || out.had_error) {
        micropy_nlr_raise(mp_state, micropy_obj_new_exception_msg_varg(mp_state, &mp_type_ValueError, "Zlib compression error"));
    }

    return micropy_obj_new_str_from_vstr(mp_state, &mp_type_bytes, &out);
}
STATIC MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(mod_uzlib_compress_obj, 1, 3, micropy_mod_uzlib_compress);

STATIC mp_obj_t micropy_mod_uzlib_offzip(struct _mp_state_ctx_t *mp_state, size_t n_args, const mp_obj_t *args) {
    mp_buffer_info_t bufinfo;
    mp_obj_t list;

    micropy_get_buffer_raise(mp_state, args[0], &bufinfo, MP_BUFFER_READ);

    int wbits = MAX_WBITS;
    if (n_args > 1) {
        // custom window value
        wbits = micropy_obj_int_get_truncated(mp_state, args[1]);
    }

    if (offzip_init(wbits) != Z_OK) {
        micropy_nlr_raise(mp_state, micropy_obj_new_exception_msg_varg(mp_state, &mp_type_ValueError, "offZip init error"));
    }

    list = micropy_obj_new_list(mp_state, 0, NULL);
    FILE* fd = fmemopen(bufinfo.buf, bufinfo.len, "rb");

    while (offzip_search(fd) == Z_OK)
    {
        mp_obj_t items[3];
        uint32_t offz = 0, inlen = 0, outlen = 0;

        if (offzip_verify(fd, &offz, &inlen, &outlen) != Z_OK) {
            DEBUG_printf("offZip unzip error\n");
            continue;
        }

        items[0] = micropy_obj_new_int_from_uint(mp_state, offz);
        items[1] = micropy_obj_new_int_from_uint(mp_state, inlen);
        items[2] = micropy_obj_new_int_from_uint(mp_state, outlen);
        micropy_obj_list_append(mp_state, list, micropy_obj_new_tuple(mp_state, 3, items));

        DEBUG_printf("Found compressed block at offset 0x%08x: %d -> %d\n", offz, inlen, outlen);
    }

    offzip_free();
    fclose (fd);

    return list;
}
STATIC MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(mod_uzlib_offzip_obj, 1, 2, micropy_mod_uzlib_offzip);

#if MICROPY_PY_UZLIB

STATIC const mp_rom_map_elem_t mp_module_uzlib_globals_table[] = {
    { MP_ROM_QSTR(MP_QSTR___name__), MP_ROM_QSTR(MP_QSTR_uzlib) },
    { MP_ROM_QSTR(MP_QSTR_compress), MP_ROM_PTR(&mod_uzlib_compress_obj) },
    { MP_ROM_QSTR(MP_QSTR_decompress), MP_ROM_PTR(&mod_uzlib_decompress_obj) },
    { MP_ROM_QSTR(MP_QSTR_offzip), MP_ROM_PTR(&mod_uzlib_offzip_obj) },
};

STATIC MP_DEFINE_CONST_DICT(mp_module_uzlib_globals, mp_module_uzlib_globals_table);

const mp_obj_module_t mp_module_uzlib = {
    .base = { &mp_type_module },
    .name = MP_QSTR_uzlib,
    .globals = (mp_obj_dict_t*)&mp_module_uzlib_globals,
};

#endif // MICROPY_PY_UZLIB
/*
 *
 * Copyright (c) 2025 Damian Parrino
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

 #include <stdio.h>
#include <assert.h>
#include <string.h>

//#include "py/nlr.h"
//#include "py/runtime.h"
//#include "py/binary.h"

#include "apollo.h"
#include "crc_util.h"

// external definitions
extern void sha1( const unsigned char *input, size_t ilen, unsigned char output[20] );
extern void sha256( const unsigned char *input, size_t ilen, unsigned char output[32], int is224 );
extern void sha512( const unsigned char *input, size_t ilen, unsigned char output[64], int is384 );
extern void md5( const unsigned char *input, size_t ilen, unsigned char output[16] );
extern void ripemd160( const unsigned char *input, size_t ilen, unsigned char output[20] );
extern void sha1_hmac( const unsigned char *key, size_t keylen, const unsigned char *input, size_t ilen, unsigned char output[20] );

//---  Custom game checksum functions ---//
MP_DECLARE_CONST_FUN_OBJ(mod_uhashlib_eachecksum_obj);
MP_DECLARE_CONST_FUN_OBJ(mod_uhashlib_ffx_checksum_obj);
MP_DECLARE_CONST_FUN_OBJ(mod_uhashlib_ff13_checksum_obj);
MP_DECLARE_CONST_FUN_OBJ(mod_uhashlib_deadrising_checksum_obj);
MP_DECLARE_CONST_FUN_OBJ(mod_uhashlib_kh25_checksum_obj);
MP_DECLARE_CONST_FUN_OBJ(mod_uhashlib_khcom_checksum_obj);
MP_DECLARE_CONST_FUN_OBJ(mod_uhashlib_mgs2_checksum_obj);
MP_DECLARE_CONST_FUN_OBJ(mod_uhashlib_mgspw_checksum_obj);
MP_DECLARE_CONST_FUN_OBJ(mod_uhashlib_sw4_checksum_obj);
MP_DECLARE_CONST_FUN_OBJ(mod_uhashlib_toz_checksum_obj);
MP_DECLARE_CONST_FUN_OBJ(mod_uhashlib_tiara2_checksum_obj);
MP_DECLARE_CONST_FUN_OBJ(mod_uhashlib_castlevania_checksum_obj);
MP_DECLARE_CONST_FUN_OBJ(mod_uhashlib_rockstar_checksum_obj);
MP_DECLARE_CONST_FUN_OBJ(mod_uhashlib_dbzxv2_checksum_obj);

//---  Generic hash functions ---//
MP_DECLARE_CONST_FUN_OBJ(mod_uhashlib_crc_obj);
MP_DECLARE_CONST_FUN_OBJ(mod_uhashlib_crc16_obj);
MP_DECLARE_CONST_FUN_OBJ(mod_uhashlib_crc32_obj);
MP_DECLARE_CONST_FUN_OBJ(mod_uhashlib_crc32big_obj);
MP_DECLARE_CONST_FUN_OBJ(mod_uhashlib_crc64_iso_obj);
MP_DECLARE_CONST_FUN_OBJ(mod_uhashlib_crc64_ecma_obj);
MP_DECLARE_CONST_FUN_OBJ(mod_uhashlib_ripemd160_obj);
MP_DECLARE_CONST_FUN_OBJ(mod_uhashlib_md5_obj);
MP_DECLARE_CONST_FUN_OBJ(mod_uhashlib_md5_xor_obj);
MP_DECLARE_CONST_FUN_OBJ(mod_uhashlib_sha1_obj);
MP_DECLARE_CONST_FUN_OBJ(mod_uhashlib_sha256_obj);
MP_DECLARE_CONST_FUN_OBJ(mod_uhashlib_sha384_obj);
MP_DECLARE_CONST_FUN_OBJ(mod_uhashlib_sha512_obj);
MP_DECLARE_CONST_FUN_OBJ(mod_uhashlib_hmac_sha1_obj);
MP_DECLARE_CONST_FUN_OBJ(mod_uhashlib_sha1_xor64_obj);
MP_DECLARE_CONST_FUN_OBJ(mod_uhashlib_adler16_obj);
MP_DECLARE_CONST_FUN_OBJ(mod_uhashlib_adler32_obj);
MP_DECLARE_CONST_FUN_OBJ(mod_uhashlib_checksum32_obj);
MP_DECLARE_CONST_FUN_OBJ(mod_uhashlib_sdbm_obj);
MP_DECLARE_CONST_FUN_OBJ(mod_uhashlib_fnv1_obj);
MP_DECLARE_CONST_FUN_OBJ(mod_uhashlib_add_obj);
MP_DECLARE_CONST_FUN_OBJ(mod_uhashlib_wadd_obj);
MP_DECLARE_CONST_FUN_OBJ(mod_uhashlib_dwadd_obj);
MP_DECLARE_CONST_FUN_OBJ(mod_uhashlib_qwadd_obj);
MP_DECLARE_CONST_FUN_OBJ(mod_uhashlib_wadd_le_obj);
MP_DECLARE_CONST_FUN_OBJ(mod_uhashlib_dwadd_le_obj);
MP_DECLARE_CONST_FUN_OBJ(mod_uhashlib_wsub_obj);
MP_DECLARE_CONST_FUN_OBJ(mod_uhashlib_force_crc32_obj);
MP_DECLARE_CONST_FUN_OBJ(mod_uhashlib_murmur3_32_obj);
MP_DECLARE_CONST_FUN_OBJ(mod_uhashlib_jhash_obj);
MP_DECLARE_CONST_FUN_OBJ(mod_uhashlib_jenkins_oaat_obj);
MP_DECLARE_CONST_FUN_OBJ(mod_uhashlib_lookup3_little2_obj);
MP_DECLARE_CONST_FUN_OBJ(mod_uhashlib_djb2_obj);


/*
 * write_le_uint16: append an unsigned 16 bits Little Endian
 * value to a buffer
 */
#define micropy_write_le_uint16(mp_state, buf, val) \
	buf[0] = (uint8_t)val; \
	buf[1] = (uint8_t)(val >> 8);

#define micropy_write_be_uint16(mp_state, buf, val) \
	buf[1] = (uint8_t)val; \
	buf[0] = (uint8_t)(val >> 8);

/*
 * write_le_uint32: append an unsigned 32 bits Little Endian
 * value to a buffer
 */
#define micropy_write_le_uint32(mp_state, buf, val) \
	buf[0] = (uint8_t)val; \
	buf[1] = (uint8_t)(val >> 8); \
	buf[2] = (uint8_t)(val >> 16); \
	buf[3] = (uint8_t)(val >> 24);

#define micropy_write_be_uint32(mp_state, buf, val) \
	buf[3] = (uint8_t)val; \
	buf[2] = (uint8_t)(val >> 8); \
	buf[1] = (uint8_t)(val >> 16); \
	buf[0] = (uint8_t)(val >> 24);

/*
 * write_le_uint64: append an unsigned 64 bits Little Endian
 * value to a buffer
 */
#define micropy_write_le_uint64(mp_state, buf, val) \
    buf[0] = (uint8_t)val; \
    buf[1] = (uint8_t)(val >> 8); \
    buf[2] = (uint8_t)(val >> 16); \
    buf[3] = (uint8_t)(val >> 24); \
    buf[4] = (uint8_t)(val >> 32); \
    buf[5] = (uint8_t)(val >> 40); \
    buf[6] = (uint8_t)(val >> 48); \
    buf[7] = (uint8_t)(val >> 56);

#define micropy_write_be_uint64(mp_state, buf, val) \
    buf[7] = (uint8_t)val; \
    buf[6] = (uint8_t)(val >> 8); \
    buf[5] = (uint8_t)(val >> 16); \
    buf[4] = (uint8_t)(val >> 24); \
    buf[3] = (uint8_t)(val >> 32); \
    buf[2] = (uint8_t)(val >> 40); \
    buf[1] = (uint8_t)(val >> 48); \
    buf[0] = (uint8_t)(val >> 56);

/*
 * read_be_uint64: read an unsigned 64 bits Big Endian
 * value from a buffer
 */
#define micropy_read_be_uint64(mp_state, buf) \
    ((uint64_t)(buf[7]) | ((uint64_t)(buf[6]) << 8) | \
    ((uint64_t)(buf[5]) << 16) | ((uint64_t)(buf[4]) << 24) | \
    ((uint64_t)(buf[3]) << 32) | ((uint64_t)(buf[2]) << 40) | \
    ((uint64_t)(buf[1]) << 48) | ((uint64_t)(buf[0]) << 56))

#define micropy_parse_uint64_from_obj(mp_state, obj, buf, ret) \
    micropy_set_unaligned(mp_state, UINT64, buf, true, obj); \
    ret = micropy_read_be_uint64(mp_state, buf);


mp_obj_t micropy_mod_uhashlib_add(struct _mp_state_ctx_t *mp_state, mp_obj_t data) {
    uint8_t out[4];
    mp_buffer_info_t bufinfo;
    micropy_get_buffer_raise(mp_state, data, &bufinfo, MP_BUFFER_READ);

    uint32_t crc = add_hash(bufinfo.buf, bufinfo.len);
    micropy_write_be_uint32(mp_state, out, crc);

    return micropy_obj_new_bytearray(mp_state, sizeof(out), out);
}
MP_DEFINE_CONST_FUN_OBJ_1(mod_uhashlib_add_obj, micropy_mod_uhashlib_add);

mp_obj_t micropy_mod_uhashlib_wadd(struct _mp_state_ctx_t *mp_state, mp_obj_t data) {
    uint8_t out[4];
    mp_buffer_info_t bufinfo;
    micropy_get_buffer_raise(mp_state, data, &bufinfo, MP_BUFFER_READ);

    uint32_t crc = wadd_hash(bufinfo.buf, bufinfo.len, 0);
    micropy_write_be_uint32(mp_state, out, crc);

    return micropy_obj_new_bytearray(mp_state, sizeof(out), out);
}
MP_DEFINE_CONST_FUN_OBJ_1(mod_uhashlib_wadd_obj, micropy_mod_uhashlib_wadd);

mp_obj_t micropy_mod_uhashlib_wadd_le(struct _mp_state_ctx_t *mp_state, mp_obj_t data) {
    uint8_t out[4];
    mp_buffer_info_t bufinfo;
    micropy_get_buffer_raise(mp_state, data, &bufinfo, MP_BUFFER_READ);

    uint32_t crc = wadd_hash(bufinfo.buf, bufinfo.len, 1);
    micropy_write_be_uint32(mp_state, out, crc);

    return micropy_obj_new_bytearray(mp_state, sizeof(out), out);
}
MP_DEFINE_CONST_FUN_OBJ_1(mod_uhashlib_wadd_le_obj, micropy_mod_uhashlib_wadd_le);

mp_obj_t micropy_mod_uhashlib_dwadd(struct _mp_state_ctx_t *mp_state, mp_obj_t data) {
    uint8_t out[4];
    mp_buffer_info_t bufinfo;
    micropy_get_buffer_raise(mp_state, data, &bufinfo, MP_BUFFER_READ);

    uint32_t crc = dwadd_hash(bufinfo.buf, bufinfo.len, 0);
    micropy_write_be_uint32(mp_state, out, crc);

    return micropy_obj_new_bytearray(mp_state, sizeof(out), out);
}
MP_DEFINE_CONST_FUN_OBJ_1(mod_uhashlib_dwadd_obj, micropy_mod_uhashlib_dwadd);

mp_obj_t micropy_mod_uhashlib_dwadd_le(struct _mp_state_ctx_t *mp_state, mp_obj_t data) {
    uint8_t out[4];
    mp_buffer_info_t bufinfo;
    micropy_get_buffer_raise(mp_state, data, &bufinfo, MP_BUFFER_READ);

    uint32_t crc = dwadd_hash(bufinfo.buf, bufinfo.len, 1);
    micropy_write_be_uint32(mp_state, out, crc);

    return micropy_obj_new_bytearray(mp_state, sizeof(out), out);
}
MP_DEFINE_CONST_FUN_OBJ_1(mod_uhashlib_dwadd_le_obj, micropy_mod_uhashlib_dwadd_le);

mp_obj_t micropy_mod_uhashlib_qwadd(struct _mp_state_ctx_t *mp_state, mp_obj_t data) {
    uint8_t out[4];
    mp_buffer_info_t bufinfo;
    micropy_get_buffer_raise(mp_state, data, &bufinfo, MP_BUFFER_READ);

    uint32_t crc = qwadd_hash(bufinfo.buf, bufinfo.len);
    micropy_write_be_uint32(mp_state, out, crc);

    return micropy_obj_new_bytearray(mp_state, sizeof(out), out);
}
MP_DEFINE_CONST_FUN_OBJ_1(mod_uhashlib_qwadd_obj, micropy_mod_uhashlib_qwadd);

mp_obj_t micropy_mod_uhashlib_wsub(struct _mp_state_ctx_t *mp_state, mp_obj_t data) {
    uint8_t out[4];
    mp_buffer_info_t bufinfo;
    micropy_get_buffer_raise(mp_state, data, &bufinfo, MP_BUFFER_READ);

    uint32_t crc = wsub_hash(bufinfo.buf, bufinfo.len);
    micropy_write_be_uint32(mp_state, out, crc);

    return micropy_obj_new_bytearray(mp_state, sizeof(out), out);
}
MP_DEFINE_CONST_FUN_OBJ_1(mod_uhashlib_wsub_obj, micropy_mod_uhashlib_wsub);

mp_obj_t micropy_mod_uhashlib_adler16(struct _mp_state_ctx_t *mp_state, mp_obj_t data) {
    uint8_t out[2];
    mp_buffer_info_t bufinfo;
    micropy_get_buffer_raise(mp_state, data, &bufinfo, MP_BUFFER_READ);

    uint16_t crc = adler16(bufinfo.buf, bufinfo.len);
    micropy_write_be_uint16(mp_state, out, crc);

    return micropy_obj_new_bytearray(mp_state, 2, out);
}
MP_DEFINE_CONST_FUN_OBJ_1(mod_uhashlib_adler16_obj, micropy_mod_uhashlib_adler16);

mp_obj_t micropy_mod_uhashlib_adler32(struct _mp_state_ctx_t *mp_state, size_t n_args, const mp_obj_t *args) {
    uint8_t out[4];
    mp_buffer_info_t bufinfo;
    micropy_get_buffer_raise(mp_state, args[0], &bufinfo, MP_BUFFER_READ);

    uint32_t crc = adler32(0L, NULL, 0);
    if (n_args > 1) {
        // custom initial value
        crc = micropy_obj_int_get_truncated(mp_state, args[1]);
    }

    crc = adler32(crc, bufinfo.buf, bufinfo.len);
    micropy_write_be_uint32(mp_state, out, crc);

    return micropy_obj_new_bytearray(mp_state, sizeof(out), out);
}
MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(mod_uhashlib_adler32_obj, 1, 2, micropy_mod_uhashlib_adler32);

mp_obj_t micropy_mod_uhashlib_checksum32(struct _mp_state_ctx_t *mp_state, mp_obj_t data) {
    uint8_t out[4];
    mp_buffer_info_t bufinfo;
    micropy_get_buffer_raise(mp_state, data, &bufinfo, MP_BUFFER_READ);

    uint32_t crc = Checksum32_hash(bufinfo.buf, bufinfo.len);
    micropy_write_be_uint32(mp_state, out, crc);

    return micropy_obj_new_bytearray(mp_state, sizeof(out), out);
}
MP_DEFINE_CONST_FUN_OBJ_1(mod_uhashlib_checksum32_obj, micropy_mod_uhashlib_checksum32);

mp_obj_t micropy_mod_uhashlib_crc(struct _mp_state_ctx_t *mp_state, size_t n_args, const mp_obj_t *args) {
    uint8_t buf[0x10] = {0};
    mp_buffer_info_t bufinfo;
    micropy_get_buffer_raise(mp_state, args[0], &bufinfo, MP_BUFFER_READ);

    int width = micropy_obj_int_get_truncated(mp_state, args[1]);

    if (width != 16 && width != 32 && width != 64) {
        micropy_nlr_raise(mp_state, micropy_obj_new_exception_msg_varg(mp_state, &mp_type_ValueError, "CRC width must be 16, 32 or 64"));
    }

    vstr_t vstr;
    byte *out;
    custom_crc_t crc_opts = {
        .width = width,
        .refIn = micropy_obj_int_get_truncated(mp_state, args[5]),
        .refOut = micropy_obj_int_get_truncated(mp_state, args[6]),
    };
    micropy_parse_uint64_from_obj(mp_state, args[2], buf, crc_opts.poly);
    micropy_parse_uint64_from_obj(mp_state, args[3], buf, crc_opts.init);
    micropy_parse_uint64_from_obj(mp_state, args[4], buf, crc_opts.xor);

    switch (width)
    {
    case 16:
        micropy_vstr_init_len(mp_state, &vstr, 2);
        out = (byte*)vstr.buf;
        uint16_t crc16 = crc16_hash(bufinfo.buf, bufinfo.len, &crc_opts);
        micropy_write_be_uint16(mp_state, out, crc16);
        break;

    case 32:
        micropy_vstr_init_len(mp_state, &vstr, 4);
        out = (byte*)vstr.buf;
        uint32_t crc32 = crc32_hash(bufinfo.buf, bufinfo.len, &crc_opts);
        micropy_write_be_uint32(mp_state, out, crc32);
        break;

    case 64:
        micropy_vstr_init_len(mp_state, &vstr, 8);
        out = (byte*)vstr.buf;
        uint64_t crc64 = crc64_hash(bufinfo.buf, bufinfo.len, &crc_opts);
        micropy_write_be_uint64(mp_state, out, crc64);
        break;
        
    default:
        break;
    }

    return micropy_obj_new_str_from_vstr(mp_state, &mp_type_bytes, &vstr);
}
MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(mod_uhashlib_crc_obj, 7, 7, micropy_mod_uhashlib_crc);

mp_obj_t micropy_mod_uhashlib_crc16(struct _mp_state_ctx_t *mp_state, mp_obj_t data) {
    uint8_t out[2];
    mp_buffer_info_t bufinfo;
    micropy_get_buffer_raise(mp_state, data, &bufinfo, MP_BUFFER_READ);

    custom_crc_t crc_opts = {
        .init = CRC_16_INIT_VALUE,
        .poly = CRC_16_POLYNOMIAL,
        .xor = CRC_16_XOR_VALUE,
        .refIn = 0,
        .refOut = 0,
    };

    uint16_t crc = crc16_hash(bufinfo.buf, bufinfo.len, &crc_opts);
    micropy_write_be_uint16(mp_state, out, crc);

    return micropy_obj_new_bytearray(mp_state, 2, out);
}
MP_DEFINE_CONST_FUN_OBJ_1(mod_uhashlib_crc16_obj, micropy_mod_uhashlib_crc16);

mp_obj_t micropy_mod_uhashlib_crc32(struct _mp_state_ctx_t *mp_state, mp_obj_t data) {
    uint8_t out[4];
    mp_buffer_info_t bufinfo;
    micropy_get_buffer_raise(mp_state, data, &bufinfo, MP_BUFFER_READ);

    custom_crc_t crc_opts = {
        .init = CRC_32_INIT_VALUE,
        .poly = CRC_32_POLYNOMIAL,
        .xor = CRC_32_XOR_VALUE,
        .refIn = 1,
        .refOut = 1,
    };

    uint32_t crc = crc32_hash(bufinfo.buf, bufinfo.len, &crc_opts);
    micropy_write_be_uint32(mp_state, out, crc);

    return micropy_obj_new_bytearray(mp_state, sizeof(out), out);
}
MP_DEFINE_CONST_FUN_OBJ_1(mod_uhashlib_crc32_obj, micropy_mod_uhashlib_crc32);

mp_obj_t micropy_mod_uhashlib_crc32big(struct _mp_state_ctx_t *mp_state, mp_obj_t data) {
    uint8_t out[4];
    mp_buffer_info_t bufinfo;
    micropy_get_buffer_raise(mp_state, data, &bufinfo, MP_BUFFER_READ);

    custom_crc_t crc_opts = {
        .init = CRC_32_INIT_VALUE,
        .poly = CRC_32_POLYNOMIAL,
        .xor = CRC_32_XOR_VALUE,
        .refIn = 0,
        .refOut = 0,
    };

    uint32_t crc = crc32_hash(bufinfo.buf, bufinfo.len, &crc_opts);
    micropy_write_be_uint32(mp_state, out, crc);

    return micropy_obj_new_bytearray(mp_state, sizeof(out), out);
}
MP_DEFINE_CONST_FUN_OBJ_1(mod_uhashlib_crc32big_obj, micropy_mod_uhashlib_crc32big);

mp_obj_t micropy_mod_uhashlib_crc64_ecma(struct _mp_state_ctx_t *mp_state, mp_obj_t data) {
    uint8_t out[8];
    mp_buffer_info_t bufinfo;
    micropy_get_buffer_raise(mp_state, data, &bufinfo, MP_BUFFER_READ);

    custom_crc_t crc_opts = {
        .init = CRC_64_ECMA182_INIT_VALUE,
        .poly = CRC_64_ECMA182_POLY,
        .xor = CRC_64_ECMA182_XOR_VALUE,
        .refIn = 0,
        .refOut = 0,
    };

    uint64_t crc = crc64_hash(bufinfo.buf, bufinfo.len, &crc_opts);
    micropy_write_be_uint64(mp_state, out, crc);

    return micropy_obj_new_bytearray(mp_state, sizeof(out), out);
}
MP_DEFINE_CONST_FUN_OBJ_1(mod_uhashlib_crc64_ecma_obj, micropy_mod_uhashlib_crc64_ecma);

mp_obj_t micropy_mod_uhashlib_crc64_iso(struct _mp_state_ctx_t *mp_state, mp_obj_t data) {
    uint8_t out[8];
    mp_buffer_info_t bufinfo;
    micropy_get_buffer_raise(mp_state, data, &bufinfo, MP_BUFFER_READ);

    custom_crc_t crc_opts = {
        .init = CRC_64_ISO_INIT_VALUE,
        .poly = CRC_64_ISO_POLY,
        .xor = CRC_64_ISO_XOR_VALUE,
        .refIn = 0,
        .refOut = 0,
    };

    uint64_t crc = crc64_hash(bufinfo.buf, bufinfo.len, &crc_opts);
    micropy_write_be_uint64(mp_state, out, crc);

    return micropy_obj_new_bytearray(mp_state, sizeof(out), out);
}
MP_DEFINE_CONST_FUN_OBJ_1(mod_uhashlib_crc64_iso_obj, micropy_mod_uhashlib_crc64_iso);

mp_obj_t micropy_mod_uhashlib_djb2(struct _mp_state_ctx_t *mp_state, mp_obj_t data) {
    uint8_t out[4];
    mp_buffer_info_t bufinfo;
    micropy_get_buffer_raise(mp_state, data, &bufinfo, MP_BUFFER_READ);

    uint32_t crc = djb2_hash(bufinfo.buf, bufinfo.len);
    micropy_write_be_uint32(mp_state, out, crc);

    return micropy_obj_new_bytearray(mp_state, sizeof(out), out);
}
MP_DEFINE_CONST_FUN_OBJ_1(mod_uhashlib_djb2_obj, micropy_mod_uhashlib_djb2);

mp_obj_t micropy_mod_uhashlib_fnv1(struct _mp_state_ctx_t *mp_state, size_t n_args, const mp_obj_t *args) {
    uint8_t out[4];
    mp_buffer_info_t bufinfo;
    micropy_get_buffer_raise(mp_state, args[0], &bufinfo, MP_BUFFER_READ);

    uint32_t init_val = FNV1_INIT_VALUE;
    if (n_args > 1) {
        // custom initial value
        init_val = micropy_obj_int_get_truncated(mp_state, args[1]);
    }

    uint32_t crc = fnv1_hash(bufinfo.buf, bufinfo.len, init_val);
    micropy_write_be_uint32(mp_state, out, crc);

    return micropy_obj_new_bytearray(mp_state, sizeof(out), out);
}
MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(mod_uhashlib_fnv1_obj, 1, 2, micropy_mod_uhashlib_fnv1);

mp_obj_t micropy_mod_uhashlib_force_crc32(struct _mp_state_ctx_t *mp_state, mp_obj_t data, mp_obj_t offset, mp_obj_t newcrc) {
    uint8_t out[4];
    mp_buffer_info_t bufinfo;
    micropy_get_buffer_raise(mp_state, data, &bufinfo, MP_BUFFER_READ);

    uint32_t crc = force_crc32(bufinfo.buf, bufinfo.len, micropy_obj_int_get_truncated(mp_state, offset), micropy_obj_int_get_truncated(mp_state, newcrc));
    micropy_write_be_uint32(mp_state, out, crc);

    return micropy_obj_new_bytearray(mp_state, sizeof(out), out);
}
MP_DEFINE_CONST_FUN_OBJ_3(mod_uhashlib_force_crc32_obj, micropy_mod_uhashlib_force_crc32);

mp_obj_t micropy_mod_uhashlib_hmac_sha1(struct _mp_state_ctx_t *mp_state, mp_obj_t key, mp_obj_t data) {
    uint8_t out[20];
    mp_buffer_info_t keyinfo, bufinfo;
    micropy_get_buffer_raise(mp_state, key, &keyinfo, MP_BUFFER_READ);
    micropy_get_buffer_raise(mp_state, data, &bufinfo, MP_BUFFER_READ);

    sha1_hmac(keyinfo.buf, keyinfo.len, bufinfo.buf, bufinfo.len, out);

    return micropy_obj_new_bytearray(mp_state, sizeof(out), out);
}
MP_DEFINE_CONST_FUN_OBJ_2(mod_uhashlib_hmac_sha1_obj, micropy_mod_uhashlib_hmac_sha1);

mp_obj_t micropy_mod_uhashlib_jenkins_oaat(struct _mp_state_ctx_t *mp_state, size_t n_args, const mp_obj_t *args) {
    uint8_t out[4];
    mp_buffer_info_t bufinfo;
    micropy_get_buffer_raise(mp_state, args[0], &bufinfo, MP_BUFFER_READ);

    uint32_t init_val = 0;
    if (n_args > 1) {
        // custom initial value
        init_val = micropy_obj_int_get_truncated(mp_state, args[1]);
    }

    uint32_t crc = jenkins_oaat_hash(bufinfo.buf, bufinfo.len, init_val);
    micropy_write_be_uint32(mp_state, out, crc);

    return micropy_obj_new_bytearray(mp_state, sizeof(out), out);
}
MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(mod_uhashlib_jenkins_oaat_obj, 1, 2, micropy_mod_uhashlib_jenkins_oaat);

mp_obj_t micropy_mod_uhashlib_jhash(struct _mp_state_ctx_t *mp_state, size_t n_args, const mp_obj_t *args) {
    uint8_t out[4];
    mp_buffer_info_t bufinfo;
    micropy_get_buffer_raise(mp_state, args[0], &bufinfo, MP_BUFFER_READ);

    uint32_t init_val = 0;
    if (n_args > 1) {
        // custom initial value
        init_val = micropy_obj_int_get_truncated(mp_state, args[1]);
    }

    uint32_t crc = jhash(bufinfo.buf, bufinfo.len, init_val);
    micropy_write_be_uint32(mp_state, out, crc);

    return micropy_obj_new_bytearray(mp_state, sizeof(out), out);
}
MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(mod_uhashlib_jhash_obj, 1, 2, micropy_mod_uhashlib_jhash);

mp_obj_t micropy_mod_uhashlib_lookup3_little2(struct _mp_state_ctx_t *mp_state, mp_obj_t data, mp_obj_t pc_iv1, mp_obj_t pb_iv2) {
    uint8_t out[4];
    mp_obj_t items[2];
    mp_buffer_info_t bufinfo;
    micropy_get_buffer_raise(mp_state, data, &bufinfo, MP_BUFFER_READ);

    uint32_t iv1 = micropy_obj_int_get_truncated(mp_state, pc_iv1);
    uint32_t iv2 = micropy_obj_int_get_truncated(mp_state, pb_iv2);
    lookup3_hashlittle2(bufinfo.buf, bufinfo.len, &iv1, &iv2);

    micropy_write_be_uint32(mp_state, out, iv1);
    items[0] = micropy_obj_new_bytearray(mp_state, sizeof(out), out);
    micropy_write_be_uint32(mp_state, out, iv2);
    items[1] = micropy_obj_new_bytearray(mp_state, sizeof(out), out);

    return micropy_obj_new_tuple(mp_state, 2, items);
}
MP_DEFINE_CONST_FUN_OBJ_3(mod_uhashlib_lookup3_little2_obj, micropy_mod_uhashlib_lookup3_little2);

mp_obj_t micropy_mod_uhashlib_ripemd160(struct _mp_state_ctx_t *mp_state, mp_obj_t data) {
    uint8_t out[20];
    mp_buffer_info_t bufinfo;
    micropy_get_buffer_raise(mp_state, data, &bufinfo, MP_BUFFER_READ);

    ripemd160(bufinfo.buf, bufinfo.len, out);

    return micropy_obj_new_bytearray(mp_state, sizeof(out), out);
}
MP_DEFINE_CONST_FUN_OBJ_1(mod_uhashlib_ripemd160_obj, micropy_mod_uhashlib_ripemd160);

mp_obj_t micropy_mod_uhashlib_md5(struct _mp_state_ctx_t *mp_state, mp_obj_t data) {
    uint8_t out[16];
    mp_buffer_info_t bufinfo;
    micropy_get_buffer_raise(mp_state, data, &bufinfo, MP_BUFFER_READ);

    md5(bufinfo.buf, bufinfo.len, out);

    return micropy_obj_new_bytearray(mp_state, sizeof(out), out);
}
MP_DEFINE_CONST_FUN_OBJ_1(mod_uhashlib_md5_obj, micropy_mod_uhashlib_md5);

mp_obj_t micropy_mod_uhashlib_md5_xor(struct _mp_state_ctx_t *mp_state, mp_obj_t data) {
    uint8_t out[4];
    mp_buffer_info_t bufinfo;
    micropy_get_buffer_raise(mp_state, data, &bufinfo, MP_BUFFER_READ);

    uint32_t hash[4];
    md5(bufinfo.buf, bufinfo.len, (uint8_t*) hash);
    hash[0] ^= (hash[1] ^ hash[2] ^ hash[3]);
    micropy_write_be_uint32(mp_state, out, hash[0]);

    return micropy_obj_new_bytearray(mp_state, sizeof(out), out);
}
MP_DEFINE_CONST_FUN_OBJ_1(mod_uhashlib_md5_xor_obj, micropy_mod_uhashlib_md5_xor);

mp_obj_t micropy_mod_uhashlib_murmur3_32(struct _mp_state_ctx_t *mp_state, size_t n_args, const mp_obj_t *args) {
    uint8_t out[4];
    mp_buffer_info_t bufinfo;
    micropy_get_buffer_raise(mp_state, args[0], &bufinfo, MP_BUFFER_READ);

    uint32_t init_val = 0;
    if (n_args > 1) {
        // custom initial value
        init_val = micropy_obj_int_get_truncated(mp_state, args[1]);
    }

    uint32_t crc = murmur3_32(bufinfo.buf, bufinfo.len, init_val);
    micropy_write_be_uint32(mp_state, out, crc);

    return micropy_obj_new_bytearray(mp_state, sizeof(out), out);
}
MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(mod_uhashlib_murmur3_32_obj, 1, 2, micropy_mod_uhashlib_murmur3_32);

mp_obj_t micropy_mod_uhashlib_sdbm(struct _mp_state_ctx_t *mp_state, size_t n_args, const mp_obj_t *args) {
    uint8_t out[4];
    mp_buffer_info_t bufinfo;
    micropy_get_buffer_raise(mp_state, args[0], &bufinfo, MP_BUFFER_READ);

    uint32_t init_val = 0;
    if (n_args > 1) {
        // custom initial value
        init_val = micropy_obj_int_get_truncated(mp_state, args[1]);
    }

    uint32_t crc = sdbm_hash(bufinfo.buf, bufinfo.len, init_val);
    micropy_write_be_uint32(mp_state, out, crc);

    return micropy_obj_new_bytearray(mp_state, sizeof(out), out);
}
MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(mod_uhashlib_sdbm_obj, 1, 2, micropy_mod_uhashlib_sdbm);

mp_obj_t micropy_mod_uhashlib_sha1(struct _mp_state_ctx_t *mp_state, mp_obj_t data) {
    uint8_t out[20];
    mp_buffer_info_t bufinfo;
    micropy_get_buffer_raise(mp_state, data, &bufinfo, MP_BUFFER_READ);

    sha1(bufinfo.buf, bufinfo.len, out);

    return micropy_obj_new_bytearray(mp_state, sizeof(out), out);
}
MP_DEFINE_CONST_FUN_OBJ_1(mod_uhashlib_sha1_obj, micropy_mod_uhashlib_sha1);

mp_obj_t micropy_mod_uhashlib_sha256(struct _mp_state_ctx_t *mp_state, mp_obj_t data) {
    uint8_t out[32];
    mp_buffer_info_t bufinfo;
    micropy_get_buffer_raise(mp_state, data, &bufinfo, MP_BUFFER_READ);

    sha256(bufinfo.buf, bufinfo.len, out, 0);

    return micropy_obj_new_bytearray(mp_state, sizeof(out), out);
}
MP_DEFINE_CONST_FUN_OBJ_1(mod_uhashlib_sha256_obj, micropy_mod_uhashlib_sha256);

mp_obj_t micropy_mod_uhashlib_sha384(struct _mp_state_ctx_t *mp_state, mp_obj_t data) {
    uint8_t out[64];
    mp_buffer_info_t bufinfo;
    micropy_get_buffer_raise(mp_state, data, &bufinfo, MP_BUFFER_READ);

    sha512(bufinfo.buf, bufinfo.len, out, 1);

    return micropy_obj_new_bytearray(mp_state, sizeof(out), out);
}
MP_DEFINE_CONST_FUN_OBJ_1(mod_uhashlib_sha384_obj, micropy_mod_uhashlib_sha384);

mp_obj_t micropy_mod_uhashlib_sha512(struct _mp_state_ctx_t *mp_state, mp_obj_t data) {
    uint8_t out[64];
    mp_buffer_info_t bufinfo;
    micropy_get_buffer_raise(mp_state, data, &bufinfo, MP_BUFFER_READ);

    sha512(bufinfo.buf, bufinfo.len, out, 0);

    return micropy_obj_new_bytearray(mp_state, sizeof(out), out);
}
MP_DEFINE_CONST_FUN_OBJ_1(mod_uhashlib_sha512_obj, micropy_mod_uhashlib_sha512);

mp_obj_t micropy_mod_uhashlib_sha1_xor64(struct _mp_state_ctx_t *mp_state, mp_obj_t data) {
    uint8_t out[8];
    mp_buffer_info_t bufinfo;
    micropy_get_buffer_raise(mp_state, data, &bufinfo, MP_BUFFER_READ);

    uint64_t sha[3] = {0, 0, 0};
    sha1(bufinfo.buf, bufinfo.len, (uint8_t*) sha);
    sha[0] ^= (sha[1] ^ sha[2]);
    micropy_write_le_uint64(mp_state, out, sha[0]);

    return micropy_obj_new_bytearray(mp_state, sizeof(out), out);
}
MP_DEFINE_CONST_FUN_OBJ_1(mod_uhashlib_sha1_xor64_obj, micropy_mod_uhashlib_sha1_xor64);

mp_obj_t micropy_mod_uhashlib_eachecksum(struct _mp_state_ctx_t *mp_state, mp_obj_t data) {
    uint8_t out[4];
    mp_buffer_info_t bufinfo;
    micropy_get_buffer_raise(mp_state, data, &bufinfo, MP_BUFFER_READ);

    uint32_t crc = MC02_hash(bufinfo.buf, bufinfo.len);
    micropy_write_be_uint32(mp_state, out, crc);

    return micropy_obj_new_bytearray(mp_state, sizeof(out), out);
}
MP_DEFINE_CONST_FUN_OBJ_1(mod_uhashlib_eachecksum_obj, micropy_mod_uhashlib_eachecksum);

mp_obj_t micropy_mod_uhashlib_ffx_checksum(struct _mp_state_ctx_t *mp_state, mp_obj_t data) {
    uint8_t out[4];
    mp_buffer_info_t bufinfo;
    micropy_get_buffer_raise(mp_state, data, &bufinfo, MP_BUFFER_READ);

    uint32_t crc = ffx_hash(bufinfo.buf, bufinfo.len);
    micropy_write_be_uint32(mp_state, out, crc);

    return micropy_obj_new_bytearray(mp_state, sizeof(out), out);
}
MP_DEFINE_CONST_FUN_OBJ_1(mod_uhashlib_ffx_checksum_obj, micropy_mod_uhashlib_ffx_checksum);

mp_obj_t micropy_mod_uhashlib_ff13_checksum(struct _mp_state_ctx_t *mp_state, mp_obj_t data) {
    uint8_t out[4];
    mp_buffer_info_t bufinfo;
    micropy_get_buffer_raise(mp_state, data, &bufinfo, MP_BUFFER_READ);

    uint32_t crc = ff13_checksum(bufinfo.buf, bufinfo.len);
    micropy_write_be_uint32(mp_state, out, crc);

    return micropy_obj_new_bytearray(mp_state, sizeof(out), out);
}
MP_DEFINE_CONST_FUN_OBJ_1(mod_uhashlib_ff13_checksum_obj, micropy_mod_uhashlib_ff13_checksum);

mp_obj_t micropy_mod_uhashlib_kh25_checksum(struct _mp_state_ctx_t *mp_state, mp_obj_t data) {
    uint8_t out[4];
    mp_buffer_info_t bufinfo;
    micropy_get_buffer_raise(mp_state, data, &bufinfo, MP_BUFFER_READ);

    uint32_t crc = kh25_hash(bufinfo.buf, bufinfo.len);
    micropy_write_be_uint32(mp_state, out, crc);

    return micropy_obj_new_bytearray(mp_state, sizeof(out), out);
}
MP_DEFINE_CONST_FUN_OBJ_1(mod_uhashlib_kh25_checksum_obj, micropy_mod_uhashlib_kh25_checksum);

mp_obj_t micropy_mod_uhashlib_khcom_checksum(struct _mp_state_ctx_t *mp_state, mp_obj_t data) {
    uint8_t out[4];
    mp_buffer_info_t bufinfo;
    micropy_get_buffer_raise(mp_state, data, &bufinfo, MP_BUFFER_READ);

    uint32_t crc = kh_com_hash(bufinfo.buf, bufinfo.len);
    micropy_write_be_uint32(mp_state, out, crc);

    return micropy_obj_new_bytearray(mp_state, sizeof(out), out);
}
MP_DEFINE_CONST_FUN_OBJ_1(mod_uhashlib_khcom_checksum_obj, micropy_mod_uhashlib_khcom_checksum);

mp_obj_t micropy_mod_uhashlib_mgs2_checksum(struct _mp_state_ctx_t *mp_state, mp_obj_t data) {
    uint8_t out[4];
    mp_buffer_info_t bufinfo;
    micropy_get_buffer_raise(mp_state, data, &bufinfo, MP_BUFFER_READ);

    uint32_t crc = mgs2_hash(bufinfo.buf, bufinfo.len);
    micropy_write_be_uint32(mp_state, out, crc);

    return micropy_obj_new_bytearray(mp_state, sizeof(out), out);
}
MP_DEFINE_CONST_FUN_OBJ_1(mod_uhashlib_mgs2_checksum_obj, micropy_mod_uhashlib_mgs2_checksum);

mp_obj_t micropy_mod_uhashlib_mgspw_checksum(struct _mp_state_ctx_t *mp_state, mp_obj_t data) {
    uint8_t out[4];
    mp_buffer_info_t bufinfo;
    micropy_get_buffer_raise(mp_state, data, &bufinfo, MP_BUFFER_READ);

    uint32_t crc = mgspw_Checksum(bufinfo.buf, bufinfo.len);
    micropy_write_be_uint32(mp_state, out, crc);

    return micropy_obj_new_bytearray(mp_state, sizeof(out), out);
}
MP_DEFINE_CONST_FUN_OBJ_1(mod_uhashlib_mgspw_checksum_obj, micropy_mod_uhashlib_mgspw_checksum);

mp_obj_t micropy_mod_uhashlib_sw4_checksum(struct _mp_state_ctx_t *mp_state, mp_obj_t data) {
    uint8_t out[4];
    mp_buffer_info_t bufinfo;
    micropy_get_buffer_raise(mp_state, data, &bufinfo, MP_BUFFER_READ);

    mp_obj_t items[4];
    uint32_t hash[4];

    sw4_hash(bufinfo.buf, bufinfo.len, hash);
    micropy_write_be_uint32(mp_state, out, hash[0]);
    items[0] = micropy_obj_new_bytearray(mp_state, sizeof(out), out);
    micropy_write_be_uint32(mp_state, out, hash[1]);
    items[1] = micropy_obj_new_bytearray(mp_state, sizeof(out), out);
    micropy_write_be_uint32(mp_state, out, hash[2]);
    items[2] = micropy_obj_new_bytearray(mp_state, sizeof(out), out);
    micropy_write_be_uint32(mp_state, out, hash[3]);
    items[3] = micropy_obj_new_bytearray(mp_state, sizeof(out), out);

    return micropy_obj_new_tuple(mp_state, 4, items);
}
MP_DEFINE_CONST_FUN_OBJ_1(mod_uhashlib_sw4_checksum_obj, micropy_mod_uhashlib_sw4_checksum);

mp_obj_t micropy_mod_uhashlib_toz_checksum(struct _mp_state_ctx_t *mp_state, mp_obj_t data) {
    uint8_t out[20];
    mp_buffer_info_t bufinfo;
    micropy_get_buffer_raise(mp_state, data, &bufinfo, MP_BUFFER_READ);

    toz_hash(bufinfo.buf, bufinfo.len, out);

    return micropy_obj_new_bytearray(mp_state, sizeof(out), out);
}
MP_DEFINE_CONST_FUN_OBJ_1(mod_uhashlib_toz_checksum_obj, micropy_mod_uhashlib_toz_checksum);

mp_obj_t micropy_mod_uhashlib_tiara2_checksum(struct _mp_state_ctx_t *mp_state, mp_obj_t data) {
    uint8_t out[4];
    mp_buffer_info_t bufinfo;
    micropy_get_buffer_raise(mp_state, data, &bufinfo, MP_BUFFER_READ);

    uint32_t crc = tiara2_hash(bufinfo.buf, bufinfo.len);
    micropy_write_be_uint32(mp_state, out, crc);

    return micropy_obj_new_bytearray(mp_state, sizeof(out), out);
}
MP_DEFINE_CONST_FUN_OBJ_1(mod_uhashlib_tiara2_checksum_obj, micropy_mod_uhashlib_tiara2_checksum);

mp_obj_t micropy_mod_uhashlib_castlevania_checksum(struct _mp_state_ctx_t *mp_state, mp_obj_t data) {
    uint8_t out[4];
    mp_buffer_info_t bufinfo;
    micropy_get_buffer_raise(mp_state, data, &bufinfo, MP_BUFFER_READ);

    uint32_t crc = castlevania_hash(bufinfo.buf, bufinfo.len);
    micropy_write_be_uint32(mp_state, out, crc);

    return micropy_obj_new_bytearray(mp_state, sizeof(out), out);
}
MP_DEFINE_CONST_FUN_OBJ_1(mod_uhashlib_castlevania_checksum_obj, micropy_mod_uhashlib_castlevania_checksum);

mp_obj_t micropy_mod_uhashlib_rockstar_checksum(struct _mp_state_ctx_t *mp_state, mp_obj_t data) {
    mp_buffer_info_t bufinfo;
    micropy_get_buffer_raise(mp_state, data, &bufinfo, MP_BUFFER_READ);

    micropy_nlr_raise(mp_state, micropy_obj_new_exception_msg_varg(mp_state, &mp_type_ValueError, "NOT IMPLEMENTED"));

    vstr_t vstr;
    micropy_vstr_init_len(mp_state, &vstr, 4);
    byte *out = (byte*)vstr.buf;

    uint32_t crc = add_hash(bufinfo.buf, bufinfo.len);
    micropy_write_be_uint32(mp_state, out, crc);

    return micropy_obj_new_str_from_vstr(mp_state, &mp_type_bytes, &vstr);
}
MP_DEFINE_CONST_FUN_OBJ_1(mod_uhashlib_rockstar_checksum_obj, micropy_mod_uhashlib_rockstar_checksum);

mp_obj_t micropy_mod_uhashlib_dbzxv2_checksum(struct _mp_state_ctx_t *mp_state, mp_obj_t data) {
    uint8_t out[8];
    mp_buffer_info_t bufinfo;
    micropy_get_buffer_raise(mp_state, data, &bufinfo, MP_BUFFER_READ);

    uint64_t crc = dbzxv2_checksum(bufinfo.buf, bufinfo.len);
    micropy_write_be_uint64(mp_state, out, crc);

    return micropy_obj_new_bytearray(mp_state, sizeof(out), out);
}
MP_DEFINE_CONST_FUN_OBJ_1(mod_uhashlib_dbzxv2_checksum_obj, micropy_mod_uhashlib_dbzxv2_checksum);

mp_obj_t micropy_mod_uhashlib_deadrising_checksum(struct _mp_state_ctx_t *mp_state, mp_obj_t data) {
    uint8_t out[4];
    mp_buffer_info_t bufinfo;
    micropy_get_buffer_raise(mp_state, data, &bufinfo, MP_BUFFER_READ);

    uint32_t crc = deadrising_checksum(bufinfo.buf, bufinfo.len);
    micropy_write_be_uint32(mp_state, out, crc);

    return micropy_obj_new_bytearray(mp_state, sizeof(out), out);
}
MP_DEFINE_CONST_FUN_OBJ_1(mod_uhashlib_deadrising_checksum_obj, micropy_mod_uhashlib_deadrising_checksum);

#if MICROPY_PY_UHASHLIB

STATIC const mp_rom_map_elem_t mp_module_hashlib_globals_table[] = {
    { MP_ROM_QSTR(MP_QSTR___name__), MP_ROM_QSTR(MP_QSTR_uhashlib) },
    { MP_ROM_QSTR(MP_QSTR_CRC_16_BITS), MP_OBJ_NEW_SMALL_INT(16) },
    { MP_ROM_QSTR(MP_QSTR_CRC_32_BITS), MP_OBJ_NEW_SMALL_INT(32) },
    { MP_ROM_QSTR(MP_QSTR_CRC_64_BITS), MP_OBJ_NEW_SMALL_INT(64) },
    { MP_ROM_QSTR(MP_QSTR_crc), MP_ROM_PTR(&mod_uhashlib_crc_obj) },
    { MP_ROM_QSTR(MP_QSTR_crc16), MP_ROM_PTR(&mod_uhashlib_crc16_obj) },
    { MP_ROM_QSTR(MP_QSTR_crc32), MP_ROM_PTR(&mod_uhashlib_crc32_obj) },
    { MP_ROM_QSTR(MP_QSTR_crc32big), MP_ROM_PTR(&mod_uhashlib_crc32big_obj) },
    { MP_ROM_QSTR(MP_QSTR_crc64_iso), MP_ROM_PTR(&mod_uhashlib_crc64_iso_obj) },
    { MP_ROM_QSTR(MP_QSTR_crc64_ecma), MP_ROM_PTR(&mod_uhashlib_crc64_ecma_obj) },
    { MP_ROM_QSTR(MP_QSTR_ripemd160), MP_ROM_PTR(&mod_uhashlib_ripemd160_obj) },
    { MP_ROM_QSTR(MP_QSTR_md5), MP_ROM_PTR(&mod_uhashlib_md5_obj) },
    { MP_ROM_QSTR(MP_QSTR_md5_xor), MP_ROM_PTR(&mod_uhashlib_md5_xor_obj) },
    { MP_ROM_QSTR(MP_QSTR_sha1), MP_ROM_PTR(&mod_uhashlib_sha1_obj) },
    { MP_ROM_QSTR(MP_QSTR_sha256), MP_ROM_PTR(&mod_uhashlib_sha256_obj) },
    { MP_ROM_QSTR(MP_QSTR_sha384), MP_ROM_PTR(&mod_uhashlib_sha384_obj) },
    { MP_ROM_QSTR(MP_QSTR_sha512), MP_ROM_PTR(&mod_uhashlib_sha512_obj) },
    { MP_ROM_QSTR(MP_QSTR_hmac_sha1), MP_ROM_PTR(&mod_uhashlib_hmac_sha1_obj) },
    { MP_ROM_QSTR(MP_QSTR_sha1_xor64), MP_ROM_PTR(&mod_uhashlib_sha1_xor64_obj) },
    { MP_ROM_QSTR(MP_QSTR_adler16), MP_ROM_PTR(&mod_uhashlib_adler16_obj) },
    { MP_ROM_QSTR(MP_QSTR_adler32), MP_ROM_PTR(&mod_uhashlib_adler32_obj) },
    { MP_ROM_QSTR(MP_QSTR_checksum32), MP_ROM_PTR(&mod_uhashlib_checksum32_obj) },
    { MP_ROM_QSTR(MP_QSTR_sdbm), MP_ROM_PTR(&mod_uhashlib_sdbm_obj) },
    { MP_ROM_QSTR(MP_QSTR_fnv1), MP_ROM_PTR(&mod_uhashlib_fnv1_obj) },
    { MP_ROM_QSTR(MP_QSTR_add), MP_ROM_PTR(&mod_uhashlib_add_obj) },
    { MP_ROM_QSTR(MP_QSTR_wadd), MP_ROM_PTR(&mod_uhashlib_wadd_obj) },
    { MP_ROM_QSTR(MP_QSTR_dwadd), MP_ROM_PTR(&mod_uhashlib_dwadd_obj) },
    { MP_ROM_QSTR(MP_QSTR_qwadd), MP_ROM_PTR(&mod_uhashlib_qwadd_obj) },
    { MP_ROM_QSTR(MP_QSTR_wadd_le), MP_ROM_PTR(&mod_uhashlib_wadd_le_obj) },
    { MP_ROM_QSTR(MP_QSTR_dwadd_le), MP_ROM_PTR(&mod_uhashlib_dwadd_le_obj) },
    { MP_ROM_QSTR(MP_QSTR_wsub), MP_ROM_PTR(&mod_uhashlib_wsub_obj) },
    { MP_ROM_QSTR(MP_QSTR_force_crc32), MP_ROM_PTR(&mod_uhashlib_force_crc32_obj) },
    { MP_ROM_QSTR(MP_QSTR_murmur3_32), MP_ROM_PTR(&mod_uhashlib_murmur3_32_obj) },
    { MP_ROM_QSTR(MP_QSTR_jhash), MP_ROM_PTR(&mod_uhashlib_jhash_obj) },
    { MP_ROM_QSTR(MP_QSTR_jenkins_oaat), MP_ROM_PTR(&mod_uhashlib_jenkins_oaat_obj) },
    { MP_ROM_QSTR(MP_QSTR_lookup3_little2), MP_ROM_PTR(&mod_uhashlib_lookup3_little2_obj) },
    { MP_ROM_QSTR(MP_QSTR_djb2), MP_ROM_PTR(&mod_uhashlib_djb2_obj) },
    { MP_ROM_QSTR(MP_QSTR_eachecksum), MP_ROM_PTR(&mod_uhashlib_eachecksum_obj) },
    { MP_ROM_QSTR(MP_QSTR_ffx_checksum), MP_ROM_PTR(&mod_uhashlib_ffx_checksum_obj) },
    { MP_ROM_QSTR(MP_QSTR_ff13_checksum), MP_ROM_PTR(&mod_uhashlib_ff13_checksum_obj) },
    { MP_ROM_QSTR(MP_QSTR_kh25_checksum), MP_ROM_PTR(&mod_uhashlib_kh25_checksum_obj) },
    { MP_ROM_QSTR(MP_QSTR_khcom_checksum), MP_ROM_PTR(&mod_uhashlib_khcom_checksum_obj) },
    { MP_ROM_QSTR(MP_QSTR_mgs2_checksum), MP_ROM_PTR(&mod_uhashlib_mgs2_checksum_obj) },
    { MP_ROM_QSTR(MP_QSTR_mgspw_checksum), MP_ROM_PTR(&mod_uhashlib_mgspw_checksum_obj) },
    { MP_ROM_QSTR(MP_QSTR_sw4_checksum), MP_ROM_PTR(&mod_uhashlib_sw4_checksum_obj) },
    { MP_ROM_QSTR(MP_QSTR_toz_checksum), MP_ROM_PTR(&mod_uhashlib_toz_checksum_obj) },
    { MP_ROM_QSTR(MP_QSTR_tiara2_checksum), MP_ROM_PTR(&mod_uhashlib_tiara2_checksum_obj) },
    { MP_ROM_QSTR(MP_QSTR_castlevania_checksum), MP_ROM_PTR(&mod_uhashlib_castlevania_checksum_obj) },
    { MP_ROM_QSTR(MP_QSTR_rockstar_checksum), MP_ROM_PTR(&mod_uhashlib_rockstar_checksum_obj) },
    { MP_ROM_QSTR(MP_QSTR_dbzxv2_checksum), MP_ROM_PTR(&mod_uhashlib_dbzxv2_checksum_obj) },
    { MP_ROM_QSTR(MP_QSTR_deadrising_checksum), MP_ROM_PTR(&mod_uhashlib_deadrising_checksum_obj) },
};

STATIC MP_DEFINE_CONST_DICT(mp_module_hashlib_globals, mp_module_hashlib_globals_table);

const mp_obj_module_t mp_module_uhashlib = {
    .base = { &mp_type_module },
    .name = MP_QSTR_uhashlib,
    .globals = (mp_obj_dict_t*)&mp_module_hashlib_globals,
};

#endif //MICROPY_PY_UHASHLIB
/*
 * This file is part of the Micro Python project, http://micropython.org/
 *
 * The MIT License (MIT)
 *
 * Copyright (c) 2014 Paul Sokolovsky
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

#include <stdio.h>
#include <assert.h>
#include <string.h>

//#include "py/nlr.h"
//#include "py/runtime.h"
//#include "py/binary.h"
//#include "extmod/modubinascii.h"


mp_obj_t micropy_mod_binascii_hexlify(struct _mp_state_ctx_t *mp_state, size_t n_args, const mp_obj_t *args) {
    // Second argument is for an extension to allow a separator to be used
    // between values.
    const char *sep = NULL;
    mp_buffer_info_t bufinfo;
    micropy_get_buffer_raise(mp_state, args[0], &bufinfo, MP_BUFFER_READ);

    vstr_t vstr;
    size_t out_len = bufinfo.len * 2;
    if (n_args > 1) {
        // 1-char separator between hex numbers
        out_len += bufinfo.len - 1;
        sep = micropy_obj_str_get_str(mp_state, args[1]);
    }
    micropy_vstr_init_len(mp_state, &vstr, out_len);
    byte *in = bufinfo.buf, *out = (byte*)vstr.buf;
    for (mp_uint_t i = bufinfo.len; i--;) {
        byte d = (*in >> 4);
        if (d > 9) {
            d += 'a' - '9' - 1;
        }
        *out++ = d + '0';
        d = (*in++ & 0xf);
        if (d > 9) {
            d += 'a' - '9' - 1;
        }
        *out++ = d + '0';
        if (sep != NULL && i != 0) {
            *out++ = *sep;
        }
    }
    return micropy_obj_new_str_from_vstr(mp_state, &mp_type_bytes, &vstr);
}
MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(mod_binascii_hexlify_obj, 1, 2, micropy_mod_binascii_hexlify);

mp_obj_t micropy_mod_binascii_unhexlify(struct _mp_state_ctx_t *mp_state, mp_obj_t data) {
    mp_buffer_info_t bufinfo;
    micropy_get_buffer_raise(mp_state, data, &bufinfo, MP_BUFFER_READ);

    if ((bufinfo.len & 1) != 0) {
        micropy_nlr_raise(mp_state, micropy_obj_new_exception_msg_varg(mp_state, &mp_type_ValueError, "odd-length string"));
    }
    vstr_t vstr;
    micropy_vstr_init_len(mp_state, &vstr, bufinfo.len / 2);
    byte *in = bufinfo.buf, *out = (byte*)vstr.buf;
    byte hex_byte = 0;
    for (mp_uint_t i = bufinfo.len; i--;) {
        byte hex_ch = *in++;
        if (unichar_isxdigit(hex_ch)) {
            hex_byte += unichar_xdigit_value(hex_ch);
        } else {
            micropy_nlr_raise(mp_state, micropy_obj_new_exception_msg_varg(mp_state, &mp_type_ValueError, "non-hex digit found"));
        }
        if (i & 1) {
            hex_byte <<= 4;
        } else {
            *out++ = hex_byte;
            hex_byte = 0;
        }
    }
    return micropy_obj_new_str_from_vstr(mp_state, &mp_type_bytes, &vstr);
}
MP_DEFINE_CONST_FUN_OBJ_1(mod_binascii_unhexlify_obj, micropy_mod_binascii_unhexlify);

mp_obj_t micropy_mod_binascii_a2b_base64(struct _mp_state_ctx_t *mp_state, mp_obj_t data) {
    mp_buffer_info_t bufinfo;
    micropy_get_buffer_raise(mp_state, data, &bufinfo, MP_BUFFER_READ);
    if (bufinfo.len % 4 != 0) {
        micropy_nlr_raise(mp_state, micropy_obj_new_exception_msg(mp_state, &mp_type_ValueError, "incorrect padding"));
    }

    vstr_t vstr;
    byte *in = bufinfo.buf;
    if (bufinfo.len == 0) {
        micropy_vstr_init_len(mp_state, &vstr, 0);
    }
    else {
        micropy_vstr_init_len(mp_state, &vstr, ((bufinfo.len / 4) * 3) - ((in[bufinfo.len-1] == '=') ? ((in[bufinfo.len-2] == '=') ? 2 : 1 ) : 0)); 
    }
    byte *out = (byte*)vstr.buf;
    for (mp_uint_t i = bufinfo.len; i; i -= 4) {
        char hold[4];
        for (int j = 4; j--;) {
            if (in[j] >= 'A' && in[j] <= 'Z') {
                hold[j] = in[j] - 'A';
            } else if (in[j] >= 'a' && in[j] <= 'z') {
                hold[j] = in[j] - 'a' + 26;
            } else if (in[j] >= '0' && in[j] <= '9') {
                hold[j] = in[j] - '0' + 52;
            } else if (in[j] == '+') {
                hold[j] = 62;
            } else if (in[j] == '/') {
                hold[j] = 63;
            } else if (in[j] == '=') {
                if (j < 2 || i > 4) {
                    micropy_nlr_raise(mp_state, micropy_obj_new_exception_msg(mp_state, &mp_type_ValueError, "incorrect padding"));
                }
                hold[j] = 64;
            } else {
                micropy_nlr_raise(mp_state, micropy_obj_new_exception_msg(mp_state, &mp_type_ValueError, "invalid character"));
            }
        }
        in += 4;

        *out++ = (hold[0]) << 2 | (hold[1]) >> 4;
        if (hold[2] != 64) {
            *out++ = (hold[1] & 0x0F) << 4 | hold[2] >> 2;
            if (hold[3] != 64) {
                *out++ = (hold[2] & 0x03) << 6 | hold[3];
            }
        }
    }
    return micropy_obj_new_str_from_vstr(mp_state, &mp_type_bytes, &vstr);
}
MP_DEFINE_CONST_FUN_OBJ_1(mod_binascii_a2b_base64_obj, micropy_mod_binascii_a2b_base64);

mp_obj_t micropy_mod_binascii_b2a_base64(struct _mp_state_ctx_t *mp_state, mp_obj_t data) {
    mp_buffer_info_t bufinfo;
    micropy_get_buffer_raise(mp_state, data, &bufinfo, MP_BUFFER_READ);

    vstr_t vstr;
    micropy_vstr_init_len(mp_state, &vstr, ((bufinfo.len != 0) ? (((bufinfo.len - 1) / 3) + 1) * 4 : 0) + 1);

    // First pass, we convert input buffer to numeric base 64 values
    byte *in = bufinfo.buf, *out = (byte*)vstr.buf;
    mp_uint_t i;
    for (i = bufinfo.len; i >= 3; i -= 3) {
        *out++ = (in[0] & 0xFC) >> 2;
        *out++ = (in[0] & 0x03) << 4 | (in[1] & 0xF0) >> 4;
        *out++ = (in[1] & 0x0F) << 2 | (in[2] & 0xC0) >> 6;
        *out++ = in[2] & 0x3F;
        in += 3;
    }
    if (i != 0) {
        *out++ = (in[0] & 0xFC) >> 2;
        if (i == 2) {
            *out++ = (in[0] & 0x03) << 4 | (in[1] & 0xF0) >> 4;
            *out++ = (in[1] & 0x0F) << 2;
        }
        else {
            *out++ = (in[0] & 0x03) << 4;
            *out++ = 64;
        }
        *out++ = 64;
    }

    // Second pass, we convert number base 64 values to actual base64 ascii encoding
    out = (byte*)vstr.buf;
    for (mp_uint_t j = vstr.len - 1; j--;) {
        if (*out < 26) {
            *out += 'A';
        } else if (*out < 52) {
            *out += 'a' - 26;
        } else if (*out < 62) {
            *out += '0' - 52;
        } else if (*out == 62) {
            *out ='+';
        } else if (*out == 63) {
            *out = '/';
        } else {
            *out = '=';
        }
        out++;
    }
    *out = '\n';
    return micropy_obj_new_str_from_vstr(mp_state, &mp_type_bytes, &vstr);
}
MP_DEFINE_CONST_FUN_OBJ_1(mod_binascii_b2a_base64_obj, micropy_mod_binascii_b2a_base64);

#if MICROPY_PY_UBINASCII

STATIC const mp_rom_map_elem_t mp_module_binascii_globals_table[] = {
    { MP_ROM_QSTR(MP_QSTR___name__), MP_ROM_QSTR(MP_QSTR_ubinascii) },
    { MP_ROM_QSTR(MP_QSTR_hexlify), MP_ROM_PTR(&mod_binascii_hexlify_obj) },
    { MP_ROM_QSTR(MP_QSTR_unhexlify), MP_ROM_PTR(&mod_binascii_unhexlify_obj) },
    { MP_ROM_QSTR(MP_QSTR_a2b_base64), MP_ROM_PTR(&mod_binascii_a2b_base64_obj) },
    { MP_ROM_QSTR(MP_QSTR_b2a_base64), MP_ROM_PTR(&mod_binascii_b2a_base64_obj) },
};

STATIC MP_DEFINE_CONST_DICT(mp_module_binascii_globals, mp_module_binascii_globals_table);

const mp_obj_module_t mp_module_ubinascii = {
    .base = { &mp_type_module },
    .name = MP_QSTR_ubinascii,
    .globals = (mp_obj_dict_t*)&mp_module_binascii_globals,
};

#endif //MICROPY_PY_UBINASCII
/*
 *
 * Copyright (c) 2025 Damian Parrino
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

#include <stdio.h>
#include <assert.h>
#include <string.h>

//#include "py/nlr.h"
//#include "py/runtime.h"
//#include "py/binary.h"

#include "apollo.h"
#include "crc_util.h"

//---  Custom crypto functions ---//
MP_DECLARE_CONST_FUN_OBJ(mod_ucrypto_diablo3_obj);
MP_DECLARE_CONST_FUN_OBJ(mod_ucrypto_dw8xl_obj);
MP_DECLARE_CONST_FUN_OBJ(mod_ucrypto_silent_hill3_obj);
MP_DECLARE_CONST_FUN_OBJ(mod_ucrypto_nfs_undercover_obj);
MP_DECLARE_CONST_FUN_OBJ(mod_ucrypto_final_fantasy13_obj);
MP_DECLARE_CONST_FUN_OBJ(mod_ucrypto_borderlands3_obj);
MP_DECLARE_CONST_FUN_OBJ(mod_ucrypto_mgs_pw_obj);
MP_DECLARE_CONST_FUN_OBJ(mod_ucrypto_mgs_base64_obj);
MP_DECLARE_CONST_FUN_OBJ(mod_ucrypto_mgs_obj);
MP_DECLARE_CONST_FUN_OBJ(mod_ucrypto_mgs5_tpp_obj);
MP_DECLARE_CONST_FUN_OBJ(mod_ucrypto_monster_hunter_obj);
MP_DECLARE_CONST_FUN_OBJ(mod_ucrypto_rgg_studio_obj);

//---  Generic crypto functions ---//
MP_DECLARE_CONST_FUN_OBJ(mod_ucrypto_aes_ecb_obj);
MP_DECLARE_CONST_FUN_OBJ(mod_ucrypto_aes_cbc_obj);
MP_DECLARE_CONST_FUN_OBJ(mod_ucrypto_aes_ctr_obj);
MP_DECLARE_CONST_FUN_OBJ(mod_ucrypto_des_ecb_obj);
MP_DECLARE_CONST_FUN_OBJ(mod_ucrypto_des3_cbc_obj);
MP_DECLARE_CONST_FUN_OBJ(mod_ucrypto_blowfish_ecb_obj);
MP_DECLARE_CONST_FUN_OBJ(mod_ucrypto_blowfish_cbc_obj);
MP_DECLARE_CONST_FUN_OBJ(mod_ucrypto_camellia_ecb_obj);


mp_obj_t micropy_mod_ucrypto_dw8xl(struct _mp_state_ctx_t *mp_state, mp_obj_t data) {
    mp_buffer_info_t bufinfo;
    micropy_get_buffer_raise(mp_state, data, &bufinfo, MP_BUFFER_RW);

    dw8xl_encode_data(bufinfo.buf, bufinfo.len);

    return data;
}
MP_DEFINE_CONST_FUN_OBJ_1(mod_ucrypto_dw8xl_obj, micropy_mod_ucrypto_dw8xl);

mp_obj_t micropy_mod_ucrypto_diablo3(struct _mp_state_ctx_t *mp_state, mp_obj_t enc_mode, mp_obj_t data) {
    mp_buffer_info_t bufinfo;
    micropy_get_buffer_raise(mp_state, data, &bufinfo, MP_BUFFER_RW);

    if (micropy_obj_int_get_truncated(mp_state, enc_mode))
        // encryption mode
        diablo_encrypt_data(bufinfo.buf, bufinfo.len);
    else
        // decryption mode
        diablo_decrypt_data(bufinfo.buf, bufinfo.len);

    return enc_mode;
}
MP_DEFINE_CONST_FUN_OBJ_2(mod_ucrypto_diablo3_obj, micropy_mod_ucrypto_diablo3);

mp_obj_t micropy_mod_ucrypto_silent_hill3(struct _mp_state_ctx_t *mp_state, mp_obj_t enc_mode, mp_obj_t data) {
    mp_buffer_info_t bufinfo;
    micropy_get_buffer_raise(mp_state, data, &bufinfo, MP_BUFFER_RW);

    if (micropy_obj_int_get_truncated(mp_state, enc_mode))
        // encryption mode
        sh3_encrypt_data(bufinfo.buf, bufinfo.len);
    else
        // decryption mode
        sh3_decrypt_data(bufinfo.buf, bufinfo.len);

    return enc_mode;
}
MP_DEFINE_CONST_FUN_OBJ_2(mod_ucrypto_silent_hill3_obj, micropy_mod_ucrypto_silent_hill3);

mp_obj_t micropy_mod_ucrypto_nfs_undercover(struct _mp_state_ctx_t *mp_state, mp_obj_t enc_mode, mp_obj_t data) {
    mp_buffer_info_t bufinfo;
    micropy_get_buffer_raise(mp_state, data, &bufinfo, MP_BUFFER_RW);

    if (micropy_obj_int_get_truncated(mp_state, enc_mode))
        // encryption mode
        nfsu_encrypt_data(bufinfo.buf, bufinfo.len);
    else
        // decryption mode
        nfsu_decrypt_data(bufinfo.buf, bufinfo.len);

    return enc_mode;
}
MP_DEFINE_CONST_FUN_OBJ_2(mod_ucrypto_nfs_undercover_obj, micropy_mod_ucrypto_nfs_undercover);

mp_obj_t micropy_mod_ucrypto_final_fantasy13(struct _mp_state_ctx_t *mp_state, size_t n_args, const mp_obj_t *args) {
    mp_buffer_info_t bufinfo, keyinfo;
    micropy_get_buffer_raise(mp_state, args[1], &bufinfo, MP_BUFFER_RW);
    micropy_get_buffer_raise(mp_state, args[2], &keyinfo, MP_BUFFER_READ);

    if (micropy_obj_int_get_truncated(mp_state, args[0]))
        // encryption mode
        ff13_encrypt_data(micropy_obj_int_get_truncated(mp_state, args[3]), bufinfo.buf, bufinfo.len, keyinfo.buf, keyinfo.len);
    else
        // decryption mode
        ff13_decrypt_data(micropy_obj_int_get_truncated(mp_state, args[3]), bufinfo.buf, bufinfo.len, keyinfo.buf, keyinfo.len);

    return args[0];
}
MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(mod_ucrypto_final_fantasy13_obj, 4, 4, micropy_mod_ucrypto_final_fantasy13);

mp_obj_t micropy_mod_ucrypto_borderlands3(struct _mp_state_ctx_t *mp_state, mp_obj_t enc_mode, mp_obj_t data, mp_obj_t type) {
    mp_buffer_info_t bufinfo;
    micropy_get_buffer_raise(mp_state, data, &bufinfo, MP_BUFFER_RW);

    if (micropy_obj_int_get_truncated(mp_state, enc_mode))
        // encryption mode
        borderlands3_Encrypt(bufinfo.buf, bufinfo.len, micropy_obj_int_get_truncated(mp_state, type));
    else
        // decryption mode
        borderlands3_Decrypt(bufinfo.buf, bufinfo.len, micropy_obj_int_get_truncated(mp_state, type));

    return enc_mode;
}
MP_DEFINE_CONST_FUN_OBJ_3(mod_ucrypto_borderlands3_obj, micropy_mod_ucrypto_borderlands3);

mp_obj_t micropy_mod_ucrypto_mgs_pw(struct _mp_state_ctx_t *mp_state, mp_obj_t enc_mode, mp_obj_t data) {
    mp_buffer_info_t bufinfo;
    micropy_get_buffer_raise(mp_state, data, &bufinfo, MP_BUFFER_RW);

    if (micropy_obj_int_get_truncated(mp_state, enc_mode))
        // encryption mode
        mgspw_Encrypt(bufinfo.buf, bufinfo.len);
    else
        // decryption mode
        mgspw_Decrypt(bufinfo.buf, bufinfo.len);

    return enc_mode;
}
MP_DEFINE_CONST_FUN_OBJ_2(mod_ucrypto_mgs_pw_obj, micropy_mod_ucrypto_mgs_pw);

mp_obj_t micropy_mod_ucrypto_mgs_base64(struct _mp_state_ctx_t *mp_state, mp_obj_t enc_mode, mp_obj_t data) {
    mp_buffer_info_t bufinfo;
    micropy_get_buffer_raise(mp_state, data, &bufinfo, MP_BUFFER_RW);

    if (micropy_obj_int_get_truncated(mp_state, enc_mode))
        // encryption mode
        mgs_EncodeBase64(bufinfo.buf, bufinfo.len);
    else
        // decryption mode
        mgs_DecodeBase64(bufinfo.buf, bufinfo.len);

    return enc_mode;
}
MP_DEFINE_CONST_FUN_OBJ_2(mod_ucrypto_mgs_base64_obj, micropy_mod_ucrypto_mgs_base64);

mp_obj_t micropy_mod_ucrypto_mgs5_tpp(struct _mp_state_ctx_t *mp_state, mp_obj_t data, mp_obj_t key) {
    mp_buffer_info_t bufinfo;
    micropy_get_buffer_raise(mp_state, data, &bufinfo, MP_BUFFER_RW);

    mgs5tpp_encode_data(bufinfo.buf, bufinfo.len, micropy_obj_int_get_truncated(mp_state, key));

    return data;
}
MP_DEFINE_CONST_FUN_OBJ_2(mod_ucrypto_mgs5_tpp_obj, micropy_mod_ucrypto_mgs5_tpp);

mp_obj_t micropy_mod_ucrypto_rgg_studio(struct _mp_state_ctx_t *mp_state, mp_obj_t data, mp_obj_t key) {
    mp_buffer_info_t bufinfo, keyinfo;
    micropy_get_buffer_raise(mp_state, data, &bufinfo, MP_BUFFER_RW);
    micropy_get_buffer_raise(mp_state, key, &keyinfo, MP_BUFFER_READ);

    rgg_xor_data(bufinfo.buf, bufinfo.len, keyinfo.buf, keyinfo.len);

    return data;
}
MP_DEFINE_CONST_FUN_OBJ_2(mod_ucrypto_rgg_studio_obj, micropy_mod_ucrypto_rgg_studio);

mp_obj_t micropy_mod_ucrypto_mgs(struct _mp_state_ctx_t *mp_state, mp_obj_t enc_mode, mp_obj_t data, mp_obj_t key) {
    mp_buffer_info_t bufinfo, keyinfo;
    micropy_get_buffer_raise(mp_state, data, &bufinfo, MP_BUFFER_RW);
    micropy_get_buffer_raise(mp_state, key, &keyinfo, MP_BUFFER_READ);

    if (micropy_obj_int_get_truncated(mp_state, enc_mode))
        // encryption mode
        mgs_Encrypt(bufinfo.buf, bufinfo.len, keyinfo.buf, keyinfo.len);
    else
        // decryption mode
        mgs_Decrypt(bufinfo.buf, bufinfo.len, keyinfo.buf, keyinfo.len);

    return data;
}
MP_DEFINE_CONST_FUN_OBJ_3(mod_ucrypto_mgs_obj, micropy_mod_ucrypto_mgs);

mp_obj_t micropy_mod_ucrypto_monster_hunter(struct _mp_state_ctx_t *mp_state, mp_obj_t enc_mode, mp_obj_t data, mp_obj_t gver) {
    mp_buffer_info_t bufinfo;
    micropy_get_buffer_raise(mp_state, data, &bufinfo, MP_BUFFER_RW);

    int ver = micropy_obj_int_get_truncated(mp_state, gver);
    if (ver != 2 && ver != 3) {
        micropy_nlr_raise(mp_state, micropy_obj_new_exception_msg_varg(mp_state, &mp_type_ValueError, "Game version must be 2 or 3"));
    }

    if (micropy_obj_int_get_truncated(mp_state, enc_mode))
        // encryption mode
        monsterhunter_encrypt_data(bufinfo.buf, bufinfo.len, ver);
    else
        // decryption mode
        monsterhunter_decrypt_data(bufinfo.buf, bufinfo.len, ver);

    return enc_mode;
}
MP_DEFINE_CONST_FUN_OBJ_3(mod_ucrypto_monster_hunter_obj, micropy_mod_ucrypto_monster_hunter);

mp_obj_t micropy_mod_ucrypto_aes_ecb(struct _mp_state_ctx_t *mp_state, mp_obj_t enc_mode, mp_obj_t data, mp_obj_t key) {
    mp_buffer_info_t bufinfo, keyinfo;
    micropy_get_buffer_raise(mp_state, data, &bufinfo, MP_BUFFER_RW);
    micropy_get_buffer_raise(mp_state, key, &keyinfo, MP_BUFFER_READ);

    if (micropy_obj_int_get_truncated(mp_state, enc_mode))
        // encryption mode
        aes_ecb_encrypt(bufinfo.buf, bufinfo.len, keyinfo.buf, keyinfo.len);
    else
        // decryption mode
        aes_ecb_decrypt(bufinfo.buf, bufinfo.len, keyinfo.buf, keyinfo.len);

    return data;
}
MP_DEFINE_CONST_FUN_OBJ_3(mod_ucrypto_aes_ecb_obj, micropy_mod_ucrypto_aes_ecb);

mp_obj_t micropy_mod_ucrypto_aes_ctr(struct _mp_state_ctx_t *mp_state, mp_obj_t data, mp_obj_t key, mp_obj_t iv) {
    mp_buffer_info_t bufinfo, keyinfo, ivinfo;
    micropy_get_buffer_raise(mp_state, data, &bufinfo, MP_BUFFER_RW);
    micropy_get_buffer_raise(mp_state, key, &keyinfo, MP_BUFFER_READ);
    micropy_get_buffer_raise(mp_state, iv, &ivinfo, MP_BUFFER_READ);

    aes_ctr_xcrypt(bufinfo.buf, bufinfo.len, keyinfo.buf, keyinfo.len, ivinfo.buf, ivinfo.len);

    return data;
}
MP_DEFINE_CONST_FUN_OBJ_3(mod_ucrypto_aes_ctr_obj, micropy_mod_ucrypto_aes_ctr);

mp_obj_t micropy_mod_ucrypto_blowfish_ecb(struct _mp_state_ctx_t *mp_state, mp_obj_t enc_mode, mp_obj_t data, mp_obj_t key) {
    mp_buffer_info_t bufinfo, keyinfo;
    micropy_get_buffer_raise(mp_state, data, &bufinfo, MP_BUFFER_RW);
    micropy_get_buffer_raise(mp_state, key, &keyinfo, MP_BUFFER_READ);

    if (micropy_obj_int_get_truncated(mp_state, enc_mode))
        // encryption mode
        blowfish_ecb_encrypt(bufinfo.buf, bufinfo.len, keyinfo.buf, keyinfo.len);
    else
        // decryption mode
        blowfish_ecb_decrypt(bufinfo.buf, bufinfo.len, keyinfo.buf, keyinfo.len);

    return data;
}
MP_DEFINE_CONST_FUN_OBJ_3(mod_ucrypto_blowfish_ecb_obj, micropy_mod_ucrypto_blowfish_ecb);

mp_obj_t micropy_mod_ucrypto_camellia_ecb(struct _mp_state_ctx_t *mp_state, mp_obj_t enc_mode, mp_obj_t data, mp_obj_t key) {
    mp_buffer_info_t bufinfo, keyinfo;
    micropy_get_buffer_raise(mp_state, data, &bufinfo, MP_BUFFER_RW);
    micropy_get_buffer_raise(mp_state, key, &keyinfo, MP_BUFFER_READ);

    if (micropy_obj_int_get_truncated(mp_state, enc_mode))
        // encryption mode
        camellia_ecb_encrypt(bufinfo.buf, bufinfo.len, keyinfo.buf, keyinfo.len);
    else
        // decryption mode
        camellia_ecb_decrypt(bufinfo.buf, bufinfo.len, keyinfo.buf, keyinfo.len);

    return data;
}
MP_DEFINE_CONST_FUN_OBJ_3(mod_ucrypto_camellia_ecb_obj, micropy_mod_ucrypto_camellia_ecb);

mp_obj_t micropy_mod_ucrypto_des_ecb(struct _mp_state_ctx_t *mp_state, mp_obj_t enc_mode, mp_obj_t data, mp_obj_t key) {
    mp_buffer_info_t bufinfo, keyinfo;
    micropy_get_buffer_raise(mp_state, data, &bufinfo, MP_BUFFER_RW);
    micropy_get_buffer_raise(mp_state, key, &keyinfo, MP_BUFFER_READ);

    if (micropy_obj_int_get_truncated(mp_state, enc_mode))
        // encryption mode
        des_ecb_encrypt(bufinfo.buf, bufinfo.len, keyinfo.buf, keyinfo.len);
    else
        // decryption mode
        des_ecb_decrypt(bufinfo.buf, bufinfo.len, keyinfo.buf, keyinfo.len);

    return data;
}
MP_DEFINE_CONST_FUN_OBJ_3(mod_ucrypto_des_ecb_obj, micropy_mod_ucrypto_des_ecb);

mp_obj_t micropy_mod_ucrypto_aes_cbc(struct _mp_state_ctx_t *mp_state, size_t n_args, const mp_obj_t *args) {
    mp_buffer_info_t bufinfo, keyinfo, ivinfo;
    micropy_get_buffer_raise(mp_state, args[1], &bufinfo, MP_BUFFER_RW);
    micropy_get_buffer_raise(mp_state, args[2], &keyinfo, MP_BUFFER_READ);
    micropy_get_buffer_raise(mp_state, args[3], &ivinfo, MP_BUFFER_READ);

    if (micropy_obj_int_get_truncated(mp_state, args[0]))
        // encryption mode
        aes_cbc_encrypt(bufinfo.buf, bufinfo.len, keyinfo.buf, keyinfo.len, ivinfo.buf, ivinfo.len);
    else
        // decryption mode
        aes_cbc_decrypt(bufinfo.buf, bufinfo.len, keyinfo.buf, keyinfo.len, ivinfo.buf, ivinfo.len);

    return args[0];
}
MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(mod_ucrypto_aes_cbc_obj, 4, 4, micropy_mod_ucrypto_aes_cbc);

mp_obj_t micropy_mod_ucrypto_blowfish_cbc(struct _mp_state_ctx_t *mp_state, size_t n_args, const mp_obj_t *args) {
    mp_buffer_info_t bufinfo, keyinfo, ivinfo;
    micropy_get_buffer_raise(mp_state, args[1], &bufinfo, MP_BUFFER_RW);
    micropy_get_buffer_raise(mp_state, args[2], &keyinfo, MP_BUFFER_READ);
    micropy_get_buffer_raise(mp_state, args[3], &ivinfo, MP_BUFFER_READ);

    if (micropy_obj_int_get_truncated(mp_state, args[0]))
        // encryption mode
        blowfish_cbc_encrypt(bufinfo.buf, bufinfo.len, keyinfo.buf, keyinfo.len, ivinfo.buf, ivinfo.len);
    else
        // decryption mode
        blowfish_cbc_decrypt(bufinfo.buf, bufinfo.len, keyinfo.buf, keyinfo.len, ivinfo.buf, ivinfo.len);

    return args[0];
}
MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(mod_ucrypto_blowfish_cbc_obj, 4, 4, micropy_mod_ucrypto_blowfish_cbc);

mp_obj_t micropy_mod_ucrypto_des3_cbc(struct _mp_state_ctx_t *mp_state, size_t n_args, const mp_obj_t *args) {
    mp_buffer_info_t bufinfo, keyinfo, ivinfo;
    micropy_get_buffer_raise(mp_state, args[1], &bufinfo, MP_BUFFER_RW);
    micropy_get_buffer_raise(mp_state, args[2], &keyinfo, MP_BUFFER_READ);
    micropy_get_buffer_raise(mp_state, args[3], &ivinfo, MP_BUFFER_READ);

    if (micropy_obj_int_get_truncated(mp_state, args[0]))
        // encryption mode
        des3_cbc_encrypt(bufinfo.buf, bufinfo.len, keyinfo.buf, keyinfo.len, ivinfo.buf, ivinfo.len);
    else
        // decryption mode
        des3_cbc_decrypt(bufinfo.buf, bufinfo.len, keyinfo.buf, keyinfo.len, ivinfo.buf, ivinfo.len);

    return args[0];
}
MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(mod_ucrypto_des3_cbc_obj, 4, 4, micropy_mod_ucrypto_des3_cbc);

#if MICROPY_PY_UCRYPTO

STATIC const mp_rom_map_elem_t mp_module_ucrypto_globals_table[] = {
    { MP_ROM_QSTR(MP_QSTR___name__), MP_ROM_QSTR(MP_QSTR_ucrypto) },
    { MP_ROM_QSTR(MP_QSTR_DECRYPT), MP_OBJ_NEW_SMALL_INT(0) },
    { MP_ROM_QSTR(MP_QSTR_ENCRYPT), MP_OBJ_NEW_SMALL_INT(1) },
    { MP_ROM_QSTR(MP_QSTR_diablo3), MP_ROM_PTR(&mod_ucrypto_diablo3_obj) },
    { MP_ROM_QSTR(MP_QSTR_dw8xl), MP_ROM_PTR(&mod_ucrypto_dw8xl_obj) },
    { MP_ROM_QSTR(MP_QSTR_silent_hill3), MP_ROM_PTR(&mod_ucrypto_silent_hill3_obj) },
    { MP_ROM_QSTR(MP_QSTR_nfs_undercover), MP_ROM_PTR(&mod_ucrypto_nfs_undercover_obj) },
    { MP_ROM_QSTR(MP_QSTR_final_fantasy13), MP_ROM_PTR(&mod_ucrypto_final_fantasy13_obj) },
    { MP_ROM_QSTR(MP_QSTR_borderlands3), MP_ROM_PTR(&mod_ucrypto_borderlands3_obj) },
    { MP_ROM_QSTR(MP_QSTR_mgs_pw), MP_ROM_PTR(&mod_ucrypto_mgs_pw_obj) },
    { MP_ROM_QSTR(MP_QSTR_mgs_base64), MP_ROM_PTR(&mod_ucrypto_mgs_base64_obj) },
    { MP_ROM_QSTR(MP_QSTR_mgs), MP_ROM_PTR(&mod_ucrypto_mgs_obj) },
    { MP_ROM_QSTR(MP_QSTR_mgs5_tpp), MP_ROM_PTR(&mod_ucrypto_mgs5_tpp_obj) },
    { MP_ROM_QSTR(MP_QSTR_monster_hunter), MP_ROM_PTR(&mod_ucrypto_monster_hunter_obj) },
    { MP_ROM_QSTR(MP_QSTR_rgg_studio), MP_ROM_PTR(&mod_ucrypto_rgg_studio_obj) },
    { MP_ROM_QSTR(MP_QSTR_aes_ecb), MP_ROM_PTR(&mod_ucrypto_aes_ecb_obj) },
    { MP_ROM_QSTR(MP_QSTR_aes_cbc), MP_ROM_PTR(&mod_ucrypto_aes_cbc_obj) },
    { MP_ROM_QSTR(MP_QSTR_aes_ctr), MP_ROM_PTR(&mod_ucrypto_aes_ctr_obj) },
    { MP_ROM_QSTR(MP_QSTR_des_ecb), MP_ROM_PTR(&mod_ucrypto_des_ecb_obj) },
    { MP_ROM_QSTR(MP_QSTR_des3_cbc), MP_ROM_PTR(&mod_ucrypto_des3_cbc_obj) },
    { MP_ROM_QSTR(MP_QSTR_blowfish_ecb), MP_ROM_PTR(&mod_ucrypto_blowfish_ecb_obj) },
    { MP_ROM_QSTR(MP_QSTR_blowfish_cbc), MP_ROM_PTR(&mod_ucrypto_blowfish_cbc_obj) },
    { MP_ROM_QSTR(MP_QSTR_camellia_ecb), MP_ROM_PTR(&mod_ucrypto_camellia_ecb_obj) },
};

STATIC MP_DEFINE_CONST_DICT(mp_module_ucrypto_globals, mp_module_ucrypto_globals_table);

const mp_obj_module_t mp_module_ucrypto = {
    .base = { &mp_type_module },
    .name = MP_QSTR_ucrypto,
    .globals = (mp_obj_dict_t*)&mp_module_ucrypto_globals,
};

#endif //MICROPY_PY_UCRYPTO
#include <setjmp.h>

void micropy_gc_collect(mp_state_ctx_t *mp) {
    micropy_gc_collect_start(mp);
    jmp_buf regs;
    setjmp(regs);
    // GC stack (and regs because we captured them)
    void **regs_ptr = (void**)(void*)&regs;
    micropy_gc_collect_root(mp, regs_ptr, ((mp_uint_t)mp->vm.stack_top - (mp_uint_t)&regs) / sizeof(mp_uint_t));
    micropy_gc_collect_end(mp);
}

uint micropy_import_stat(mp_state_ctx_t *mp, const char *path) {
    return MP_IMPORT_STAT_NO_EXIST;
}

void micropy_nlr_jump_fail(mp_state_ctx_t *mp, void *val) {
    micropy_printf(mp, &mp_plat_print, "FATAL: uncaught NLR %p\n", val);
    exit(1);
}

/*
mp_obj_t mp_builtin_open(mp_state_ctx_t *mp, mp_uint_t n_args, const mp_obj_t *args, mp_map_t *kwargs) {
    micropy_nlr_raise(mp, micropy_obj_new_exception_msg(mp, &mp_type_OSError, "open() not implemented"));
}
MP_DEFINE_CONST_FUN_OBJ_KW(mp_builtin_open_obj, 1, mp_builtin_open);
*/

mp_state_ctx_t *micropy_create(void *heap, size_t heap_size) {
    mp_state_ctx_t *mp = heap;
    micropy_stack_ctrl_init(mp);
    micropy_stack_set_limit(mp, 40000 * (BYTES_PER_WORD / 4));
    heap += sizeof(mp_state_ctx_t);
    heap_size -= sizeof(mp_state_ctx_t);
    micropy_gc_init(mp, heap, heap + heap_size);
    micropy_init(mp);
    return mp;
}

void micropy_destroy(mp_state_ctx_t *mp) {
    micropy_deinit(mp);
}

STATIC int micropy_execute_from_lexer(mp_state_ctx_t *mp, mp_lexer_t *lex, mp_parse_input_kind_t input_kind, bool is_repl) {
    if (lex == NULL) {
        micropy_printf(mp, &mp_plat_print, "MemoryError: lexer could not allocate memory\n");
        return 1;
    }

    nlr_buf_t nlr;
    if (micropy_nlr_push(mp, &nlr) == 0) {
        qstr source_name = lex->source_name;

        #if MICROPY_PY___FILE__
        if (input_kind == MP_PARSE_FILE_INPUT) {
            micropy_store_global(mp, MP_QSTR___file__, MP_OBJ_NEW_QSTR(source_name));
        }
        #endif

        mp_parse_tree_t pt = micropy_parse(mp, lex, input_kind);
        mp_obj_t module_fun = micropy_compile(mp, &pt, source_name, MP_EMIT_OPT_NONE, is_repl);
        micropy_call_function_0(mp, module_fun);

        micropy_nlr_pop(mp);
        return 0;

    } else {
        // uncaught exception
        mp_obj_t exc = nlr.ret_val;
        // check for SystemExit
        if (micropy_obj_is_subclass_fast(mp, micropy_obj_get_type(mp, exc), &mp_type_SystemExit)) {
            // None is an exit value of 0; an int is its value; anything else is 1
            mp_obj_t exit_val = micropy_obj_exception_get_value(mp, exc);
            mp_int_t val = 0;
            if (exit_val != mp_const_none && !micropy_obj_get_int_maybe(mp, exit_val, &val)) {
                val = 1;
            }
            return 0x100 | (val & 255);
        }

        // Report all other exceptions
        micropy_obj_print_exception(mp, &mp_plat_print, exc);
        return 1;
    }
}

int micropy_exec_str(mp_state_ctx_t *mp, const char *str) {
    mp_lexer_t *lex = micropy_lexer_new_from_str_len(mp, MP_QSTR__lt_stdin_gt_, str, strlen(str), false);
    return micropy_execute_from_lexer(mp, lex, MP_PARSE_FILE_INPUT, false);
}
